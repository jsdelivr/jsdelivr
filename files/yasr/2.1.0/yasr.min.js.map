{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/main.js","lib/jquery.csv-0.71.js","node_modules/codemirror/addon/edit/matchbrackets.js","node_modules/codemirror/mode/javascript/javascript.js","node_modules/codemirror/mode/xml/xml.js","node_modules/yasgui-utils/node_modules/store/store.js","node_modules/yasgui-utils/package.json","node_modules/yasgui-utils/src/main.js","node_modules/yasgui-utils/src/storage.js","node_modules/yasgui-utils/src/svg.js","package.json","src/bindingsToCsv.js","src/boolean.js","src/defaults.js","src/error.js","src/imgs.js","src/parsers/csv.js","src/parsers/dlv.js","src/parsers/json.js","src/parsers/tsv.js","src/parsers/wrapper.js","src/parsers/xml.js","src/rawResponse.js","src/table.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACh1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"yasr.min.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\nvar $ = (function(){try{return require('jquery')}catch(e){return window.jQuery}})();\nvar utils = require(\"yasgui-utils\");\nconsole = console || {\"log\":function(){}};//make sure any console statements don't break in IE\n\n\n\n\n/**\n * Main YASR constructor\n * \n * @constructor\n * @param {DOM-Element} parent element to append editor to.\n * @param {object} settings\n * @class YASR\n * @return {doc} YASR document\n */\nvar root = module.exports = function(parent, options, queryResults) {\n\tvar yasr = {};\n\tyasr.options = $.extend(true, {}, root.defaults, options);\n\tyasr.container = $(\"<div class='yasr'></div>\").appendTo(parent);\n\tyasr.header = $(\"<div class='yasr_header'></div>\").appendTo(yasr.container);\n\tyasr.resultsContainer = $(\"<div class='yasr_results'></div>\").appendTo(yasr.container);\n\t\n\t\n\t//first initialize plugins\n\tyasr.plugins = {};\n\tfor (var pluginName in root.plugins) {\n\t\tyasr.plugins[pluginName] = new root.plugins[pluginName](yasr);\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\tyasr.draw = function(output) {\n\t\tif (!yasr.results) return false;\n\t\tif (!output) output = yasr.options.output;\n\t\t\n\t\tif (output in yasr.plugins && yasr.plugins[output].canHandleResults(yasr)) {\n\t\t\t$(yasr.resultsContainer).empty();\n\t\t\tyasr.plugins[output].draw();\n\t\t\treturn true;\n\t\t}\n\t\t//ah, our default output does not take our current results. Try to autodetect\n\t\tvar selectedOutput = null;\n\t\tvar selectedOutputPriority = -1;\n\t\tfor (var tryOutput in yasr.plugins) {\n\t\t\tif (yasr.plugins[tryOutput].canHandleResults(yasr)) {\n\t\t\t\tvar priority = yasr.plugins[tryOutput].getPriority;\n\t\t\t\tif (typeof priority == \"function\") priority = priority(yasr);\n\t\t\t\tif (priority != null && priority != undefined && priority > selectedOutputPriority) {\n\t\t\t\t\tselectedOutputPriority = priority;\n\t\t\t\t\tselectedOutput = tryOutput;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (selectedOutput) {\n\t\t\t$(yasr.resultsContainer).empty();\n\t\t\tyasr.plugins[selectedOutput].draw();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\tyasr.somethingDrawn = function() {\n\t\treturn !yasr.resultsContainer.is(\":empty\");\n\t};\n\tyasr.setResponse = function(queryResults) {\n\t\ttry {\n\t\t\tyasr.results = require(\"./parsers/wrapper.js\")(queryResults);\n\t\t} catch(exception) {\n\t\t\tyasr.results = exception;\n\t\t}\n\t\tyasr.draw();\n\t\t\n\t\t//store if needed\n\t\tif (yasr.options.persistency && yasr.options.persistency.results) {\n\t\t\tif (yasr.results.getOriginalResponseAsString && yasr.results.getOriginalResponseAsString().length < yasr.options.persistency.results.maxSize) {\n\t\t\t\tvar id = (typeof yasr.options.persistency.results.id == \"string\" ? yasr.options.persistency.results.id: yasr.options.persistency.results.id(yasr));\n\t\t\t\tutils.storage.set(id, yasr.results.getOriginalResponse(), \"month\");\n\t\t\t}\n\t\t}\n\t};\n\t\n//\tyasr.plugins = {};\n//\tfor (var plugin in root.plugins) {\n//\t\tyasr.plugins[plugin] = root.plugins[plugin](yasr, yasr.resultsContainer);\n//\t}\n\t/**\n\t * postprocess\n\t */\n\tif (yasr.options.persistency && yasr.options.persistency.outputSelector) {\n\t\tvar id = (typeof yasr.options.persistency.outputSelector == \"string\"? yasr.options.persistency.outputSelector: yasr.options.persistency.outputSelector(yasr));\n\t\tif (id) {\n\t\t\tvar selection = utils.storage.get(id);\n\t\t\tif (selection) yasr.options.output = selection;\n\t\t}\n\t}\n\tif (!queryResults && yasr.options.persistency && yasr.options.persistency.results) {\n\t\tvar id = (typeof yasr.options.persistency.results.id == \"string\" ? yasr.options.persistency.results.id: yasr.options.persistency.results.id(yasr));\n\t\tqueryResults = utils.storage.get(id);\n\t}\n\t\n\tdrawHeader(yasr);\n\t\n\tif (queryResults) {\n\t\tyasr.setResponse(queryResults);\n\t} \n\tupdateHeader(yasr);\n\treturn yasr;\n};\nvar updateHeader = function(yasr) {\n\tvar downloadIcon = yasr.header.find(\".yasr_downloadIcon\");\n\t\tdownloadIcon\n\t\t\t.removeAttr(\"title\");//and remove previous titles\n\t\n\tvar outputPlugin = yasr.plugins[yasr.options.output];\n\tif (outputPlugin) {\n\t\tvar info = (outputPlugin.getDownloadInfo? outputPlugin.getDownloadInfo(): null);\n\t\tif (info) {\n\t\t\tif (info.buttonTitle) downloadIcon.attr(info.buttonTitle);\n\t\t\tdownloadIcon.prop(\"disabled\", false);\n\t\t\tdownloadIcon.find(\"path\").each(function(){\n\t\t\t\tthis.style.fill = \"black\";\n\t\t\t});\n\t\t} else {\n\t\t\tdownloadIcon.prop(\"disabled\", true).prop(\"title\", \"Download not supported for this result representation\");\n\t\t\tdownloadIcon.find(\"path\").each(function(){\n\t\t\t\tthis.style.fill = \"gray\";\n\t\t\t});\n\t\t}\n\t}\n};\n\nvar drawHeader = function(yasr) {\n\tvar drawOutputSelector = function() {\n\t\tvar btnGroup = $('<div class=\"yasr_btnGroup\"></div>');\n\t\t$.each(yasr.plugins, function(pluginName, plugin) {\n\t\t\tif (plugin.hideFromSelection) return;\n\t\t\tvar name = plugin.name || pluginName;\n\t\t\tvar button = $(\"<button class='yasr_btn'></button>\")\n\t\t\t.text(name)\n\t\t\t.addClass(\"select_\" + pluginName)\n\t\t\t.click(function() {\n\t\t\t\t//update buttons\n\t\t\t\tbtnGroup.find(\"button.selected\").removeClass(\"selected\");\n\t\t\t\t$(this).addClass(\"selected\");\n\t\t\t\t//set and draw output\n\t\t\t\tyasr.options.output = pluginName;\n\t\t\t\t\n\t\t\t\t//store if needed\n\t\t\t\tif (yasr.options.persistency && yasr.options.persistency.outputSelector) {\n\t\t\t\t\tvar id = (typeof yasr.options.persistency.outputSelector == \"string\"? yasr.options.persistency.outputSelector: yasr.options.persistency.outputSelector(yasr));\n\t\t\t\t\tutils.storage.set(id, yasr.options.output, \"month\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tyasr.draw();\n\t\t\t\tupdateHeader(yasr);\n\t\t\t})\n\t\t\t.appendTo(btnGroup);\n\t\t\tif (yasr.options.output == pluginName) button.addClass(\"selected\");\n\t\t});\n\t\t\n\t\tif (btnGroup.children().length > 1) yasr.header.append(btnGroup);\n\t};\n\tvar drawDownloadIcon = function() {\n\t\tvar stringToUrl = function(string, contentType) {\n\t\t\tvar url = null;\n\t\t\tvar windowUrl = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\t\t\tif (windowUrl && Blob) {\n\t\t\t\tvar blob = new Blob([string], {type: contentType});\n\t\t\t\turl = windowUrl.createObjectURL(blob);\n\t\t\t}\n\t\t\treturn url;\n\t\t};\n\t\tvar button = $(\"<button class='yasr_btn yasr_downloadIcon'></button>\")\n\t\t\t.append(require(\"yasgui-utils\").svg.getElement(require('./imgs.js').download, {width: \"15px\", height: \"15px\"}))\n\t\t\t.click(function() {\n\t\t\t\tvar currentPlugin = yasr.plugins[yasr.options.output];\n\t\t\t\tif (currentPlugin && currentPlugin.getDownloadInfo) {\n\t\t\t\t\tvar downloadInfo = currentPlugin.getDownloadInfo();\n\t\t\t\t\tvar downloadUrl = stringToUrl(downloadInfo.getContent(), (downloadInfo.contentType? downloadInfo.contentType: \"text/plain\"));\n\t\t\t\t\tvar downloadMockLink = $(\"<a></a>\");\n\t\t\t\t\tdownloadMockLink.attr(\"href\", downloadUrl);\n\t\t\t\t\tdownloadMockLink.attr(\"download\", downloadInfo.filename);\n\t\t\t\t\tdownloadMockLink.get(0).click();\n\t\t\t\t}\n\t\t\t});\n\t\tyasr.header.append(button);\n\t};\n\tif (yasr.options.drawOutputSelector) drawOutputSelector();\n\tif (yasr.options.drawDownloadIcon) drawDownloadIcon();\n};\n\nroot.plugins = {};\nroot.registerOutput = function(name, constructor) {\n\troot.plugins[name] = constructor;\n};\n//initialize the outputs we provide as default\nroot.registerOutput('boolean', require(\"./boolean.js\"));\nroot.registerOutput('table', require(\"./table.js\"));\nroot.registerOutput('rawResponse', require(\"./rawResponse.js\"));\nroot.registerOutput('error', require(\"./error.js\"));\n\n/**\n * The default options of YASR. Either change the default options by setting YASR.defaults, or by\n * passing your own options as second argument to the YASR constructor\n * \n * @attribute YASR.defaults\n */\nroot.defaults = require('./defaults.js');\nroot.version = {\n\t\"YASR\" : require(\"../package.json\").version,\n\t\"jquery\": $.fn.jquery,\n\t\"yasgui-utils\": require(\"yasgui-utils\").version\n};\n","/**\n * jQuery-csv (jQuery Plugin)\n * version: 0.71 (2012-11-19)\n *\n * This document is licensed as free software under the terms of the\n * MIT License: http://www.opensource.org/licenses/mit-license.php\n *\n * Acknowledgements:\n * The original design and influence to implement this library as a jquery\n * plugin is influenced by jquery-json (http://code.google.com/p/jquery-json/).\n * If you're looking to use native JSON.Stringify but want additional backwards\n * compatibility for browsers that don't support it, I highly recommend you\n * check it out.\n *\n * A special thanks goes out to rwk@acm.org for providing a lot of valuable\n * feedback to the project including the core for the new FSM\n * (Finite State Machine) parsers. If you're looking for a stable TSV parser\n * be sure to take a look at jquery-tsv (http://code.google.com/p/jquery-tsv/).\n\n * For legal purposes I'll include the \"NO WARRANTY EXPRESSED OR IMPLIED.\n * USE AT YOUR OWN RISK.\". Which, in 'layman's terms' means, by using this\n * library you are accepting responsibility if it breaks your code.\n *\n * Legal jargon aside, I will do my best to provide a useful and stable core\n * that can effectively be built on.\n *\n * Copyrighted 2012 by Evan Plaice.\n */\n\nRegExp.escape= function(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\n(function( $ ) {\n  'use strict'\n  /**\n   * jQuery.csv.defaults\n   * Encapsulates the method paramater defaults for the CSV plugin module.\n   */\n\n  $.csv = {\n    defaults: {\n      separator:',',\n      delimiter:'\"',\n      headers:true\n    },\n\n    hooks: {\n      castToScalar: function(value, state) {\n        var hasDot = /\\./;\n        if (isNaN(value)) {\n          return value;\n        } else {\n          if (hasDot.test(value)) {\n            return parseFloat(value);\n          } else {\n            var integer = parseInt(value);\n            if(isNaN(integer)) {\n              return null;\n            } else {\n              return integer;\n            }\n          }\n        }\n      }\n    },\n\n    parsers: {\n      parse: function(csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter;\n\n        // set initial state if it's missing\n        if(!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n        if(!options.state.colNum) {\n          options.state.colNum = 1;\n        }\n\n        // clear initial state\n        var data = [];\n        var entry = [];\n        var state = 0;\n        var value = ''\n        var exit = false;\n\n        function endOfEntry() {\n          // reset the state\n          state = 0;\n          value = '';\n\n          // if 'start' hasn't been met, don't output\n          if(options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = [];\n            options.state.rowNum++;\n            options.state.colNum = 1;\n            return;\n          }\n          \n          if(options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            data.push(entry);\n          } else {\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if(hookVal !== false) {\n              data.push(hookVal);\n            }\n          }\n          //console.log('entry:' + entry);\n          \n          // cleanup\n          entry = [];\n\n          // if 'end' is met, stop parsing\n          if(options.end && options.state.rowNum >= options.end) {\n            exit = true;\n          }\n          \n          // update global state\n          options.state.rowNum++;\n          options.state.colNum = 1;\n        }\n\n        function endOfValue() {\n          if(options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value);\n          } else {\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\n            // false skips the row, configurable through a hook\n            if(hook !== false) {\n              entry.push(hook);\n            }\n          }\n          //console.log('value:' + value);\n          // reset the state\n          value = '';\n          state = 0;\n          // update global state\n          options.state.colNum++;\n        }\n\n        // escape regex-specific control chars\n        var escSeparator = RegExp.escape(separator);\n        var escDelimiter = RegExp.escape(delimiter);\n\n        // compile the regEx str using the custom delimiter/separator\n        var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\n        var matchSrc = match.source;\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\n        match = RegExp(matchSrc, 'gm');\n\n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(match, function (m0) {\n          if(exit) {\n            return;\n          }\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += '';\n                endOfValue();\n                break;\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                state = 1;\n                break;\n              }\n              // null last value\n              if (m0 === '\\n') {\n                endOfValue();\n                endOfEntry();\n                break;\n              }\n              // phantom carriage return\n              if (/^\\r$/.test(m0)) {\n                break;\n              }\n              // un-delimited value\n              value += m0;\n              state = 3;\n              break;\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2;\n                break;\n              }\n              // delimited data\n              value += m0;\n              state = 1;\n              break;\n\n            // delimiter found in delimited input\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0;\n                state = 1;\n                break;\n              }\n              // null value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // end of entry\n              if (m0 === '\\n') {\n                endOfValue();\n                endOfEntry();\n                break;\n              }\n              // phantom carriage return\n              if (/^\\r$/.test(m0)) {\n                break;\n              }\n              // broken paser?\n              throw new Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n\n            // un-delimited input\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // end of entry\n              if (m0 === '\\n') {\n                endOfValue();\n                endOfEntry();\n                break;\n              }\n              // phantom carriage return\n              if (/^\\r$/.test(m0)) {\n                break;\n              }\n              if (m0 === delimiter) {\n              // non-compliant data\n                throw new Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n              }\n              // broken parser?\n              throw new Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n            default:\n              // shenanigans\n              throw new Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n          }\n          //console.log('val:' + m0 + ' state:' + state);\n        });\n\n        // submit the last entry\n        // ignore null last line\n        if(entry.length !== 0) {\n          endOfValue();\n          endOfEntry();\n        }\n\n        return data;\n      },\n\n      // a csv-specific line splitter\n      splitLines: function(csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter;\n\n        // set initial state if it's missing\n        if(!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n\n        // clear initial state\n        var entries = [];\n        var state = 0;\n        var entry = '';\n        var exit = false;\n\n        function endOfLine() {          \n          // reset the state\n          state = 0;\n          \n          // if 'start' hasn't been met, don't output\n          if(options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = '';\n            options.state.rowNum++;\n            return;\n          }\n          \n          if(options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            entries.push(entry);\n          } else {\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if(hookVal !== false) {\n              entries.push(hookVal);\n            }\n          }\n\n          // cleanup\n          entry = '';\n\n          // if 'end' is met, stop parsing\n          if(options.end && options.state.rowNum >= options.end) {\n            exit = true;\n          }\n          \n          // update global state\n          options.state.rowNum++;\n        }\n\n        // escape regex-specific control chars\n        var escSeparator = RegExp.escape(separator);\n        var escDelimiter = RegExp.escape(delimiter);\n\n        // compile the regEx str using the custom delimiter/separator\n        var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\n        var matchSrc = match.source;\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\n        match = RegExp(matchSrc, 'gm');\n        \n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(match, function (m0) {\n          if(exit) {\n            return;\n          }\n          switch (state) {\n            // the start of a value/entry\n            case 0:\n              // null value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                entry += m0;\n                state = 1;\n                break;\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              }\n              // phantom carriage return\n              if (/^\\r$/.test(m0)) {\n                break;\n              }\n              // un-delimit value\n              entry += m0;\n              state = 3;\n              break;\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                entry += m0;\n                state = 2;\n                break;\n              }\n              // delimited data\n              entry += m0;\n              state = 1;\n              break;\n\n            // delimiter found in delimited input\n            case 2:\n              // escaped delimiter?\n              var prevChar = entry.substr(entry.length - 1);\n              if (m0 === delimiter && prevChar === delimiter) {\n                entry += m0;\n                state = 1;\n                break;\n              }\n              // end of value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              }\n              // phantom carriage return\n              if (m0 === '\\r') {\n                break;\n              }\n              // broken paser?\n              throw new Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\n\n            // un-delimited input\n            case 3:\n              // null value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              }\n              // phantom carriage return\n              if (m0 === '\\r') {\n                break;\n              }\n              // non-compliant data\n              if (m0 === delimiter) {\n                throw new Error('CSVDataError: Illegal quote [Row:' + options.state.rowNum + ']');\n              }\n              // broken parser?\n              throw new Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\n            default:\n              // shenanigans\n              throw new Error('CSVDataError: Unknown state [Row:' + options.state.rowNum + ']');\n          }\n          //console.log('val:' + m0 + ' state:' + state);\n        });\n\n        // submit the last entry\n        // ignore null last line\n        if(entry !== '') {\n          endOfLine();\n        }\n\n        return entries;\n      },\n\n      // a csv entry parser\n      parseEntry: function(csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter;\n        \n        // set initial state if it's missing\n        if(!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n        if(!options.state.colNum) {\n          options.state.colNum = 1;\n        }\n\n        // clear initial state\n        var entry = [];\n        var state = 0;\n        var value = '';\n\n        function endOfValue() {\n          if(options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value);\n          } else {\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\n            // false skips the value, configurable through a hook\n            if(hook !== false) {\n              entry.push(hook);\n            }\n          }\n          // reset the state\n          value = '';\n          state = 0;\n          // update global state\n          options.state.colNum++;\n        }\n\n        // checked for a cached regEx first\n        if(!options.match) {\n          // escape regex-specific control chars\n          var escSeparator = RegExp.escape(separator);\n          var escDelimiter = RegExp.escape(delimiter);\n          \n          // compile the regEx str using the custom delimiter/separator\n          var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\n          var matchSrc = match.source;\n          matchSrc = matchSrc.replace(/S/g, escSeparator);\n          matchSrc = matchSrc.replace(/D/g, escDelimiter);\n          options.match = RegExp(matchSrc, 'gm');\n        }\n\n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(options.match, function (m0) {\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += '';\n                endOfValue();\n                break;\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                state = 1;\n                break;\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              }\n              // un-delimited value\n              value += m0;\n              state = 3;\n              break;\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2;\n                break;\n              }\n              // delimited data\n              value += m0;\n              state = 1;\n              break;\n\n            // delimiter found in delimited input\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0;\n                state = 1;\n                break;\n              }\n              // null value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              }\n              // broken paser?\n              throw new Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n\n            // un-delimited input\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              }\n              // non-compliant data\n              if (m0 === delimiter) {\n                throw new Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n              }\n              // broken parser?\n              throw new Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n            default:\n              // shenanigans\n              throw new Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n          }\n          //console.log('val:' + m0 + ' state:' + state);\n        });\n\n        // submit the last value\n        endOfValue();\n\n        return entry;\n      }\n    },\n\n    /**\n     * $.csv.toArray(csv)\n     * Converts a CSV entry string to a javascript array.\n     *\n     * @param {Array} csv The string containing the CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with simple CSV strings only. It's useful if you only\n     * need to parse a single entry. If you need to parse more than one line,\n     * use $.csv2Array instead.\n     */\n    toArray: function(csv, options, callback) {\n      var options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      var state = (options.state !== undefined ? options.state : {});\n\n      // setup\n      var options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        state: state\n      }\n\n      var entry = $.csv.parsers.parseEntry(csv, options);\n\n      // push the value to a callback if one is defined\n      if(!config.callback) {\n        return entry;\n      } else {\n        config.callback('', entry);\n      }\n    },\n\n    /**\n     * $.csv.toArrays(csv)\n     * Converts a CSV string to a javascript array.\n     *\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with multi-line CSV. The breakdown is simple. The first\n     * dimension of the array represents the line (or entry/row) while the second\n     * dimension contains the values (or values/columns).\n     */\n    toArrays: function(csv, options, callback) {\n      var options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      \n      // setup\n      var data = [];\n      var options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        }\n      };\n\n      // break the data down to lines\n      data = $.csv.parsers.parse(csv, options);\n\n      // push the value to a callback if one is defined\n      if(!config.callback) {\n        return data;\n      } else {\n        config.callback('', data);\n      }\n    },\n\n    /**\n     * $.csv.toObjects(csv)\n     * Converts a CSV string to a javascript object.\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     * @param {Boolean} [headers] Indicates whether the data contains a header line. Defaults to true.\n     *\n     * This method deals with multi-line CSV strings. Where the headers line is\n     * used as the key for each value per entry.\n     */\n    toObjects: function(csv, options, callback) {\n      var options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\n      options.start = 'start' in options ? options.start : 1;\n      \n      // account for headers\n      if(config.headers) {\n        options.start++;\n      }\n      if(options.end && config.headers) {\n        options.end++;\n      }\n      \n      // setup\n      var lines = [];\n      var data = [];\n      \n      var options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        },\n        match: false\n      };\n\n      // fetch the headers\n      var headerOptions = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        start: 1,\n        end: 1,\n        state: {\n          rowNum:1,\n          colNum:1\n        }\n      }\n      var headerLine = $.csv.parsers.splitLines(csv, headerOptions);\n      var headers = $.csv.toArray(headerLine[0], options);\n\n      // fetch the data\n      var lines = $.csv.parsers.splitLines(csv, options);\n      \n      // reset the state for re-use\n      options.state.colNum = 1;\n      if(headers){\n        options.state.rowNum = 2;\n      } else {\n        options.state.rowNum = 1;\n      }\n      \n      // convert data to objects\n      for(var i=0, len=lines.length; i<len; i++) {\n        var entry = $.csv.toArray(lines[i], options);\n        var object = {};\n        for(var j in headers) {\n          object[headers[j]] = entry[j];\n        }\n        data.push(object);\n        \n        // update row state\n        options.state.rowNum++;\n      }\n\n      // push the value to a callback if one is defined\n      if(!config.callback) {\n        return data;\n      } else {\n        config.callback('', data);\n      }\n    },\n\n     /**\n     * $.csv.fromArrays(arrays)\n     * Converts a javascript array to a CSV String.\n     *\n     * @param {Array} array An array containing an array of CSV entries.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method generates a CSV file from an array of arrays (representing entries).\n     */\n    fromArrays: function(arrays, options, callback) {\n      var options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.escaper = 'escaper' in options ? options.escaper : $.csv.defaults.escaper;\n      config.experimental = 'experimental' in options ? options.experimental : false;\n\n      if(!config.experimental) {\n        throw new Error('not implemented');\n      }\n\n      var output = [];\n      for(i in arrays) {\n        output.push(arrays[i]);\n      }\n\n      // push the value to a callback if one is defined\n      if(!config.callback) {\n        return output;\n      } else {\n        config.callback('', output);\n      }\n    },\n\n    /**\n     * $.csv.fromObjects(objects)\n     * Converts a javascript dictionary to a CSV string.\n     * @param {Object} objects An array of objects containing the data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method generates a CSV file from an array of objects (name:value pairs).\n     * It starts by detecting the headers and adding them as the first line of\n     * the CSV file, followed by a structured dump of the data.\n     */\n    fromObjects2CSV: function(objects, options, callback) {\n      var options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.experimental = 'experimental' in options ? options.experimental : false;\n\n      if(!config.experimental) {\n        throw new Error('not implemented');\n      }\n\n      var output = [];\n      for(i in objects) {\n        output.push(arrays[i]);\n      }\n\n      // push the value to a callback if one is defined\n      if(!config.callback) {\n        return output;\n      } else {\n        config.callback('', output);\n      }\n    }\n  };\n\n  // Maintenance code to maintain backward-compatibility\n  // Will be removed in release 1.0\n  $.csvEntry2Array = $.csv.toArray;\n  $.csv2Array = $.csv.toArrays;\n  $.csv2Dictionary = $.csv.toObjects;\n\n})( jQuery );\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod((function(){try{return require('codemirror')}catch(e){return window.CodeMirror}})());\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\n  function findMatchingBracket(cm, where, strict, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.display.input.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  var currentlyHighlighted = null;\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init)\n      cm.off(\"cursorActivity\", doMatchBrackets);\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, strict, config){\n    return findMatchingBracket(this, pos, strict, config);\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// TODO actually recognize syntax of TypeScript constructs\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod((function(){try{return require('codemirror')}catch(e){return window.CodeMirror}})());\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    var jsKeywords = {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"delete\": C, \"throw\": C, \"debugger\": C,\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"module\": kw(\"module\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"variable-3\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"interface\"),\n        \"extends\": kw(\"extends\"),\n        \"constructor\": kw(\"constructor\"),\n\n        // scope modifiers\n        \"public\": kw(\"public\"),\n        \"private\": kw(\"private\"),\n        \"protected\": kw(\"protected\"),\n        \"static\": kw(\"static\"),\n\n        // types\n        \"string\": type, \"number\": type, \"bool\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (state.lastType == \"operator\" || state.lastType == \"keyword c\" ||\n               state.lastType == \"sof\" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n        readRegexp(stream);\n        stream.eatWhile(/[gimy]/); // 'y' is \"sticky\" option in Mozilla\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n                     ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) break;\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"module\") return cont(pushlex(\"form\"), pushcontext, afterModule, popcontext, poplex);\n    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n    if (type == \"export\") return cont(pushlex(\"form\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"form\"), afterImport, poplex);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"keyword c\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, comprehension, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") { return pass(quasi, maybeop); }\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (type == \"[\") {\n      return cont(expression, expect(\"]\"), afterprop);\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(what, proceed);\n      }\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (isTS && type == \":\") return cont(typedef);\n  }\n  function typedef(type) {\n    if (type == \"variable\"){cx.marked = \"variable-3\"; return cont();}\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, statement, popcontext);\n  }\n  function funarg(type) {\n    if (type == \"spread\") return cont(funarg);\n    return pass(pattern, maybetype);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"extends\") return cont(expression, classNameAfter);\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(classGetterSetter, functiondef, classBody);\n      return cont(functiondef, classBody);\n    }\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \";\") return cont(classBody);\n    if (type == \"}\") return cont();\n  }\n  function classGetterSetter(type) {\n    if (type != \"variable\") return pass();\n    cx.marked = \"property\";\n    return cont();\n  }\n  function afterModule(type, value) {\n    if (type == \"string\") return cont(statement);\n    if (type == \"variable\") { register(value); return cont(maybeFrom); }\n  }\n  function afterExport(_type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    return pass(statement);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    return pass(importSpec, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    return cont();\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(expressionNoComma, maybeArrayComprehension);\n  }\n  function maybeArrayComprehension(type) {\n    if (type == \"for\") return pass(comprehension, expect(\"]\"));\n    if (type == \",\") return cont(commasep(maybeexpressionNoComma, \"]\"));\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function comprehension(type) {\n    if (type == \"for\") return cont(forspec, comprehension);\n    if (type == \"if\") return cont(expression, comprehension);\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod((function(){try{return require('codemirror')}catch(e){return window.CodeMirror}})());\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"xml\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;\n  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag;\n  if (multilineTagIndentPastTag == null) multilineTagIndentPastTag = true;\n\n  var Kludges = parserConfig.htmlMode ? {\n    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                      'track': true, 'wbr': true, 'menuitem': true},\n    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                       'th': true, 'tr': true},\n    contextGrabbers: {\n      'dd': {'dd': true, 'dt': true},\n      'dt': {'dd': true, 'dt': true},\n      'li': {'li': true},\n      'option': {'option': true, 'optgroup': true},\n      'optgroup': {'optgroup': true},\n      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n      'rp': {'rp': true, 'rt': true},\n      'rt': {'rp': true, 'rt': true},\n      'tbody': {'tbody': true, 'tfoot': true},\n      'td': {'td': true, 'th': true},\n      'tfoot': {'tbody': true},\n      'th': {'td': true, 'th': true},\n      'thead': {'tbody': true, 'tfoot': true},\n      'tr': {'tr': true}\n    },\n    doNotIndent: {\"pre\": true},\n    allowUnquoted: true,\n    allowMissing: true,\n    caseFold: true\n  } : {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false,\n    caseFold: false\n  };\n  var alignCDATA = parserConfig.alignCDATA;\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (Kludges.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if (state.context && state.context.tagName == tagName) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          Kludges.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!Kludges.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && Kludges.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: inText,\n              state: baseState,\n              indented: 0,\n              tagName: null, tagStart: null,\n              context: null};\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (multilineTagIndentPastTag)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * multilineTagIndentFactor;\n      }\n      if (alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (Kludges.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = Kludges.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: parserConfig.htmlMode ? \"html\" : \"xml\",\n    helperType: parserConfig.htmlMode ? \"html\" : \"xml\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n",";(function(win){\n\tvar store = {},\n\t\tdoc = win.document,\n\t\tlocalStorageName = 'localStorage',\n\t\tscriptTag = 'script',\n\t\tstorage\n\n\tstore.disabled = false\n\tstore.set = function(key, value) {}\n\tstore.get = function(key) {}\n\tstore.remove = function(key) {}\n\tstore.clear = function() {}\n\tstore.transact = function(key, defaultVal, transactionFn) {\n\t\tvar val = store.get(key)\n\t\tif (transactionFn == null) {\n\t\t\ttransactionFn = defaultVal\n\t\t\tdefaultVal = null\n\t\t}\n\t\tif (typeof val == 'undefined') { val = defaultVal || {} }\n\t\ttransactionFn(val)\n\t\tstore.set(key, val)\n\t}\n\tstore.getAll = function() {}\n\tstore.forEach = function() {}\n\n\tstore.serialize = function(value) {\n\t\treturn JSON.stringify(value)\n\t}\n\tstore.deserialize = function(value) {\n\t\tif (typeof value != 'string') { return undefined }\n\t\ttry { return JSON.parse(value) }\n\t\tcatch(e) { return value || undefined }\n\t}\n\n\t// Functions to encapsulate questionable FireFox 3.6.13 behavior\n\t// when about.config::dom.storage.enabled === false\n\t// See https://github.com/marcuswestin/store.js/issues#issue/13\n\tfunction isLocalStorageNameSupported() {\n\t\ttry { return (localStorageName in win && win[localStorageName]) }\n\t\tcatch(err) { return false }\n\t}\n\n\tif (isLocalStorageNameSupported()) {\n\t\tstorage = win[localStorageName]\n\t\tstore.set = function(key, val) {\n\t\t\tif (val === undefined) { return store.remove(key) }\n\t\t\tstorage.setItem(key, store.serialize(val))\n\t\t\treturn val\n\t\t}\n\t\tstore.get = function(key) { return store.deserialize(storage.getItem(key)) }\n\t\tstore.remove = function(key) { storage.removeItem(key) }\n\t\tstore.clear = function() { storage.clear() }\n\t\tstore.getAll = function() {\n\t\t\tvar ret = {}\n\t\t\tstore.forEach(function(key, val) {\n\t\t\t\tret[key] = val\n\t\t\t})\n\t\t\treturn ret\n\t\t}\n\t\tstore.forEach = function(callback) {\n\t\t\tfor (var i=0; i<storage.length; i++) {\n\t\t\t\tvar key = storage.key(i)\n\t\t\t\tcallback(key, store.get(key))\n\t\t\t}\n\t\t}\n\t} else if (doc.documentElement.addBehavior) {\n\t\tvar storageOwner,\n\t\t\tstorageContainer\n\t\t// Since #userData storage applies only to specific paths, we need to\n\t\t// somehow link our data to a specific path.  We choose /favicon.ico\n\t\t// as a pretty safe option, since all browsers already make a request to\n\t\t// this URL anyway and being a 404 will not hurt us here.  We wrap an\n\t\t// iframe pointing to the favicon in an ActiveXObject(htmlfile) object\n\t\t// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)\n\t\t// since the iframe access rules appear to allow direct access and\n\t\t// manipulation of the document element, even for a 404 page.  This\n\t\t// document can be used instead of the current document (which would\n\t\t// have been limited to the current path) to perform #userData storage.\n\t\ttry {\n\t\t\tstorageContainer = new ActiveXObject('htmlfile')\n\t\t\tstorageContainer.open()\n\t\t\tstorageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src=\"/favicon.ico\"></iframe>')\n\t\t\tstorageContainer.close()\n\t\t\tstorageOwner = storageContainer.w.frames[0].document\n\t\t\tstorage = storageOwner.createElement('div')\n\t\t} catch(e) {\n\t\t\t// somehow ActiveXObject instantiation failed (perhaps some special\n\t\t\t// security settings or otherwse), fall back to per-path storage\n\t\t\tstorage = doc.createElement('div')\n\t\t\tstorageOwner = doc.body\n\t\t}\n\t\tfunction withIEStorage(storeFunction) {\n\t\t\treturn function() {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments, 0)\n\t\t\t\targs.unshift(storage)\n\t\t\t\t// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx\n\t\t\t\t// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx\n\t\t\t\tstorageOwner.appendChild(storage)\n\t\t\t\tstorage.addBehavior('#default#userData')\n\t\t\t\tstorage.load(localStorageName)\n\t\t\t\tvar result = storeFunction.apply(store, args)\n\t\t\t\tstorageOwner.removeChild(storage)\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\n\t\t// In IE7, keys cannot start with a digit or contain certain chars.\n\t\t// See https://github.com/marcuswestin/store.js/issues/40\n\t\t// See https://github.com/marcuswestin/store.js/issues/83\n\t\tvar forbiddenCharsRegex = new RegExp(\"[!\\\"#$%&'()*+,/\\\\\\\\:;<=>?@[\\\\]^`{|}~]\", \"g\")\n\t\tfunction ieKeyFix(key) {\n\t\t\treturn key.replace(/^d/, '___$&').replace(forbiddenCharsRegex, '___')\n\t\t}\n\t\tstore.set = withIEStorage(function(storage, key, val) {\n\t\t\tkey = ieKeyFix(key)\n\t\t\tif (val === undefined) { return store.remove(key) }\n\t\t\tstorage.setAttribute(key, store.serialize(val))\n\t\t\tstorage.save(localStorageName)\n\t\t\treturn val\n\t\t})\n\t\tstore.get = withIEStorage(function(storage, key) {\n\t\t\tkey = ieKeyFix(key)\n\t\t\treturn store.deserialize(storage.getAttribute(key))\n\t\t})\n\t\tstore.remove = withIEStorage(function(storage, key) {\n\t\t\tkey = ieKeyFix(key)\n\t\t\tstorage.removeAttribute(key)\n\t\t\tstorage.save(localStorageName)\n\t\t})\n\t\tstore.clear = withIEStorage(function(storage) {\n\t\t\tvar attributes = storage.XMLDocument.documentElement.attributes\n\t\t\tstorage.load(localStorageName)\n\t\t\tfor (var i=0, attr; attr=attributes[i]; i++) {\n\t\t\t\tstorage.removeAttribute(attr.name)\n\t\t\t}\n\t\t\tstorage.save(localStorageName)\n\t\t})\n\t\tstore.getAll = function(storage) {\n\t\t\tvar ret = {}\n\t\t\tstore.forEach(function(key, val) {\n\t\t\t\tret[key] = val\n\t\t\t})\n\t\t\treturn ret\n\t\t}\n\t\tstore.forEach = withIEStorage(function(storage, callback) {\n\t\t\tvar attributes = storage.XMLDocument.documentElement.attributes\n\t\t\tfor (var i=0, attr; attr=attributes[i]; ++i) {\n\t\t\t\tcallback(attr.name, store.deserialize(storage.getAttribute(attr.name)))\n\t\t\t}\n\t\t})\n\t}\n\n\ttry {\n\t\tvar testKey = '__storejs__'\n\t\tstore.set(testKey, testKey)\n\t\tif (store.get(testKey) != testKey) { store.disabled = true }\n\t\tstore.remove(testKey)\n\t} catch(e) {\n\t\tstore.disabled = true\n\t}\n\tstore.enabled = !store.disabled\n\n\tif (typeof module != 'undefined' && module.exports && this.module !== module) { module.exports = store }\n\telse if (typeof define === 'function' && define.amd) { define(store) }\n\telse { win.store = store }\n\n})(Function('return this')());\n","module.exports={\n  \"name\": \"yasgui-utils\",\n  \"version\": \"1.4.1\",\n  \"description\": \"Utils for YASGUI libs\",\n  \"main\": \"src/main.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/YASGUI/Utils.git\"\n  },\n  \"licenses\": [\n    {\n      \"type\": \"MIT\",\n      \"url\": \"http://yasgui.github.io/license.txt\"\n    }\n  ],\n  \"author\": {\n    \"name\": \"Laurens Rietveld\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"Laurens Rietveld\",\n      \"email\": \"laurens.rietveld@gmail.com\",\n      \"url\": \"http://laurensrietveld.nl\"\n    }\n  ],\n  \"bugs\": {\n    \"url\": \"https://github.com/YASGUI/Utils/issues\"\n  },\n  \"homepage\": \"https://github.com/YASGUI/Utils\",\n  \"dependencies\": {\n    \"store\": \"^1.3.14\"\n  },\n  \"readme\": \"A simple utils repo for the YASGUI tools\\n\",\n  \"readmeFilename\": \"README.md\",\n  \"_id\": \"yasgui-utils@1.4.1\",\n  \"_from\": \"yasgui-utils@^1.4.1\"\n}\n","window.console = window.console || {\"log\":function(){}};//make sure any console statements don't break IE\nmodule.exports = {\n\tstorage: require(\"./storage.js\"),\n\tsvg: require(\"./svg.js\"),\n\tversion: {\n\t\t\"yasgui-utils\" : require(\"../package.json\").version,\n\t}\n};\n","var store = require(\"store\");\nvar times = {\n\tday: function() {\n\t\treturn 1000 * 3600 * 24;//millis to day\n\t},\n\tmonth: function() {\n\t\ttimes.day() * 30;\n\t},\n\tyear: function() {\n\t\ttimes.month() * 12;\n\t}\n};\n\nvar root = module.exports = {\n\tset : function(key, val, exp) {\n\t\tif (typeof exp == \"string\") {\n\t\t\texp = times[exp]();\n\t\t}\n\t\t//try to store string for dom objects (e.g. XML result). Otherwise, we might get a circular reference error when stringifying this\n\t\tif (val.documentElement) val = new XMLSerializer().serializeToString(val.documentElement);\n\t\tstore.set(key, {\n\t\t\tval : val,\n\t\t\texp : exp,\n\t\t\ttime : new Date().getTime()\n\t\t});\n\t},\n\tget : function(key) {\n\t\tvar info = store.get(key);\n\t\tif (!info) {\n\t\t\treturn null;\n\t\t}\n\t\tif (info.exp && new Date().getTime() - info.time > info.exp) {\n\t\t\treturn null;\n\t\t}\n\t\treturn info.val;\n\t}\n\n};\n","module.exports = {\n\tdraw: function(parent, svgString, config) {\n\t\tif (!parent) return;\n\t\tvar el = module.exports.getElement(svgString, config);\n\t\tif (el) {\n\t\t\tif (parent.append) {\n\t\t\t\tparent.append(el);\n\t\t\t} else {\n\t\t\t\t//regular dom doc\n\t\t\t\tparent.appendChild(el);\n\t\t\t}\n\t\t}\n\t},\n\tgetElement: function(svgString, config) {\n\t\tif (svgString && svgString.indexOf(\"<svg\") == 0) {\n\t\t\tif (!config.width) config.width = \"100%\";\n\t\t\tif (!config.height) config.height = \"100%\";\n\t\t\t\n\t\t\tvar parser = new DOMParser();\n\t\t\tvar dom = parser.parseFromString(svgString, \"text/xml\");\n\t\t\tvar svg = dom.documentElement;\n\t\t\t\n\t\t\tvar svgContainer = document.createElement(\"div\");\n\t\t\tsvgContainer.style.display = \"inline-block\";\n\t\t\tsvgContainer.style.width = config.width;\n\t\t\tsvgContainer.style.height = config.height;\n\t\t\tsvgContainer.appendChild(svg);\n\t\t\treturn svgContainer;\n\t\t}\n\t\treturn false;\n\t}\n};","module.exports={\n  \"name\": \"yasgui-yasr\",\n  \"description\": \"Yet Another SPARQL Resultset GUI\",\n  \"version\": \"2.1.0\",\n  \"main\": \"src/main.js\",\n  \"licenses\": [\n    {\n      \"type\": \"MIT\",\n      \"url\": \"http://yasr.yasgui.org/license.txt\"\n    }\n  ],\n  \"author\": \"Laurens Rietveld\",\n  \"homepage\": \"http://yasr.yasgui.org\",\n  \"devDependencies\": {\n    \"browserify\": \"^6.1.0\",\n    \"gulp\": \"~3.6.0\",\n    \"gulp-bump\": \"^0.1.11\",\n    \"gulp-concat\": \"^2.4.1\",\n    \"gulp-connect\": \"^2.0.5\",\n    \"gulp-embedlr\": \"^0.5.2\",\n    \"gulp-filter\": \"^1.0.2\",\n    \"gulp-git\": \"^0.5.2\",\n    \"gulp-jsvalidate\": \"^0.2.0\",\n    \"gulp-livereload\": \"^1.3.1\",\n    \"gulp-minify-css\": \"^0.3.0\",\n    \"gulp-notify\": \"^1.2.5\",\n    \"gulp-rename\": \"^1.2.0\",\n    \"gulp-streamify\": \"0.0.5\",\n    \"gulp-tag-version\": \"^1.1.0\",\n    \"gulp-uglify\": \"^0.2.1\",\n    \"require-dir\": \"^0.1.0\",\n    \"run-sequence\": \"^1.0.1\",\n    \"vinyl-buffer\": \"^1.0.0\",\n    \"vinyl-source-stream\": \"~0.1.1\",\n    \"watchify\": \"^0.6.4\",\n    \"gulp-sourcemaps\": \"^1.2.4\",\n    \"exorcist\": \"^0.1.6\",\n    \"vinyl-transform\": \"0.0.1\",\n    \"gulp-sass\": \"^1.2.2\",\n    \"yasgui-yasqe\": \"^2.0.1\",\n    \"twitter-bootstrap-3.0.0\": \"^3.0.0\",\n    \"browserify-transform-tools\": \"^1.2.1\"\n  },\n  \"bugs\": \"https://github.com/YASGUI/YASR/issues/\",\n  \"keywords\": [\n    \"JavaScript\",\n    \"SPARQL\",\n    \"Editor\",\n    \"Semantic Web\",\n    \"Linked Data\"\n  ],\n  \"maintainers\": [\n    {\n      \"name\": \"Laurens Rietveld\",\n      \"email\": \"laurens.rietveld@gmail.com\",\n      \"web\": \"http://laurensrietveld.nl\"\n    }\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/YASGUI/YASR.git\"\n  },\n  \"dependencies\": {\n    \"jquery\": \"~ 1.11.0\",\n    \"codemirror\": \"^4.2.0\",\n    \"yasgui-utils\": \"^1.4.1\"\n  },\n  \"optionalShim\": {\n    \"codemirror\": {\n      \"require\": \"codemirror\",\n      \"global\": \"CodeMirror\"\n    },\n    \"jquery\": {\n      \"require\": \"jquery\",\n      \"global\": \"jQuery\"\n    },\n    \"../../lib/codemirror\": {\n      \"require\": \"codemirror\",\n      \"global\": \"CodeMirror\"\n    },\n    \"../lib/DataTables/media/js/jquery.dataTables.js\": {\n      \"require\": \"jquery.dataTables\",\n      \"global\": \"jQuery\"\n    }\n  }\n}\n","module.exports = function(result) {\n\tvar quote = \"\\\"\";\n\tvar delimiter = \",\";\n\tvar lineBreak= \"\\n\";\n\t\n\tvar variables = result.head.vars;\n\t\n\tvar querySolutions= result.results.bindings;\n\t\n\t\n\t\n\tvar createHeader = function() {\n\t\tfor (var i = 0; i < variables.length; i++) {\n\t\t\taddValueToString(variables[i]);\n\t\t}\n\t\tcsvString += lineBreak;\n\t};\n\t\n\tvar createBody = function() {\n\t\tfor (var i = 0; i < querySolutions.length; i++) {\n\t\t\taddQuerySolutionToString(querySolutions[i]);\n\t\t\tcsvString += lineBreak;\n\t\t}\n\t};\n\t\n\tvar addQuerySolutionToString = function(querySolution) {\n\t\tfor (var i = 0; i < variables.length; i++) {\n\t\t\tvar variable = variables[i];\n\t\t\tif(querySolution.hasOwnProperty(variable)){\n\t\t\t\taddValueToString(querySolution[variable][\"value\"]);\n\t\t\t} else {\n\t\t\t\taddValueToString(\"\");\n\t\t\t}\n\t\t}\n\t};\n\tvar addValueToString = function(value) {\n\t\t//Quotes in the string need to be escaped\n\t\tvalue.replace(quote, quote + quote);\n\t\tif (needToQuoteString(value)) {\n\t\t\tvalue = quote + value + quote;\n\t\t}\n\t\tcsvString += \" \" + value + \" \" + delimiter;\n\t};\n\t\n\tvar needToQuoteString = function(value) {\n\t\t//quote when it contains whitespace or the delimiter\n\t\tvar needQuoting = false;\n\t\tif (value.match(\"[\\\\w|\"+ delimiter + \"|\" + quote + \"]\")) {\n\t\t\tneedQuoting = true;\n\t\t}\n\t\treturn needQuoting;\n\t};\n\t\n\tcsvString = \"\";\n\tcreateHeader();\n\tcreateBody();\n\treturn csvString;\n};","var $ = (function(){try{return require('jquery')}catch(e){return window.jQuery}})();\n\n/**\n * Constructor of plugin which displays boolean info\n * \n * @param yasr {object}\n * @param parent {DOM element}\n * @param options {object}\n * @class YASR.plugins.boolean\n * @return yasr-boolean (doc)\n * \n */\nvar root = module.exports = function(yasr) {\n\tvar container = $(\"<div class='booleanResult'></div>\");\n\tvar draw = function() {\n\t\tcontainer.empty().appendTo(yasr.resultsContainer);\n\t\tvar booleanVal = yasr.results.getBoolean();\n\t\t\n\t\tvar imgId = null;\n\t\tvar textVal = null;\n\t\tif (booleanVal === true) {\n\t\t\timgId = \"check\";\n\t\t\ttextVal = \"True\";\n\t\t} else if (booleanVal === false) {\n\t\t\timgId = \"cross\";\n\t\t\ttextVal = \"False\";\n\t\t} else {\n\t\t\tcontainer.width(\"140\");\n\t\t\ttextVal = \"Could not find boolean value in response\";\n\t\t}\n\t\t\n\t\t//add icon\n\t\tif (imgId) require(\"yasgui-utils\").svg.draw(container, require('./imgs.js')[imgId], {\n\t\t\twidth: 25,\n\t\t\theight: 25,\n\t\t});\n\t\t\n\t\t$(\"<span></span>\").text(textVal).appendTo(container);\n\t};\n\t\n\n\tvar canHandleResults = function(){return yasr.results.getBoolean() === true || yasr.results.getBoolean() == false;};\n\n\t\n\t\n\treturn {\n\t\tname: null,//don't need to set this: we don't show it in the selection widget anyway, so don't need a human-friendly name\n\t\tdraw: draw,\n\t\thideFromSelection: true,\n\t\tgetPriority: 10,\n\t\tcanHandleResults: canHandleResults\n\t}\n};\n\n\nroot.version = {\n\t\"YASR-boolean\" : require(\"../package.json\").version,\n\t\"jquery\": $.fn.jquery,\n};\n\n","var $ = (function(){try{return require('jquery')}catch(e){return window.jQuery}})();\nmodule.exports = {\n\t/**\n\t * key of default plugin to use\n\t * @property output\n\t * @type string\n\t * @default \"table\"\n\t */\n\toutput: \"table\",\n\t\n\toutputPlugins: [\"table\", \"error\", \"boolean\", \"rawResponse\"],\n\t\n\t/**\n\t * Draw the output selector widget\n\t * \n\t * @property drawOutputSelector\n\t * @type boolean\n\t * @default true\n\t */\n\tdrawOutputSelector: true,\n\t\n\t/**\n\t * Draw download icon. This issues html5 download functionality to 'download' files created on the client-side.\n\t *  This allows the user to download results already queried for, such as a CSV when a table is shown, or the original response when the raw response output is selected\n\t * \n\t * @property drawDownloadIcon\n\t * @type boolean\n\t * @default true\n\t */\n\tdrawDownloadIcon: true,\n\t\n\t\n\tgetUsedPrefixes: null,\n\t/**\n\t * Make certain settings and values of YASR persistent. Setting a key\n\t * to null, will disable persistancy: nothing is stored between browser\n\t * sessions Setting the values to a string (or a function which returns a\n\t * string), will store the query in localstorage using the specified string.\n\t * By default, the ID is dynamically generated by finding the nearest DOM element with an \"id\" set,\n\t * to avoid collissions when using multiple YASR items on one page\n\t * \n\t * @property persistency\n\t * @type object\n\t */\n\tpersistency: {\n\t\t/**\n\t\t * Persistency setting for the selected output\n\t\t * \n\t\t * @property persistency.outputSelector\n\t\t * @type string|function\n\t\t * @default function (determine unique id)\n\t\t */\n\t\toutputSelector: function(yasr) {\n\t\t\treturn \"selector_\" + $(yasr.container).closest('[id]').attr('id');\n\t\t},\n\t\t/**\n\t\t * Persistency setting for query results.\n\t\t * \n\t\t * @property persistency.results\n\t\t * @type object\n\t\t */\n\t\tresults: {\n\t\t\t/**\n\t\t\t * Get the key to store results in\n\t\t\t * \n\t\t\t * @property persistency.results.id\n\t\t\t * @type string|function\n\t\t\t * @default function (determine unique id)\n\t\t\t */\n\t\t\tid: function(yasr){\n\t\t\t\treturn \"results_\" +  $(yasr.container).closest('[id]').attr('id');\n\t\t\t},\n\t\t\t/**\n\t\t\t * The result set might too large to fit in local storage. \n\t\t\t * It is impossible to detect how large the local storage is.\n\t\t\t * Therefore, we do not store all results in local storage, depending on a max number of characters in the SPARQL result serialization.\n\t\t\t * Set this function conservitavely. (especially when using multiple YASR instances on one page)\n\t\t\t * \n\t\t\t * @property persistency.results.maxSize\n\t\t\t * @type int\n\t\t\t * @default 100000\n\t\t\t */\n\t\t\tmaxSize: 100000 //char count\n\t\t}\n\t\t\n\t},\n\t\n\t\n};","var $ = (function(){try{return require('jquery')}catch(e){return window.jQuery}})();\n\n/**\n * Constructor of plugin which displays SPARQL errors\n * \n * @param yasr {object}\n * @param parent {DOM element}\n * @param options {object}\n * @class YASR.plugins.boolean\n * @return yasr-erro (doc)\n * \n */\nvar root = module.exports = function(yasr) {\n\tvar container = $(\"<div class='errorResult'></div>\");\n\tvar options = $.extend(true, {}, root.defaults);\n\t\n\tvar draw = function() {\n\t\tcontainer.empty().appendTo(yasr.resultsContainer);\n\t\t$(\"<span class='exception'>ERROR</span>\").appendTo(container);\n\t\t$(\"<p></p>\").html(yasr.results.getException()).appendTo(container);\n\t};\n\t\n\t\n\tvar  canHandleResults = function(yasr){return yasr.results.getException() || false;};\n\t\n\treturn {\n\t\tname: null,//don't need to set this: we don't show it in the selection widget anyway, so don't need a human-friendly name\n\t\tdraw: draw,\n\t\tgetPriority: 20,\n\t\thideFromSelection: true,\n\t\tcanHandleResults: canHandleResults,\n\t}\n};\n\n/**\n * Defaults for error plugin\n * \n * @type object\n * @attribute YASR.plugins.error.defaults\n */\nroot.defaults = {\n\t\n};","module.exports = {\n\tcross: '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" x=\"0px\" y=\"0px\" width=\"30px\" height=\"30px\" viewBox=\"0 0 100 100\" enable-background=\"new 0 0 100 100\" xml:space=\"preserve\"><g>\t<path d=\"M83.288,88.13c-2.114,2.112-5.575,2.112-7.689,0L53.659,66.188c-2.114-2.112-5.573-2.112-7.687,0L24.251,87.907   c-2.113,2.114-5.571,2.114-7.686,0l-4.693-4.691c-2.114-2.114-2.114-5.573,0-7.688l21.719-21.721c2.113-2.114,2.113-5.573,0-7.686   L11.872,24.4c-2.114-2.113-2.114-5.571,0-7.686l4.842-4.842c2.113-2.114,5.571-2.114,7.686,0L46.12,33.591   c2.114,2.114,5.572,2.114,7.688,0l21.721-21.719c2.114-2.114,5.573-2.114,7.687,0l4.695,4.695c2.111,2.113,2.111,5.571-0.003,7.686   L66.188,45.973c-2.112,2.114-2.112,5.573,0,7.686L88.13,75.602c2.112,2.111,2.112,5.572,0,7.687L83.288,88.13z\"/></g></svg>',\n\tcheck: '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" x=\"0px\" y=\"0px\" width=\"30px\" height=\"30px\" viewBox=\"0 0 100 100\" enable-background=\"new 0 0 100 100\" xml:space=\"preserve\"><path fill=\"#000000\" d=\"M14.301,49.982l22.606,17.047L84.361,4.903c2.614-3.733,7.76-4.64,11.493-2.026l0.627,0.462  c3.732,2.614,4.64,7.758,2.025,11.492l-51.783,79.77c-1.955,2.791-3.896,3.762-7.301,3.988c-3.405,0.225-5.464-1.039-7.508-3.084  L2.447,61.814c-3.263-3.262-3.263-8.553,0-11.814l0.041-0.019C5.75,46.718,11.039,46.718,14.301,49.982z\"/></svg>',\n\tunsorted: '<svg   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"   xmlns:cc=\"http://creativecommons.org/ns#\"   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"   xmlns:svg=\"http://www.w3.org/2000/svg\"   xmlns=\"http://www.w3.org/2000/svg\"   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"   version=\"1.1\"   id=\"Layer_1\"   x=\"0px\"   y=\"0px\"   width=\"100%\"   height=\"100%\"   viewBox=\"0 0 54.552711 113.78478\"   enable-background=\"new 0 0 100 100\"   xml:space=\"preserve\"><g     id=\"g5\"     transform=\"matrix(-0.70522156,-0.70898699,-0.70898699,0.70522156,97.988199,55.081205)\"><path       style=\"fill:#000000\"       inkscape:connector-curvature=\"0\"       id=\"path7\"       d=\"M 57.911,66.915 45.808,55.063 42.904,52.238 31.661,41.25 31.435,41.083 31.131,40.775 30.794,40.523 30.486,40.3 30.069,40.05 29.815,39.911 29.285,39.659 29.089,39.576 28.474,39.326 28.363,39.297 H 28.336 L 27.665,39.128 27.526,39.1 26.94,38.99 26.714,38.961 26.212,38.934 h -0.31 -0.444 l -0.339,0.027 c -1.45,0.139 -2.876,0.671 -4.11,1.564 l -0.223,0.141 -0.279,0.25 -0.335,0.308 -0.054,0.029 -0.171,0.194 -0.334,0.364 -0.224,0.279 -0.25,0.336 -0.225,0.362 -0.192,0.308 -0.197,0.421 -0.142,0.279 -0.193,0.477 -0.084,0.222 -12.441,38.414 c -0.814,2.458 -0.313,5.029 1.115,6.988 v 0.026 l 0.418,0.532 0.17,0.165 0.251,0.281 0.084,0.079 0.283,0.281 0.25,0.194 0.474,0.367 0.083,0.053 c 2.015,1.371 4.641,1.874 7.131,1.094 L 55.228,80.776 c 4.303,-1.342 6.679,-5.814 5.308,-10.006 -0.387,-1.259 -1.086,-2.35 -1.979,-3.215 l -0.368,-0.337 -0.278,-0.303 z m -6.318,5.896 0.079,0.114 -37.369,11.57 11.854,-36.538 10.565,10.317 2.876,2.825 11.995,11.712 z\" /></g><path     style=\"fill:#000000\"     inkscape:connector-curvature=\"0\"     id=\"path7-9\"     d=\"m 8.8748339,52.571766 16.9382111,-0.222584 4.050851,-0.06665 15.719154,-0.222166 0.27778,-0.04246 0.43276,0.0017 0.41632,-0.06121 0.37532,-0.0611 0.47132,-0.119342 0.27767,-0.08206 0.55244,-0.198047 0.19707,-0.08043 0.61095,-0.259721 0.0988,-0.05825 0.019,-0.01914 0.59303,-0.356548 0.11787,-0.0788 0.49125,-0.337892 0.17994,-0.139779 0.37317,-0.336871 0.21862,-0.219786 0.31311,-0.31479 0.21993,-0.259387 c 0.92402,-1.126057 1.55249,-2.512251 1.78961,-4.016904 l 0.0573,-0.25754 0.0195,-0.374113 0.0179,-0.454719 0.0175,-0.05874 -0.0169,-0.258049 -0.0225,-0.493503 -0.0398,-0.355569 -0.0619,-0.414201 -0.098,-0.414812 -0.083,-0.353334 L 53.23955,41.1484 53.14185,40.850967 52.93977,40.377742 52.84157,40.161628 34.38021,4.2507375 C 33.211567,1.9401875 31.035446,0.48226552 28.639484,0.11316952 l -0.01843,-0.01834 -0.671963,-0.07882 -0.236871,0.0042 L 27.335984,-4.7826577e-7 27.220736,0.00379952 l -0.398804,0.0025 -0.313848,0.04043 -0.594474,0.07724 -0.09611,0.02147 C 23.424549,0.60716252 21.216017,2.1142355 20.013025,4.4296865 L 0.93967491,40.894479 c -2.08310801,3.997178 -0.588125,8.835482 3.35080799,10.819749 1.165535,0.613495 2.43199,0.88731 3.675026,0.864202 l 0.49845,-0.02325 0.410875,0.01658 z M 9.1502369,43.934401 9.0136999,43.910011 27.164145,9.2564625 44.70942,43.42818 l -14.765289,0.214677 -4.031106,0.0468 -16.7627881,0.244744 z\" /></svg>',\n\tsortDesc: '<svg   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"   xmlns:cc=\"http://creativecommons.org/ns#\"   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"   xmlns:svg=\"http://www.w3.org/2000/svg\"   xmlns=\"http://www.w3.org/2000/svg\"   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"   version=\"1.1\"   id=\"Layer_1\"   x=\"0px\"   y=\"0px\"   width=\"100%\"   height=\"100%\"   viewBox=\"0 0 54.552711 113.78478\"   enable-background=\"new 0 0 100 100\"   xml:space=\"preserve\"><g     id=\"g5\"     transform=\"matrix(-0.70522156,-0.70898699,-0.70898699,0.70522156,97.988199,55.081205)\"><path       style=\"fill:#000000\"       inkscape:connector-curvature=\"0\"       id=\"path7\"       d=\"M 57.911,66.915 45.808,55.063 42.904,52.238 31.661,41.25 31.435,41.083 31.131,40.775 30.794,40.523 30.486,40.3 30.069,40.05 29.815,39.911 29.285,39.659 29.089,39.576 28.474,39.326 28.363,39.297 H 28.336 L 27.665,39.128 27.526,39.1 26.94,38.99 26.714,38.961 26.212,38.934 h -0.31 -0.444 l -0.339,0.027 c -1.45,0.139 -2.876,0.671 -4.11,1.564 l -0.223,0.141 -0.279,0.25 -0.335,0.308 -0.054,0.029 -0.171,0.194 -0.334,0.364 -0.224,0.279 -0.25,0.336 -0.225,0.362 -0.192,0.308 -0.197,0.421 -0.142,0.279 -0.193,0.477 -0.084,0.222 -12.441,38.414 c -0.814,2.458 -0.313,5.029 1.115,6.988 v 0.026 l 0.418,0.532 0.17,0.165 0.251,0.281 0.084,0.079 0.283,0.281 0.25,0.194 0.474,0.367 0.083,0.053 c 2.015,1.371 4.641,1.874 7.131,1.094 L 55.228,80.776 c 4.303,-1.342 6.679,-5.814 5.308,-10.006 -0.387,-1.259 -1.086,-2.35 -1.979,-3.215 l -0.368,-0.337 -0.278,-0.303 z m -6.318,5.896 0.079,0.114 -37.369,11.57 11.854,-36.538 10.565,10.317 2.876,2.825 11.995,11.712 z\" /></g><path     style=\"fill:#000000\"     inkscape:connector-curvature=\"0\"     id=\"path9\"     d=\"m 27.813273,0.12823506 0.09753,0.02006 c 2.39093,0.458209 4.599455,1.96811104 5.80244,4.28639004 L 52.785897,40.894525 c 2.088044,4.002139 0.590949,8.836902 -3.348692,10.821875 -1.329078,0.688721 -2.766603,0.943695 -4.133174,0.841768 l -0.454018,0.02 L 27.910392,52.354171 23.855313,52.281851 8.14393,52.061827 7.862608,52.021477 7.429856,52.021738 7.014241,51.959818 6.638216,51.900838 6.164776,51.779369 5.889216,51.699439 5.338907,51.500691 5.139719,51.419551 4.545064,51.145023 4.430618,51.105123 4.410168,51.084563 3.817138,50.730843 3.693615,50.647783 3.207314,50.310611 3.028071,50.174369 2.652795,49.833957 2.433471,49.613462 2.140099,49.318523 1.901127,49.041407 C 0.97781,47.916059 0.347935,46.528448 0.11153,45.021676 L 0.05352,44.766255 0.05172,44.371683 0.01894,43.936017 0,43.877277 0.01836,43.62206 0.03666,43.122889 0.0765,42.765905 0.13912,42.352413 0.23568,41.940425 0.32288,41.588517 0.481021,41.151945 0.579391,40.853806 0.77369,40.381268 0.876097,40.162336 19.338869,4.2542801 c 1.172169,-2.308419 3.34759,-3.76846504 5.740829,-4.17716604 l 0.01975,0.01985 0.69605,-0.09573 0.218437,0.0225 0.490791,-0.02132 0.39809,0.0046 0.315972,0.03973 0.594462,0.08149 z\" /></svg>',\n\tsortAsc: '<svg   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"   xmlns:cc=\"http://creativecommons.org/ns#\"   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"   xmlns:svg=\"http://www.w3.org/2000/svg\"   xmlns=\"http://www.w3.org/2000/svg\"   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"   version=\"1.1\"   id=\"Layer_1\"   x=\"0px\"   y=\"0px\"   width=\"100%\"   height=\"100%\"   viewBox=\"0 0 54.552711 113.78478\"   enable-background=\"new 0 0 100 100\"   xml:space=\"preserve\"><g     id=\"g5\"     transform=\"matrix(-0.70522156,0.70898699,-0.70898699,-0.70522156,97.988199,58.704807)\"><path       style=\"fill:#000000\"       inkscape:connector-curvature=\"0\"       id=\"path7\"       d=\"M 57.911,66.915 45.808,55.063 42.904,52.238 31.661,41.25 31.435,41.083 31.131,40.775 30.794,40.523 30.486,40.3 30.069,40.05 29.815,39.911 29.285,39.659 29.089,39.576 28.474,39.326 28.363,39.297 H 28.336 L 27.665,39.128 27.526,39.1 26.94,38.99 26.714,38.961 26.212,38.934 h -0.31 -0.444 l -0.339,0.027 c -1.45,0.139 -2.876,0.671 -4.11,1.564 l -0.223,0.141 -0.279,0.25 -0.335,0.308 -0.054,0.029 -0.171,0.194 -0.334,0.364 -0.224,0.279 -0.25,0.336 -0.225,0.362 -0.192,0.308 -0.197,0.421 -0.142,0.279 -0.193,0.477 -0.084,0.222 -12.441,38.414 c -0.814,2.458 -0.313,5.029 1.115,6.988 v 0.026 l 0.418,0.532 0.17,0.165 0.251,0.281 0.084,0.079 0.283,0.281 0.25,0.194 0.474,0.367 0.083,0.053 c 2.015,1.371 4.641,1.874 7.131,1.094 L 55.228,80.776 c 4.303,-1.342 6.679,-5.814 5.308,-10.006 -0.387,-1.259 -1.086,-2.35 -1.979,-3.215 l -0.368,-0.337 -0.278,-0.303 z m -6.318,5.896 0.079,0.114 -37.369,11.57 11.854,-36.538 10.565,10.317 2.876,2.825 11.995,11.712 z\" /></g><path     style=\"fill:#000000\"     inkscape:connector-curvature=\"0\"     id=\"path9\"     d=\"m 27.813273,113.65778 0.09753,-0.0201 c 2.39093,-0.45821 4.599455,-1.96811 5.80244,-4.28639 L 52.785897,72.891487 c 2.088044,-4.002139 0.590949,-8.836902 -3.348692,-10.821875 -1.329078,-0.688721 -2.766603,-0.943695 -4.133174,-0.841768 l -0.454018,-0.02 -16.939621,0.223997 -4.055079,0.07232 -15.711383,0.220024 -0.281322,0.04035 -0.432752,-2.61e-4 -0.415615,0.06192 -0.376025,0.05898 -0.47344,0.121469 -0.27556,0.07993 -0.550309,0.198748 -0.199188,0.08114 -0.594655,0.274528 -0.114446,0.0399 -0.02045,0.02056 -0.59303,0.35372 -0.123523,0.08306 -0.486301,0.337172 -0.179243,0.136242 -0.375276,0.340412 -0.219324,0.220495 -0.293372,0.294939 -0.238972,0.277116 C 0.97781,65.869953 0.347935,67.257564 0.11153,68.764336 L 0.05352,69.019757 0.05172,69.414329 0.01894,69.849995 0,69.908735 l 0.01836,0.255217 0.0183,0.499171 0.03984,0.356984 0.06262,0.413492 0.09656,0.411988 0.0872,0.351908 0.158141,0.436572 0.09837,0.298139 0.194299,0.472538 0.102407,0.218932 18.462772,35.908054 c 1.172169,2.30842 3.34759,3.76847 5.740829,4.17717 l 0.01975,-0.0199 0.69605,0.0957 0.218437,-0.0225 0.490791,0.0213 0.39809,-0.005 0.315972,-0.0397 0.594462,-0.0815 z\" /></svg>',\n\tdownload: '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" baseProfile=\"tiny\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 100 100\" xml:space=\"preserve\"><g id=\"Captions\"></g><g id=\"Your_Icon\">\t<path fill-rule=\"evenodd\" fill=\"#000000\" d=\"M88,84v-2c0-2.961-0.859-4-4-4H16c-2.961,0-4,0.98-4,4v2c0,3.102,1.039,4,4,4h68   C87.02,88,88,87.039,88,84z M58,12H42c-5,0-6,0.941-6,6v22H16l34,34l34-34H64V18C64,12.941,62.939,12,58,12z\"/></g></svg>',\n};","var $ = (function(){try{return require('jquery')}catch(e){return window.jQuery}})();\nvar root = module.exports = function(queryResponse) {\n\treturn require(\"./dlv.js\")(queryResponse, \",\");\n};","var $ = jQuery = (function(){try{return require('jquery')}catch(e){return window.jQuery}})();\nrequire(\"../../lib/jquery.csv-0.71.js\");\nvar root = module.exports = function(queryResponse, separator) {\n\tvar json = {};\n\tvar arrays =  $.csv.toArrays(queryResponse, {separator: separator});\n\tvar detectType = function(value) {\n\t\tif (value.indexOf(\"http\") == 0) {\n\t\t\treturn \"uri\";\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\t\n\tvar getBoolean = function() {\n\t\tif (arrays.length == 2 && arrays[0].length == 1 && arrays[1].length == 1\n\t\t\t\t&& arrays[0][0] == \"boolean\" && (arrays[1][0] == \"1\" || arrays[1][0] == \"0\")) {\n\t\t\tjson.boolean = (arrays[1][0] == \"1\"? true: false);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\t\n\tvar getVariables = function() {\n\t\tif (arrays.length > 0 && arrays[0].length > 0) {\n\t\t\tjson.head = {vars: arrays[0]};\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\t\n\tvar getBindings = function() {\n\t\tif (arrays.length > 1) {\n\t\t\tjson.results = {bindings: []};\n\t\t\tfor (var rowIt = 1; rowIt < arrays.length; rowIt++) {\n\t\t\t\tvar binding = {};\n\t\t\t\tfor (var colIt = 0; colIt < arrays[rowIt].length; colIt++) {\n\t\t\t\t\tvar varName = json.head.vars[colIt];\n\t\t\t\t\tif (varName) {\n\t\t\t\t\t\tvar value = arrays[rowIt][colIt];\n\t\t\t\t\t\tvar detectedType = detectType(value);\n\t\t\t\t\t\tbinding[varName] = {value: value};\n\t\t\t\t\t\tif (detectedType) binding[varName].type = detectedType;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tjson.results.bindings.push(binding);\n\t\t\t}\n\t\t\tjson.head = {vars: arrays[0]};\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\tvar isBoolean = getBoolean();\n\tif (!isBoolean) {\n\t\tvar varsFetched = getVariables();\n\t\tif (varsFetched) getBindings();\n\t}\n\t\n\treturn json;\n};","var $ = (function(){try{return require('jquery')}catch(e){return window.jQuery}})();\nvar root = module.exports = function(queryResponse) {\n\t\n\tif (typeof queryResponse == \"string\") {\n\t\ttry {\n\t\t\treturn JSON.parse(queryResponse);\n\t    } catch (e) {\n\t        return false;\n\t    }\n\t}\n\tif (typeof queryResponse == \"object\" && queryResponse.constructor === {}.constructor) {\n\t\treturn queryResponse;\n\t}\n\treturn false;\n\t\n};","var $ = (function(){try{return require('jquery')}catch(e){return window.jQuery}})();\nvar root = module.exports = function(queryResponse) {\n\treturn require(\"./dlv.js\")(queryResponse, \"\\t\");\n};","var $ = (function(){try{return require('jquery')}catch(e){return window.jQuery}})();\n\nvar root = module.exports = function(queryResponse) {\n\tvar parsers = {\n\t\txml: require(\"./xml.js\"),\n\t\tjson: require(\"./json.js\"),\n\t\ttsv: require(\"./tsv.js\"),\n\t\tcsv: require(\"./csv.js\")\n\t};\n\tvar contentType;\n\tvar origResponse;\n\tvar json = null;\n\tvar type = null;//json, xml, csv, or tsv\n\tvar exception = (typeof queryResponse == \"object\" && queryResponse.exception? queryResponse.exception: null);\n\t\t\n\tcontentType = (typeof queryResponse == \"object\" && queryResponse.contentType? queryResponse.contentType.toLowerCase(): null);\n\torigResponse = (typeof queryResponse == \"object\" && queryResponse.response? queryResponse.response: queryResponse);\n\t\n\t\n\n\tvar getAsJson = function() {\n\t\tif (json) return json;\n\t\tif (json === false || exception) return false;//already tried parsing this, and failed. do not try again... \n\t\tvar getParserFromContentType = function() {\n\t\t\tif (contentType) {\n\t\t\t\tif (contentType.indexOf(\"json\") > -1) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = parsers.json(origResponse);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\texception = e;\n\t\t\t\t\t}\n\t\t\t\t\ttype = \"json\";\n\t\t\t\t} else if (contentType.indexOf(\"xml\") > -1) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = parsers.xml(origResponse);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\texception = e;\n\t\t\t\t\t}\n\t\t\t\t\ttype = \"xml\";\n\t\t\t\t} else if (contentType.indexOf(\"csv\") > -1) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = parsers.csv(origResponse);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\texception = e;\n\t\t\t\t\t}\n\t\t\t\t\ttype = \"csv\";\n\t\t\t\t} else if (contentType.indexOf(\"tab-separated\") > -1) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = parsers.tsv(origResponse);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\texception = e;\n\t\t\t\t\t}\n\t\t\t\t\ttype = \"tsv\";\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\n\t\tvar doLuckyGuess = function() {\n\t\t\tjson = parsers.json(origResponse);\n\t\t\tif (json)  {\n\t\t\t\ttype = \"json\";\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tjson = parsers.xml(origResponse);\n\t\t\t\t\tif (json) type=\"xml\";\n\t\t\t\t} catch(err){};\n\t\t\t}\n\t\t};\n\n\t\t\n\t\tgetParserFromContentType();\n\t\tif (!json) {\n\t\t\tdoLuckyGuess();\n\t\t}\n\t\tif (!json) json = false;//explicitly set to false, so we don't try to parse this thing again..\n\t\treturn json;\n\t};\n\n\n\tvar getVariables = function() {\n\t\tvar json = getAsJson();\n\t\tif (json && \"head\" in json) {\n\t\t\treturn json.head.vars;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tvar getBindings = function() {\n\t\tvar json = getAsJson();\n\t\tif (json && \"results\" in json) {\n\t\t\treturn json.results.bindings;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tvar getBoolean = function() {\n\t\tvar json = getAsJson();\n\t\tif (json && \"boolean\" in json) {\n\t\t\treturn json.boolean;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\tvar getOriginalResponse = function() {\n\t\treturn origResponse;\n\t};\n\tvar getOriginalResponseAsString = function() {\n\t\tvar responseString = \"\";\n\t\tif (typeof origResponse == \"string\") {\n\t\t\tresponseString = origResponse;\n\t\t} else if (type == \"json\") {\n\t\t\tresponseString = JSON.stringify(origResponse, undefined, 2);//prettifies as well\n\t\t} else if (type == \"xml\") {\n\t\t\tresponseString = new XMLSerializer().serializeToString(origResponse);\n\t\t}\n\t\treturn responseString;\n\t};\n\tvar getException = function() {\n\t\treturn exception;\n\t};\n\tvar getType = function() {\n\t\tif (type == null) getAsJson();//detects type as well\n\t\treturn type;\n\t};\n\tjson = getAsJson();\n\t\n\treturn {\n\t\tgetAsJson: getAsJson,\n\t\tgetOriginalResponse: getOriginalResponse,\n\t\tgetOriginalResponseAsString: getOriginalResponseAsString,\n\t\tgetOriginalContentType: function(){return contentType;},\n\t\tgetVariables: getVariables,\n\t\tgetBindings: getBindings,\n\t\tgetBoolean: getBoolean,\n\t\tgetType: getType,\n\t\tgetException: getException\n\t};\n};\n\n\n\n","var $ = (function(){try{return require('jquery')}catch(e){return window.jQuery}})();\nvar root = module.exports = function(xml) {\n\n\t\n\t\n\t/**\n\t * head\n\t */\n\tvar parseHead = function(node) {\n\t\tjson.head = {};\n\t\tfor (var headNodeIt = 0; headNodeIt < node.childNodes.length; headNodeIt++) {\n\t\t\tvar headNode = node.childNodes[headNodeIt];\n\t\t\tif (headNode.nodeName == \"variable\") {\n\t\t\t\tif (!json.head.vars) json.head.vars = [];\n\t\t\t\tvar name = headNode.getAttribute(\"name\");\n\t\t\t\tif (name) json.head.vars.push(name);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar parseResults = function(node) {\n\t\tjson.results = {};\n\t\tjson.results.bindings = [];\n\t\tfor (var resultIt = 0; resultIt < node.childNodes.length; resultIt++) {\n\t\t\tvar resultNode = node.childNodes[resultIt];\n\t\t\tvar jsonResult = null;\n\t\t\t\n\t\t\tfor (var bindingIt = 0; bindingIt < resultNode.childNodes.length; bindingIt++) {\n\t\t\t\tvar bindingNode = resultNode.childNodes[bindingIt];\n\t\t\t\tif (bindingNode.nodeName == \"binding\") {\n\t\t\t\t\tvar varName = bindingNode.getAttribute(\"name\");\n\t\t\t\t\tif (varName) {\n\t\t\t\t\t\tjsonResult = jsonResult || {};\n\t\t\t\t\t\tjsonResult[varName] = {};\n\t\t\t\t\t\tfor (var bindingInfIt = 0; bindingInfIt < bindingNode.childNodes.length; bindingInfIt++) {\n\t\t\t\t\t\t\tvar bindingInf = bindingNode.childNodes[bindingInfIt];\n \t\t\t\t\t\t\tvar type = bindingInf.nodeName;\n\t\t\t\t\t\t\tif (type == \"#text\") continue;\n\t\t\t\t\t\t\tjsonResult[varName].type = type;\n\t\t\t\t\t\t\tjsonResult[varName].value = bindingInf.innerHTML;\n\t\t\t\t\t\t\tvar dataType = bindingInf.getAttribute(\"datatype\");\n\t\t\t\t\t\t\tif (dataType) jsonResult[varName].datatype = dataType;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (jsonResult) json.results.bindings.push(jsonResult);\n\t\t}\n\t};\n\t\n\tvar parseBoolean = function(node) {\n\t\tif (node.innerHTML == \"true\") {\n\t\t\tjson.boolean = true;\n\t\t} else {\n\t\t\tjson.boolean = false;\n\t\t}\n\t};\n\tvar mainXml = null;\n\tif (typeof xml == \"string\") {\n\t\tmainXml = $.parseXML(xml);\n\t} else if ($.isXMLDoc(xml)) {\n\t\tmainXml = xml;\n\t}\n\tvar xml = null;\n\tif (mainXml.childNodes.length > 0) {\n\t\t//enter the main 'sparql' node\n\t\txml = mainXml.childNodes[0];\n\t} else {\n\t\treturn null;\n\t}\n\tvar json = {};\n\t\n\t\n    for(var i = 0; i < xml.childNodes.length; i++) {\n    \tvar node = xml.childNodes[i];\n    \tif (node.nodeName == \"head\") parseHead(node);\n    \tif (node.nodeName == \"results\") parseResults(node);\n    \tif (node.nodeName == \"boolean\") parseBoolean(node);\n    }\n    \n\treturn json;\n};\n","var $ = (function(){try{return require('jquery')}catch(e){return window.jQuery}})(),\n\tCodeMirror = (function(){try{return require('codemirror')}catch(e){return window.CodeMirror}})();\n\nrequire('codemirror/addon/edit/matchbrackets.js');\nrequire('codemirror/mode/xml/xml.js');\nrequire('codemirror/mode/javascript/javascript.js');\n\nvar root = module.exports = function(yasr) {\n\tvar plugin = {};\n\tvar options = $.extend(true, {}, root.defaults);\n\tvar draw = function() {\n\t\tvar cmOptions = options.CodeMirror;\n\t\tcmOptions.value = yasr.results.getOriginalResponseAsString();\n\t\t\n\t\tvar mode = yasr.results.getType();\n\t\tif (mode) {\n\t\t\tif (mode == \"json\") {\n\t\t\t\tmode = {name: \"javascript\", json: true};\n\t\t\t}\n\t\t\tcmOptions.mode = mode;\n\t\t}\n\t\t\n\t\tCodeMirror(yasr.resultsContainer.get()[0], cmOptions);\n\t\t\n\t};\n\tvar canHandleResults = function(){\n\t\tif (!yasr.results) return false;\n\t\tvar response = yasr.results.getOriginalResponseAsString();\n\t\tif ((!response || response.length == 0) && yasr.results.getException()) return false;//in this case, show exception instead, as we have nothing to show anyway\n\t\treturn true;\n\t};\n\t\n\tvar getDownloadInfo = function() {\n\t\tif (!yasr.results) return null;\n\t\tvar contentType = yasr.results.getOriginalContentType();\n\t\tvar type = yasr.results.getType();\n\t\treturn {\n\t\t\tgetContent: function() {return yasr.results.getOriginalResponse();},\n\t\t\tfilename: \"queryResults\" + (type? \".\" + type: \"\"),\n\t\t\tcontentType: (contentType? contentType: \"text/plain\"),\n\t\t\tbuttonTitle: \"Download raw response\"\n\t\t};\n\t};\n\t\n\treturn {\n\t\tdraw: draw,\n\t\tname: \"Raw Response\",\n\t\tcanHandleResults: canHandleResults,\n\t\tgetPriority: 2,\n\t\tgetDownloadInfo: getDownloadInfo,\n\t\t\n\t}\n};\n\n\n\nroot.defaults = {\n\tCodeMirror: {\n\t\treadOnly: true,\n\t}\n};\n\nroot.version = {\n\t\"YASR-rawResponse\" : require(\"../package.json\").version,\n\t\"jquery\": $.fn.jquery,\n\t\"CodeMirror\" : CodeMirror.version\n};","var $ = (function(){try{return require('jquery')}catch(e){return window.jQuery}})(),\n\tyutils = require(\"yasgui-utils\"),\n\timgs = require('./imgs.js');\n(function(){try{return require('jquery.dataTables')}catch(e){return window.jQuery}})();\n\n\n\n/**\n * Constructor of plugin which displays results as a table\n * \n * @param yasr {object}\n * @param parent {DOM element}\n * @param options {object}\n * @class YASR.plugins.table\n * @return yasr-table (doc)\n * \n */\nvar root = module.exports = function(yasr) {\n\tvar table = null;\n\tvar options = $.extend(true, {}, root.defaults);\n\t\n\n\tvar getRows = function() {\n\t\tvar rows = [];\n\t\tvar bindings = yasr.results.getBindings();\n\t\tvar vars = yasr.results.getVariables();\n\t\tvar usedPrefixes = null;\n\t\tif (yasr.options.getUsedPrefixes) {\n\t\t\tusedPrefixes = (typeof yasr.options.getUsedPrefixes == \"function\"? yasr.options.getUsedPrefixes(yasr):  yasr.options.getUsedPrefixes);\n\t\t}\n\t\tfor (var rowId = 0; rowId < bindings.length; rowId++) {\n\t\t\tvar row = [];\n\t\t\trow.push(\"\");//row numbers\n\t\t\tvar binding = bindings[rowId];\n\t\t\tfor (var colId = 0; colId < vars.length; colId++) {\n\t\t\t\tvar sparqlVar = vars[colId];\n\t\t\t\tif (sparqlVar in binding) {\n\t\t\t\t\tif (options.drawCellContent) {\n\t\t\t\t\t\trow.push(options.drawCellContent(yasr, rowId, colId, binding, sparqlVar, usedPrefixes));\n\t\t\t\t\t} else {\n\t\t\t\t\t\trow.push(\"\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trow.push(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\trows.push(row);\n\t\t}\n\t\treturn rows;\n\t};\n\t\n\n\tvar addEvents = function() {\n\t\ttable.on( 'order.dt', function () {\n\t\t    drawSvgIcons();\n\t\t});\n\t\t$.extend(true, options.callbacks, options.handlers);\n\t\ttable.delegate(\"td\", \"click\", function(event) {\n\t\t\tif (options.callbacks && options.callbacks.onCellClick) {\n\t\t\t\tvar result = options.callbacks.onCellClick(this, event);\n\t\t\t\tif (result === false) return false;\n\t\t\t}\n\t\t}).delegate(\"td\",'mouseenter', function(event) {\n\t\t\tif (options.callbacks && options.callbacks.onCellMouseEnter) {\n\t\t\t\toptions.callbacks.onCellMouseEnter(this, event);\n\t\t\t}\n\t\t\tvar tdEl = $(this);\n\t\t\tif (options.fetchTitlesFromPreflabel \n\t\t\t\t\t&& tdEl.attr(\"title\") === undefined\n\t\t\t\t\t&& tdEl.text().trim().indexOf(\"http\") == 0) {\n\t\t\t\taddPrefLabel(tdEl);\n\t\t\t}\n\t\t}).delegate(\"td\",'mouseleave', function(event) {\n\t\t\tif (options.callbacks && options.callbacks.onCellMouseLeave) {\n\t\t\t\toptions.callbacks.onCellMouseLeave(this, event);\n\t\t\t\t\n\t\t\t}\n\t\t});\n\t};\n\t\n\tvar draw = function() {\n\t\ttable = $('<table cellpadding=\"0\" cellspacing=\"0\" border=\"0\" class=\"resultsTable\"></table>');\n\t\t$(yasr.resultsContainer).html(table);\n\n\t\tvar dataTableConfig = options.datatable;\n\t\tdataTableConfig.data = getRows();\n\t\tdataTableConfig.columns = options.getColumns(yasr);\n\t\ttable.DataTable($.extend(true, {}, dataTableConfig));//make copy. datatables adds properties for backwards compatability reasons, and don't want this cluttering our own \n\t\t\n\t\t\n\t\tdrawSvgIcons();\n\t\t\n\t\taddEvents();\n\t\t\n\t\t//move the table upward, so the table options nicely aligns with the yasr header\n\t\tvar headerHeight = yasr.header.outerHeight() - 5; //add some space of 5 px between table and yasr header\n\t\tif (headerHeight > 0) {\n\t\t\tyasr.resultsContainer.find(\".dataTables_wrapper\")\n\t\t\t.css(\"position\", \"relative\")\n\t\t\t.css(\"top\", \"-\" + headerHeight + \"px\")\n\t\t\t.css(\"margin-bottom\", \"-\" + headerHeight + \"px\");\n\t\t}\n\t\t\n\t\t\n\t};\n\t\n\tvar drawSvgIcons = function() {\n\t\tvar sortings = {\n\t\t\t\"sorting\": \"unsorted\",\n\t\t\t\"sorting_asc\": \"sortAsc\",\n\t\t\t\"sorting_desc\": \"sortDesc\"\n\t\t};\n\t\ttable.find(\".sortIcons\").remove();\n\t\tvar width = 8;\n\t\tvar height = 13;\n\t\tfor (var sorting in sortings) {\n\t\t\tvar svgDiv = $(\"<div class='sortIcons'></div>\").css(\"float\", \"right\").css(\"margin-right\", \"-12px\").width(width).height(height);\n\t\t\tyutils.svg.draw(svgDiv, imgs[sortings[sorting]], {width: width+2, height: height+1});\n\t\t\ttable.find(\"th.\" + sorting).append(svgDiv);\n\t\t}\n\t};\n\t/**\n\t * Check whether this plugin can handler the current results\n\t * \n\t * @property canHandleResults\n\t * @type function\n\t * @default If resultset contains variables in the resultset, return true\n\t */\n\tvar canHandleResults = function(){\n\t\treturn yasr.results && yasr.results.getVariables() && yasr.results.getVariables().length > 0;\n\t};\n\n\t\n\tvar getDownloadInfo = function() {\n\t\tif (!yasr.results) return null;\n\t\treturn {\n\t\t\tgetContent: function(){return require(\"./bindingsToCsv.js\")(yasr.results.getAsJson());},\n\t\t\tfilename: \"queryResults.csv\",\n\t\t\tcontentType: \"text/csv\",\n\t\t\tbuttonTitle: \"Download as CSV\"\n\t\t};\n\t};\n\t\n\treturn {\n\t\tname: \"Table\",\n\t\tdraw: draw,\n\t\tgetPriority: 10,\n\t\tgetDownloadInfo: getDownloadInfo,\n\t\tcanHandleResults: canHandleResults,\n\t}\n};\n\n\nvar getFormattedValueFromBinding = function(yasr, rowId, colId, bindings, sparqlVar, usedPrefixes) {\n\tvar binding = bindings[sparqlVar];\n\tvar value = null;\n\tif (binding.type == \"uri\") {\n\t\tvar href = visibleString = binding.value;\n\t\tif (usedPrefixes) {\n\t\t\tfor (var prefix in usedPrefixes) {\n\t\t\t\tif (visibleString.indexOf(usedPrefixes[prefix]) == 0) {\n\t\t\t\t\tvisibleString = prefix + href.substring(usedPrefixes[prefix].length);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvalue = \"<a class='uri' target='_blank' href='\" + href + \"'>\" + visibleString + \"</a>\";\n\t} else {\n\t\tvar stringRepresentation = binding.value;\n\t\tif (binding[\"xml:lang\"]) {\n\t\t\tstringRepresentation = '\"' + binding.value + '\"@' + binding[\"xml:lang\"];\n\t\t} else if (binding.datatype) {\n\t\t\tvar xmlSchemaNs = \"http://www.w3.org/2001/XMLSchema#\";\n\t\t\tvar dataType = binding.datatype;\n\t\t\tif (dataType.indexOf(xmlSchemaNs) == 0) {\n\t\t\t\tdataType = \"xsd:\" + dataType.substring(xmlSchemaNs.length);\n\t\t\t} else {\n\t\t\t\tdataType = \"<\" + dataType + \">\";\n\t\t\t}\n\t\t\t\n\t\t\tstringRepresentation = '\"' + stringRepresentation + '\"^^' + dataType;\n\t\t}\n\t\t\n\t\tvalue = \"<span class='nonUri'>\" + stringRepresentation + \"</span>\";\n\t}\n\treturn value;\n};\n\n\n\n\n\n\nvar addPrefLabel = function(td) {\n\tvar addEmptyTitle = function() {\n\t\ttd.attr(\"title\",\"\");//this avoids trying to fetch the label again on next hover\n\t};\n\t$.get(\"http://preflabel.org/api/v1/label/\" + encodeURIComponent(td.text()) + \"?silent=true\")\n\t\t.success(function(data) {\n\t\t\tif (typeof data == \"object\" && data.label) {\n\t\t\t\ttd.attr(\"title\", data.label);\n\t\t\t} else if (typeof data == \"string\" && data.length > 0 ) {\n\t\t\t\ttd.attr(\"title\", data);\n\t\t\t} else {\n\t\t\t\taddEmptyTitle();\n\t\t\t}\n\t\t\t\n\t\t})\n\t\t.fail(addEmptyTitle);\n};\n\nvar openCellUriInNewWindow = function(cell) {\n\tif (cell.className.indexOf(\"uri\") >= 0) {\n\t\twindow.open(this.innerHTML);\n\t}\n};\n\n/**\n * Defaults for table plugin\n * \n * @type object\n * @attribute YASR.plugins.table.defaults\n */\nroot.defaults = {\n\t\n\t/**\n\t * Draw the cell content, from a given binding\n\t * \n\t * @property drawCellContent\n\t * @param binding {object}\n\t * @type function\n\t * @return string\n\t * @default YASR.plugins.table.getFormattedValueFromBinding\n\t */\n\tdrawCellContent: getFormattedValueFromBinding,\n\t\n\tgetColumns: function(yasr) {\n\t\tvar cols = [];\n\t\tcols.push({\"title\": \"\"});//row numbers\n\t\tvar sparqlVars = yasr.results.getVariables();\n\t\tfor (var i = 0; i < sparqlVars.length; i++) {\n\t\t\tcols.push({\"title\": sparqlVars[i]});\n\t\t}\n\t\treturn cols;\n\t},\n\t/**\n\t * Try to fetch the label representation for each URI, using the preflabel.org services. (fetching occurs when hovering over the cell)\n\t * \n\t * @property fetchTitlesFromPreflabel\n\t * @type boolean\n\t * @default true\n\t */\n\tfetchTitlesFromPreflabel: true,\n\t/**\n\t * Set a number of handlers for the table\n\t * \n\t * @property handlers\n\t * @type object\n\t */\n\tcallbacks: {\n\t\t/**\n\t\t * Mouse-enter-cell event\n\t\t * \n\t\t * @property handlers.onCellMouseEnter\n\t\t * @type function\n\t\t * @param td-element\n\t\t * @default null\n\t\t */\n\t\tonCellMouseEnter: null,\n\t\t/**\n\t\t * Mouse-leave-cell event\n\t\t * \n\t\t * @property handlers.onCellMouseLeave\n\t\t * @type function\n\t\t * @param td-element\n\t\t * @default null\n\t\t */\n\t\tonCellMouseLeave: null,\n\t\t/**\n\t\t * Cell clicked event\n\t\t * \n\t\t * @property handlers.onCellClick\n\t\t * @type function\n\t\t * @param td-element\n\t\t * @default null\n\t\t */\n\t\tonCellClick: null\n\t},\n\t/**\n\t * This plugin uses the datatables jquery plugin (See datatables.net). For any datatables specific defaults, change this object. \n\t * See the datatables reference for more information\n\t * \n\t * @property datatable\n\t * @type object\n\t */\n\tdatatable: {\n\t\t\"order\": [],//disable initial sorting\n\t\t\"pageLength\": 50,//default page length\n    \t\"lengthMenu\": [[10, 50, 100, 1000, -1], [10, 50, 100, 1000, \"All\"]],//possible page lengths\n    \t\"lengthChange\": true,//allow changing page length\n    \t\"pagingType\": \"full_numbers\",//how to show the pagination options\n        \"drawCallback\": function ( oSettings ) {\n        \t//trick to show row numbers\n        \tfor ( var i = 0; i < oSettings.aiDisplay.length; i++) {\n\t\t\t\t$('td:eq(0)',oSettings.aoData[oSettings.aiDisplay[i]].nTr).html(i + 1);\n\t\t\t}\n        \t\n        \t//Hide pagination when we have a single page\n        \tvar activePaginateButton = false;\n        \t$(oSettings.nTableWrapper).find(\".paginate_button\").each(function() {\n        \t\tif ($(this).attr(\"class\").indexOf(\"current\") == -1 && $(this).attr(\"class\").indexOf(\"disabled\") == -1) {\n        \t\t\tactivePaginateButton = true;\n        \t\t}\n        \t});\n        \tif (activePaginateButton) {\n        \t\t$(oSettings.nTableWrapper).find(\".dataTables_paginate\").show();\n        \t} else {\n        \t\t$(oSettings.nTableWrapper).find(\".dataTables_paginate\").hide();\n        \t}\n\t\t},\n\t\t\"columnDefs\": [\n\t\t\t{ \"width\": \"12px\", \"orderable\": false, \"targets\": 0  }//disable row sorting for first col\n\t\t],\n\t},\n};\n\nroot.version = {\n\t\"YASR-table\" : require(\"../package.json\").version,\n\t\"jquery\": $.fn.jquery,\n\t\"jquery-datatables\": $.fn.DataTable.version\n};\n"]}