{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 1880702945a75ae02be2","webpack:///./src/js-joda.js","webpack:///./src/Clock.js","webpack:///./src/assert.js","webpack:///./src/errors.js","webpack:///./src/Instant.js","webpack:///./src/LocalTime.js","webpack:///./src/MathUtil.js","webpack:///./src/LocalDateTime.js","webpack:///./src/LocalDate.js","webpack:///./src/chrono/IsoChronology.js","webpack:///./src/Enum.js","webpack:///./src/Month.js","webpack:///./src/temporal/ChronoField.js","webpack:///./src/temporal/ChronoUnit.js","webpack:///./src/Duration.js","webpack:///./src/temporal/TemporalAmount.js","webpack:///./src/Year.js","webpack:///./src/temporal/TemporalUnit.js","webpack:///./src/temporal/TemporalField.js","webpack:///./src/temporal/ValueRange.js","webpack:///./src/temporal/Temporal.js","webpack:///./src/temporal/TemporalAccessor.js","webpack:///./src/temporal/TemporalQueries.js","webpack:///./src/format/ResolverStyle.js","webpack:///./src/chrono/ChronoLocalDate.js","webpack:///./src/temporal/TemporalQuery.js","webpack:///./src/format/DateTimeFormatter.js","webpack:///./src/Period.js","webpack:///./src/format/ParsePosition.js","webpack:///./src/format/DateTimeBuilder.js","webpack:///./src/format/EnumMap.js","webpack:///./src/format/DateTimeParseContext.js","webpack:///./src/format/DateTimePrintContext.js","webpack:///./src/format/DateTimeFormatterBuilder.js","webpack:///./src/ZoneIdFactory.js","webpack:///./src/StringUtil.js","webpack:///./src/ZoneOffset.js","webpack:///./src/ZoneId.js","webpack:///./src/zone/ZoneRules.js","webpack:///./src/ZoneRegion.js","webpack:///./src/zone/SystemDefaultZoneId.js","webpack:///./src/zone/SystemDefaultZoneRules.js","webpack:///./src/format/DecimalStyle.js","webpack:///./src/format/SignStyle.js","webpack:///./src/format/StringBuilder.js","webpack:///./src/DayOfWeek.js","webpack:///./src/ZonedDateTime.js","webpack:///./src/chrono/ChronoZonedDateTime.js","webpack:///./src/chrono/ChronoLocalDateTime.js","webpack:///./src/temporal/NativeJsTemporal.js","webpack:///./src/temporal/IsoFields.js","webpack:///./src/temporal/TemporalAdjusters.js","webpack:///./src/temporal/TemporalAdjuster.js","webpack:///./src/_init.js","webpack:///./src/temporal/TemporalQueriesFactory.js"],"names":[],"mappings":"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","file":"js-joda.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JSJoda\"] = factory();\n\telse\n\t\troot[\"JSJoda\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1880702945a75ae02be2\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport { Clock } from './Clock';\nexport { DateTimeException, DateTimeParseException } from './errors';\nexport { DayOfWeek } from './DayOfWeek';\nexport { Duration } from './Duration';\nexport { Instant } from './Instant';\nexport { LocalDate } from './LocalDate';\nexport { LocalTime } from './LocalTime';\nexport { LocalDateTime } from './LocalDateTime';\nexport { Month } from './Month';\nexport { Period } from './Period';\nexport { Year } from './Year';\nexport { ZonedDateTime } from './ZonedDateTime';\nexport { ZoneOffset } from './ZoneOffset';\nexport { ZoneId } from './ZoneId';\n\nexport {nativeJs} from './temporal/NativeJsTemporal';\nexport {ChronoField} from './temporal/ChronoField';\nexport {ChronoUnit} from './temporal/ChronoUnit';\nexport {IsoFields} from './temporal/IsoFields';\nexport {TemporalAdjusters} from './temporal/TemporalAdjusters';\nexport {TemporalQueries} from './temporal/TemporalQueries';\n\nexport {DateTimeFormatter} from './format/DateTimeFormatter';\nexport {DateTimeFormatterBuilder} from './format/DateTimeFormatterBuilder';\nexport {ResolverStyle} from './format/ResolverStyle';\n\nimport './_init';\n\n\n/** WEBPACK FOOTER **\n ** ./src/js-joda.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail, requireNonNull} from './assert';\nimport {Instant} from './Instant';\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\n\n/**\n * A clock providing access to the current instant, date and time using a time-zone.\n * <p>\n * Instances of this class are used to find the current instant, which can be\n * interpreted using the stored time-zone to find the current date and time.\n * As such, a clock can be used instead of {@link System#currentTimeMillis()}\n * and {@link TimeZone#getDefault()}.\n * <p>\n * Use of a {@code Clock} is optional. All key date-time classes also have a\n * {@code now()} factory method that uses the system clock in the default time zone.\n * The primary purpose of this abstraction is to allow alternate clocks to be\n * plugged in as and when required. Applications use an object to obtain the\n * current time rather than a static method. This can simplify testing.\n * <p>\n * Best practice for applications is to pass a {@code Clock} into any method\n * that requires the current instant.\n *\n * This approach allows an alternate clock, such as {@link #fixed(Instant, ZoneId) fixed}\n * or {@link #offset(Clock, Duration) offset} to be used during testing.\n * <p>\n * The {@code system} factory methods provide clocks based on the best available\n * system clock This may use {@link System#currentTimeMillis()}, or a higher\n * resolution clock if one is available.\n */\n\n/**\n * The javascript Clock implementation differs from the openjdk.\n *\n * Javascript only provides the UTC millis of epoch and the ZoneOffset in minutes of the system default time.\n * Javascript do not provide the system default ZoneId.\n *\n * the system default ZoneId is only guessable by the ZoneOffset, like moment-timezone does by returning one ZoneId\n * with the same ZoneOffset.\n *\n * Therefore we are doing a shortcut here, by defining a SystemUTCClock and a SystemDefaultClock, the Clock itself\n * is returning the ZoneOffset and not the ZoneRules as in the jdk. We should change it, when introducing the iana\n * timezone database and implementing the timezone domains.\n *\n */\n\nexport class Clock {\n    /**\n     * Obtains a clock that returns the current instant using the\n     * system clock, converting to date and time using the Date.getTime() UTC millis.\n     * <p>\n     * This clock, rather than {@link #systemDefaultZone()}, should be used when\n     * you need the current instant without the date or time.\n     * <p>\n     * @return {Clock} a clock that uses the system clock in the UTC zone, not null\n     */\n    static systemUTC() {\n        return new SystemClock(ZoneOffset.UTC);\n    }\n\n    /**\n     * Obtains a clock that returns the current instant using the best available\n     * system clock, converting to date and time using the default time-zone.\n     * <p>\n     * This clock is based on the available system clock using the Date.getTime() UTC millis\n     * <p>\n     * Using this method hard codes a dependency to the default time-zone into your application.\n     *\n     * The {@link #systemUTC() UTC clock} should be used when you need the current instant\n     * without the date or time.\n     * <p>\n     *\n     * @return {Clock} a clock that uses the system clock in the default zone, not null\n     * @see ZoneId#systemDefault()\n     */\n    static systemDefaultZone() {\n        return new SystemClock(ZoneId.systemDefault());\n    }\n\n    /**\n     *\n     * @param {ZoneId} zone\n     * @return {Clock} a clock that uses the specified time zone\n     */\n    static system(zone){\n        return new SystemClock(zone);\n    }\n\n    /**\n     * Obtains a clock that always returns the same instant.\n     * <p>\n     * This clock simply returns the specified instant.\n     * As such, it is not a clock in the conventional sense.\n     * The main use case for this is in testing, where the fixed clock ensures\n     * tests are not dependent on the current clock.\n     *\n     * @param {Instant} fixedInstant  the instant to use as the clock, not null\n     * @param {ZoneOffset} zoneOffset  the zoneOffset to use as zone Offset, not null\n     * @return {Clock} a clock that always returns the same instant, not null\n     */\n    static fixed(fixedInstant, zoneOffset) {\n        return new FixedClock(fixedInstant, zoneOffset);\n    }\n\n    /**\n      * Gets the current millisecond instant of the clock.\n      * <p>\n      * This returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).\n      * This is equivalent to the definition of {@link Date#getTime()}.\n      * <p>\n      * Most applications should avoid this method and use {@link Instant} to represent\n      * an instant on the time-line rather than a raw millisecond value.\n      * This method is provided to allow the use of the clock in high performance use cases\n      * where the creation of an object would be unacceptable.\n      * <p>\n      * The default implementation currently calls {@link #instant}.\n      *\n      * @return the current millisecond instant from this clock, measured from\n      *  the Java epoch of 1970-01-01T00:00Z (UTC), not null\n      */\n    millis(){\n        abstractMethodFail('Clock.millis');\n    }\n\n    /**\n     * Gets the current instant of the clock.\n     * <p>\n     * This returns an instant representing the current instant as defined by the clock.\n     *\n     * @return {Instant} the current instant from this clock, not null\n     */\n    instant(){\n        abstractMethodFail('Clock.instant');\n    }\n\n    zone(){\n        abstractMethodFail('Clock.zone');\n    }\n}\n\n/**\n * Implementation of a clock that always returns the latest time from\n * {@link Date#getTime()}.\n */\nclass SystemClock extends Clock {\n    /**\n     *\n     * @param {!ZoneId} zone\n     */\n    constructor(zone){\n        requireNonNull(zone, 'zone');\n        super();\n        this._zone = zone;\n    }\n\n    /**\n     *\n     * @returns {!ZoneId}\n     */\n    zone() {\n        return this._zone;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    millis() {\n        return new Date().getTime();\n    }\n\n    /**\n     *\n     * @returns {Instant}\n     */\n    instant() {\n        return Instant.ofEpochMilli(this.millis());\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return 'SystemClock[' + this._zone.toString() + ']';\n    }\n\n}\n\n/**\n * Implementation of a clock that always returns the same instant.\n * This is typically used for testing.\n */\nclass FixedClock extends Clock{\n    constructor(fixedInstant, zoneId) {\n        super();\n        this._instant = fixedInstant;\n        this._zoneId = zoneId;\n    }\n\n    instant() {\n        return this._instant;\n    }\n    \n    millis(){\n        return this._instant.toEpochMilli();\n    }\n\n    zone() {\n        return this._zoneId;\n    }\n\n    toString(){\n        return 'FixedClock[]';\n    }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clock.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport {NullPointerException, IllegalArgumentException} from './errors';\n\nexport function assert(assertion, msg, error) {\n    if(!assertion){\n        if (error) {\n            throw new error(msg);\n        } else {\n            throw new Error(msg);\n        }\n    }\n}\n\nexport function requireNonNull(value, parameterName) {\n    if (value == null) {\n        throw new NullPointerException(parameterName + ' must not be null');\n    }\n    return value;\n}\n\nexport function requireInstance(value, _class, parameterName) {\n    if (!(value instanceof _class)) {\n        throw new IllegalArgumentException(parameterName + ' must be an instance of ' + (_class.name ? _class.name : _class));\n    }\n    return value;\n}\n\nexport function abstractMethodFail(methodName){\n    throw new TypeError('abstract mehod \"' + methodName + '\" is not implemented');\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/assert.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nfunction createErrorType(name, init, superErrorClass = Error) {\n    function E(message) {\n        if (!Error.captureStackTrace){\n            this.stack = (new Error()).stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        this.message = message;\n        init && init.apply(this, arguments);\n\n    }\n    E.prototype = new superErrorClass();\n    E.prototype.name = name;\n    E.prototype.constructor = E;\n    return E;\n}\n\nexport var DateTimeException = createErrorType('DateTimeException', messageWithCause);\nexport var DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);\nexport var UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);\nexport var ArithmeticException = createErrorType('ArithmeticException');\nexport var IllegalArgumentException = createErrorType('IllegalArgumentException');\nexport var IllegalStateException = createErrorType('IllegalStateException');\nexport var NullPointerException = createErrorType('NullPointerException');\n\nfunction messageWithCause(message, cause = null) {\n    let msg = message || this.name;\n    if (cause !== null && cause instanceof Error) {\n        msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n    }\n    this.message = msg;\n}\n\nfunction messageForDateTimeParseException(message, text = '', index = 0, cause = null) {\n    let msg = message || this.name;\n    msg += ': ' + text + ', at index: ' + index;\n    if (cause !== null && cause instanceof Error) {\n        msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n    }\n    this.message = msg;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/errors.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException} from './errors';\n\nimport {Clock} from './Clock';\nimport {LocalTime} from './LocalTime';\nimport {MathUtil} from './MathUtil';\n\nimport {Temporal} from './temporal/Temporal';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\n\nconst NANOS_PER_MILLI = 1000000;\n\n/**\n * An instantaneous point on the time-line.\n * \n * This class models a single instantaneous point on the time-line.\n * This might be used to record event time-stamps in the application.\n * \n * Time-scale\n * \n * The length of the solar day is the standard way that humans measure time.\n * This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,\n * forming a 86400 second day.\n * \n * Modern timekeeping is based on atomic clocks which precisely define an SI second\n * relative to the transitions of a Caesium atom. The length of an SI second was defined\n * to be very close to the 86400th fraction of a day.\n * \n * Unfortunately, as the Earth rotates the length of the day varies.\n * In addition, over time the average length of the day is getting longer as the Earth slows.\n * As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.\n * The actual length of any given day and the amount by which the Earth is slowing\n * are not predictable and can only be determined by measurement.\n * The UT1 time-scale captures the accurate length of day, but is only available some\n * time after the day has completed.\n * \n * The UTC time-scale is a standard approach to bundle up all the additional fractions\n * of a second from UT1 into whole seconds, known as <i>leap-seconds</i>.\n * A leap-second may be added or removed depending on the Earth's rotational changes.\n * As such, UTC permits a day to have 86399 SI seconds or 86401 SI seconds where\n * necessary in order to keep the day aligned with the Sun.\n * \n * The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.\n * Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and\n * alterations to the length of the notional second. As of 2012, discussions are underway\n * to change the definition of UTC again, with the potential to remove leap seconds or\n * introduce other changes.\n * \n * Given the complexity of accurate timekeeping described above, this Java API defines\n * its own time-scale, the <i>Java Time-Scale</i>.\n * \n * The Java Time-Scale divides each calendar day into exactly 86400\n * subdivisions, known as seconds.  These seconds may differ from the\n * SI second.  It closely matches the de facto international civil time\n * scale, the definition of which changes from time to time.\n * \n * The Java Time-Scale has slightly different definitions for different\n * segments of the time-line, each based on the consensus international\n * time scale that is used as the basis for civil time. Whenever the\n * internationally-agreed time scale is modified or replaced, a new\n * segment of the Java Time-Scale must be defined for it.  Each segment\n * must meet these requirements:\n * <ul>\n * <li>the Java Time-Scale shall closely match the underlying international\n *  civil time scale;</li>\n * <li>the Java Time-Scale shall exactly match the international civil\n *  time scale at noon each day;</li>\n * <li>the Java Time-Scale shall have a precisely-defined relationship to\n *  the international civil time scale.</li>\n * </ul>\n * There are currently, as of 2013, two segments in the Java time-scale.\n * \n * For the segment from 1972-11-03 (exact boundary discussed below) until\n * further notice, the consensus international time scale is UTC (with\n * leap seconds).  In this segment, the Java Time-Scale is identical to\n * <a href=\"http://www.cl.cam.ac.uk/~mgk25/time/utc-sls/\">UTC-SLS</a>.\n * This is identical to UTC on days that do not have a leap second.\n * On days that do have a leap second, the leap second is spread equally\n * over the last 1000 seconds of the day, maintaining the appearance of\n * exactly 86400 seconds per day.\n * \n * For the segment prior to 1972-11-03, extending back arbitrarily far,\n * the consensus international time scale is defined to be UT1, applied\n * proleptically, which is equivalent to the (mean) solar time on the\n * prime meridian (Greenwich). In this segment, the Java Time-Scale is\n * identical to the consensus international time scale. The exact\n * boundary between the two segments is the instant where UT1 = UTC\n * between 1972-11-03T00:00 and 1972-11-04T12:00.\n * \n * Implementations of the Java time-scale using the JSR-310 API are not\n * required to provide any clock that is sub-second accurate, or that\n * progresses monotonically or smoothly. Implementations are therefore\n * not required to actually perform the UTC-SLS slew or to otherwise be\n * aware of leap seconds. JSR-310 does, however, require that\n * implementations must document the approach they use when defining a\n * clock representing the current instant.\n * See {@link Clock} for details on the available clocks.\n * \n * The Java time-scale is used for all date-time classes.\n * This includes {@code Instant}, {@code LocalDate}, {@code LocalTime}, {@code OffsetDateTime},\n * {@code ZonedDateTime} and {@code Duration}.\n *\n * <h3>Static properties of Class {@link Instant}</h3>\n *\n * Instant.EPOCH\n *\n * Instant.MIN\n *\n * Instant.MAX\n *\n * Instant.MIN_SECONDS\n *\n * Instant.MAX_SECONDS\n *\n */\nexport class Instant extends Temporal {\n\n    /**\n     * Obtains the current instant from the system clock, or if specified\n     * the current instant from the specified clock.\n     *\n     * This will query the specified clock to obtain the current time.\n     *\n     * @param {Clock} [clock=Clock.systemUTC()] - the clock to use, defaults to the system clock\n     * @return {Instant} the current instant, not null\n     */\n    static now(clock = Clock.systemUTC()){\n        return clock.instant();\n    }\n\n    /**\n     * Obtains an instance of {@code Instant} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * @param {number} epochSecond - the number of seconds from 1970-01-01T00:00:00Z\n     * @param {number} nanoAdjustment nanoseconds start from the start of epochSecond, if null the nanosecond field is set to zero.\n     * @return {Instant} an instant, not null\n     * @throws DateTimeException if the instant exceeds the maximum or minimum instant\n     */\n    static ofEpochSecond(epochSecond, nanoAdjustment=0){\n        var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        return Instant._create(secs, nos);\n    }\n\n    /**\n     * Obtains an instance of {@code Instant} using milliseconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     * <p>\n     * The seconds and nanoseconds are extracted from the specified milliseconds.\n     *\n     * @param {number} epochMilli - the number of milliseconds from 1970-01-01T00:00:00Z\n     * @return {Instant} an instant, not null\n     * @throws DateTimeException if the instant exceeds the maximum or minimum instant\n     */\n    static ofEpochMilli(epochMilli) {\n        var secs = MathUtil.floorDiv(epochMilli, 1000);\n        var mos = MathUtil.floorMod(epochMilli, 1000);\n        return Instant._create(secs, mos * 1000000);\n    }\n\n    /**\n     * Obtains an instance of {@code Instant} from a temporal object.\n     * <p>\n     * A {@code TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@code Instant}.\n     * <p>\n     * The conversion extracts the {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS}\n     * and {@link ChronoField#NANO_OF_SECOND NANO_OF_SECOND} fields.\n     * <p>\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code Instant::from}.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {Instant} the instant, not null\n     * @throws DateTimeException if unable to convert to an {@code Instant}\n     */\n    static from(temporal) {\n        try {\n            let instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);\n            let nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n            return Instant.ofEpochSecond(instantSecs, nanoOfSecond);\n        } catch (ex) {\n            throw new DateTimeException('Unable to obtain Instant from TemporalAccessor: ' +\n                    temporal + ', type ' + typeof temporal, ex);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@code Instant} from a text string such as\n     * {@code 2007-12-03T10:15:30.000Z}.\n     * <p>\n     * The string must represent a valid instant in UTC and is parsed using\n     * {@link DateTimeFormatter#ISO_INSTANT}.\n     *\n     * @param {string} text - the text to parse, not null\n     * @return {Instant} the parsed instant, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parse(text) {\n        return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);\n    }\n\n    /**\n     *\n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @returns {Instant}\n     * @private\n     */\n    static _create(seconds, nanoOfSecond){\n        if(seconds === 0 && nanoOfSecond === 0){\n            return Instant.EPOCH;\n        }\n        return new Instant(seconds, nanoOfSecond);\n    }\n\n    /**\n     *\n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @private\n     */\n    static _validate(seconds, nanoOfSecond){\n        if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {\n            throw new DateTimeException('Instant exceeds minimum or maximum instant');\n        }\n        if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {\n            throw new DateTimeException('Instant exceeds minimum or maximum instant');\n        }\n    }\n\n    /**\n     * \n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @private\n     */\n    constructor(seconds, nanoOfSecond){\n        super();\n        Instant._validate(seconds, nanoOfSecond);\n        this._seconds = seconds;\n        this._nanos = nanoOfSecond;\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     * <p>\n     * This checks if this instant can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range} and\n     * {@link #get(TemporalField) get} methods will throw an exception.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * <ul>\n     * <li>{@code NANO_OF_SECOND}\n     * <li>{@code MICRO_OF_SECOND}\n     * <li>{@code MILLI_OF_SECOND}\n     * <li>{@code INSTANT_SECONDS}\n     * </ul>\n     * All other {@code ChronoField} instances will return false.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this instant, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;\n        }\n        if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     * <p>\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This instant is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this instant as an {@code int}.\n     * <p>\n     * This queries this instant for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code INSTANT_SECONDS} which is too\n     * large to fit in an {@code int} and throws a {@code DateTimeException}.\n     * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this instant as a {@code long}.\n     * <p>\n     * This queries this instant for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.NANO_OF_SECOND: return this._nanos;\n                case ChronoField.MICRO_OF_SECOND: return MathUtil.intDiv(this._nanos, 1000);\n                case ChronoField.MILLI_OF_SECOND: return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n                case ChronoField.INSTANT_SECONDS: return this._seconds;\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * Gets the number of seconds from the Java epoch of 1970-01-01T00:00:00Z.\n     *\n     * The epoch second count is a simple incrementing count of seconds where\n     * second 0 is 1970-01-01T00:00:00Z.\n     * The nanosecond part of the day is returned by {@code getNanosOfSecond}.\n     *\n     * @return {number} the seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    epochSecond(){\n        return this._seconds;\n    }\n\n    /**\n     * Gets the number of nanoseconds, later along the time-line, from the start\n     * of the second.\n     *\n     * The nanosecond-of-second value measures the total number of nanoseconds from\n     * the second returned by {@code getEpochSecond}.\n     *\n     * @return {number} the nanoseconds within the second, always positive, never exceeds 999,999,999\n     */\n    nano(){\n        return this._nanos;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * function overloading for {@link Instant.with}\n     *\n     * if called with 1 argument {@link Instant.withTemporalAdjuster} is called\n     * otherwise {@link Instant.with2}\n     *\n     * @param {!(TemporalAdjuster|TemporalField)} adjusterOrField\n     * @param {number} newValue\n     * @returns {Instant}\n     */\n    with(adjusterOrField, newValue){\n        if(arguments.length === 1){\n            return this.withTemporalAdjuster(adjusterOrField);\n        } else {\n            return this.with2(adjusterOrField, newValue);\n        }\n    }\n    /**\n     * Returns an adjusted copy of this instant.\n     * <p>\n     * This returns a new {@code Instant}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {Instant} an {@code Instant} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified field set to a new value.\n     * <p>\n     * This returns a new {@code Instant}, based on this one, with the value\n     * for the specified field changed.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * <ul>\n     * <li>{@code NANO_OF_SECOND} -\n     *  Returns an {@code Instant} with the specified nano-of-second.\n     *  The epoch-second will be unchanged.\n     * <li>{@code MICRO_OF_SECOND} -\n     *  Returns an {@code Instant} with the nano-of-second replaced by the specified\n     *  micro-of-second multiplied by 1,000. The epoch-second will be unchanged.\n     * <li>{@code MILLI_OF_SECOND} -\n     *  Returns an {@code Instant} with the nano-of-second replaced by the specified\n     *  milli-of-second multiplied by 1,000,000. The epoch-second will be unchanged.\n     * <li>{@code INSTANT_SECONDS} -\n     *  Returns an {@code Instant} with the specified epoch-second.\n     *  The nano-of-second will be unchanged.\n     * </ul>\n     * <p>\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@code DateTimeException} will be thrown.\n     * <p>\n     * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {Instant} an {@code Instant} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.MILLI_OF_SECOND: {\n                    let nval = newValue * NANOS_PER_MILLI;\n                    return (nval !== this._nanos? Instant._create(this._seconds, nval) : this);\n                }\n                case ChronoField.MICRO_OF_SECOND: {\n                    let nval = newValue * 1000;\n                    return (nval !== this._nanos? Instant._create(this._seconds, nval) : this);\n                }\n                case ChronoField.NANO_OF_SECOND: return (newValue !== this._nanos? Instant._create(this._seconds, newValue) : this);\n                case ChronoField.INSTANT_SECONDS: return (newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code Instant} truncated to the specified unit.\n     * <p>\n     * Truncating the instant returns a copy of the original with fields\n     * smaller than the specified unit set to zero.\n     * The fields are calculated on the basis of using a UTC offset as seen\n     * in {@code toString}.\n     * For example, truncating with the {@link ChronoUnit#MINUTES MINUTES} unit will\n     * round down to the nearest minute, setting the seconds and nanoseconds to zero.\n     * <p>\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalUnit} unit - the unit to truncate to, not null\n     * @return {Instant} an {@code Instant} based on this instant with the time truncated, not null\n     * @throws DateTimeException if the unit is invalid for truncation\n     */\n    truncatedTo(unit) {\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.NANOS) {\n            return this;\n        }\n        var unitDur = unit.duration();\n        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n            throw new DateTimeException('Unit is too large to be used for truncation');\n        }\n        var dur = unitDur.toNanos();\n        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n            throw new DateTimeException('Unit must divide into a standard day without remainder');\n        }\n        var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;\n        var result = MathUtil.intDiv(nod, dur) * dur;\n        return this.plusNanos(result - nod);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {TemporalAmount|number} amount\n     * @param {TemporalUnit} unit - only required if first param is a TemporalAmount\n     * @return {Instant}\n     */\n    plus(amount, unit){\n        if(arguments.length === 1){\n            return this.plus1(amount);\n        } else {\n            return this.plus2(amount, unit);\n        }\n    }\n\n    /**\n     * @param {!TemporalAmount} amount\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    plus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * @param {!number} amountToAdd\n     * @param {!TemporalUnit} unit\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    plus2(amountToAdd, unit) {\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this._plus(MathUtil.intDiv(amountToAdd, 1000000), MathUtil.intMod(amountToAdd, 1000000) * 1000);\n                case ChronoUnit.MILLIS: return this.plusMillis(amountToAdd);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));\n                case ChronoUnit.HOURS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));\n                case ChronoUnit.HALF_DAYS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));\n                case ChronoUnit.DAYS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in seconds added.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToAdd  the seconds to add, positive or negative\n     * @return {Instant} an {@code Instant} based on this instant with the specified seconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    plusSeconds(secondsToAdd) {\n        return this._plus(secondsToAdd, 0);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in milliseconds added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} millisToAdd - the milliseconds to add, positive or negative\n     * @return {Instant} an {@code Instant} based on this instant with the specified milliseconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMillis(millisToAdd) {\n        return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in nanoseconds added.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToAdd - the nanoseconds to add, positive or negative\n     * @return {Instant} an {@code Instant} based on this instant with the specified nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    plusNanos(nanosToAdd) {\n        return this._plus(0, nanosToAdd);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToAdd - the seconds to add, positive or negative\n     * @param {number} nanosToAdd - the nanos to add, positive or negative\n     * @return {Instant} an {@code Instant} based on this instant with the specified seconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    _plus(secondsToAdd, nanosToAdd) {\n        if ((secondsToAdd | nanosToAdd) === 0) {\n            return this;\n        }\n        var epochSec = this._seconds + secondsToAdd;\n        epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n        var _nanosToAdd = nanosToAdd % LocalTime.NANOS_PER_SECOND;\n        var nanoAdjustment = this._nanos + _nanosToAdd;\n        return Instant.ofEpochSecond(epochSec, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {TemporalAmount|number} amount\n     * @param {TemporalUnit} unit - only required if first param is a TemporalAmount\n     * @return {Instant}\n     */\n    minus(amount, unit){\n        if(arguments.length === 1){\n            return this.minus1(amount);\n        } else {\n            return this.minus2(amount, unit);\n        }\n    }\n\n    /**\n     * @param {!TemporalAmount} amount\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    minus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * @param {!number} amountToSubtract\n     * @param {!TemporalUnit} unit\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    minus2(amountToSubtract, unit) {\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in seconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToSubtract - the seconds to subtract, positive or negative\n     * @return {Instant} an {@code Instant} based on this instant with the specified seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    minusSeconds(secondsToSubtract) {\n        return this.plusSeconds(secondsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in milliseconds subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} millisToSubtract - the milliseconds to subtract, positive or negative\n     * @return {Instant} an {@code Instant} based on this instant with the specified milliseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMillis(millisToSubtract) {\n        return this.plusMillis(-1 * millisToSubtract);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in nanoseconds subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToSubtract  the nanoseconds to subtract, positive or negative\n     * @return {Instant} an {@code Instant} based on this instant with the specified nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusNanos(nanosToSubtract) {\n        return this.plusNanos(-1 * nanosToSubtract);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Queries this instant using the specified query.\n     * <p>\n     * This queries this instant using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param {!TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                query === TemporalQueries.chronology() || query === TemporalQueries.zoneId() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this instant.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with the instant changed to be the same as this.\n     * <p>\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * twice, passing {@link ChronoField#INSTANT_SECONDS} and\n     * {@link ChronoField#NANO_OF_SECOND} as the fields.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisInstant.adjustInto(temporal);\n     *   temporal = temporal.with(thisInstant);\n     * </pre>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);\n    }\n\n    /**\n     * Calculates the period between this instant and another instant in\n     * terms of the specified unit.\n     * <p>\n     * This calculates the period between two instants in terms of a single unit.\n     * The start and end points are {@code this} and the specified instant.\n     * The result will be negative if the end is before the start.\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two instants.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code Instant} using {@link #from(TemporalAccessor)}.\n     * For example, the period in days between two dates can be calculated\n     * using {@code startInstant.until(endInstant, SECONDS)}.\n     * <p>\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a {@code long} representing the amount of\n     * the specified unit. By contrast, the result of {@code between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, SECONDS);   // this method\n     *   dateTime.plus(SECONDS.between(start, end));      // use in plus/minus\n     * </pre>\n     * <p>\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS}, {@code HALF_DAYS} and {@code DAYS}\n     * are supported. Other {@code ChronoUnit} values will throw an exception.\n     * <p>\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the input temporal as\n     * the second argument.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive - the end date, which is converted to an {@code Instant}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date and the end date\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        let end = Instant.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this._nanosUntil(end);\n                case ChronoUnit.MICROS: return MathUtil.intDiv(this._nanosUntil(end), 1000);\n                case ChronoUnit.MILLIS: return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());\n                case ChronoUnit.SECONDS: return this._secondsUntil(end);\n                case ChronoUnit.MINUTES: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);\n                case ChronoUnit.HOURS: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS: return MathUtil.intDiv(this._secondsUntil(end), (12 * LocalTime.SECONDS_PER_HOUR));\n                case ChronoUnit.DAYS: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     *\n     * @param {Temporal} end\n     * @returns {number}\n     * @private\n     */\n    _nanosUntil(end) {\n        let secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        let totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);\n        return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());\n    }\n\n    /**\n     *\n     * @param {Temporal} end\n     * @returns {number}\n     * @private\n     */\n    _secondsUntil(end) {\n        let secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        let nanosDiff = end.nano() - this.nano();\n        if (secsDiff > 0 && nanosDiff < 0) {\n            secsDiff--;\n        } else if (secsDiff < 0 && nanosDiff > 0) {\n            secsDiff++;\n        }\n        return secsDiff;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this instant with an offset to create an {@code OffsetDateTime}.\n     * <p>\n     * This returns an {@code OffsetDateTime} formed from this instant at the\n     * specified offset from UTC/Greenwich. An exception will be thrown if the\n     * instant is too large to fit into an offset date-time.\n     * <p>\n     * This method is equivalent to\n     * {@link OffsetDateTime#ofInstant(Instant, ZoneId) OffsetDateTime.ofInstant(this, offset)}.\n     *\n     * @param {ZoneOffset} offset - the offset to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this instant and the specified offset, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    //atOffset(offset) {\n    //    return OffsetDateTime.ofInstant(this, offset);\n    //}\n\n    /**\n     * Combines this instant with a time-zone to create a {@code ZonedDateTime}.\n     * <p>\n     * This returns an {@code ZonedDateTime} formed from this instant at the\n     * specified time-zone. An exception will be thrown if the instant is too\n     * large to fit into a zoned date-time.\n     * <p>\n     * This method is equivalent to\n     * {@link ZonedDateTime#ofInstant(Instant, ZoneId) ZonedDateTime.ofInstant(this, zone)}.\n     *\n     * @param {ZoneId} zone - the zone to combine with, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this instant and the specified zone, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    //atZone(zone) {\n    //    return ZonedDateTime.ofInstant(this, zone);\n    //}\n\n    //-----------------------------------------------------------------------\n     /**\n      * Converts this instant to the number of milliseconds from the epoch\n      * of 1970-01-01T00:00:00Z.\n      * <p>\n      * If this instant represents a point on the time-line too far in the future\n      * or past to fit in a {@code long} milliseconds, then an exception is thrown.\n      * <p>\n      * If this instant has greater than millisecond precision, then the conversion\n      * will drop any excess precision information as though the amount in nanoseconds\n      * was subject to integer division by one million.\n      *\n      * @return {number} the number of milliseconds since the epoch of 1970-01-01T00:00:00Z\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n     toEpochMilli() {\n         var millis = MathUtil.safeMultiply(this._seconds, 1000);\n         return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n     }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this instant to the specified instant.\n     * <p>\n     * The comparison is based on the time-line position of the instants.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     * @throws NullPointerException if otherInstant is null\n     */\n    compareTo(otherInstant) {\n        requireNonNull(otherInstant, 'otherInstant');\n        requireInstance(otherInstant, Instant, 'otherInstant');\n        var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return this._nanos - otherInstant._nanos;\n    }\n\n    /**\n     * Checks if this instant is after the specified instant.\n     * <p>\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {boolean} true if this instant is after the specified instant\n     * @throws NullPointerException if otherInstant is null\n     */\n    isAfter(otherInstant) {\n        return this.compareTo(otherInstant) > 0;\n    }\n\n    /**\n     * Checks if this instant is before the specified instant.\n     * <p>\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {boolean} true if this instant is before the specified instant\n     * @throws NullPointerException if otherInstant is null\n     */\n    isBefore(otherInstant) {\n        return this.compareTo(otherInstant) < 0;\n    }\n\n    /**\n     * Checks if this instant is equal to the specified instant.\n     * <p>\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {*} otherInstant - the other instant, null/ undefined returns false\n     * @return {boolean} true if the other instant is equal to this one\n     */\n    equals(otherInstant) {\n        if(this === otherInstant){\n            return true;\n        }\n        if(otherInstant instanceof Instant){\n            return this.epochSecond() === otherInstant.epochSecond() &&\n                this.nano() === otherInstant.nano();\n        }\n        return false;\n    }\n\n    /**\n     * Returns a hash code for this instant.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return ((this._seconds ^ (this._seconds >>> 24))) + 51 * this._nanos;\n    }\n\n    /**\n     * A string representation of this instant using ISO-8601 representation.\n     * <p>\n     * The format used is the same as {@link DateTimeFormatter#ISO_INSTANT}.\n     *\n     * @return {string} an ISO-8601 representation of this instant, not null\n     */\n    toString(){\n        return DateTimeFormatter.ISO_INSTANT.format(this);\n    }\n}\n\nexport function _init() {\n    Instant.MIN_SECONDS = -31619119219200; // -1000000-01-01T00:00:00Z\n    Instant.MAX_SECONDS = 31494816403199; // +1000000-12-31T23:59:59.999999999Z\n    Instant.EPOCH = new Instant(0, 0);\n    Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);\n    Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);\n    Instant.FROM = createTemporalQuery('Instant.FROM', (temporal) => {\n        return Instant.from(temporal);\n    });\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Instant.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n\nimport {MathUtil} from './MathUtil';\nimport {assert, requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException, IllegalArgumentException} from './errors';\n\nimport {Clock} from './Clock';\nimport {LocalDateTime} from './LocalDateTime';\nimport {ZoneId} from './ZoneId';\n\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\n\n/**\n * A time without time-zone in the ISO-8601 calendar system,\n * such as {@code 10:15:30}.\n * <p>\n * {@link LocalTime} is an immutable date-time object that represents a time,\n * often viewed as hour-minute-second.\n * Time is represented to nanosecond precision.\n * For example, the value '13:45.30.123456789' can be stored in a {@link LocalTime}.\n * <p>\n * It does not store or represent a date or time-zone.\n * Instead, it is a description of the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * <p>\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. This API assumes that all calendar systems use the same\n * representation, this class, for time-of-day.\n *\n * <h3>Static properties of Class {@link LocalTime}</h3>\n *\n * LocalTime.MIN\n *\n * The minimum supported {@link LocalTime}, '00:00'.\n * This is the time of midnight at the start of the day.\n *\n * LocalTime.MAX\n *\n * The maximum supported {@link LocalTime}, '23:59:59.999999999'.\n * This is the time just before midnight at the end of the day.\n *\n * LocalTime.MIDNIGHT\n *\n * The time of midnight at the start of the day, '00:00'.\n *\n * LocalTime.NOON\n *\n * The time of noon in the middle of the day, '12:00'.\n *\n * LocalTime.HOURS_PER_DAY\n *\n * Hours per day.\n *\n * LocalTime.MINUTES_PER_HOUR\n *\n * Minutes per hour.\n *\n * LocalTime.MINUTES_PER_DAY\n *\n * Minutes per day.\n *\n * LocalTime.SECONDS_PER_MINUTE\n *\n * Seconds per minute.\n *\n * LocalTime.SECONDS_PER_HOUR\n *\n * Seconds per hour.\n *\n * LocalTime.SECONDS_PER_DAY\n *\n * Seconds per day.\n *\n * LocalTime.MILLIS_PER_DAY\n *\n * Milliseconds per day.\n *\n * LocalTime.MICROS_PER_DAY\n *\n * Microseconds per day.\n *\n * LocalTime.NANOS_PER_SECOND\n *\n * Nanos per second.\n *\n * LocalTime.NANOS_PER_MINUTE\n *\n * Nanos per minute.\n *\n * LocalTime.NANOS_PER_HOUR\n *\n * Nanos per hour.\n *\n * LocalTime.NANOS_PER_DAY\n *\n * Nanos per day.\n *\n */\nexport class LocalTime extends Temporal /** implements Temporal, TemporalAdjuster */ {\n    /**\n     * Obtains the current time from the specified clock. \n     * If no argument is specified the system default clock is queried, \n     * if a zone-id is passed a system clock with the specified zone is queried.\n     * <p>\n     * This will query the specified clock to obtain the current time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param {Clock|ZoneId} clockOrZone - the zone ID or clock to use, if null Clock.systemDefaultZone() is used.\n     * @return {LocalDateTime} the current time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        if (clockOrZone == null){\n            return LocalTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock){\n            return LocalTime._now(clockOrZone);\n        } else {\n            return LocalTime._now(Clock.system(clockOrZone));\n        }\n    }\n\n    /**\n     * Obtains the current time from the specified clock.\n     * <p>\n     * This will query the specified clock to obtain the current time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param {Clock} [clock=Clock.systemDefaultZone()] - the clock to use, not null\n     * @return {LocalTime} the current time, not null\n     */\n    static _now(clock = Clock.systemDefaultZone()) {\n        requireNonNull(clock, 'clock');// inline OffsetTime factory to avoid creating object and InstantProvider checks\n        return LocalTime.ofInstant(clock.instant(), clock.zone());\n    }\n\n    /**\n     * obtain a LocalTime from an Instant in the specified time-zone or, if null\n     * in the system default time-zone\n     *\n     * @param {!Instant} instant\n     * @param {ZoneId} [zone=ZoneId.systemDefault()], defaults to ZoneId.systemDefault()\n     * @returns {LocalDate} the current date, not null\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()){\n        var offset = zone.rules().offset(instant);\n        var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);\n        secsOfDay = MathUtil.intMod((secsOfDay + offset.totalSeconds()), LocalTime.SECONDS_PER_DAY);\n        if (secsOfDay < 0) {\n            secsOfDay += LocalTime.SECONDS_PER_DAY;\n        }\n        return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from an hour, minute, second and nanosecond.\n     * <p>\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [hour=0] - the hour-of-day to represent, from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     */\n    static of(hour, minute, second, nanoOfSecond) {\n        return new LocalTime(hour, minute, second, nanoOfSecond);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from a second-of-day value, with\n     * associated nanos of second.\n     * <p>\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [secondOfDay=0] - the second-of-day, from {@code 0} to {@code 24 * 60 * 60 - 1}\n     * @param {number} [nanoOfSecond=0] - the nano-of-second, from 0 to 999,999,999\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the either input value is invalid\n     */\n    static ofSecondOfDay(secondOfDay=0, nanoOfSecond=0) {\n        ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);\n        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        var hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);\n        secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;\n        var minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);\n        secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;\n        return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);\n    }\n    \n    /**\n     * Obtains an instance of {@link LocalTime} from a nanos-of-day value.\n     * <p>\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [nanoOfDay=0] - the nano of day, from {@code 0} to {@code 24 * 60 * 60 * 1,000,000,000 - 1}\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the nanos of day value is invalid\n     */\n    static ofNanoOfDay(nanoOfDay=0) {\n        ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);\n        var hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);\n        nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;\n        var minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);\n        nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;\n        var seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);\n        nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;\n        return new LocalTime(hours, minutes, seconds, nanoOfDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalTime} from a temporal object.\n     * <p>\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalTime}.\n     * <p>\n     * The conversion uses the {@link TemporalQueries#localTime()} query, which relies\n     * on extracting the {@link ChronoField#NANO_OF_DAY NANO_OF_DAY} field.\n     * <p>\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link LocalTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        var time = temporal.query(TemporalQueries.localTime());\n        if (time == null) {\n            throw new DateTimeException(`Unable to obtain LocalTime TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n        return time;\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from a text string using a specific formatter.\n     * <p>\n     * The text is parsed using the formatter, returning a time.\n     *\n     * @param {!String} text - the text to parse, not null\n     * @param {!String} formatter - the formatter to use, not null\n     * @return {LocalTime} the parsed local time, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter=DateTimeFormatter.ISO_LOCAL_TIME) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, LocalTime.FROM);\n    }\n\n    /**\n     * Constructor, previously validated.\n     *\n     * @param {number} [hour=0] - the hour-of-day to represent, validated from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, validated from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, validated from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, validated from 0 to 999,999,999\n     */\n    constructor(hour=0, minute=0, second=0, nanoOfSecond=0) {\n        super();\n        LocalTime._validate(hour, minute, second, nanoOfSecond);\n        if ((minute | second | nanoOfSecond) === 0) {\n            return LocalTime.HOURS[hour];\n        }\n        this._hour = hour;\n        this._minute = minute;\n        this._second = second;\n        this._nano = nanoOfSecond;\n    }\n\n    static _validate(hour, minute, second, nanoOfSecond){\n        ChronoField.HOUR_OF_DAY.checkValidValue(hour);\n        ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);\n        ChronoField.SECOND_OF_MINUTE.checkValidValue(second);\n        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        \n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * <p>\n     * This checks if this time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range} and\n     * {@link #get(TemporalField) get} methods will throw an exception.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * <ul>\n     * <li>{@link ChronoField.NANO_OF_SECOND}\n     * <li>{@link ChronoField.NANO_OF_DAY}\n     * <li>{@link ChronoField.MICRO_OF_SECOND}\n     * <li>{@link ChronoField.MICRO_OF_DAY}\n     * <li>{@link ChronoField.MILLI_OF_SECOND}\n     * <li>{@link ChronoField.MILLI_OF_DAY}\n     * <li>{@link ChronoField.SECOND_OF_MINUTE}\n     * <li>{@link ChronoField.SECOND_OF_DAY}\n     * <li>{@link ChronoField.MINUTE_OF_HOUR}\n     * <li>{@link ChronoField.MINUTE_OF_DAY}\n     * <li>{@link ChronoField.HOUR_OF_AMPM}\n     * <li>{@link ChronoField.CLOCK_HOUR_OF_AMPM}\n     * <li>{@link ChronoField.HOUR_OF_DAY}\n     * <li>{@link ChronoField.CLOCK_HOUR_OF_DAY}\n     * <li>{@link ChronoField.AMPM_OF_DAY}\n     * </ul>\n     * All other {@link ChronoField} instances will return false.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing this as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {ChronoField|ChronoUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isTimeBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     * <p>\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing this as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {ChronoField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        requireNonNull(field);\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this time as an {@code int}.\n     * <p>\n     * This queries this time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this time, except {@link ChronoField.NANO_OF_DAY} and {@link ChronoField.MICRO_OF_DAY}\n     * which are too large to fit in an {@code int} and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {ChronoField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this time as a {@code long}.\n     * <p>\n     * This queries this time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.from}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {ChronoField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            return this._get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * \n     * @param {ChronoField} field\n     * @returns {number}\n     * @private\n     */\n    _get0(field) {\n        switch (field) {\n            case ChronoField.NANO_OF_SECOND: return this._nano;\n            case ChronoField.NANO_OF_DAY: return this.toNanoOfDay();\n            case ChronoField.MICRO_OF_SECOND: return MathUtil.intDiv(this._nano, 1000);\n            case ChronoField.MICRO_OF_DAY: return MathUtil.intDiv(this.toNanoOfDay(), 1000);\n            case ChronoField.MILLI_OF_SECOND: return MathUtil.intDiv(this._nano, 1000000);\n            case ChronoField.MILLI_OF_DAY: return MathUtil.intDiv(this.toNanoOfDay(), 1000000);\n            case ChronoField.SECOND_OF_MINUTE: return this._second;\n            case ChronoField.SECOND_OF_DAY: return this.toSecondOfDay();\n            case ChronoField.MINUTE_OF_HOUR: return this._minute;\n            case ChronoField.MINUTE_OF_DAY: return this._hour * 60 + this._minute;\n            case ChronoField.HOUR_OF_AMPM: return MathUtil.intMod(this._hour, 12);\n            case ChronoField.CLOCK_HOUR_OF_AMPM: var ham = MathUtil.intMod(this._hour, 12); return (ham % 12 === 0 ? 12 : ham);\n            case ChronoField.HOUR_OF_DAY: return this._hour;\n            case ChronoField.CLOCK_HOUR_OF_DAY: return (this._hour === 0 ? 24 : this._hour);\n            case ChronoField.AMPM_OF_DAY: return MathUtil.intDiv(this._hour, 12);\n        }\n        throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._hour;\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._minute;\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._second;\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._nano;\n    }\n\n    /**\n     * function overloading for {@link LocalDate.with}\n     * \n     * if called with 1 (or less) arguments {@link LocalTime.withTemporalAdjuster} is called.\n     * Otherwise {@link LocalTime.with2} is called.\n     *\n     * @param {!(TemporalAdjuster|ChronoField)} adjusterOrField\n     * @param {number} newValue - only required if called with 2 arguments\n     * @return {LocalTime}\n     */\n    with(adjusterOrField, newValue){\n        if(arguments.length < 2){\n            return this.withTemporalAdjuster(adjusterOrField);\n        } else {\n            return this.with2(adjusterOrField, newValue);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this time.\n     * <p>\n     * This returns a new {@link LocalTime}, based on this one, with the time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * <p>\n     * A simple adjuster might simply set the one of the fields, such as the hour field.\n     * A more complex adjuster might set the time to the last hour of the day.\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster.adjustInto} method on the\n     * specified adjuster passing this as the argument.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {LocalTime} a {@link LocalTime} based on this with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalTime) {\n            return adjuster;\n        }\n        assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this time with the specified field set to a new value.\n     * <p>\n     * This returns a new {@link LocalTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the hour, minute or second.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * <ul>\n     * <li>{@link ChronoField.NANO_OF_SECOND} -\n     *  Returns a {@link LocalTime} with the specified nano-of-second.\n     *  The hour, minute and second will be unchanged.\n     * <li>{@link ChronoField.NANO_OF_DAY} -\n     *  Returns a {@link LocalTime} with the specified nano-of-day.\n     *  This completely replaces the time and is equivalent to {@link #ofNanoOfDay(long)}.\n     * <li>{@link ChronoField.MICRO_OF_SECOND} -\n     *  Returns a {@link LocalTime} with the nano-of-second replaced by the specified\n     *  micro-of-second multiplied by 1,000.\n     *  The hour, minute and second will be unchanged.\n     * <li>{@link ChronoField.MICRO_OF_DAY} -\n     *  Returns a {@link LocalTime} with the specified micro-of-day.\n     *  This completely replaces the time and is equivalent to using {@link #ofNanoOfDay(long)}\n     *  with the micro-of-day multiplied by 1,000.\n     * <li>{@link ChronoField.MILLI_OF_SECOND} -\n     *  Returns a {@link LocalTime} with the nano-of-second replaced by the specified\n     *  milli-of-second multiplied by 1,000,000.\n     *  The hour, minute and second will be unchanged.\n     * <li>{@link ChronoField.MILLI_OF_DAY} -\n     *  Returns a {@link LocalTime} with the specified milli-of-day.\n     *  This completely replaces the time and is equivalent to using {@link #ofNanoOfDay(long)}\n     *  with the milli-of-day multiplied by 1,000,000.\n     * <li>{@link ChronoField.SECOND_OF_MINUTE} -\n     *  Returns a {@link LocalTime} with the specified second-of-minute.\n     *  The hour, minute and nano-of-second will be unchanged.\n     * <li>{@link ChronoField.SECOND_OF_DAY} -\n     *  Returns a {@link LocalTime} with the specified second-of-day.\n     *  The nano-of-second will be unchanged.\n     * <li>{@link ChronoField.MINUTE_OF_HOUR} -\n     *  Returns a {@link LocalTime} with the specified minute-of-hour.\n     *  The hour, second-of-minute and nano-of-second will be unchanged.\n     * <li>{@link ChronoField.MINUTE_OF_DAY} -\n     *  Returns a {@link LocalTime} with the specified minute-of-day.\n     *  The second-of-minute and nano-of-second will be unchanged.\n     * <li>{@link ChronoField.HOUR_OF_AMPM} -\n     *  Returns a {@link LocalTime} with the specified hour-of-am-pm.\n     *  The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * <li>{@link ChronoField.CLOCK_HOUR_OF_AMPM} -\n     *  Returns a {@link LocalTime} with the specified clock-hour-of-am-pm.\n     *  The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * <li>{@link ChronoField.HOUR_OF_DAY} -\n     *  Returns a {@link LocalTime} with the specified hour-of-day.\n     *  The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * <li>{@link ChronoField.CLOCK_HOUR_OF_DAY} -\n     *  Returns a {@link LocalTime} with the specified clock-hour-of-day.\n     *  The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * <li>{@link ChronoField.AMPM_OF_DAY} -\n     *  Returns a {@link LocalTime} with the specified AM/PM.\n     *  The hour-of-am-pm, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * </ul>\n     * <p>\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     * <p>\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing this as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!ChronoField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalTime} a {@link LocalTime} based on this with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.NANO_OF_SECOND: return this.withNano(newValue);\n                case ChronoField.NANO_OF_DAY: return LocalTime.ofNanoOfDay(newValue);\n                case ChronoField.MICRO_OF_SECOND: return this.withNano(newValue * 1000);\n                case ChronoField.MICRO_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000);\n                case ChronoField.MILLI_OF_SECOND: return this.withNano( newValue * 1000000);\n                case ChronoField.MILLI_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000000);\n                case ChronoField.SECOND_OF_MINUTE: return this.withSecond(newValue);\n                case ChronoField.SECOND_OF_DAY: return this.plusSeconds(newValue - this.toSecondOfDay());\n                case ChronoField.MINUTE_OF_HOUR: return this.withMinute(newValue);\n                case ChronoField.MINUTE_OF_DAY: return this.plusMinutes(newValue - (this._hour * 60 + this._minute));\n                case ChronoField.HOUR_OF_AMPM: return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));\n                case ChronoField.CLOCK_HOUR_OF_AMPM: return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));\n                case ChronoField.HOUR_OF_DAY: return this.withHour(newValue);\n                case ChronoField.CLOCK_HOUR_OF_DAY: return this.withHour((newValue === 24 ? 0 : newValue));\n                case ChronoField.AMPM_OF_DAY: return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the hour-of-day value altered.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [hour=0] - the hour-of-day to set in the result, from 0 to 23\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested hour, not null\n     * @throws {DateTimeException} if the hour value is invalid\n     */\n    withHour(hour=0) {\n        if (this._hour === hour) {\n            return this;\n        }\n        return new LocalTime(hour, this._minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the minute-of-hour value altered.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [minute=0] - the minute-of-hour to set in the result, from 0 to 59\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested minute, not null\n     * @throws {DateTimeException} if the minute value is invalid\n     */\n    withMinute(minute=0) {\n        if (this._minute === minute) {\n            return this;\n        }\n        return new LocalTime(this._hour, minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the second-of-minute value altered.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [second=0] - the second-of-minute to set in the result, from 0 to 59\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested second, not null\n     * @throws {DateTimeException} if the second value is invalid\n     */\n    withSecond(second=0) {\n        if (this._second === second) {\n            return this;\n        }\n        return new LocalTime(this._hour, this._minute, second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the nano-of-second value altered.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested nanosecond, not null\n     * @throws {DateTimeException} if the nanos value is invalid\n     */\n    withNano(nanoOfSecond=0) {\n        if (this._nano === nanoOfSecond) {\n            return this;\n        }\n        return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the time truncated.\n     * <p>\n     * Truncating the time returns a copy of the original time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit.MINUTES} minutes unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * <p>\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit.DAYS}. Other units throw an exception.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!ChronoUnit} unit - the unit to truncate to, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the time truncated, not null\n     * @throws {DateTimeException} if unable to truncate\n     */\n    truncatedTo(unit) {\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.NANOS) {\n            return this;\n        }\n        var unitDur = unit.duration();\n        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n            throw new DateTimeException('Unit is too large to be used for truncation');\n        }\n        var dur = unitDur.toNanos();\n        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n            throw new DateTimeException('Unit must divide into a standard day without remainder');\n        }\n        var nod = this.toNanoOfDay();\n        return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * function overloading for {@link LocalDate.plus}\n     *\n     * if called with 1 (or less) arguments {@link LocalTime.plus1} is called.\n     * Otherwise {@link LocalTime.plus2} is called.\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {ChronoUnit} unit - only required if called with 2 arguments\n     * @return {LocalTime}\n     */\n    plus(amount, unit){\n        if(arguments.length < 2){\n            return this.plus1(amount);\n        } else {\n            return this.plus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * This method returns a new time based on this time with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link #plus(long, TemporalUnit)}.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to add, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the addition made, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    plus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this time with the specified period added.\n     * <p>\n     * This method returns a new time based on this time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add hours, minutes or seconds.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {ChronoUnit} unit - the unit of the period to add, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n                case ChronoUnit.MILLIS: return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusMinutes(amountToAdd);\n                case ChronoUnit.HOURS: return this.plusHours(amountToAdd);\n                case ChronoUnit.HALF_DAYS: return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in hours added.\n     * <p>\n     * This adds the specified number of hours to this time, returning a new time.\n     * The calculation wraps around midnight.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hoursToAdd - the hours to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the hours added, not null\n     */\n    plusHours(hoursToAdd) {\n        if (hoursToAdd === 0) {\n            return this;\n        }\n\n        var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);\n        return new LocalTime(newHour, this._minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in minutes added.\n     * <p>\n     * This adds the specified number of minutes to this time, returning a new time.\n     * The calculation wraps around midnight.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutesToAdd - the minutes to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the minutes added, not null\n     */\n    plusMinutes(minutesToAdd) {\n        if (minutesToAdd === 0) {\n            return this;\n        }\n        var mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;\n        var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);\n        if (mofd === newMofd) {\n            return this;\n        }\n        var newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);\n        var newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);\n        return new LocalTime(newHour, newMinute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in seconds added.\n     * <p>\n     * This adds the specified number of seconds to this time, returning a new time.\n     * The calculation wraps around midnight.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondstoAdd - the seconds to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the seconds added, not null\n     */\n    plusSeconds(secondstoAdd) {\n        if (secondstoAdd === 0) {\n            return this;\n        }\n        var sofd = this._hour * LocalTime.SECONDS_PER_HOUR +\n                    this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;\n        var newSofd = MathUtil.intMod((MathUtil.intMod(secondstoAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY), LocalTime.SECONDS_PER_DAY);\n        if (sofd === newSofd) {\n            return this;\n        }\n        var newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);\n        var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n        var newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);\n        return new LocalTime(newHour, newMinute, newSecond, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in nanoseconds added.\n     * <p>\n     * This adds the specified number of nanoseconds to this time, returning a new time.\n     * The calculation wraps around midnight.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToAdd - the nanos to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the nanoseconds added, not null\n     */\n    plusNanos(nanosToAdd) {\n        if (nanosToAdd === 0) {\n            return this;\n        }\n        var nofd = this.toNanoOfDay();\n        var newNofd = MathUtil.intMod((MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY), LocalTime.NANOS_PER_DAY);\n        if (nofd === newNofd) {\n            return this;\n        }\n        var newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);\n        var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n        var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);\n        var newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);\n        return new LocalTime(newHour, newMinute, newSecond, newNano);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDate.minus}\n     *\n     * if called with 1 (or less) arguments {@link LocalTime.minus1} is called.\n     * Otherwise {@link LocalTime.minus2} is called.\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {ChronoUnit} unit - only required if called with 2 arguments\n     * @return {LocalTime}\n     */\n    minus(amount, unit){\n        if(arguments.length < 2){\n            return this.minus1(amount);\n        } else {\n            return this.minus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this time with the specified period subtracted.\n     * <p>\n     * This method returns a new time based on this time with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link #minus(long, TemporalUnit)}.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to subtract, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the subtraction made, not null\n     * @throws {DateTimeException} if the subtraction cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n\n    minus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this time with the specified period subtracted.\n     * <p>\n     * This method returns a new time based on this time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract hours, minutes or seconds.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {ChronoUnit} unit - the unit of the period to subtract, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        requireNonNull(unit, 'unit');\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in hours subtracted.\n     * <p>\n     * This subtracts the specified number of hours from this time, returning a new time.\n     * The calculation wraps around midnight.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hoursToSubtract - the hours to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the hours subtracted, not null\n     */\n    minusHours(hoursToSubtract) {\n        return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in minutes subtracted.\n     * <p>\n     * This subtracts the specified number of minutes from this time, returning a new time.\n     * The calculation wraps around midnight.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutesToSubtract - the minutes to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the minutes subtracted, not null\n     */\n    minusMinutes(minutesToSubtract) {\n        return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in seconds subtracted.\n     * <p>\n     * This subtracts the specified number of seconds from this time, returning a new time.\n     * The calculation wraps around midnight.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToSubtract - the seconds to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the seconds subtracted, not null\n     */\n    minusSeconds(secondsToSubtract) {\n        return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in nanoseconds subtracted.\n     * <p>\n     * This subtracts the specified number of nanoseconds from this time, returning a new time.\n     * The calculation wraps around midnight.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToSubtract - the nanos to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the nanoseconds subtracted, not null\n     */\n    minusNanos(nanosToSubtract) {\n        return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this time using the specified query.\n     * <p>\n     * This queries this time using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing this as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.localTime()) {\n            return this;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        if (query === TemporalQueries.chronology() || query === TemporalQueries.zoneId() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.offset() ||\n                query === TemporalQueries.localDate()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same time as this object.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with the time changed to be the same as this.\n     * <p>\n     * The adjustment is equivalent to using {@link Temporal.with}\n     * passing {@link ChronoField.NANO_OF_DAY} as the field.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal.with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalTime.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalTime);\n     * </pre>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());\n    }\n\n    /**\n     * Calculates the period between this time and another time in\n     * terms of the specified unit.\n     * <p>\n     * This calculates the period between two times in terms of a single unit.\n     * The start and end points are this and the specified time.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalTime}.\n     * For example, the period in hours between two times can be calculated\n     * using {@code startTime.until(endTime, HOURS)}.\n     * <p>\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two times.\n     * For example, the period in hours between 11:30 and 13:29 will only\n     * be one hour as it is one minute short of two hours.\n     * <p>\n     * This method operates in association with {@link TemporalUnit.between}.\n     * The result of this method is a {@code long} representing the amount of\n     * the specified unit. By contrast, the result of {@code between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, HOURS);   // this method\n     *   dateTime.plus(HOURS.between(start, end));      // use in plus/minus\n     * </pre>\n     * <p>\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link ChronoUnit.NANOS}, {@link ChronoUnit.MICROS}, {@link ChronoUnit.MILLIS}, {@link ChronoUnit.SECONDS},\n     * {@link ChronoUnit.MINUTES}, {@link ChronoUnit.HOURS} and {@link ChronoUnit.HALF_DAYS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     * <p>\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing this as the first argument and the input temporal as\n     * the second argument.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAccessor} endExclusive - the end time, which is converted to a {@link LocalTime}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this time and the end time\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        var end = LocalTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();  // no overflow\n            switch (unit) {\n                case ChronoUnit.NANOS: return nanosUntil;\n                case ChronoUnit.MICROS: return MathUtil.intDiv(nanosUntil, 1000);\n                case ChronoUnit.MILLIS: return MathUtil.intDiv(nanosUntil, 1000000);\n                case ChronoUnit.SECONDS: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);\n                case ChronoUnit.MINUTES: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);\n                case ChronoUnit.HOURS: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS: return MathUtil.intDiv(nanosUntil, (12 * LocalTime.NANOS_PER_HOUR));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this time with a date to create a {@link LocalDateTime}.\n     * <p>\n     * This returns a {@link LocalDateTime} formed from this time at the specified date.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {LocalDate} date - the date to combine with, not null\n     * @return {LocalDateTime} the local date-time formed from this time and the specified date, not null\n     */\n    atDate(date) {\n        return LocalDateTime.of(date, this);\n    }\n\n    /**\n     * Combines this time with an offset to create an {@link OffsetTime}.\n     * <p>\n     * This returns an {@link OffsetTime} formed from this time at the specified offset.\n     * All possible combinations of time and offset are valid.\n     *\n     * @param {OffsetTime} offset - the offset to combine with, not null\n     * @return {OffsetTime} the offset time formed from this time and the specified offset, not null\n     */\n/*\n    atOffset(offset) {\n        return OffsetTime.of(this, offset);\n    }\n*/\n\n    //-----------------------------------------------------------------------\n    /**\n     * Extracts the time as seconds of day,\n     * from {@code 0} to {@code 24 * 60 * 60 - 1}.\n     *\n     * @return {number} the second-of-day equivalent to this time\n     */\n    toSecondOfDay() {\n        var total = this._hour * LocalTime.SECONDS_PER_HOUR;\n        total += this._minute * LocalTime.SECONDS_PER_MINUTE;\n        total += this._second;\n        return total;\n    }\n\n    /**\n     * Extracts the time as nanos of day,\n     * from {@code 0} to {@code 24 * 60 * 60 * 1,000,000,000 - 1}.\n     *\n     * @return {number} the nano of day equivalent to this time\n     */\n    toNanoOfDay() {\n        var total = this._hour * LocalTime.NANOS_PER_HOUR;\n        total += this._minute * LocalTime.NANOS_PER_MINUTE;\n        total += this._second * LocalTime.NANOS_PER_SECOND;\n        total += this._nano;\n        return total;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this {@link LocalTime} to another time.\n     * <p>\n     * The comparison is based on the time-line position of the local times within a day.\n     * It is 'consistent with equals', as defined by {@link Comparable}.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     * @throws {NullPointerException} if {@code other} is null\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalTime, 'other');\n        var cmp = MathUtil.compareNumbers(this._hour, other._hour);\n        if (cmp === 0) {\n            cmp = MathUtil.compareNumbers(this._minute, other._minute);\n            if (cmp === 0) {\n                cmp = MathUtil.compareNumbers(this._second, other._second);\n                if (cmp === 0) {\n                    cmp = MathUtil.compareNumbers(this._nano, other._nano);\n                }\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this {@link LocalTime} is after the specified time.\n     * <p>\n     * The comparison is based on the time-line position of the time within a day.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {boolean}true if this is after the specified time\n     * @throws {NullPointerException} if {@code other} is null\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Checks if this {@link LocalTime} is before the specified time.\n     * <p>\n     * The comparison is based on the time-line position of the time within a day.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {boolean}true if this point is before the specified time\n     * @throws {NullPointerException} if {@code other} is null\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this time is equal to another time.\n     * <p>\n     * The comparison is based on the time-line position of the time within a day.\n     * <p>\n     * Only objects of type {@link LocalTime} are compared, other types return false.\n     * To compare the date of two {@link TemporalAccessor} instances, use\n     * {@link ChronoField#NANO_OF_DAY} as a comparator.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean}true if this is equal to the other time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalTime) {\n            return this._hour === other._hour && this._minute === other._minute &&\n                this._second === other._second && this._nano === other._nano;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        var nod = this.toNanoOfDay();\n        return (nod ^ (nod >>> 24));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this time as a {@link String}, such as {@code 10:15}.\n     * <p>\n     * The output will be one of the following ISO-8601 formats:\n     * <p><ul>\n     * <li>{@code HH:mm}</li>\n     * <li>{@code HH:mm:ss}</li>\n     * <li>{@code HH:mm:ss.SSS}</li>\n     * <li>{@code HH:mm:ss.SSSSSS}</li>\n     * <li>{@code HH:mm:ss.SSSSSSSSS}</li>\n     * </ul><p>\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return {string} a string representation of this time, not null\n     */\n    toString() {\n        var buf = '';\n        var hourValue = this._hour;\n        var minuteValue = this._minute;\n        var secondValue = this._second;\n        var nanoValue = this._nano;\n        buf += hourValue < 10 ? '0' : '';\n        buf += hourValue;\n        buf += minuteValue < 10 ? ':0' : ':';\n        buf += minuteValue;\n        if (secondValue > 0 || nanoValue > 0) {\n            buf += secondValue < 10 ? ':0' : ':';\n            buf += secondValue;\n            if (nanoValue > 0) {\n                buf += '.';\n                if(MathUtil.intMod(nanoValue, 1000000) === 0) {\n                    buf += ('' + (MathUtil.intDiv(nanoValue, 1000000) + 1000)).substring(1);\n                } else if (MathUtil.intMod(nanoValue, 1000) === 0) {\n                    buf += ('' + (MathUtil.intDiv(nanoValue, 1000) + 1000000)).substring(1);\n                } else {\n                    buf += ('' + (nanoValue + 1000000000)).substring(1);\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * Outputs this time as a {@link String} using the formatter.\n     * <p>\n     * This time will be passed to the formatter\n     * {@link DateTimeFormatter#format(TemporalAccessor) print method}.\n     *\n     * @param {DateTineFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted time string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n}\n\nexport function _init() {\n    /**\n     * Constants for the local time of each hour.\n     */\n    LocalTime.HOURS = [];\n    for (let i = 0; i < 24; i++) {\n        LocalTime.HOURS[i] = makeLocalTimeConst(i);\n    }\n\n    function makeLocalTimeConst(hour = 0, minute = 0, second = 0, nano = 0) {\n        var localTime = Object.create(LocalTime.prototype);\n        Temporal.call(localTime);\n        localTime._hour = hour;\n        localTime._minute = minute;\n        localTime._second = second;\n        localTime._nano = nano;\n        return localTime;\n    }\n\n    /**\n     * The minimum supported {@link LocalTime}, '00:00'.\n     * This is the time of midnight at the start of the day.\n     */\n    LocalTime.MIN = LocalTime.HOURS[0];\n    /**\n     * The maximum supported {@link LocalTime}, '23:59:59.999999999'.\n     * This is the time just before midnight at the end of the day.\n     */\n    LocalTime.MAX = makeLocalTimeConst(23, 59, 59, 999999999);\n    /**\n     * The time of midnight at the start of the day, '00:00'.\n     */\n    LocalTime.MIDNIGHT = LocalTime.HOURS[0];\n    /**\n     * The time of noon in the middle of the day, '12:00'.\n     */\n    LocalTime.NOON = LocalTime.HOURS[12];\n\n    LocalTime.FROM = createTemporalQuery('LocalTime.FROM', (temporal) => {\n        return LocalTime.from(temporal);\n    });\n\n    /**\n     * Hours per day.\n     */\n    LocalTime.HOURS_PER_DAY = 24;\n    /**\n     * Minutes per hour.\n     */\n    LocalTime.MINUTES_PER_HOUR = 60;\n    /**\n     * Minutes per day.\n     */\n    LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;\n    /**\n     * Seconds per minute.\n     */\n    LocalTime.SECONDS_PER_MINUTE = 60;\n    /**\n     * Seconds per hour.\n     */\n    LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\n    /**\n     * Seconds per day.\n     */\n    LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;\n    /**\n     * Milliseconds per day.\n     */\n    LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;\n    /**\n     * Microseconds per day.\n     */\n    LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;\n    /**\n     * Nanos per second.\n     */\n    LocalTime.NANOS_PER_SECOND = 1000000000;\n    /**\n     * Nanos per minute.\n     */\n    LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;\n    /**\n     * Nanos per hour.\n     */\n    LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\n    /**\n     * Nanos per day.\n     */\n    LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/LocalTime.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport {ArithmeticException} from './errors';\n\nexport const MAX_SAFE_INTEGER = 9007199254740991;\nexport const MIN_SAFE_INTEGER = -9007199254740991;\n\n/**\n * Math helper with static function for integer operations\n */\nexport class MathUtil {\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static intDiv(x, y) {\n        var r = x/y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static intMod(x, y) {\n        var r = x - MathUtil.intDiv(x, y) * y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     * \n     * @param {number} r\n     * @returns {number}\n     */\n    static roundDown(r){\n        if (r < 0) {\n            return Math.ceil(r);\n        } else {\n            return Math.floor(r);\n        }\n    }\n    \n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static floorDiv(x, y){\n        var r = Math.floor(x / y);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static floorMod(x, y){\n        var r = x - MathUtil.floorDiv(x, y) * y;\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeAdd(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        var r = MathUtil.safeToInt(x + y);\n        if (r === x || r === y) {\n            throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');\n        }\n        return r;\n    }\n\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeSubtract(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0 && y === 0) {\n            return 0;\n        } else if (x === 0) {\n            return MathUtil.safeZero(-1 * y);\n        } else if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        return MathUtil.safeToInt(x - y);\n    }\n\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeMultiply(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 1) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 1) {\n            return MathUtil.safeZero(x);\n        }\n        if (x === 0 || y === 0) {\n            return 0;\n        }\n        let r = MathUtil.safeToInt(x * y);\n        if (r / y !== x || (x === MIN_SAFE_INTEGER && y === -1) || (y === MIN_SAFE_INTEGER && x === -1)) {\n            throw new ArithmeticException('Multiplication overflows: ' + x + ' * ' + y);\n        }\n        return r;\n    }\n\n    /**\n     * \n     * @param {number} value\n     * @returns {number}\n     */\n    static parseInt(value) {\n        var r = parseInt(value);\n        return MathUtil.safeToInt(r);\n    }\n\n    /**\n     * \n     * @param {number} value\n     * @returns {number}\n     */\n    static safeToInt(value) {\n        MathUtil.verifyInt(value);\n        return MathUtil.safeZero(value);\n    }\n\n    /**\n     * \n     * @param {number} value\n     */\n    static verifyInt(value){\n        if (value == null) {\n            throw new ArithmeticException(`Invalid value: '${value}', using null or undefined as argument`);\n        }\n        if (isNaN(value)) {\n            throw new ArithmeticException('Invalid int value, using NaN as argument');\n        }\n        if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {\n            throw new ArithmeticException('Calculation overflows an int: ' + value);\n        }\n    }\n\n    /**\n     * \n     * @param {number} value\n     * @returns {number}\n     */\n    static safeZero(value){\n        return value === 0 ? 0 : value;\n    }\n\n    /**\n     * Compares two Numbers.\n     *\n     * @param {number} a  the first value\n     * @param {number} b  the second value\n     * @return {number} the result\n     */\n    static compareNumbers(a, b) {\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n\n}\n\nMathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nMathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/MathUtil.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MathUtil} from './MathUtil';\nimport {assert, requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException, IllegalArgumentException} from './errors';\n\nimport {Clock} from './Clock';\nimport {LocalDate} from './LocalDate';\nimport {LocalTime} from './LocalTime';\nimport {ZonedDateTime} from './ZonedDateTime';\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\n\n\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\n\nimport {ChronoLocalDateTime} from './chrono/ChronoLocalDateTime';\n\n/**\n * A date-time without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30}.\n * <p>\n * {@link LocalDateTime} is an immutable date-time object that represents a date-time,\n * often viewed as year-month-day-hour-minute-second. Other date and time fields,\n * such as day-of-year, day-of-week and week-of-year, can also be accessed.\n * Time is represented to nanosecond precision.\n * For example, the value '2nd October 2007 at 13:45.30.123456789' can be\n * stored in a {@link LocalDateTime}.\n * <p>\n * This class does not store or represent a time-zone.\n * Instead, it is a description of the date, as used for birthdays, combined with\n * the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * <p>\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * <h3>Static properties of Class {@link LocalTime}</h3>\n *\n * LocalDateTime.MIN\n *\n * The minimum supported {@link LocalDateTime}, '-999999999-01-01T00:00:00'.\n * This is the local date-time of midnight at the start of the minimum date.\n * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n * This could be used by an application as a 'far past' date-time.\n *\n * LocalDateTime.MAX\n *\n * The maximum supported {@link LocalDateTime}, '+999999999-12-31T23:59:59.999999999'.\n * This is the local date-time just before midnight at the end of the maximum date.\n * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n * This could be used by an application as a 'far future' date-time.\n *\n */\nexport class LocalDateTime extends ChronoLocalDateTime\n        /** extends ChronoLocalDateTime<LocalDate>\n        implements Temporal, TemporalAdjuster, Serializable */ {\n\n\n    /**\n     * Obtains the current date-time from from the specified clock or the system clock in the specified time-zone.\n     * <p>\n     * If the argument is an instance of Clock this will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     * <p>\n     * If the argument is an instance of ZoneId this will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * <p>\n     * If nor argument is applied, the system default time zone is used to obtain the current date-time.    \n     * <p>\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {Clock|ZoneId} clockOrZone - the zone ID or clock to use, if null Clock.systemDefaultZone() is used.\n     * @return {LocalDateTime} the current date-time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        if (clockOrZone == null){\n            return LocalDateTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock){\n            return LocalDateTime._now(clockOrZone);\n        } else {\n            return LocalDateTime._now(Clock.system(clockOrZone));\n        }\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * <p>\n     * This will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param {Clock} clock - the clock to use, defaults to Clock.systemDefaultZone()\n     * @return {LocalDateTime} the current date-time, not null\n     */\n    static _now(clock) {\n        requireNonNull(clock, 'clock');\n        return LocalDateTime.ofInstant(clock.instant(), clock.zone());\n\n        // this is an alternative implementation with better performance.\n        // var epochMilli = clock.millis();\n        // var offset = clock.zone().rules().offsetOfEpochMilli(epochMilli);\n        // return LocalDateTime._ofEpochMillis(epochMilli, offset);\n        \n    }\n\n    /**\n     * @see comment at {LocalDateTime._now}\n     * @param {number} epochMilli\n     * @param {ZoneOffset} offset\n     * @return {LocalDateTime} the  date-time, not null\n     * \n     */\n    static _ofEpochMillis(epochMilli, offset){\n        var localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();  \n        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n        var nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;\n        var date = LocalDate.ofEpochDay(localEpochDay);\n        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n        return new LocalDateTime(date, time);\n        \n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.of}\n     * \n     * if called with 2 arguments and first argument is an instance of LocalDate and second is an\n     * instance of LocalTime, then {@link LocalDateTime.ofDateAndTime} is executed.\n     * \n     * Otherwise {@link LocalDateTime.ofNumbers} is executed.\n     * \n     * @returns {LocalDateTime}\n     */\n    static of(){\n        if (arguments.length === 2 && (arguments[0] instanceof LocalDate || arguments[1] instanceof LocalTime)){\n            return LocalDateTime.ofDateAndTime.apply(this, arguments);\n        } else {\n            return LocalDateTime.ofNumbers.apply(this, arguments);\n        }\n    }\n    /**\n     * Obtains an instance of {@link LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * <p>\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param {number} [year=0] - the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} [month=0] - the month-of-year to represent, from 1 to 12 or from a Month\n     * @param {number} [dayOfMonth=0] - the day-of-month to represent, from 1 to 31\n     * @param {number} [hour=0] - the hour-of-day to represent, from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     * @throws {DateTimeException} if the day-of-month is invalid for the month-year\n     */\n    static ofNumbers(year=0, month=0, dayOfMonth=0, hour=0, minute=0, second=0, nanoOfSecond=0) {\n        var date = LocalDate.of(year, month, dayOfMonth);\n        var time = LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a date and time.\n     *\n     * @param {!LocalDate} date - the local date, not null\n     * @param {!LocalTime} time - the local time, not null\n     * @return {LocalDateTime} the local date-time, not null\n     */\n    static ofDateAndTime(date, time) {\n        requireNonNull(date, 'date');\n        requireNonNull(time, 'time');\n        return new LocalDateTime(date, time);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from an {@link Instant} and zone ID.\n     * <p>\n     * This creates a local date-time based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date-time.\n     *\n     * @param {!Instant} instant  the instant to create the date-time from, not null\n     * @param {!ZoneId} [zone=ZoneId.systemDefault()]  the time-zone, which may be an offset, defaults to ZoneId.systemDefault()\n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()) {\n        requireNonNull(instant, 'instant');\n        requireNonNull(zone, 'zone');\n        var rules = zone.rules();\n        var offset = rules.offset(instant);\n        return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     * <p>\n     * This allows the {@link ChronoField.INSTANT_SECONDS} epoch-second field\n     * to be converted to a local date-time. This is primarily intended for\n     * low-level conversions rather than general application usage.\n     *\n     * @param {number} epochSecond - the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param {number|!ZoneOffset} nanoOfSecond - the nanosecond within the second, from 0 to 999,999,999\n     * @param {ZoneOffset} offset - the zone offset, not null if called with 3 arguments \n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    static ofEpochSecond(epochSecond=0, nanoOfSecond=0, offset) {\n        if(arguments.length === 2 && nanoOfSecond instanceof ZoneOffset){\n            offset = nanoOfSecond;\n            nanoOfSecond = 0;\n        }\n        requireNonNull(offset, 'offset');\n        var localSecond = epochSecond + offset.totalSeconds();  // overflow caught later\n        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n        var date = LocalDate.ofEpochDay(localEpochDay);\n        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a temporal object.\n     * <p>\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalDateTime}.\n     * <p>\n     * The conversion extracts and combines {@link LocalDate} and {@link LocalTime}.\n     * <p>\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDateTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalDateTime} {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalDateTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof LocalDateTime) {\n            return temporal;\n        } else if (temporal instanceof ZonedDateTime) {\n            return temporal.toLocalDateTime();\n        }\n        try {\n            var date = LocalDate.from(temporal);\n            var time = LocalTime.from(temporal);\n            return new LocalDateTime(date, time);\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain LocalDateTime TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a text string using a specific formatter.\n     * <p>\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param {!string} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=DateTimeFormatter.ISO_LOCAL_DATE_TIME] - the formatter to use,\n     * defaults to DateTimeFormatter.ISO_LOCAL_DATE_TIME\n     * @return {LocalDateTime} the parsed local date-time, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME) {\n        return formatter.parse(text, LocalDateTime.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {LocalDate} date - the date part of the date-time, validated not null\n     * @param {LocalTime} time - the time part of the date-time, validated not null\n     */\n    constructor(date, time) {\n        super();\n        requireInstance(date, LocalDate, 'date');\n        requireInstance(time, LocalTime, 'time');\n        this._date = date;\n        this._time = time;\n    }\n\n    /**\n     * Returns a copy of this date-time with the new date and time, checking\n     * to see if a new object is in fact required.\n     *\n     * @param {LocalDate} newDate - the date of the new date-time, not null\n     * @param {LocalTime} newTime - the time of the new date-time, not null\n     * @return {LocalDateTime} the date-time, not null\n     */\n    _withDateTime(newDate, newTime) {\n        if (this._date === newDate && this._time === newTime) {\n            return this;\n        }\n        return new LocalDateTime(newDate, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * <p>\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link LocalDateTime.range} range and\n     * {@link LocalDateTime.get} get methods will throw an exception.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * <ul>\n     * <li>{@link ChronoField.NANO_OF_SECOND}\n     * <li>{@link ChronoField.NANO_OF_DAY}\n     * <li>{@link ChronoField.MICRO_OF_SECOND}\n     * <li>{@link ChronoField.MICRO_OF_DAY}\n     * <li>{@link ChronoField.MILLI_OF_SECOND}\n     * <li>{@link ChronoField.MILLI_OF_DAY}\n     * <li>{@link ChronoField.SECOND_OF_MINUTE}\n     * <li>{@link ChronoField.SECOND_OF_DAY}\n     * <li>{@link ChronoField.MINUTE_OF_HOUR}\n     * <li>{@link ChronoField.MINUTE_OF_DAY}\n     * <li>{@link ChronoField.HOUR_OF_AMPM}\n     * <li>{@link ChronoField.CLOCK_HOUR_OF_AMPM}\n     * <li>{@link ChronoField.HOUR_OF_DAY}\n     * <li>{@link ChronoField.CLOCK_HOUR_OF_DAY}\n     * <li>{@link ChronoField.AMPM_OF_DAY}\n     * <li>{@link ChronoField.DAY_OF_WEEK}\n     * <li>{@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * <li>{@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * <li>{@link ChronoField.DAY_OF_MONTH}\n     * <li>{@link ChronoField.DAY_OF_YEAR}\n     * <li>{@link ChronoField.EPOCH_DAY}\n     * <li>{@link ChronoField.ALIGNED_WEEK_OF_MONTH}\n     * <li>{@link ChronoField.ALIGNED_WEEK_OF_YEAR}\n     * <li>{@link ChronoField.MONTH_OF_YEAR}\n     * <li>{@link ChronoField.EPOCH_MONTH}\n     * <li>{@link ChronoField.YEAR_OF_ERA}\n     * <li>{@link ChronoField.YEAR}\n     * <li>{@link ChronoField.ERA}\n     * </ul>\n     * All other {@link ChronoField} instances will return false.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing {@link this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date-time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     * <p>\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@link this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.range(field) : this._date.range(field));\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@link int}.\n     * <p>\n     * This queries this date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@link NANO_OF_DAY}, {@link MICRO_OF_DAY},\n     * {@link EPOCH_DAY} and {@link EPOCH_MONTH} which are too large to fit in\n     * an {@link int} and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@link this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.get(field) : this._date.get(field));\n        }\n        return super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@link long}.\n     * <p>\n     * This queries this date-time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@link this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field));\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     * <p>\n     * This method returns the primitive {@link int} value for the year.\n     * <p>\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA}.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._date.year();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * <p>\n     * This method returns the month as an {@link int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    monthValue() {\n        return this._date.monthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     * <p>\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@link int} values mean.\n     * If you need access to the primitive {@link int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return {Month} the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    month() {\n        return this._date.month();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * <p>\n     * This method returns the primitive {@link int} value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._date.dayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * <p>\n     * This method returns the primitive {@link int} value for the day-of-year.\n     *\n     * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    dayOfYear() {\n        return this._date.dayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n     * <p>\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@link int} values mean.\n     * If you need access to the primitive {@link int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * <p>\n     * Additional information can be obtained from the {@link DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {number} the day-of-week, not null\n     */\n    dayOfWeek() {\n        return this._date.dayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._time.hour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._time.minute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._time.second();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._time.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.with}\n     *\n     * if called with 1 argument, {@link LocalDateTime.withTemporalAdjuster} is applied,\n     * otherwise {@link LocalDateTime.with2}.\n     *\n     * @param {!(TemporalAdjuster|TemporalField)} adjusterOrField\n     * @param {number} newValue - only require if first argument is a TemporalField\n     * @returns {LocalDateTime}\n     */\n    with(adjusterOrField, newValue){\n        if(arguments.length === 1){\n            return this.withTemporalAdjuster(adjusterOrField);\n        } else {\n            return this.with2(adjusterOrField, newValue);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this date-time.\n     * <p>\n     * This returns a new {@link LocalDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * <p>\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the 'last day of the month' and 'next Wednesday'.\n     * Key date-time classes also implement the {@link TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * <p>\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = localDateTime.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     * <p>\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@link TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * <pre>\n     *  result = localDateTime.with(date);\n     *  result = localDateTime.with(time);\n     * </pre>\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@link this} as the argument.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster the adjuster to use, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on {@link this} with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return this._withDateTime(adjuster, this._time);\n        } else if (adjuster instanceof LocalTime) {\n            return this._withDateTime(this._date, adjuster);\n        } else if (adjuster instanceof LocalDateTime) {\n            return adjuster;\n        }\n        assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * <p>\n     * This returns a new {@link LocalDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * <p>\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * <p>\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDate#with(TemporalField, long) LocalDate}\n     * or {@link LocalTime#with(TemporalField, long) LocalTime}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@link this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalDateTime} a {@link LocalDateTime} based on {@link this} with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            if (field.isTimeBased()) {\n                return this._withDateTime(this._date, this._time.with(field, newValue));\n            } else {\n                return this._withDateTime(this._date.with(field, newValue), this._time);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the year altered.\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year - the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested year, not null\n     * @throws {DateTimeException} if the year value is invalid\n     */\n    withYear(year) {\n        return this._withDateTime(this._date.withYear(year), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the month-of-year altered.\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!(number|Month)} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested month, not null\n     * @throws {DateTimeException} if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this._withDateTime(this._date.withMonth(month), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the day-of-month altered.\n     * If the resulting {@link LocalDateTime} is invalid, an exception is thrown.\n     * The time does not affect the calculation and will be the same in the result.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested day, not null\n     * @throws {DateTimeException} if the day-of-month value is invalid\n     * @throws {DateTimeException} if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the day-of-year altered.\n     * If the resulting {@link LocalDateTime} is invalid, an exception is thrown.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfYear - the day-of-year to set in the result, from 1 to 365-366\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-year value is invalid\n     * @throws {DateTimeException} if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the hour-of-day value altered.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hour - the hour-of-day to set in the result, from 0 to 23\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested hour, not null\n     * @throws {DateTimeException} if the hour value is invalid\n     */\n    withHour(hour) {\n        var newTime = this._time.withHour(hour);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the minute-of-hour value altered.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minute - the minute-of-hour to set in the result, from 0 to 59\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested minute, not null\n     * @throws {DateTimeException} if the minute value is invalid\n     */\n    withMinute(minute) {\n        var newTime = this._time.withMinute(minute);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the second-of-minute value altered.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} second - the second-of-minute to set in the result, from 0 to 59\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested second, not null\n     * @throws {DateTimeException} if the second value is invalid\n     */\n    withSecond(second) {\n        var newTime = this._time.withSecond(second);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the nano-of-second value altered.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanoOfSecond - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws {DateTimeException} if the nano value is invalid\n     */\n    withNano(nanoOfSecond) {\n        var newTime = this._time.withNano(nanoOfSecond);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the time truncated.\n     * <p>\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * <p>\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalUnit} unit - the unit to truncate to, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the time truncated, not null\n     * @throws {DateTimeException} if unable to truncate\n     */\n    truncatedTo(unit) {\n        return this._withDateTime(this._date, this._time.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.plus}\n     *\n     * if called with 1 argument {@link LocalDateTime.plusTemporalAmount} is applied,\n     * otherwise {@link LocalDateTime.plus2}\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {TemporalUnit} unit\n     * @returns {LocalDateTime}\n     */\n    plus(amount, unit){\n        if(arguments.length === 1){\n            return this.plusTemporalAmount(amount);\n        } else {\n            return this.plus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     * <p>\n     * This method returns a new date-time based on this time with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link #plus(long, TemporalUnit)}.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to add, not null\n     * @return {LocalDateTime} based on this date-time with the addition made, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    plusTemporalAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     * <p>\n     * This method returns a new date-time based on this date-time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {!TemporalUnit} unit - the unit of the period to add, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n                case ChronoUnit.MILLIS: return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusMinutes(amountToAdd);\n                case ChronoUnit.HOURS: return this.plusHours(amountToAdd);\n                case ChronoUnit.HALF_DAYS: return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);  // no overflow (256 is multiple of 2)\n            }\n            return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in years added.\n     * <p>\n     * This method adds the specified amount to the years field in three steps:\n     * <ol>\n     * <li>Add the input years to the year field</li>\n     * <li>Check if the resulting date would be invalid</li>\n     * <li>Adjust the day-of-month to the last valid day if necessary</li>\n     * </ol>\n     * <p>\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the years added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusYears(years) {\n        var newDate = this._date.plusYears(years);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in months added.\n     * <p>\n     * This method adds the specified amount to the months field in three steps:\n     * <ol>\n     * <li>Add the input months to the month-of-year field</li>\n     * <li>Check if the resulting date would be invalid</li>\n     * <li>Adjust the day-of-month to the last valid day if necessary</li>\n     * </ol>\n     * <p>\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the months added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMonths(months) {\n        var newDate = this._date.plusMonths(months);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in weeks added.\n     * <p>\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * <p>\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the weeks added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusWeeks(weeks) {\n        var newDate = this._date.plusWeeks(weeks);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in days added.\n     * <p>\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * <p>\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the days added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusDays(days) {\n        var newDate = this._date.plusDays(days);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in hours added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the hours added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusHours(hours) {\n        return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in minutes added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the minutes added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMinutes(minutes) {\n        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in seconds added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the seconds added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusSeconds(seconds) {\n        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in nanoseconds added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusNanos(nanos) {\n        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.minus}\n     *\n     * if called with 1 argument {@link LocalDateTime.minusTemporalAmount} is applied,\n     * otherwise {@link LocalDateTime.minus2}\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {TemporalUnit} unit\n     * @returns {LocalDateTime}\n     */\n    minus(amount, unit){\n        if(arguments.length === 1){\n            return this.minusTemporalAmount(amount);\n        } else {\n            return this.minus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     * <p>\n     * This method returns a new date-time based on this time with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link #minus(long, TemporalUnit)}.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to subtract, not null\n     * @return {LocalDateTime} based on this date-time with the subtraction made, not null\n     * @throws {DateTimeException} if the subtraction cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    minusTemporalAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     * <p>\n     * This method returns a new date-time based on this date-time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to subtract, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        requireNonNull(unit, 'unit');\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in years subtracted.\n     * <p>\n     * This method subtracts the specified amount from the years field in three steps:\n     * <ol>\n     * <li>Subtract the input years from the year field</li>\n     * <li>Check if the resulting date would be invalid</li>\n     * <li>Adjust the day-of-month to the last valid day if necessary</li>\n     * </ol>\n     * <p>\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the years subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusYears(years) {\n        return this.plusYears(-1 * years);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in months subtracted.\n     * <p>\n     * This method subtracts the specified amount from the months field in three steps:\n     * <ol>\n     * <li>Subtract the input months from the month-of-year field</li>\n     * <li>Check if the resulting date would be invalid</li>\n     * <li>Adjust the day-of-month to the last valid day if necessary</li>\n     * </ol>\n     * <p>\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the months subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMonths(months) {\n        return this.plusMonths(-1 * months);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in weeks subtracted.\n     * <p>\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * <p>\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusWeeks(weeks) {\n        return this.plusWeeks(-1 * weeks);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in days subtracted.\n     * <p>\n     * This method subtracts the specified amount from the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * <p>\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the days subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusDays(days) {\n        return this.plusDays(-1 * days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in hours subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the hours subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusHours(hours) {\n        return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in minutes subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMinutes(minutes) {\n        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in seconds subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusSeconds(seconds) {\n        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in nanoseconds subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanos - the nanos to subtract, may be negative\n     * @return {LocalDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusNanos(nanos) {\n        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {LocalDate} newDate  the new date to base the calculation on, not null\n     * @param {Number} hours - the hours to add, may be negative\n     * @param {Number} minutes - the minutes to add, may be negative\n     * @param {Number} seconds - the seconds to add, may be negative\n     * @param {Number} nanos - the nanos to add, may be negative\n     * @param {Number} sign - the sign to determine add or subtract\n     * @return {LocalDateTime} the combined result, not null\n     */\n    _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {\n        // 9223372036854775808 long, 2147483648 int\n        if ((hours | minutes | seconds | nanos) === 0) {\n            return this._withDateTime(newDate, this._time);\n        }\n        var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) +             //   max/24*60*60*1B\n                MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) +                //   max/24*60*60\n                MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) +                //   max/24*60\n                MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);                     //   max/24\n        totDays *= sign;                                   // total max*0.4237...\n        var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) +                    //   max  86400000000000\n                (MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY)) * LocalTime.NANOS_PER_SECOND +   //   max  86400000000000\n                (MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY)) * LocalTime.NANOS_PER_MINUTE +   //   max  86400000000000\n                (MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY)) * LocalTime.NANOS_PER_HOUR;          //   max  86400000000000\n        var curNoD = this._time.toNanoOfDay();                       //   max  86400000000000\n        totNanos = totNanos * sign + curNoD;                    // total 432000000000000\n        totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);\n        var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);\n        var newTime = (newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD));\n        return this._withDateTime(newDate.plusDays(totDays), newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * <p>\n     * This queries this date-time using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@link this} as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date and time as this object.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with the date and time changed to be the same as this.\n     * <p>\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * twice, passing {@link ChronoField#EPOCH_DAY} and\n     * {@link ChronoField#NANO_OF_DAY} as the fields.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalDateTime.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalDateTime);\n     * </pre>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return {LocalDateTime} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the period between this date-time and another date-time in\n     * terms of the specified unit.\n     * <p>\n     * This calculates the period between two date-times in terms of a single unit.\n     * The start and end points are {@link this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalDateTime}.\n     * For example, the period in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * <p>\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the period in months between 2012-06-15T00:00 and 2012-08-14T23:59\n     * will only be one month as it is one minute short of two months.\n     * <p>\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a {@link long} representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     * <p>\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n     * {@link MINUTES}, {@link HOURS} and {@link HALF_DAYS}, {@link DAYS},\n     * {@link WEEKS}, {@link MONTHS}, {@link YEARS}, {@link DECADES},\n     * {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     * <p>\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@link this} as the first argument and the input temporal as\n     * the second argument.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive - the end date-time, which is converted to a {@link LocalDateTime}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date-time and the end date-time\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        var end = LocalDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            if (unit.isTimeBased()) {\n                var daysUntil = this._date.daysUntil(end._date);\n                var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();\n                if (daysUntil > 0 && timeUntil < 0) {\n                    daysUntil--;\n                    timeUntil += LocalTime.NANOS_PER_DAY;\n                } else if (daysUntil < 0 && timeUntil > 0) {\n                    daysUntil++;\n                    timeUntil -= LocalTime.NANOS_PER_DAY;\n                }\n                var amount = daysUntil;\n                switch (unit) {\n                    case ChronoUnit.NANOS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);\n                        return MathUtil.safeAdd(amount, timeUntil);\n                    case ChronoUnit.MICROS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));\n                    case ChronoUnit.MILLIS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));\n                    case ChronoUnit.SECONDS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));\n                    case ChronoUnit.MINUTES:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));\n                    case ChronoUnit.HOURS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));\n                    case ChronoUnit.HALF_DAYS:\n                        amount = MathUtil.safeMultiply(amount, 2);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, (LocalTime.NANOS_PER_HOUR * 12)));\n                }\n                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n            }\n            var endDate = end._date;\n            var endTime = end._time;\n            if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {\n                endDate = endDate.minusDays(1);\n            } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {\n                endDate = endDate.plusDays(1);\n            }\n            return this._date.until(endDate, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with an offset to create an {@link OffsetDateTime}.\n     * <p>\n     * This returns an {@link OffsetDateTime} formed from this date-time at the specified offset.\n     * All possible combinations of date-time and offset are valid.\n     *\n     * @param {ZoneOffset} offset  the offset to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this date-time and the specified offset, not null\n     */\n/*\n    atOffset(offset) {\n        return OffsetDateTime.of(this, offset);\n    }\n*/\n\n    /**\n     * Combines this date-time with a time-zone to create a {@link ZonedDateTime}.\n     * <p>\n     * This returns a {@link ZonedDateTime} formed from this date-time at the\n     * specified time-zone. The result will match this date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     * <p>\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules rules} of the zone ID.\n     *<p>\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     * <p>\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     * <p>\n     * To obtain the later offset during an overlap, call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} on the result of this method.\n     * To throw an exception when there is a gap or overlap, use\n     * {@link ZonedDateTime#ofStrict(LocalDateTime, ZoneOffset, ZoneId)}.\n     *\n     * @param {ZoneId} zone  the time-zone to use, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this date-time, not null\n     */\n    atZone(zone) {\n        return ZonedDateTime.of(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@link LocalDate} part of this date-time.\n     * <p>\n     * This returns a {@link LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return {LocalDate} the date part of this date-time, not null\n     */\n    toLocalDate() {\n        return this._date;\n    }\n\n    /**\n     * Gets the {@link LocalTime} part of this date-time.\n     * <p>\n     * This returns a {@link LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return {LocalTime} the time part of this date-time, not null\n     */\n    toLocalTime() {\n        return this._time;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * <p>\n     * The comparison is primarily based on the date-time, from earliest to latest.\n     * It is 'consistent with equals', as defined by {@link Comparable}.\n     * <p>\n     * If all the date-times being compared are instances of {@link LocalDateTime},\n     * then the comparison will be entirely based on the date-time.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDateTime#compareTo}.\n     *\n     * @param {!LocalDateTime} other - the other date-time to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalDateTime, 'other');\n        return this._compareTo0(other);\n/*\n        if (other instanceof LocalDateTime) {\n            return this._compareTo0(other);\n        }\n        return super.compareTo(other);\n*/\n    }\n\n    /**\n     *\n     * @param {!LocalDateTime} other\n     * @returns {number}\n     * @private\n     */\n    _compareTo0(other) {\n        var cmp = this._date.compareTo(other.toLocalDate());\n        if (cmp === 0) {\n            cmp = this._time.compareTo(other.toLocalTime());\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date-time is after the specified date-time.\n     * <p>\n     * This checks to see if this date-time represents a point on the\n     * local time-line after the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isAfter(b) == false\n     *   a.isAfter(a) == false\n     *   b.isAfter(a) == true\n     * </pre>\n     * <p>\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link #DATE_TIME_COMPARATOR}.\n     *\n     * @param {LocalDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is after the specified date-time\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalDateTime, 'other');\n        return this._compareTo0(other) > 0;\n/*\n        if (other instanceof LocalDateTime) {\n            return this._compareTo0(other) > 0;\n        }\n        return super.isAfter(other);\n*/\n    }\n\n    /**\n     * Checks if this date-time is before the specified date-time.\n     * <p>\n     * This checks to see if this date-time represents a point on the\n     * local time-line before the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isBefore(b) == true\n     *   a.isBefore(a) == false\n     *   b.isBefore(a) == false\n     * </pre>\n     * <p>\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link #DATE_TIME_COMPARATOR}.\n     *\n     * @param {LocalDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is before the specified date-time\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalDateTime, 'other');\n        return this._compareTo0(other) < 0;\n/*\n        if (other instanceof LocalDateTime) {\n            return this._compareTo0(other) < 0;\n        }\n        return super.isBefore(other);\n*/\n    }\n\n    /**\n     * Checks if this date-time is equal to the specified date-time.\n     * <p>\n     * This checks to see if this date-time represents the same point on the\n     * local time-line as the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isEqual(b) == false\n     *   a.isEqual(a) == true\n     *   b.isEqual(a) == false\n     * </pre>\n     * <p>\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link #DATE_TIME_COMPARATOR}.\n     *\n     * @param {*} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is equal to the specified date-time\n     */\n    isEqual(other) {\n        if (other instanceof LocalDateTime) {\n            return this._compareTo0(other) === 0;\n        }\n        return super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * <p>\n     * Compares this {@link LocalDateTime} with another ensuring that the date-time is the same.\n     * Only objects of type {@link LocalDateTime} are compared, other types return false.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalDateTime) {\n            return this._date.equals(other._date) && this._time.equals(other._time);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._date.hashCode() ^ this._time.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@link String}, such as {@code 2007-12-03T10:15:30}.\n     * <p>\n     * The output will be one of the following ISO-8601 formats:\n     * <p><ul>\n     * <li>{@code yyyy-MM-dd'T'HH:mm}</li>\n     * <li>{@code yyyy-MM-dd'T'HH:mm:ss}</li>\n     * <li>{@code yyyy-MM-dd'T'HH:mm:ss.SSS}</li>\n     * <li>{@code yyyy-MM-dd'T'HH:mm:ss.SSSSSS}</li>\n     * <li>{@code yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS}</li>\n     * </ul><p>\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return {string} a string representation of this date-time, not null\n     */\n    toString() {\n        return this._date.toString() + 'T' + this._time.toString();\n    }\n\n    /**\n     * Outputs this date-time as a {@link String} using the formatter.\n     * <p>\n     * This date-time will be passed to the formatter\n     * {@link DateTimeFormatter#format(TemporalAccessor) print method}.\n     *\n     * @param {!DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted date-time string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n}\n\nexport function _init(){\n    /**\n     * The minimum supported {@link LocalDateTime}, '-999999999-01-01T00:00:00'.\n     * This is the local date-time of midnight at the start of the minimum date.\n     * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n     * This could be used by an application as a 'far past' date-time.\n     */\n    LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n\n    /**\n     * The maximum supported {@link LocalDateTime}, '+999999999-12-31T23:59:59.999999999'.\n     * This is the local date-time just before midnight at the end of the maximum date.\n     * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n     * This could be used by an application as a 'far future' date-time.\n     */\n    LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n\n    LocalDateTime.FROM = createTemporalQuery('LocalDateTime.FROM', (temporal) => {\n        return LocalDateTime.from(temporal);\n    });\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/LocalDateTime.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull, requireInstance} from './assert';\n\nimport {MathUtil} from './MathUtil';\nimport {DateTimeException, UnsupportedTemporalTypeException, NullPointerException, IllegalArgumentException} from './errors';\n\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {ChronoLocalDate} from './chrono/ChronoLocalDate';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\nimport {ValueRange} from './temporal/ValueRange';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\n\nimport {Clock} from './Clock';\nimport {DayOfWeek} from './DayOfWeek';\nimport {Month} from './Month';\nimport {Period} from './Period';\nimport {Year} from './Year';\nimport {LocalTime} from './LocalTime';\nimport {LocalDateTime} from './LocalDateTime';\nimport {ZoneId} from './ZoneId';\nimport {ZonedDateTime} from './ZonedDateTime';\n\n/**\n * The number of days in a 400 year cycle.\n */\nconst  DAYS_PER_CYCLE = 146097;\n\n/**\n* The number of days from year zero to year 1970.\n* There are five 400 year cycles from year zero to 2000.\n* There are 7 leap years from 1970 to 2000.\n*/\nconst  DAYS_0000_TO_1970 = (DAYS_PER_CYCLE * 5) - (30 * 365 + 7);\n\n/**\n * A date without a time-zone in the ISO-8601 calendar system,\n * such as 2007-12-03.\n *\n * LocalDate is an immutable date-time object that represents a date,\n * often viewed as year-month-day. Other date fields, such as day-of-year,\n * day-of-week and week-of-year, can also be accessed.\n * For example, the value \"2nd October 2007\" can be stored in a LocalDate.\n *\n * This class does not store or represent a time or time-zone.\n * Instead, it is a description of the date, as used for birthdays.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * <h3>Static properties of Class {@link LocalDate}</h3>\n *\n * LocalDate.MIN = LocalDate.of(Year.MIN_VALUE, 1, 1);\n *\n * The minimum supported {@link LocalDate}\n * This could be used by an application as a \"far past\" date.\n *\n * LocalDate.MAX = LocalDate.of(Year.MAX_VALUE, 12, 31);\n *\n * The maximum supported {@link LocalDate}\n * This could be used by an application as a \"far future\" date.\n *\n * LocalDate.EPOCH_0\n *\n * The date at epoch day 0, that is 1970-01-01.\n */\n\nexport class LocalDate extends ChronoLocalDate{\n\n    /**\n     * Obtains the current date from the system clock in the default time-zone or\n     * if specified, the current date from the specified clock or\n     * if argument is a ZoneId this will query a clock with the specified ZoneId.\n     *\n     * This will query the specified clock to obtain the current date - today.\n     * Using this method allows the use of an alternate clock for testing.\n     *\n     * @param {Clock|ZoneId} [clockOrZone=Clock.systemDefaultZone()] - the clock or zone to use, \n     * if null, the system clock and default time-zone is used.\n     * @return {LocalDate} the current date, not null\n     */\n    static now(clockOrZone) {\n        var clock;\n        if(clockOrZone == null){\n            clock = Clock.systemDefaultZone();\n        } else if(clockOrZone instanceof ZoneId){\n            clock = Clock.system(clockOrZone);\n        } else {\n            clock = clockOrZone;\n        }\n        return LocalDate.ofInstant(clock.instant(), clock.zone());\n    }\n\n    /**\n     * obtain a LocalDate from an Instant in the specified time-zone or, if null\n     * in the system default time-zone\n     *\n     * @param {!Instant} instant\n     * @param {ZoneId} [zone=ZoneId.systemDefault()], defaults to ZoneId.systemDefault()\n     * @returns {LocalDate} the current date, not null\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()){\n        requireNonNull(instant, 'instant');\n        var offset = zone.rules().offset(instant);\n        var epochSec = instant.epochSecond() + offset.totalSeconds();\n        var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);\n        return LocalDate.ofEpochDay(epochDay);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a year, month and day.\n     * <p>\n     * This returns a {@link LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param {!number} year - the year to represent, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!(Month|Number)} month - the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {!number} dayOfMonth - the day-of-month to represent, from 1 to 31\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    static of(year, month, dayOfMonth) {\n        return new LocalDate(year, month, dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a year and day-of-year.\n     * <p>\n     * This returns a {@link LocalDate} with the specified year and day-of-year.\n     * The day-of-year must be valid for the year, otherwise an exception will be thrown.\n     *\n     * @param {!number} year - the year to represent, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!number} dayOfYear - the day-of-year to represent, from 1 to 366\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if the value of any field is out of range,\n     *  or if the day-of-year is invalid for the year\n     */\n    static ofYearDay(year, dayOfYear) {\n        ChronoField.YEAR.checkValidValue(year);\n        //TODO: ChronoField.DAY_OF_YEAR.checkValidValue(dayOfYear);\n        var leap = IsoChronology.isLeapYear(year);\n        if (dayOfYear === 366 && leap === false) {\n            assert(false, 'Invalid date \\'DayOfYear 366\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n        }\n        var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));\n        var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear > monthEnd) {\n            moy = moy.plus(1);\n        }\n        var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.value(), dom);\n    }\n\n    /**\n     * Obtains an instance of LocalDate from the epoch day count.\n     *\n     * This returns a LocalDate with the specified epoch-day.\n     * The {@link ChronoField.EPOCH_DAY} is a simple incrementing count\n     * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.\n     *\n     * @param {number} [epochDay=0] - the Epoch Day to convert, based on the epoch 1970-01-01\n     * @return {LocalDate} the local date, not null\n     * @throws {AssertionError} if the epoch days exceeds the supported date range\n     */\n    static ofEpochDay(epochDay=0) {\n        var adjust, adjustCycles, dom, doyEst, marchDoy0, marchMonth0, month, year, yearEst, zeroDay;\n        zeroDay = epochDay + DAYS_0000_TO_1970;\n        zeroDay -= 60;\n        adjust = 0;\n        if (zeroDay < 0) {\n            adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;\n            adjust = adjustCycles * 400;\n            zeroDay += -adjustCycles * DAYS_PER_CYCLE;\n        }\n        yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);\n        doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n        if (doyEst < 0) {\n            yearEst--;\n            doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n        }\n        yearEst += adjust;\n        marchDoy0 = doyEst;\n        marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);\n        month = (marchMonth0 + 2) % 12 + 1;\n        dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;\n        yearEst += MathUtil.intDiv(marchMonth0, 10);\n        year = yearEst;\n        return new LocalDate(year, month, dom);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a temporal object.\n     * <p>\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalDate}.\n     * <p>\n     * The conversion uses the {@link TemporalQueries.localDate()} query, which relies\n     * on extracting the {@link ChronoField.EPOCH_DAY} field.\n     * <p>\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link LocalDate::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalDate}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        var date = temporal.query(TemporalQueries.localDate());\n        if (date == null) {\n            throw new DateTimeException(\n                `Unable to obtain LocalDate from TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n        return date;\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param {!string} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=DateTimeFormatter.ISO_LOCAL_DATE] - the formatter to use, default is \n     * {@link DateTimeFormatter.ISO_LOCAL_DATE}\n     * @return {LocalDate} the parsed local date, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_LOCAL_DATE){\n        assert(formatter != null, 'formatter', NullPointerException);\n        return formatter.parse(text, LocalDate.FROM);\n    }\n\n    /**\n     * Resolves the date, resolving days past the end of month.\n     *\n     * @param {!number} year - the year to represent, validated from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!number} month - the month-of-year to represent, validated from 1 to 12\n     * @param {!number} day - the day-of-month to represent, validated from 1 to 31\n     * @return {LocalDate} resolved date, not null\n     */\n    static _resolvePreviousValid(year, month, day) {\n        switch (month) {\n            case 2:\n                day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day = Math.min(day, 30);\n                break;\n        }\n        return LocalDate.of(year, month, day);\n    }\n\n    /**\n     * Do not call the constructor directly, use the of*() factories instead like {@link LocalDate.of()}\n     *\n     * @param {!number} year\n     * @param {!(Month|number)} month\n     * @param {!number} dayOfMonth\n     * @private\n     */\n    constructor(year, month, dayOfMonth){\n        super();\n        if (month instanceof Month) {\n            month = month.value();\n        }\n        LocalDate._validate(year, month, dayOfMonth);\n        this._year = MathUtil.safeZero(year);\n        this._month = MathUtil.safeZero(month);\n        this._day = MathUtil.safeZero(dayOfMonth);\n    }\n\n\n    /**\n     * \n     * @param {!number} year\n     * @param {!number} month\n     * @param {!number} dayOfMonth\n     * @throws {DateTimeException} if date values are invalid\n     * @private\n     */\n    static _validate(year, month, dayOfMonth) {\n        var dom;\n        ChronoField.YEAR.checkValidValue(year);\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        if (dayOfMonth > 28) {\n            dom = 31;\n            switch (month) {\n                case 2:\n                    dom = IsoChronology.isLeapYear(year) ? 29 : 28;\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom = 30;\n            }\n            if (dayOfMonth > dom) {\n                if (dayOfMonth === 29) {\n                    assert(false, 'Invalid date \\'February 29\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n                } else {\n                    assert(false, 'Invalid date \\'' + year + '\\' \\'' + month + '\\' \\'' + dayOfMonth + '\\'', DateTimeException);\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     * <p>\n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link LocalDate.range} range and\n     * {@link LocalDate.get} get methods will throw an exception.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     * <ul>\n     * <li>{@link ChronoField.DAY_OF_WEEK}\n     * <li>{@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * <li>{@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * <li>{@link ChronoField.DAY_OF_MONTH}\n     * <li>{@link ChronoField.DAY_OF_YEAR}\n     * <li>{@link ChronoField.EPOCH_DAY}\n     * <li>{@link ChronoField.ALIGNED_WEEK_OF_MONTH}\n     * <li>{@link ChronoField.ALIGNED_WEEK_OF_YEAR}\n     * <li>{@link ChronoField.MONTH_OF_YEAR}\n     * <li>{@link ChronoField.EPOCH_MONTH}\n     * <li>{@link ChronoField.YEAR_OF_ERA}\n     * <li>{@link ChronoField.YEAR}\n     * <li>{@link ChronoField.ERA}\n     * </ul>\n     * All other {@link ChronoField} instances will return false.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing this as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date, false if not\n     */\n    isSupported(field) {\n        return super.isSupported(field);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     * <p>\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing this as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (field.isDateBased()) {\n                switch (field) {\n                    case ChronoField.DAY_OF_MONTH: return ValueRange.of(1, this.lengthOfMonth());\n                    case ChronoField.DAY_OF_YEAR: return ValueRange.of(1, this.lengthOfYear());\n                    case ChronoField.ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);\n                    case ChronoField.YEAR_OF_ERA:\n                        return (this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an {@code int}.\n     * <p>\n     * This queries this date for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return valid\n     * values based on this date, except {@link ChronoField.EPOCH_DAY} and {@link ChronoField.EPOCH_MONTH}\n     * which are too large to fit in an {@code int} and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field  the field to get, not null\n     * @return the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * see {LocalDate.get}, get and getLong are identical in javascript, because we are only limited by \n     * {@link MathUtil.MIN_SAFE_INTEGER}/ {@link MathUtil.MAX_SAFE_INTEGER} \n     * \n     * @param {!TemporalField} field\n     * @returns {*}\n     */\n    getLong(field) {\n        assert(field != null, '', NullPointerException);\n        if (field instanceof ChronoField) {\n            return this._get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * TODO tests are missing for the ALIGNED_* ChronoFields\n     * \n     * @param {!TemporalField} field\n     * @returns {*}\n     * @private\n     */\n    _get0(field) {\n        switch (field) {\n            case ChronoField.DAY_OF_WEEK: return this.dayOfWeek().value();\n            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH: return MathUtil.intMod((this._day - 1), 7) + 1;\n            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR: return MathUtil.intMod((this.dayOfYear() - 1), 7) + 1;\n            case ChronoField.DAY_OF_MONTH: return this._day;\n            case ChronoField.DAY_OF_YEAR: return this.dayOfYear();\n            case ChronoField.EPOCH_DAY: return this.toEpochDay();\n            case ChronoField.ALIGNED_WEEK_OF_MONTH: return MathUtil.intDiv((this._day - 1), 7) + 1;\n            case ChronoField.ALIGNED_WEEK_OF_YEAR: return MathUtil.intDiv((this.dayOfYear() - 1), 7) + 1;\n            case ChronoField.MONTH_OF_YEAR: return this._month;\n            case ChronoField.PROLEPTIC_MONTH: return this._prolepticMonth();\n            case ChronoField.YEAR_OF_ERA: return (this._year >= 1 ? this._year : 1 - this._year);\n            case ChronoField.YEAR: return this._year;\n            case ChronoField.ERA: return (this._year >= 1 ? 1 : 0);\n        }\n        throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    /**\n     * \n     * @return {number}\n     * @private\n     */\n    _prolepticMonth() {\n        return (this._year * 12) + (this._month - 1);\n    }\n\n    /**\n     * Gets the chronology of this date, which is the ISO calendar system.\n     * <p>\n     * The {@link Chronology} represents the calendar system in use.\n     * The ISO-8601 calendar system is the modern civil calendar system used today\n     * in most of the world. It is equivalent to the proleptic Gregorian calendar\n     * system, in which todays's rules for leap years are applied for all time.\n     *\n     * @return {Chronology} the ISO chronology, not null\n     */\n    chronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     *\n     * @return {number} gets the year\n     */\n    year() {\n        return this._year;\n    }\n\n    /**\n     *\n     * @return {number} gets the month value\n     */\n    monthValue() {\n        return this._month;\n    }\n\n    /**\n     *\n     * @returns {Month} month\n     */\n    month() {\n        return Month.of(this._month);\n    }\n\n    /**\n     *\n     * @return {number} gets the day of month\n     */\n    dayOfMonth() {\n        return this._day;\n    }\n\n    /**\n      * Gets the day-of-year field.\n      * <p>\n      * This method returns the primitive int value for the day-of-year.\n      *\n      * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n      */\n    dayOfYear() {\n        return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n     * <p>\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@link int} values mean.\n     * If you need access to the primitive {@link int} value then the enum\n     * provides the {@link DayOfWeek.value} int value.\n     * <p>\n     * Additional information can be obtained from the {@link DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    }\n\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     * <p>\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     * <p>\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     * <p>\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    isLeapYear() {\n        return IsoChronology.isLeapYear(this._year);\n    }\n\n    /**\n     * Returns the length of the month represented by this date.\n     * <p>\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return {number} the length of the month in days\n     */\n    lengthOfMonth() {\n        switch (this._month) {\n            case 2:\n                return (this.isLeapYear() ? 29 : 28);\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns the length of the year represented by this date.\n     * <p>\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return {number} 366 if the year is leap, 365 otherwise\n     */\n    lengthOfYear() {\n        return (this.isLeapYear() ? 366 : 365);\n    }\n\n    /**\n     * function overloading for the {@link LocalDate.with} method.\n     *\n     * calling \"with\" with one (or less) argument, assumes that the argument is an TemporalAdjuster \n     * and {@link LocalDate.withTemporalAdjuster} is called.\n     * \n     * Otherwise a TemporalField and {@link Number} newValue argument is expected and \n     * {@link LocalDate.withFieldAndValue} is called.\n     *\n     * @param {!(TemporalAdjuster|TemporalField)} fieldOrAdjuster\n     * @param {number} newValue - required if first argument is a TemporalField\n     * @return {LocalDate} the new LocalDate with the newValue set.\n     */\n    with(fieldOrAdjuster, newValue){\n        if(arguments.length < 2){\n            return this.withTemporalAdjuster(fieldOrAdjuster);\n        } else {\n            return this.withFieldAndValue(fieldOrAdjuster, newValue);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this date.\n     * <p>\n     * This returns a new {@link LocalDate}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * <p>\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@link TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * <p>\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = localDate.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster.adjustInto} method on the\n     * specified adjuster passing {@link this} as the argument.\n     *\n     * @param {!TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {LocalDate} a {@link LocalDate} based on {@link this} with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return adjuster;\n        }\n        assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     * <p>\n     * This returns a new {@link LocalDate}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * <p>\n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * <p>\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * <ul>\n     * <li>{@link DAY_OF_WEEK} -\n     *  Returns a {@link LocalDate} with the specified day-of-week.\n     *  The date is adjusted up to 6 days forward or backward within the boundary\n     *  of a Monday to Sunday week.\n     * <li>{@link ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n     *  Returns a {@link LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified month-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This may cause the date to be moved up to 6 days into the following month.\n     * <li>{@link ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n     *  Returns a {@link LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified year-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This may cause the date to be moved up to 6 days into the following year.\n     * <li>{@link DAY_OF_MONTH} -\n     *  Returns a {@link LocalDate} with the specified day-of-month.\n     *  The month and year will be unchanged. If the day-of-month is invalid for the\n     *  year and month, then a {@link DateTimeException} is thrown.\n     * <li>{@link DAY_OF_YEAR} -\n     *  Returns a {@link LocalDate} with the specified day-of-year.\n     *  The year will be unchanged. If the day-of-year is invalid for the\n     *  year, then a {@link DateTimeException} is thrown.\n     * <li>{@link EPOCH_DAY} -\n     *  Returns a {@link LocalDate} with the specified epoch-day.\n     *  This completely replaces the date and is equivalent to {@link #ofEpochDay(long)}.\n     * <li>{@link ALIGNED_WEEK_OF_MONTH} -\n     *  Returns a {@link LocalDate} with the specified aligned-week-of-month.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following month.\n     * <li>{@link ALIGNED_WEEK_OF_YEAR} -\n     *  Returns a {@link LocalDate} with the specified aligned-week-of-year.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following year.\n     * <li>{@link MONTH_OF_YEAR} -\n     *  Returns a {@link LocalDate} with the specified month-of-year.\n     *  The year will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * <li>{@link PROLEPTIC_MONTH} -\n     *  Returns a {@link LocalDate} with the specified proleptic-month.\n     *  The day-of-month will be unchanged, unless it would be invalid for the new month\n     *  and year. In that case, the day-of-month is adjusted to the maximum valid value\n     *  for the new month and year.\n     * <li>{@link YEAR_OF_ERA} -\n     *  Returns a {@link LocalDate} with the specified year-of-era.\n     *  The era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * <li>{@link YEAR} -\n     *  Returns a {@link LocalDate} with the specified year.\n     *  The month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * <li>{@link ERA} -\n     *  Returns a {@link LocalDate} with the specified era.\n     *  The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * </ul>\n     * <p>\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     * <p>\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     * <p>\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto(Temporal, long)}\n     * passing {@link this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalDate} a {@link LocalDate} based on {@link this} with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withFieldAndValue(field, newValue) {\n        assert(field != null, 'field', NullPointerException);\n        if (field instanceof ChronoField) {\n            var f = field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case ChronoField.DAY_OF_WEEK: return this.plusDays(newValue - this.dayOfWeek().value());\n                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH: return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR: return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case ChronoField.DAY_OF_MONTH: return this.withDayOfMonth(newValue);\n                case ChronoField.DAY_OF_YEAR: return this.withDayOfYear(newValue);\n                case ChronoField.EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n                case ChronoField.ALIGNED_WEEK_OF_MONTH: return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));\n                case ChronoField.ALIGNED_WEEK_OF_YEAR: return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                case ChronoField.MONTH_OF_YEAR: return this.withMonth(newValue);\n                case ChronoField.PROLEPTIC_MONTH: return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n                case ChronoField.YEAR_OF_ERA: return this.withYear((this._year >= 1 ? newValue : 1 - newValue));\n                case ChronoField.YEAR: return this.withYear(newValue);\n                case ChronoField.ERA: return (this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    /**\n     * Returns a copy of this date with the year altered.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * @param {!number} year  the year to set in the result, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested year, not null\n     * @throws {DateTimeException} if the year value is invalid\n     */\n    withYear(year) {\n        if (this._year === year) {\n            return this;\n        }\n        ChronoField.YEAR.checkValidValue(year);\n        return LocalDate._resolvePreviousValid(year, this._month, this._day);\n    }\n\n    /**\n     * Returns a copy of this date with the month-of-year altered.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * @param {!(Month|number)} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested month, not null\n     * @throws {DateTimeException} if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        var m = (month instanceof Month) ? month.value() : month;\n        if (this._month === m) {\n            return this;\n        }\n        ChronoField.MONTH_OF_YEAR.checkValidValue(m);\n        return LocalDate._resolvePreviousValid(this._year, m, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the day-of-month altered.\n     * <p>\n     * If the resulting date is invalid, an exception is thrown.\n     *\n     * @param {!number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {LocalDate} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        if (this._day === dayOfMonth) {\n            return this;\n        }\n        return LocalDate.of(this._year, this._month, dayOfMonth);\n    }\n\n    /**\n     * Returns a copy of this date with the day-of-year altered.\n     * If the resulting date is invalid, an exception is thrown.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-year value is invalid\n     * @throws {DateTimeException} if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        if (this.dayOfYear() === dayOfYear) {\n            return this;\n        }\n        return LocalDate.ofYearDay(this._year, dayOfYear);\n    }\n\n    /**\n     * function overloading for plus\n     *\n     * called with 1 (or less) arguments, p1 is expected to be a TemporalAmount and {@link LocalDate.plus1} \n     * is called.\n     * \n     * Otherwise {@link LocalDate.plus2} is called.\n     * \n     * @param {!(TemporalAmount|number)} p1\n     * @param {TemporalUnit} p2 - required if called with 2 arguments\n     * @return {LocalDate}\n     */\n    plus(p1, p2){\n        if(arguments.length < 2){\n            return this.plus1(p1);\n        } else {\n            return this.plus2(p1, p2);\n        }\n    }\n\n    /**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * This method returns a new date based on this date with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link LocalDate.plus2}.\n     *\n     * @param {!TemporalAmount} amount - the amount to add, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the addition made, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    plus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified period added.\n     * <p>\n     * This method returns a new date based on this date with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * @param {!number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {!TemporalUnit} unit - the unit of the period to add, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.DAYS: return this.plusDays(amountToAdd);\n                case ChronoUnit.WEEKS: return this.plusWeeks(amountToAdd);\n                case ChronoUnit.MONTHS: return this.plusMonths(amountToAdd);\n                case ChronoUnit.YEARS: return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS: return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in years added.\n     * <p>\n     * This method adds the specified amount to the years field in three steps:\n     * <ol>\n     * <li>Add the input years to the year field</li>\n     * <li>Check if the resulting date would be invalid</li>\n     * <li>Adjust the day-of-month to the last valid day if necessary</li>\n     * </ol>\n     * <p>\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     *\n     * @param {!number} yearsToAdd - the years to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the years added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);  // safe overflow\n        return LocalDate._resolvePreviousValid(newYear, this._month, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in months added.\n     * <p>\n     * This method adds the specified amount to the months field in three steps:\n     * <ol>\n     * <li>Add the input months to the month-of-year field</li>\n     * <li>Check if the resulting date would be invalid</li>\n     * <li>Adjust the day-of-month to the last valid day if necessary</li>\n     * </ol>\n     * <p>\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     *\n     * @param {number} monthsToAdd - the months to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the months added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        var monthCount = this._year * 12 + (this._month - 1);\n        var calcMonths = monthCount + monthsToAdd;  // safe overflow\n        var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n        var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n        return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in weeks added.\n     * <p>\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * <p>\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     *\n     * @param {!number} weeksToAdd - the weeks to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the weeks added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusWeeks(weeksToAdd) {\n        return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));\n    }\n\n\n    /**\n     * Returns a copy of this LocalDate with the specified number of days added.\n     * \n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     *\n     * @param {number} daysToAdd - the days to add, may be negative\n     * @return {LocalDate} a LocalDate based on this date with the days added, not null\n     * @throws AssertionError if the result exceeds the supported date range\n     */\n    plusDays(daysToAdd) {\n        if (daysToAdd === 0) {\n            return this;\n        }\n        var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    }\n\n    /**\n      * function overloading for minus\n      *\n      * called with 1 (or less) arguments, p1 is expected to be a TemporalAmount and {@link LocalDate.minus1} \n      * is called.\n      * \n      * Otherwise {@link LocalDate.minus2} is called.\n      * \n      * @param {!(TemporalAmount|number)} p1\n      * @param {TemporalUnit} p2 - required if called with 2 arguments\n      * @return {LocalDate}\n      */\n    minus(p1, p2){\n        if(arguments.length < 2){\n            return this.minus1(p1);\n        } else {\n            return this.minus2(p1, p2);\n        }\n    }\n\n    /**\n     * Returns a copy of this date with the specified period subtracted.\n     * <p>\n     * This method returns a new date based on this date with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link #minus(long, TemporalUnit)}.\n     *\n     * @param {!TemporalAmount} amount - the amount to subtract, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the subtraction made, not null\n     * @throws {DateTimeException} if the subtraction cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    minus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified period subtracted.\n     * <p>\n     * This method returns a new date based on this date with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * @param {!number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {!TemporalUnit} unit  the unit of the period to subtract, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in years subtracted.\n     * <p>\n     * This method subtracts the specified amount from the years field in three steps:\n     * <ol>\n     * <li>Subtract the input years to the year field</li>\n     * <li>Check if the resulting date would be invalid</li>\n     * <li>Adjust the day-of-month to the last valid day if necessary</li>\n     * </ol>\n     * <p>\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     *\n     * @param {!number} yearsToSubtract - the years to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the years subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusYears(yearsToSubtract) {\n        return this.plusYears(yearsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in months subtracted.\n     * <p>\n     * This method subtracts the specified amount from the months field in three steps:\n     * <ol>\n     * <li>Subtract the input months to the month-of-year field</li>\n     * <li>Check if the resulting date would be invalid</li>\n     * <li>Adjust the day-of-month to the last valid day if necessary</li>\n     * </ol>\n     * <p>\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     *\n     * @param {!number} monthsToSubtract - the months to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the months subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMonths(monthsToSubtract) {\n        return this.plusMonths(monthsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in weeks subtracted.\n     * <p>\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * <p>\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     *\n     * @param {!number} weeksToSubtract - the weeks to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the weeks subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusWeeks(weeksToSubtract) {\n        return this.plusWeeks(weeksToSubtract * -1);\n    }\n\n    /*\n     * Returns a copy of this LocalDate with the specified number of days subtracted.\n     * \n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     *\n     * @param {number} daysToSubtract - the days to subtract, may be negative\n     * @return {LocalDate} a LocalDate based on this date with the days subtracted, not null\n     * @throws AssertionError if the result exceeds the supported date range\n     */\n    minusDays(daysToSubtract) {\n        return this.plusDays(daysToSubtract * -1);\n    }\n\n    /**\n     * Queries this date using the specified query.\n     *\n     * This queries this date using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@link this} as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.localDate()) {\n            return this;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date as this object.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     * <p>\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField.EPOCH_DAY} as the field.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalDate.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalDate);\n     * </pre>\n     *\n     * @param {!TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return super.adjustInto(temporal);\n    }\n\n    /**\n     * function overloading for {@link LocalDate.until}\n     * \n     * called with 1 (or less) arguments {{@link LocalDate.until1}} is called\n     * otherwise {@link LocalDate.until2}\n     * \n     * @param {!TemporalAccessor} p1\n     * @param {TemporalUnit} p2 - not null if called with 2 arguments\n     * @return {number|Period}\n     */\n    until(p1, p2){\n        if(arguments.length < 2){\n            return this.until1(p1);\n        } else {\n            return this.until2(p1, p2);\n        }\n    }\n\n    /**\n     * Calculates the period between this date and another date in\n     * terms of the specified unit.\n     * <p>\n     * This calculates the period between two dates in terms of a single unit.\n     * The start and end points are {@link this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalDate}.\n     * For example, the period in days between two dates can be calculated\n     * using {@link startDate.until(endDate, DAYS)}.\n     * <p>\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the period in months between 2012-06-15 and 2012-08-14\n     * will only be one month as it is one day short of two months.\n     * <p>\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a {@link long} representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     * <p>\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link DAYS}, {@link WEEKS}, {@link MONTHS}, {@link YEARS},\n     * {@link DECADES}, {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS}\n     * are supported. Other {@link ChronoUnit} values will throw an exception.\n     * <p>\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between(Temporal, Temporal)}\n     * passing {@link this} as the first argument and the input temporal as\n     * the second argument.\n     *\n     * @param {!TemporalAccessor} endExclusive - the end date, which is converted to a {@link LocalDate}, not null\n     * @param {!TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date and the end date\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until2(endExclusive, unit) {\n        var end = LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.DAYS: return this.daysUntil(end);\n                case ChronoUnit.WEEKS: return MathUtil.intDiv(this.daysUntil(end), 7);\n                case ChronoUnit.MONTHS: return this._monthsUntil(end);\n                case ChronoUnit.YEARS: return MathUtil.intDiv(this._monthsUntil(end), 12);\n                case ChronoUnit.DECADES: return MathUtil.intDiv(this._monthsUntil(end), 120);\n                case ChronoUnit.CENTURIES: return MathUtil.intDiv(this._monthsUntil(end), 1200);\n                case ChronoUnit.MILLENNIA: return MathUtil.intDiv(this._monthsUntil(end), 12000);\n                case ChronoUnit.ERAS: return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * \n     * @param {!LocalDate} end\n     * @returns {number}\n     * @protected\n     */\n    daysUntil(end) {\n        return end.toEpochDay() - this.toEpochDay();  // no overflow\n    }\n\n    /**\n     * \n     * @param {!LocalDate} end\n     * @returns {number}\n     * @private\n     */\n    _monthsUntil(end) {\n        var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();  // no overflow\n        var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();  // no overflow\n        return MathUtil.intDiv((packed2 - packed1), 32);\n    }\n\n    /**\n     * Calculates the period between this date and another date as a {@link Period}.\n     * <p>\n     * This calculates the period between two dates in terms of years, months and days.\n     * The start and end points are {@link this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * <p>\n     * The calculation is performed using the ISO calendar system.\n     * If necessary, the input date will be converted to ISO.\n     * <p>\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then normalized into years and months based on a 12 month year.\n     * A month is considered to be complete if the end day-of-month is greater\n     * than or equal to the start day-of-month.\n     * For example, from {@link 2010-01-15} to {@link 2011-03-18} is \"1 year, 2 months and 3 days\".\n     * <p>\n     * The result of this method can be a negative period if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     * <p>\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link Period#between(LocalDate, LocalDate)}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   period = start.until(end);\n     *   period = Period.between(start, end);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     *\n     * @param {!TemporalAccessor} endDate - the end date, exclusive, which may be in any chronology, not null\n     * @return {Period} the period between this date and the end date, not null\n     */\n    until1(endDate) {\n        var end = LocalDate.from(endDate);\n        var totalMonths = end._prolepticMonth() - this._prolepticMonth();  // safe\n        var days = end._day - this._day;\n        if (totalMonths > 0 && days < 0) {\n            totalMonths--;\n            var calcDate = this.plusMonths(totalMonths);\n            days = (end.toEpochDay() - calcDate.toEpochDay());  // safe\n        } else if (totalMonths < 0 && days > 0) {\n            totalMonths++;\n            days -= end.lengthOfMonth();\n        }\n        var years = MathUtil.intDiv(totalMonths, 12);  // safe\n        var months = MathUtil.intMod(totalMonths, 12);  // safe\n        return Period.of(MathUtil.safeToInt(years), months, days);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDate.atTime} \n     * \n     * if called with 1 argument {@link LocalDate.atTime1} is called\n     * otherwise {@link LocalDate.atTime4}\n     * \n     * @return {LocalDateTime} the local date-time formed from this date and the specified params\n     */\n    atTime(){\n        if(arguments.length===1){\n            return this.atTime1.apply(this, arguments);\n        } else {\n            return this.atTime4.apply(this, arguments);\n        }\n    }\n    \n    /**\n     * Combines this date with a time to create a {@link LocalDateTime}.\n     * <p>\n     * This returns a {@link LocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {LocalTime} time - the time to combine with, not null\n     * @return {LocalDateTime} the local date-time formed from this date and the specified time, not null\n     */\n    atTime1(time) {\n        return LocalDateTime.of(this, time);\n    }\n\n    /**\n     * Combines this date with a time to create a {@link LocalDateTime}.\n     * <p>\n     * This returns a {@link LocalDateTime} formed from this date at the\n     * specified hour, minute, second and nanosecond.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {!number} hour - the hour-of-day to use, from 0 to 23\n     * @param {!number} minute - the minute-of-hour to use, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalDateTime} the local date-time formed from this date and the specified time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     */\n    atTime4(hour, minute, second=0, nanoOfSecond=0) {\n        return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));\n    }\n\n    /**\n     * Combines this date with an offset time to create an {@link OffsetDateTime}.\n     * <p>\n     * This returns an {@link OffsetDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {OffsetTime} time - the time to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this date and the specified time, not null\n     */\n/*\n    _atTimeOffsetTime(time) { // atTime(offsetTime)\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.getOffset());\n    }\n*/\n\n    /**\n     * Combines this date with the time of midnight to create a {@link LocalDateTime}\n     * at the start of this date.\n     * <p>\n     * This returns a {@link LocalDateTime} formed from this date at the time of\n     * midnight, 00:00, at the start of this date.\n     *\n     * @param {ZoneId} zone - if zone is not null @see {@link LocalDate.atStartOfDayWithZone}\n     * @return {LocalDateTime|ZonedDateTime} the local date-time of midnight at the start of this date, not null\n     */\n    atStartOfDay(zone) {\n        if(zone != null){\n            return this.atStartOfDayWithZone(zone);\n        } else {\n            return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n        }\n    }\n\n    /**\n     * Combines this date with a time-zone to create a {@link ZonedDateTime}\n     * at the start of the day\n     * <p>\n     * This returns a {@link ZonedDateTime} formed from this date at the\n     * specified zone, with the time set to be the earliest valid time according\n     * to the rules in the time-zone.\n     * <p>\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     * <p>\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     * <p>\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     * <p>\n     * To convert to a specific time in a given time-zone call {@link #atTime(LocalTime)}\n     * followed by {@link LocalDateTime#atZone(ZoneId)}.\n     *\n     * @param {!ZoneId} zone - the zone ID to use, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    atStartOfDayWithZone(zone) { \n        requireNonNull(zone, 'zone');\n        var ldt = this.atTime(LocalTime.MIDNIGHT);\n/*      TODO iana tzdb\n        // need to handle case where there is a gap from 11:30 to 00:30\n        // standard ZDT factory would result in 01:00 rather than 00:30\n        if (zone instanceof ZoneOffset === false) {\n            var rules = zone.getRules();\n            var trans = rules.getTransition(ldt);\n            if (trans != null && trans.isGap()) {\n                ldt = trans.getDateTimeAfter();\n            }\n        }\n*/\n        return ZonedDateTime.of(ldt, zone);\n    }\n\n\n    /**\n     * Converts this date to the Epoch Day.\n     *\n     * The Epoch Day count is a simple incrementing count of days where day 0 is 1970-01-01 (ISO).\n     * This definition is the same for all chronologies, enabling conversion.\n     *\n     * @return {number} the Epoch Day equivalent to this date\n     */\n    toEpochDay() {\n        var y = this.year();\n        var m = this.monthValue();\n        var total = 0;\n        total += 365 * y;\n        if (y >= 0) {\n            total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);\n        } else {\n            total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);\n        }\n        total += MathUtil.intDiv(367 * m - 362, 12);\n        total += this.dayOfMonth() - 1;\n        if (m > 2) {\n            total--;\n            if (!IsoChronology.isLeapYear(y)) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    }\n\n    /**\n     * Compares this date to another date.\n     * <p>\n     * The comparison is primarily based on the date, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * <p>\n     * If all the dates being compared are instances of {@link LocalDate},\n     * then the comparison will be entirely based on the date.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDate.compareTo}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalDate, 'other');\n        if (other instanceof LocalDate) {\n            return this._compareTo0(other);\n        }\n        // super.compareTo(other);\n    }\n\n    /**\n     *\n     * @param {!LocalDate} otherDate\n     * @returns {number}\n     * @private\n     */\n    _compareTo0(otherDate) {\n        var cmp = (this._year - otherDate._year);\n        if (cmp === 0) {\n            cmp = (this._month - otherDate._month);\n            if (cmp === 0) {\n                cmp = (this._day - otherDate._day);\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date is after the specified date.\n     * <p>\n     * This checks to see if this date represents a point on the\n     * local time-line after the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isAfter(b) == false\n     *   a.isAfter(a) == false\n     *   b.isAfter(a) == true\n     * </pre>\n     * <p>\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link #DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is after the specified date\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n        // return super.isAfter(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is before the specified date.\n     * <p>\n     * This checks to see if this date represents a point on the\n     * local time-line before the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isBefore(b) == true\n     *   a.isBefore(a) == false\n     *   b.isBefore(a) == false\n     * </pre>\n     * <p>\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link #DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is before the specified date\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n        // return super.isBefore(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is equal to the specified date.\n     * <p>\n     * This checks to see if this date represents the same point on the\n     * local time-line as the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isEqual(b) == false\n     *   a.isEqual(a) == true\n     *   b.isEqual(a) == false\n     * </pre>\n     * <p>\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)}\n     * but is the same approach as {@link #DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is equal to the specified date\n     */\n    isEqual(other) {\n        return this.compareTo(other) === 0;\n        // return super.isEqual(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is equal to another date.\n     *\n     * Compares this LocalDate with another ensuring that the date is the same.\n     *\n     * Only objects of type LocalDate are compared, other types return false.\n     *\n     * @param {*} otherDate - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date\n     */\n    equals(otherDate) {\n        if (this === otherDate) {\n            return true;\n        }\n        if (otherDate instanceof LocalDate) {\n            return this._compareTo0(otherDate) === 0;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        var yearValue = this._year;\n        var monthValue = this._month;\n        var dayValue = this._day;\n        return (yearValue & 0xFFFFF800) ^ ((yearValue << 11) + (monthValue << 6) + (dayValue));\n    }\n\n    /**\n     * Outputs this date as a String, such as 2007-12-03.\n     * The output will be in the ISO-8601 format uuuu-MM-dd.\n     *\n     * @return {string} a string representation of this date, not null\n     */\n    toString() {\n        var dayString, monthString, yearString;\n\n        var yearValue = this.year();\n        var monthValue = this.monthValue();\n        var dayValue = this.dayOfMonth();\n\n        var absYear = Math.abs(yearValue);\n\n        if (absYear < 1000) {\n            if (yearValue < 0) {\n                yearString = '-' + ('' + (yearValue - 10000)).slice(-4);\n            } else {\n                yearString = ('' + (yearValue + 10000)).slice(-4);\n            }\n        } else {\n            if (yearValue > 9999) {\n                yearString = '+' + yearValue;\n            } else {\n                yearString = '' + yearValue;\n            }\n        }\n\n        if (monthValue < 10) {\n            monthString = '-0' + monthValue;\n        } else {\n            monthString = '-' + monthValue;\n        }\n\n        if (dayValue < 10) {\n            dayString = '-0' + dayValue;\n        } else {\n            dayString = '-' + dayValue;\n        }\n\n        return yearString + monthString + dayString;\n    }\n}\n\nexport function _init() {\n    /**\n     * The minimum supported {@link LocalDate}\n     * This could be used by an application as a \"far past\" date.\n     */\n    LocalDate.MIN = LocalDate.of(Year.MIN_VALUE, 1, 1);\n    /**\n     * The maximum supported {@link LocalDate}\n     * This could be used by an application as a \"far future\" date.\n     */\n    LocalDate.MAX = LocalDate.of(Year.MAX_VALUE, 12, 31);\n    /**\n     * The date at epoch day 0, that is 1970-01-01.\n     */\n    LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);\n\n    LocalDate.FROM = createTemporalQuery('LocalDate.FROM', (temporal) => {\n        return LocalDate.from(temporal);\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/LocalDate.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {Enum} from '../Enum';\n\nimport {LocalDate} from '../LocalDate';\nimport {Month} from '../Month';\nimport {Year} from '../Year';\n\nimport {ChronoField} from '../temporal/ChronoField';\nimport {ResolverStyle} from '../format/ResolverStyle';\n\nexport class IsoChronology extends Enum{\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @param {number} prolepticYear - the ISO proleptic year to check\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    static isLeapYear(prolepticYear) {\n        return ((prolepticYear & 3) === 0) && ((prolepticYear % 100) !== 0 || (prolepticYear % 400) === 0);\n    }\n\n    resolveDate(fieldValues, resolverStyle) {\n        if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n            return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));\n        }\n\n        // normalize fields\n/*\n        var prolepticMonth = fieldValues.remove(PROLEPTIC_MONTH);\n        if (prolepticMonth != null) {\n            if (resolverStyle != ResolverStyle.LENIENT) {\n                PROLEPTIC_MONTH.checkValidValue(prolepticMonth);\n            }\n            updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, Jdk8Methods.floorMod(prolepticMonth, 12) + 1);\n            updateResolveMap(fieldValues, ChronoField.YEAR, Jdk8Methods.floorDiv(prolepticMonth, 12));\n        }\n*/\n\n        // eras\n/*\n        Long yoeLong = fieldValues.remove(YEAR_OF_ERA);\n        if (yoeLong != null) {\n            if (resolverStyle != ResolverStyle.LENIENT) {\n                YEAR_OF_ERA.checkValidValue(yoeLong);\n            }\n            Long era = fieldValues.remove(ERA);\n            if (era == null) {\n                Long year = fieldValues.get(ChronoField.YEAR);\n                if (resolverStyle == ResolverStyle.STRICT) {\n                    // do not invent era if strict, but do cross-check with year\n                    if (year != null) {\n                        updateResolveMap(fieldValues, ChronoField.YEAR, (year > 0 ? yoeLong: Jdk8Methods.safeSubtract(1, yoeLong)));\n                    } else {\n                        // reinstate the field removed earlier, no cross-check issues\n                        fieldValues.put(YEAR_OF_ERA, yoeLong);\n                    }\n                } else {\n                    // invent era\n                    updateResolveMap(fieldValues, ChronoField.YEAR, (year == null || year > 0 ? yoeLong: Jdk8Methods.safeSubtract(1, yoeLong)));\n                }\n            } else if (era.longValue() == 1L) {\n                updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);\n            } else if (era.longValue() == 0L) {\n                updateResolveMap(fieldValues, ChronoField.YEAR, Jdk8Methods.safeSubtract(1, yoeLong));\n            } else {\n                throw new DateTimeException(\"Invalid value for era: \" + era);\n            }\n        } else if (fieldValues.containsKey(ERA)) {\n            ERA.checkValidValue(fieldValues.get(ERA));  // always validated\n        }\n*/\n\n        // build date\n        if (fieldValues.containsKey(ChronoField.YEAR)) {\n            if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {\n                if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {\n                    var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);\n                    var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        var months = moy - 1;\n                        var days = dom - 1;\n                        return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);\n                    } else if (resolverStyle === ResolverStyle.SMART){\n                        ChronoField.DAY_OF_MONTH.checkValidValue(dom);\n                        if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {\n                            dom = Math.min(dom, 30);\n                        } else if (moy === 2) {\n                            dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));\n                        }\n                        return LocalDate.of(y, moy, dom);\n                    } else {\n                        return LocalDate.of(y, moy, dom);\n                    }\n                }\n/*\n                if (fieldValues.containsKey(ALIGNED_WEEK_OF_MONTH)) {\n                    if (fieldValues.containsKey(ALIGNED_DAY_OF_WEEK_IN_MONTH)) {\n                        int y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                        if (resolverStyle == ResolverStyle.LENIENT) {\n                            long months = Jdk8Methods.safeSubtract(fieldValues.remove(ChronoField.MONTH_OF_YEAR), 1);\n                            long weeks = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);\n                            long days = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH), 1);\n                            return LocalDate.of(y, 1, 1).plusMonths(months).plusWeeks(weeks).plusDays(days);\n                        }\n                        int moy = ChronoField.MONTH_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.MONTH_OF_YEAR));\n                        int aw = ALIGNED_WEEK_OF_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH));\n                        int ad = ALIGNED_DAY_OF_WEEK_IN_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                        LocalDate date = LocalDate.of(y, moy, 1).plusDays((aw - 1) * 7 + (ad - 1));\n                        if (resolverStyle == ResolverStyle.STRICT && date.get(ChronoField.MONTH_OF_YEAR) != moy) {\n                            throw new DateTimeException(\"Strict mode rejected date parsed to a different month\");\n                        }\n                        return date;\n                    }\n                    if (fieldValues.containsKey(DAY_OF_WEEK)) {\n                        int y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                        if (resolverStyle == ResolverStyle.LENIENT) {\n                            long months = Jdk8Methods.safeSubtract(fieldValues.remove(ChronoField.MONTH_OF_YEAR), 1);\n                            long weeks = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);\n                            long days = Jdk8Methods.safeSubtract(fieldValues.remove(DAY_OF_WEEK), 1);\n                            return LocalDate.of(y, 1, 1).plusMonths(months).plusWeeks(weeks).plusDays(days);\n                        }\n                        int moy = ChronoField.MONTH_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.MONTH_OF_YEAR));\n                        int aw = ALIGNED_WEEK_OF_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH));\n                        int dow = DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(DAY_OF_WEEK));\n                        LocalDate date = LocalDate.of(y, moy, 1).plusWeeks(aw - 1).with(nextOrSame(DayOfWeek.of(dow)));\n                        if (resolverStyle == ResolverStyle.STRICT && date.get(ChronoField.MONTH_OF_YEAR) != moy) {\n                            throw new DateTimeException(\"Strict mode rejected date parsed to a different month\");\n                        }\n                        return date;\n                    }\n                }\n*/\n            }\n/*\n            if (fieldValues.containsKey(DAY_OF_YEAR)) {\n                int y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                if (resolverStyle == ResolverStyle.LENIENT) {\n                    long days = Jdk8Methods.safeSubtract(fieldValues.remove(DAY_OF_YEAR), 1);\n                    return LocalDate.ofYearDay(y, 1).plusDays(days);\n                }\n                int doy = DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(DAY_OF_YEAR));\n                return LocalDate.ofYearDay(y, doy);\n            }\n*/\n/*\n            if (fieldValues.containsKey(ALIGNED_WEEK_OF_YEAR)) {\n                if (fieldValues.containsKey(ALIGNED_DAY_OF_WEEK_IN_YEAR)) {\n                    int y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    if (resolverStyle == ResolverStyle.LENIENT) {\n                        long weeks = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_WEEK_OF_YEAR), 1);\n                        long days = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);\n                        return LocalDate.of(y, 1, 1).plusWeeks(weeks).plusDays(days);\n                    }\n                    int aw = ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_YEAR));\n                    int ad = ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                    LocalDate date = LocalDate.of(y, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));\n                    if (resolverStyle == ResolverStyle.STRICT && date.get(ChronoField.YEAR) != y) {\n                        throw new DateTimeException(\"Strict mode rejected date parsed to a different year\");\n                    }\n                    return date;\n                }\n                if (fieldValues.containsKey(DAY_OF_WEEK)) {\n                    int y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    if (resolverStyle == ResolverStyle.LENIENT) {\n                        long weeks = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_WEEK_OF_YEAR), 1);\n                        long days = Jdk8Methods.safeSubtract(fieldValues.remove(DAY_OF_WEEK), 1);\n                        return LocalDate.of(y, 1, 1).plusWeeks(weeks).plusDays(days);\n                    }\n                    int aw = ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_YEAR));\n                    int dow = DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(DAY_OF_WEEK));\n                    LocalDate date = LocalDate.of(y, 1, 1).plusWeeks(aw - 1).with(nextOrSame(DayOfWeek.of(dow)));\n                    if (resolverStyle == ResolverStyle.STRICT && date.get(ChronoField.YEAR) != y) {\n                        throw new DateTimeException(\"Strict mode rejected date parsed to a different month\");\n                    }\n                    return date;\n                }\n            }\n*/\n        }\n        return null;\n    }\n\n}\n\nexport function _init() {\n    IsoChronology.INSTANCE = new IsoChronology('IsoChronology');\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/chrono/IsoChronology.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n/***\n * Base class for a pseudo enum\n */\nexport class Enum {\n    constructor(name){\n        this._name = name;\n    }\n\n    equals(other){\n        return this === other;\n    }\n\n    toString() {\n        return this._name;\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Enum.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert} from './assert';\nimport {MathUtil} from './MathUtil';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {DateTimeException, UnsupportedTemporalTypeException} from './errors';\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalQueries} from './temporal/TemporalQueries';\n\n/**\n * A month-of-year, such as 'July'.\n * <p>\n * {@link Month} is representing the 12 months of the year -\n * January, February, March, April, May, June, July, August, September, October,\n * November and December.\n * <p>\n * In addition to the textual name, each month-of-year has an {@code int} value.\n * The {@code int} value follows normal usage and the ISO-8601 standard,\n * from 1 (January) to 12 (December). It is recommended that applications use the static values defined by this class\n * rather than the {@code int} value to ensure code clarity.\n * <p>\n * This class represents a common concept that is found in many calendar systems.\n * As such, this class may be used by any calendar system that has the month-of-year\n * concept defined exactly equivalent to the ISO-8601 calendar system.\n *\n * <h3>Static properties of Class {@link Month}</h3>\n *\n * Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE,\n * Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER\n *\n */\nexport class Month extends Temporal {\n    \n    /**\n     *\n     * @param {number} value\n     */\n    constructor(value) {\n        super();\n        this._value = value;\n    }\n\n    /**\n     *\n     * @return {number} gets the value\n     */\n    value() {\n        return this._value;\n    }\n    \n    /**\n     * Checks if the specified field is supported.\n     * <p>\n     * This checks if this month-of-year can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range} and\n     * {@link #get(TemporalField) get} methods will throw an exception.\n     * <p>\n     * If the field is {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} then\n     * this method returns true.\n     * All other {@code ChronoField} instances will return false.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this month-of-year, false if not\n     */\n    isSupported(field) {\n        if (null === field) {\n            return false;\n        }\n        if (field instanceof ChronoField) {\n            return field === ChronoField.MONTH_OF_YEAR;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-of-year as an {@code int}.\n     * <p>\n     * This queries this month for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} then the\n     * value of the month-of-year, from 1 to 12, will be returned.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {Number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return this.value();\n        }\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-of-year as a {@code long}.\n     * <p>\n     * This queries this month for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} then the\n     * value of the month-of-year, from 1 to 12, will be returned.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {Number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return this.value();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n    \n    /**\n     * Returns the month-of-year that is the specified number of months after this one.\n     * <p>\n     * The calculation rolls around the end of the year from December to January.\n     * The specified period may be negative.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, positive or negative\n     * @return {Month} the resulting month, not null\n     */\n    plus(months) {\n        var amount = MathUtil.intMod(months, 12) + 12; // + 12 to make sure negative arguments are positive, the total is \"corrected\" by the next % 12\n        var newMonthVal = MathUtil.intMod((this.value() + amount), 12);\n        /* December is 12, not 0, but 12 % 12 = 0 */\n        newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;\n        return Month.of(newMonthVal);\n    }\n\n    /**\n     * Returns the month-of-year that is the specified number of months before this one.\n     * <p>\n     * The calculation rolls around the start of the year from January to December.\n     * The specified period may be negative.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, positive or negative\n     * @return {Month} the resulting month, not null\n     */\n    minus(months) {\n        return this.plus(-1 * MathUtil.intMod(months, 12));\n    }\n\n    /**\n     * Gets the length of this month in days.\n     * <p>\n     * This takes a flag to determine whether to return the length for a leap year or not.\n     * <p>\n     * February has 28 days in a standard year and 29 days in a leap year.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @param {boolean} leapYear - true if the length is required for a leap year\n     * @return {number} the length of this month in days, from 28 to 31\n     */\n    length(leapYear) {\n        switch (this) {\n            case Month.FEBRUARY:\n                return (leapYear ? 29 : 28);\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the minimum length of this month in days.\n     * <p>\n     * February has a minimum length of 28 days.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @return {number} the minimum length of this month in days, from 28 to 31\n     */\n    minLength() {\n        switch (this) {\n            case Month.FEBRUARY:\n                return 28;\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the maximum length of this month in days.\n     * <p>\n     * February has a maximum length of 29 days.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @return {number} the maximum length of this month in days, from 29 to 31\n     */\n    maxLength() {\n        switch (this) {\n            case Month.FEBRUARY:\n                return 29;\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the day-of-year corresponding to the first day of this month.\n     * <p>\n     * This returns the day-of-year that this month begins on, using the leap\n     * year flag to determine the length of February.\n     *\n     * @param {boolean} leapYear - true if the length is required for a leap year\n     * @return {number} the day of year corresponding to the first day of this month, from 1 to 336\n     */\n    firstDayOfYear(leapYear) {\n        var leap = leapYear ? 1 : 0;\n        switch (this) {\n            case Month.JANUARY:\n                return 1;\n            case Month.FEBRUARY:\n                return 32;\n            case Month.MARCH:\n                return 60 + leap;\n            case Month.APRIL:\n                return 91 + leap;\n            case Month.MAY:\n                return 121 + leap;\n            case Month.JUNE:\n                return 152 + leap;\n            case Month.JULY:\n                return 182 + leap;\n            case Month.AUGUST:\n                return 213 + leap;\n            case Month.SEPTEMBER:\n                return 244 + leap;\n            case Month.OCTOBER:\n                return 274 + leap;\n            case Month.NOVEMBER:\n                return 305 + leap;\n            case Month.DECEMBER:\n            default:\n                return 335 + leap;\n        }\n    }\n\n    /**\n     * Gets the month corresponding to the first month of this quarter.\n     * <p>\n     * The year can be divided into four quarters.\n     * This method returns the first month of the quarter for the base month.\n     * January, February and March return January.\n     * April, May and June return April.\n     * July, August and September return July.\n     * October, November and December return October.\n     *\n     * @return {Month} the first month of the quarter corresponding to this month, not null\n     */\n    firstMonthOfQuarter() {\n        switch (this) {\n            case Month.JANUARY:\n            case Month.FEBRUARY:\n            case Month.MARCH:\n                return Month.JANUARY;\n            case Month.APRIL:\n            case Month.MAY:\n            case Month.JUNE:\n                return Month.APRIL;\n            case Month.JULY:\n            case Month.AUGUST:\n            case Month.SEPTEMBER:\n                return Month.JULY;\n            case Month.OCTOBER:\n            case Month.NOVEMBER:\n            case Month.DECEMBER:\n            default:\n                return Month.OCTOBER;\n        }\n    }\n    \n    /**\n     * Queries this month-of-year using the specified query.\n     * <p>\n     * This queries this month-of-year using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        assert(query != null, 'query() parameter must not be null', DateTimeException);\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.MONTHS;\n        }\n        return super.query(query);\n    }\n\n\n\n    /**\n     * toString implementation... in JDK this is inherited from the Enum class\n     * \n     * @return {String}\n     */\n    toString() {\n        switch (this) {\n            case Month.JANUARY:\n                return 'JANUARY';\n            case Month.FEBRUARY:\n                return 'FEBRUARY';\n            case Month.MARCH:\n                return 'MARCH';\n            case Month.APRIL:\n                return 'APRIL';\n            case Month.MAY:\n                return 'MAY';\n            case Month.JUNE:\n                return 'JUNE';\n            case Month.JULY:\n                return 'JULY';\n            case Month.AUGUST:\n                return 'AUGUST';\n            case Month.SEPTEMBER:\n                return 'SEPTEMBER';\n            case Month.OCTOBER:\n                return 'OCTOBER';\n            case Month.NOVEMBER:\n                return 'NOVEMBER';\n            case Month.DECEMBER:\n                return 'DECEMBER';\n            default:\n                return 'unknown Month, value: ' + this.value();\n        }\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this month-of-year.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with the month-of-year changed to be the same as this.\n     * <p>\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField#MONTH_OF_YEAR} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@code DateTimeException} is thrown.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisMonth.adjustInto(temporal);\n     *   temporal = temporal.with(thisMonth);\n     * </pre>\n     * <p>\n     * For example, given a date in May, the following are output:\n     * <pre>\n     *   dateInMay.with(JANUARY);    // four months earlier\n     *   dateInMay.with(APRIL);      // one months earlier\n     *   dateInMay.with(MAY);        // same date\n     *   dateInMay.with(JUNE);       // one month later\n     *   dateInMay.with(DECEMBER);   // seven months later\n     * </pre>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        /* we support only ISO for now\n            if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) === false) {\n                throw new DateTimeException('Adjustment only supported on ISO date-time');\n            }\n        */\n        return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());\n    }\n    \n    /**\n     * replacement for enum values\n     * @return {Month[]}\n     */\n    static values(){\n        return MONTHS.slice();\n    }\n\n    /**\n     *\n     * @param {number} month\n     * @return {Month} not null\n     **/\n    static of(month) {\n        if (month < 1 || month > 12) {\n            assert(false, 'Invalid value for MonthOfYear: ' + month, DateTimeException);\n        }\n        return MONTHS[month-1];\n    }\n}\n\nvar MONTHS;\n\nexport function _init() {\n    Month.JANUARY = new Month(1);\n    Month.FEBRUARY = new Month(2);\n    Month.MARCH = new Month(3);\n    Month.APRIL = new Month(4);\n    Month.MAY = new Month(5);\n    Month.JUNE = new Month(6);\n    Month.JULY = new Month(7);\n    Month.AUGUST = new Month(8);\n    Month.SEPTEMBER = new Month(9);\n    Month.OCTOBER = new Month(10);\n    Month.NOVEMBER = new Month(11);\n    Month.DECEMBER = new Month(12);\n\n    MONTHS = [\n        Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE,\n        Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER\n    ];\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Month.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MAX_SAFE_INTEGER, MIN_SAFE_INTEGER} from '../MathUtil';\n\nimport {ChronoUnit} from './ChronoUnit';\nimport {TemporalField} from './TemporalField';\nimport {ValueRange} from './ValueRange';\nimport {Year} from '../Year';\n\n/**\n * A standard set of fields.\n * <p>\n * This set of fields provide field-based access to manipulate a date, time or date-time.\n * The standard set of fields can be extended by implementing {@link TemporalField}.\n * <p>\n * These fields are intended to be applicable in multiple calendar systems.\n * For example, most non-ISO calendar systems define dates as a year, month and day,\n * just with slightly different rules.\n * The documentation of each field explains how it operates.\n * \n * <h3>Static properties of Class {@link ChronoField}</h3>\n * \n * ChronoField.NANO_OF_SECOND\n *\n * ChronoField.NANO_OF_DAY\n *\n * ChronoField.MICRO_OF_SECOND\n *\n * ChronoField.MICRO_OF_DAY\n *\n * ChronoField.MILLI_OF_SECOND\n *\n * ChronoField.MILLI_OF_DAY\n *\n * ChronoField.SECOND_OF_MINUTE\n *\n * ChronoField.SECOND_OF_DAY\n *\n * ChronoField.MINUTE_OF_HOUR\n *\n * ChronoField.MINUTE_OF_DAY\n *\n * ChronoField.HOUR_OF_AMPM\n *\n * ChronoField.CLOCK_HOUR_OF_AMPM\n *\n * ChronoField.HOUR_OF_DAY\n *\n * ChronoField.CLOCK_HOUR_OF_DAY\n *\n * ChronoField.AMPM_OF_DAY\n *\n * ChronoField.DAY_OF_WEEK\n *\n * ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH\n *\n * ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR\n *\n * ChronoField.DAY_OF_MONTH\n *\n * ChronoField.DAY_OF_YEAR\n *\n * ChronoField.EPOCH_DAY\n *\n * ChronoField.ALIGNED_WEEK_OF_MONTH\n *\n * ChronoField.ALIGNED_WEEK_OF_YEAR\n *\n * ChronoField.MONTH_OF_YEAR\n *\n * ChronoField.PROLEPTIC_MONTH\n *\n * ChronoField.YEAR_OF_ERA\n *\n * ChronoField.YEAR\n *\n * ChronoField.ERA\n *\n * ChronoField.INSTANT_SECONDS\n *\n * ChronoField.OFFSET_SECONDS\n *\n */\nexport class ChronoField extends TemporalField {\n\n    /**\n     *\n     * @param {!string} name\n     * @param {!number} baseUnit\n     * @param {!number} rangeUnit\n     * @param {!ValueRange} range\n     */\n    constructor(name, baseUnit, rangeUnit, range) {\n        super();\n        this._name = name;\n        this._baseUnit = baseUnit;\n        this._rangeUnit = rangeUnit;\n        this._range = range;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    name(){\n        return this._name;    \n    }\n\n    /**\n     *\n     * @returns {!number}\n     */\n    baseUnit(){\n        return this._baseUnit;    \n    }\n\n    /**\n     *\n     * @returns {!number}\n     */\n    rangeUnit(){\n        return this._rangeUnit;    \n    }\n\n    /**\n     *\n     * @returns {!ValueRange}\n     */\n    range(){\n        return this._range;    \n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    displayName(){\n        return this.toString();    \n    }\n\n    /**\n     *\n     * @param {number} value\n     * @returns {*}\n     */\n    checkValidValue(value) {\n        return this.range().checkValidValue(value, this.name());\n    }\n\n    /**\n     * Checks if this field represents a component of a date.\n     *\n     * @return {boolean} true if it is a component of a date\n     */\n    isDateBased() {\n        var dateBased =\n            this === ChronoField.DAY_OF_WEEK ||\n            this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH ||\n            this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR ||\n            this === ChronoField.DAY_OF_MONTH ||\n            this === ChronoField.DAY_OF_YEAR ||\n            this === ChronoField.EPOCH_DAY ||\n            this === ChronoField.ALIGNED_WEEK_OF_MONTH ||\n            this === ChronoField.ALIGNED_WEEK_OF_YEAR ||\n            this === ChronoField.MONTH_OF_YEAR ||\n            //this === ChronoField.EPOCH_MONTH ||\n            this === ChronoField.YEAR_OF_ERA ||\n            this === ChronoField.YEAR ||\n            this === ChronoField.ERA;\n        return dateBased;\n    }\n\n    /**\n     * Checks if this field represents a component of a time.\n     *\n     * @return {boolean} true if it is a component of a time\n     */\n    isTimeBased() {\n        var timeBased =\n            this === ChronoField.NANO_OF_SECOND     ||\n            this === ChronoField.NANO_OF_DAY        ||\n            this === ChronoField.MICRO_OF_SECOND    ||\n            this === ChronoField.MICRO_OF_DAY       ||\n            this === ChronoField.MILLI_OF_SECOND    ||\n            this === ChronoField.MILLI_OF_DAY       ||\n            this === ChronoField.SECOND_OF_MINUTE   ||\n            this === ChronoField.SECOND_OF_DAY      ||\n            this === ChronoField.MINUTE_OF_HOUR     ||\n            this === ChronoField.MINUTE_OF_DAY      ||\n            this === ChronoField.HOUR_OF_AMPM       ||\n            this === ChronoField.CLOCK_HOUR_OF_AMPM ||\n            this === ChronoField.HOUR_OF_DAY        ||\n            this === ChronoField.CLOCK_HOUR_OF_DAY  ||\n            this === ChronoField.AMPM_OF_DAY;\n        return timeBased;\n    }\n\n    /**\n     * Get the range of valid values for this field using the temporal object to\n     * refine the result.\n     * <p>\n     * This uses the temporal object to find the range of valid values for the field.\n     * This is similar to {@link #range()}, however this method refines the result\n     * using the temporal. For example, if the field is {@code DAY_OF_MONTH} the\n     * {@code range} method is not accurate as there are four possible month lengths,\n     * 28, 29, 30 and 31 days. Using this method with a date allows the range to be\n     * accurate, returning just one of those four options.\n     * <p>\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#range(TemporalField)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisField.rangeRefinedBy(temporal);\n     *   temporal = temporal.range(thisField);\n     * </pre>\n     * It is recommended to use the second approach, {@code range(TemporalField)},\n     * as it is a lot clearer to read in code.\n     * <p>\n     * Implementations should perform any queries or calculations using the fields\n     * available in {@link ChronoField}.\n     * If the field is not supported a {@code DateTimeException} must be thrown.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object used to refine the result, not null\n     * @return {ValueRange} the range of valid values for this field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    rangeRefinedBy(temporal) {\n        return temporal.range(this);\n    }\n\n    /**\n     * Checks that the specified value is valid and fits in an {@code int}.\n     * <p>\n     * This validates that the value is within the outer range of valid values\n     * returned by {@link #range()}.\n     * It also checks that all valid values are within the bounds of an {@code int}.\n     * <p>\n     * This method checks against the range of the field in the ISO-8601 calendar system.\n     * This range may be incorrect for other calendar systems.\n     * Use {@link Chronology#range(ChronoField)} to access the correct range\n     * for a different calendar system.\n     *\n     * @param {number} value - the value to check\n     * @return {number} the value that was passed in\n     */\n    checkValidIntValue(value) {\n        return this.range().checkValidIntValue(value, this);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        return temporal.getLong(this);\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return this.name();\n    }\n\n    /**\n     *\n     * @param {*} other\n     * @returns {boolean}\n     */\n    equals(other){\n        return this === other;\n    }\n}\n\nexport function _init() {\n\n    ChronoField.NANO_OF_SECOND = new ChronoField('NanoOfSecond', ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));\n\n    ChronoField.NANO_OF_DAY = new ChronoField('NanoOfDay', ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));\n\n    ChronoField.MICRO_OF_SECOND = new ChronoField('MicroOfSecond', ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));\n\n    ChronoField.MICRO_OF_DAY = new ChronoField('MicroOfDay', ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));\n\n    ChronoField.MILLI_OF_SECOND = new ChronoField('MilliOfSecond', ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));\n\n    ChronoField.MILLI_OF_DAY = new ChronoField('MilliOfDay', ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));\n\n    ChronoField.SECOND_OF_MINUTE = new ChronoField('SecondOfMinute', ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));\n\n    ChronoField.SECOND_OF_DAY = new ChronoField('SecondOfDay', ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));\n\n    ChronoField.MINUTE_OF_HOUR = new ChronoField('MinuteOfHour', ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));\n\n    ChronoField.MINUTE_OF_DAY = new ChronoField('MinuteOfDay', ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, (24 * 60) - 1));\n\n    ChronoField.HOUR_OF_AMPM = new ChronoField('HourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));\n\n    ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField('ClockHourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));\n\n    ChronoField.HOUR_OF_DAY = new ChronoField('HourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));\n\n    ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField('ClockHourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));\n\n    ChronoField.AMPM_OF_DAY = new ChronoField('AmPmOfDay', ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));\n\n    ChronoField.DAY_OF_WEEK = new ChronoField('DayOfWeek', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField('AlignedDayOfWeekInMonth', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField('AlignedDayOfWeekInYear', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.DAY_OF_MONTH = new ChronoField('DayOfMonth', ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), 'day');\n\n    ChronoField.DAY_OF_YEAR = new ChronoField('DayOfYear', ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));\n\n    ChronoField.EPOCH_DAY = new ChronoField('EpochDay', ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(Math.floor(Year.MIN_VALUE * 365.25), Math.floor(Year.MAX_VALUE * 365.25)));\n\n    ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField('AlignedWeekOfMonth', ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));\n\n    ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField('AlignedWeekOfYear', ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));\n\n    ChronoField.MONTH_OF_YEAR = new ChronoField('MonthOfYear', ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), 'month');\n\n    ChronoField.PROLEPTIC_MONTH = new ChronoField('ProlepticMonth', ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(Year.MIN_VALUE * 12, Year.MAX_VALUE * 12 + 11));\n\n    ChronoField.YEAR_OF_ERA = new ChronoField('YearOfEra', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, Year.MAX_VALUE, Year.MAX_VALUE + 1));\n\n    ChronoField.YEAR = new ChronoField('Year', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(Year.MIN_VALUE, Year.MAX_VALUE), 'year');\n\n    ChronoField.ERA = new ChronoField('Era', ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));\n\n    ChronoField.INSTANT_SECONDS = new ChronoField('InstantSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));\n\n    ChronoField.OFFSET_SECONDS = new ChronoField('OffsetSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));\n\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/ChronoField.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MathUtil} from '../MathUtil';\n\nimport {Duration} from '../Duration';\nimport {Year} from '../Year';\nimport {TemporalUnit} from './TemporalUnit';\n\n/**\n * A standard set of date periods units.\n * <p>\n * This set of units provide unit-based access to manipulate a date, time or date-time.\n * The standard set of units can be extended by implementing {@link TemporalUnit}.\n * <p>\n * These units are intended to be applicable in multiple calendar systems.\n * For example, most non-ISO calendar systems define units of years, months and days,\n * just with slightly different rules.\n * The documentation of each unit explains how it operates.\n *\n * <h3>Static properties of Class {@link ChronoUnit}</h3>\n *\n * ChronoUnit.NANOS\n *\n * Unit that represents the concept of a nanosecond, the smallest supported unit of time.\n * For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.\n *\n * ChronoUnit.MICROS\n *\n * Unit that represents the concept of a microsecond.\n * For the ISO calendar system, it is equal to the 1,000,000th part of the second unit.\n *\n * ChronoUnit.MILLIS\n *\n * Unit that represents the concept of a millisecond.\n * For the ISO calendar system, it is equal to the 1000th part of the second unit.\n *\n * ChronoUnit.SECONDS\n *\n * Unit that represents the concept of a second.\n * For the ISO calendar system, it is equal to the second in the SI system\n * of units, except around a leap-second.\n *\n * ChronoUnit.MINUTES\n *\n * Unit that represents the concept of a minute.\n * For the ISO calendar system, it is equal to 60 seconds.\n *\n * ChronoUnit.HOURS\n *\n * Unit that represents the concept of an hour.\n * For the ISO calendar system, it is equal to 60 minutes.\n *\n * ChronoUnit.HALF_DAYS\n *\n * Unit that represents the concept of half a day, as used in AM/PM.\n * For the ISO calendar system, it is equal to 12 hours.\n *\n * ChronoUnit.DAYS\n *\n * Unit that represents the concept of a day.\n * For the ISO calendar system, it is the standard day from midnight to midnight.\n * The estimated duration of a day is {@code 24 Hours}.\n * <p>\n * When used with other calendar systems it must correspond to the day defined by\n * the rising and setting of the Sun on Earth. It is not required that days begin\n * at midnight - when converting between calendar systems, the date should be\n * equivalent at midday.\n *\n * ChronoUnit.WEEKS\n *\n * Unit that represents the concept of a week.\n * For the ISO calendar system, it is equal to 7 days.\n * <p>\n * When used with other calendar systems it must correspond to an integral number of days.\n *\n * ChronoUnit.MONTHS\n *\n * Unit that represents the concept of a month.\n * For the ISO calendar system, the length of the month varies by month-of-year.\n * The estimated duration of a month is one twelfth of {@code 365.2425 Days}.\n * <p>\n * When used with other calendar systems it must correspond to an integral number of days.\n *\n * ChronoUnit.YEARS\n *\n * Unit that represents the concept of a year.\n * For the ISO calendar system, it is equal to 12 months.\n * The estimated duration of a year is {@code 365.2425 Days}.\n * <p>\n * When used with other calendar systems it must correspond to an integral number of days\n * or months roughly equal to a year defined by the passage of the Earth around the Sun.\n *\n * ChronoUnit.DECADES\n *\n * Unit that represents the concept of a decade.\n * For the ISO calendar system, it is equal to 10 years.\n * <p>\n * When used with other calendar systems it must correspond to an integral number of days\n * and is normally an integral number of years.\n *\n * ChronoUnit.CENTURIES\n *\n * Unit that represents the concept of a century.\n * For the ISO calendar system, it is equal to 100 years.\n * <p>\n * When used with other calendar systems it must correspond to an integral number of days\n * and is normally an integral number of years.\n *\n * ChronoUnit.MILLENNIA\n *\n * Unit that represents the concept of a millennium.\n * For the ISO calendar system, it is equal to 1000 years.\n * <p>\n * When used with other calendar systems it must correspond to an integral number of days\n * and is normally an integral number of years.\n *\n * ChronoUnit.ERAS\n *\n * Unit that represents the concept of an era.\n * The ISO calendar system doesn't have eras thus it is impossible to add\n * an era to a date or date-time.\n * The estimated duration of the era is artificially defined as {Year.MAX_VALUE} + 1.\n * <p>\n * When used with other calendar systems there are no restrictions on the unit.\n *\n * ChronoUnit.FOREVER\n *\n * Artificial unit that represents the concept of forever.\n * This is primarily used with {@link TemporalField} to represent unbounded fields\n * such as the year or era.\n * The estimated duration of the era is artificially defined as the largest duration\n * supported by {@code Duration}.\n *\n */\nexport class ChronoUnit extends TemporalUnit {\n\n    /**\n     * \n     * @param {String} name\n     * @param {Duration} estimatedDuration\n     */\n    constructor (name, estimatedDuration) {\n        super();\n        this._name = name;\n        this._duration = estimatedDuration;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the estimated duration of this unit in the ISO calendar system.\n     * <p>\n     * All of the units in this class have an estimated duration.\n     * Days vary due to daylight saving time, while months have different lengths.\n     *\n     * @return {Duration} the estimated duration of this unit, not null\n     */\n    duration() {\n        return this._duration;\n    }\n\n    /**\n     * Checks if the duration of the unit is an estimate.\n     * <p>\n     * All time units in this class are considered to be accurate, while all date\n     * units in this class are considered to be estimated.\n     * <p>\n     * This definition ignores leap seconds, but considers that Days vary due to\n     * daylight saving time and months have different lengths.\n     *\n     * @return {boolean} true if the duration is estimated, false if accurate\n     */\n    isDurationEstimated() {\n        return this.isDateBased() || this === ChronoUnit.FOREVER;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this unit is a date unit.\n     *\n     * @return true if a date unit, false if a time unit\n     */\n    isDateBased() {\n        return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;\n    }\n\n    /**\n     * Checks if this unit is a time unit.\n     *\n     * @return true if a time unit, false if a date unit\n     */\n    isTimeBased() {\n        return this.compareTo(ChronoUnit.DAYS) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this unit is supported by the specified temporal object.\n     * <p>\n     * This checks that the implementing date-time can add/subtract this unit.\n     * This can be used to avoid throwing an exception.\n     * <p>\n     * This default implementation derives the value using\n     * {@link Temporal#plus(long, TemporalUnit)}.\n     *\n     * @param {Temporal} temporal  the temporal object to check, not null\n     * @return {boolean} true if the unit is supported\n     */\n    isSupportedBy(temporal) {\n        if (this === ChronoUnit.FOREVER) {\n            return false;\n        }\n        /* TODO: classes not implemented yet */\n/*\n        if (temporal instanceof ChronoLocalDate) {\n            return isDateBased();\n        }\n        if (temporal instanceof ChronoLocalDateTime || temporal instanceof ChronoZonedDateTime) {\n            return true;\n        }\n*/\n        try {\n            temporal.plus(1, this);\n            return true;\n        } catch (e) {\n            try {\n                temporal.plus(-1, this);\n                return true;\n            } catch (e2) {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Returns a copy of the specified temporal object with the specified period added.\n     * <p>\n     * The period added is a multiple of this unit. For example, this method\n     * could be used to add \"3 days\" to a date by calling this method on the\n     * instance representing \"days\", passing the date and the period \"3\".\n     * The period to be added may be negative, which is equivalent to subtraction.\n     * <p>\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus(long, TemporalUnit)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisUnit.addTo(temporal);\n     *   temporal = temporal.plus(thisUnit);\n     * </pre>\n     * It is recommended to use the second approach, {@code plus(TemporalUnit)},\n     * as it is a lot clearer to read in code.\n     * <p>\n     * Implementations should perform any queries or calculations using the units\n     * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the unit is not supported an {@code UnsupportedTemporalTypeException} must be thrown.\n     * <p>\n     * Implementations must not alter the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {Temporal} temporal  the temporal object to adjust, not null\n     * @param {Number} amount  the amount of this unit to add, positive or negative\n     * @return {Temporal} the adjusted temporal object, not null\n     * @throws DateTimeException if the amount cannot be added\n     * @throws UnsupportedTemporalTypeException if the unit is not supported by the temporal\n     */\n    addTo(temporal, amount) {\n        return temporal.plus(amount, this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the amount of time between two temporal objects.\n     * <p>\n     * This calculates the amount in terms of this unit. The start and end\n     * points are supplied as temporal objects and must be of compatible types.\n     * The implementation will convert the second type to be an instance of the\n     * first type before the calculating the amount.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in hours between two temporal objects can be\n     * calculated using {@code HOURS.between(startTime, endTime)}.\n     * <p>\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two temporals.\n     * For example, the amount in hours between the times 11:30 and 13:29\n     * will only be one hour as it is one minute short of two hours.\n     * <p>\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#until(Temporal, TemporalUnit)}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   between = thisUnit.between(start, end);\n     *   between = start.until(end, thisUnit);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     * <p>\n     * For example, this method allows the number of days between two dates to\n     * be calculated:\n     * <pre>\n     *  daysBetween = DAYS.between(start, end);\n     *  // or alternatively\n     *  daysBetween = start.until(end, DAYS);\n     * </pre>\n     * <p>\n     * Implementations should perform any queries or calculations using the units\n     * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the unit is not supported an {@code UnsupportedTemporalTypeException} must be thrown.\n     * Implementations must not alter the specified temporal objects.\n     *\n     * @implSpec\n     * Implementations must begin by checking to if the two temporals have the\n     * same type using {@code .constructor.name}. If they do not, then the result must be\n     * obtained by calling {@code temporal1.until(temporal2, this)}.\n     *\n     * @param {Temporal} temporal1  the base temporal object, not null\n     * @param {Temporal} temporal2  the other temporal object, exclusive, not null\n     * @return {Number} the amount of time between temporal1 and temporal2\n     *  in terms of this unit; positive if temporal2 is later than\n     *  temporal1, negative if earlier\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to the same type as the start temporal\n     * @throws UnsupportedTemporalTypeException if the unit is not supported by the temporal\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    between(temporal1, temporal2) {\n        return temporal1.until(temporal2, this);\n    }\n\n    //-----------------------------------------------------------------------\n    toString() {\n        return this._name;\n    }\n\n    /**\n     * Compares this ChronoUnit to the specified {TemporalUnit}.\n     * <p>\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {TemporalUnit} other  the other unit to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        return this.duration().compareTo(other.duration());\n    }\n\n}\n\nexport function _init() {\n    /**\n     * Unit that represents the concept of a nanosecond, the smallest supported unit of time.\n     * For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.\n     */\n    ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));\n    /**\n     * Unit that represents the concept of a microsecond.\n     * For the ISO calendar system, it is equal to the 1,000,000th part of the second unit.\n     */\n    ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));\n    /**\n     * Unit that represents the concept of a millisecond.\n     * For the ISO calendar system, it is equal to the 1000th part of the second unit.\n     */\n    ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));\n    /**\n     * Unit that represents the concept of a second.\n     * For the ISO calendar system, it is equal to the second in the SI system\n     * of units, except around a leap-second.\n     */\n    ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));\n    /**\n     * Unit that represents the concept of a minute.\n     * For the ISO calendar system, it is equal to 60 seconds.\n     */\n    ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));\n    /**\n     * Unit that represents the concept of an hour.\n     * For the ISO calendar system, it is equal to 60 minutes.\n     */\n    ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));\n    /**\n     * Unit that represents the concept of half a day, as used in AM/PM.\n     * For the ISO calendar system, it is equal to 12 hours.\n     */\n    ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));\n    /**\n     * Unit that represents the concept of a day.\n     * For the ISO calendar system, it is the standard day from midnight to midnight.\n     * The estimated duration of a day is {@code 24 Hours}.\n     * <p>\n     * When used with other calendar systems it must correspond to the day defined by\n     * the rising and setting of the Sun on Earth. It is not required that days begin\n     * at midnight - when converting between calendar systems, the date should be\n     * equivalent at midday.\n     */\n    ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));\n    /**\n     * Unit that represents the concept of a week.\n     * For the ISO calendar system, it is equal to 7 days.\n     * <p>\n     * When used with other calendar systems it must correspond to an integral number of days.\n     */\n    ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));\n    /**\n     * Unit that represents the concept of a month.\n     * For the ISO calendar system, the length of the month varies by month-of-year.\n     * The estimated duration of a month is one twelfth of {@code 365.2425 Days}.\n     * <p>\n     * When used with other calendar systems it must correspond to an integral number of days.\n     */\n    ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));\n    /**\n     * Unit that represents the concept of a year.\n     * For the ISO calendar system, it is equal to 12 months.\n     * The estimated duration of a year is {@code 365.2425 Days}.\n     * <p>\n     * When used with other calendar systems it must correspond to an integral number of days\n     * or months roughly equal to a year defined by the passage of the Earth around the Sun.\n     */\n    ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));\n    /**\n     * Unit that represents the concept of a decade.\n     * For the ISO calendar system, it is equal to 10 years.\n     * <p>\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));\n    /**\n     * Unit that represents the concept of a century.\n     * For the ISO calendar system, it is equal to 100 years.\n     * <p>\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));\n    /**\n     * Unit that represents the concept of a millennium.\n     * For the ISO calendar system, it is equal to 1000 years.\n     * <p>\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));\n    /**\n     * Unit that represents the concept of an era.\n     * The ISO calendar system doesn't have eras thus it is impossible to add\n     * an era to a date or date-time.\n     * The estimated duration of the era is artificially defined as {Year.MAX_VALUE} + 1.\n     * <p>\n     * When used with other calendar systems there are no restrictions on the unit.\n     */\n    ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (Year.MAX_VALUE + 1)));\n    /**\n     * Artificial unit that represents the concept of forever.\n     * This is primarily used with {@link TemporalField} to represent unbounded fields\n     * such as the year or era.\n     * The estimated duration of the era is artificially defined as the largest duration\n     * supported by {@code Duration}.\n     */\n    ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/ChronoUnit.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport {requireNonNull, requireInstance} from './assert';\nimport {ArithmeticException, DateTimeParseException, UnsupportedTemporalTypeException} from './errors';\nimport {MathUtil, MAX_SAFE_INTEGER, MIN_SAFE_INTEGER} from './MathUtil';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalAmount} from './temporal/TemporalAmount';\n\nimport {LocalTime} from './LocalTime';\n\n/**\n * A time-based amount of time, such as '34.5 seconds'.\n * <p>\n * This class models a quantity or amount of time in terms of seconds and nanoseconds.\n * It can be accessed using other duration-based units, such as minutes and hours.\n * In addition, the {@link ChronoUnit#DAYS DAYS} unit can be used and is treated as\n * exactly equal to 24 hours, thus ignoring daylight savings effects.\n * See {@link Period} for the date-based equivalent to this class.\n * <p>\n * A physical duration could be of infinite length.\n * For practicality, the duration is stored with constraints similar to {@link Instant}.\n * The duration uses nanosecond resolution with a maximum value of the seconds that can\n * be held in a {@code long}. This is greater than the current estimated age of the universe.\n * <p>\n * The range of a duration requires the storage of a number larger than a {@code long}.\n * To achieve this, the class stores a {@code long} representing seconds and an {@code int}\n * representing nanosecond-of-second, which will always be between 0 and 999,999,999.\n * <p>\n * The duration is measured in \"seconds\", but these are not necessarily identical to\n * the scientific \"SI second\" definition based on atomic clocks.\n * This difference only impacts durations measured near a leap-second and should not affect\n * most applications.\n * See {@link Instant} for a discussion as to the meaning of the second and time-scales.\n *\n * <h3>Static properties of Class {@link Duration}</h3>\n *\n * Duration.ZERO\n *\n * Constant for a duration of zero.\n *\n */\nexport class Duration extends TemporalAmount\n        /*implements TemporalAmount, Comparable<Duration>, Serializable */ {\n\n    /**\n     * Constructs an instance of {@link Duration} using seconds and nanoseconds.\n     *\n     * @param {Number} seconds - the length of the duration in seconds, positive or negative\n     * @param {Number} nanos - the nanoseconds within the second, from 0 to 999,999,999\n     * @private\n     */\n    constructor(seconds, nanos) {\n        super();\n        this._seconds = seconds;\n        this._nanos = nanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard 24 hour days.\n     * <p>\n     * The seconds are calculated based on the standard definition of a day,\n     * where each day is 86400 seconds which implies a 24 hour day.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} days - the number of days, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input days exceeds the capacity of {@link Duration}\n     */\n    static ofDays(days) {\n        return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard hours.\n     * <p>\n     * The seconds are calculated based on the standard definition of an hour,\n     * where each hour is 3600 seconds.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} hours - the number of hours, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input hours exceeds the capacity of {@link Duration}\n     */\n    static ofHours(hours) {\n        return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard minutes.\n     * <p>\n     * The seconds are calculated based on the standard definition of a minute,\n     * where each minute is 60 seconds.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} minutes - the number of minutes, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input minutes exceeds the capacity of {@link Duration}\n     */\n    static ofMinutes(minutes) {\n        return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of seconds\n     * and an adjustment in nanoseconds.\n     * <p>\n     * This method allows an arbitrary number of nanoseconds to be passed in.\n     * The factory will alter the values of the second and nanosecond in order\n     * to ensure that the stored nanosecond is in the range 0 to 999,999,999.\n     * For example, the following will result in the exactly the same duration:\n     * <pre>\n     *  Duration.ofSeconds(3, 1);\n     *  Duration.ofSeconds(4, -999_999_999);\n     *  Duration.ofSeconds(2, 1000_000_001);\n     * </pre>\n     *\n     * @param {Number} seconds - the number of seconds, positive or negative\n     * @param {Number} nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the adjustment causes the seconds to exceed the capacity of {@link Duration}\n     */\n    static ofSeconds(seconds, nanoAdjustment = 0) {\n        var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));\n        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        return Duration._create(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of milliseconds.\n     * <p>\n     * The seconds and nanoseconds are extracted from the specified milliseconds.\n     *\n     * @param {Number} millis - the number of milliseconds, positive or negative\n     * @return {!Duration}\n     */\n    static ofMillis(millis) {\n        var secs = MathUtil.intDiv(millis, 1000);\n        var mos = MathUtil.intMod(millis, 1000);\n        if (mos < 0) {\n            mos += 1000;\n            secs--;\n        }\n        return Duration._create(secs, mos * 1000000);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of nanoseconds.\n     * <p>\n     * The seconds and nanoseconds are extracted from the specified nanoseconds.\n     *\n     * @param {Number} nanos - the number of nanoseconds, positive or negative\n     * @return {!Duration}\n     */\n    static ofNanos(nanos) {\n        var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);\n        var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);\n        if (nos < 0) {\n            nos += LocalTime.NANOS_PER_SECOND;\n            secs--;\n        }\n        return this._create(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a duration in the specified unit.\n     * <p>\n     * The parameters represent the two parts of a phrase like '6 Hours'. For example:\n     * <pre>\n     *  Duration.of(3, SECONDS);\n     *  Duration.of(465, HOURS);\n     * </pre>\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an {@link TemporalUnit#isDurationEstimated() exact duration} or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * @param {Number} amount - the amount of the duration, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the duration is measured in, must have an exact duration, not null\n     * @return {!Duration}\n     * @throws DateTimeException if the period unit has an estimated duration\n     * @throws ArithmeticException if a numeric overflow occurs\n     */\n    static of(amount, unit) {\n        return Duration.ZERO.plus(amount, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from an amount.\n     * <p>\n     * This obtains a duration based on the specified amount.\n     * A TemporalAmount represents an amount of time, which may be date-based\n     * or time-based, which this factory extracts to a duration.\n     * <p>\n     * The conversion loops around the set of units from the amount and uses\n     * the duration of the unit to calculate the total Duration.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration or be ChronoUnit.DAYS which\n     * is treated as 24 hours. If any other units are found then an exception is thrown.\n     *\n     * @param {Number} amount - the temporal amount to convert, not null\n     * @return {Duration} the resulting duration, not null\n     * @throws DateTimeException if the amount cannot be converted\n     * @throws ArithmeticException if a numeric overflow occurs\n     */\n    static from(amount) {\n        requireNonNull(amount, 'amount');\n        var duration = Duration.ZERO;\n        amount.units().forEach((unit) => {\n            duration = duration.plus(amount.get(unit), unit);\n        });\n        return duration;\n    }\n    \n    /**\n     * Obtains an instance of {@link Duration} representing the duration between two instants.\n     * <p>\n     * Obtains a {@link Duration} representing the duration between two instants.\n     * This calculates the duration between two temporal objects of the same type.\n     * The difference in seconds is calculated using {@link Temporal#until(Temporal, TemporalUnit)}.\n     * The difference in nanoseconds is calculated using by querying the\n     * {@link ChronoField#NANO_OF_SECOND NANO_OF_SECOND} field.\n     * <p>\n     * The result of this method can be a negative period if the end is before the start.\n     * To guarantee to obtain a positive duration call abs() on the result.\n     *\n     * @param {Temporal} startInclusive - the start instant, inclusive, not null\n     * @param {Temporal} endExclusive - the end instant, exclusive, not null\n     * @return {!Duration}\n     * @throws DateTimeException if the seconds between the temporals cannot be obtained\n     * @throws ArithmeticException if the calculation exceeds the capacity of {@link Duration}\n     */\n    static between(startInclusive, endExclusive) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(endExclusive, 'endExclusive');\n        var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);\n        var nanos = 0;\n        if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {\n            try {\n                let startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);\n                nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;\n                if (secs > 0 && nanos < 0) {\n                    nanos += LocalTime.NANOS_PER_SECOND;\n                } else if (secs < 0 && nanos > 0) {\n                    nanos -= LocalTime.NANOS_PER_SECOND;\n                } else if (secs === 0 && nanos !== 0) {\n                    // two possible meanings for result, so recalculate secs\n                    let adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);\n                    secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);\n                }\n            } catch (e) {\n                // ignore and only use seconds\n            }\n        }\n        return this.ofSeconds(secs, nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Duration} from a text string such as {@code PnDTnHnMn.nS}.\n     * <p>\n     * This will parse a textual representation of a duration, including the\n     * string produced by {@code toString()}. The formats accepted are based\n     * on the ISO-8601 duration format {@code PnDTnHnMn.nS} with days\n     * considered to be exactly 24 hours.\n     * <p>\n     * The string starts with an optional sign, denoted by the ASCII negative\n     * or positive symbol. If negative, the whole period is negated.\n     * The ASCII letter \"P\" is next in upper or lower case.\n     * There are then four sections, each consisting of a number and a suffix.\n     * The sections have suffixes in ASCII of \"D\", \"H\", \"M\" and \"S\" for\n     * days, hours, minutes and seconds, accepted in upper or lower case.\n     * The suffixes must occur in order. The ASCII letter \"T\" must occur before\n     * the first occurrence, if any, of an hour, minute or second section.\n     * At least one of the four sections must be present, and if \"T\" is present\n     * there must be at least one section after the \"T\".\n     * The number part of each section must consist of one or more ASCII digits.\n     * The number may be prefixed by the ASCII negative or positive symbol.\n     * The number of days, hours and minutes must parse to a {@code long}.\n     * The number of seconds must parse to a {@code long} with optional fraction.\n     * The decimal point may be either a dot or a comma.\n     * The fractional part may have from zero to 9 digits.\n     * <p>\n     * The leading plus/minus sign, and negative values for other units are\n     * not part of the ISO-8601 standard.\n     * <p>\n     * Examples:\n     * <pre>\n     *    \"PT20.345S\" -> parses as \"20.345 seconds\"\n     *    \"PT15M\"     -> parses as \"15 minutes\" (where a minute is 60 seconds)\n     *    \"PT10H\"     -> parses as \"10 hours\" (where an hour is 3600 seconds)\n     *    \"P2D\"       -> parses as \"2 days\" (where a day is 24 hours or 86400 seconds)\n     *    \"P2DT3H4M\"  -> parses as \"2 days, 3 hours and 4 minutes\"\n     *    \"P-6H3M\"    -> parses as \"-6 hours and +3 minutes\"\n     *    \"-P6H3M\"    -> parses as \"-6 hours and -3 minutes\"\n     *    \"-P-6H+3M\"  -> parses as \"+6 hours and -3 minutes\"\n     * </pre>\n     *\n     * @param {String} text - the text to parse, not null\n     * @return {Duration} the parsed duration, not null\n     * @throws DateTimeParseException if the text cannot be parsed to a duration\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        /**\n         * The pattern for parsing.\n         */\n        const PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');\n        var matches = PATTERN.exec(text);\n        if (matches !== null) {\n            // check for letter T but no time sections\n            if ('T' === matches[3] === false) {\n                var negate = '-' === matches[1];\n                var dayMatch = matches[2];\n                var hourMatch = matches[4];\n                var minuteMatch = matches[5];\n                var secondMatch = matches[6];\n                var fractionMatch = matches[7];\n                if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {\n                    var daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');\n                    var hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');\n                    var minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');\n                    var seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');\n                    var negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';\n                    var nanos = Duration._parseFraction(text,  fractionMatch, negativeSecs ? -1 : 1);\n                    try {\n                        return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);\n                    } catch (ex) {\n                        throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);\n                    }\n                }\n            }\n        }\n        throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);\n    }\n\n    static _parseNumber(text, parsed, multiplier, errorText) {\n        // regex limits to [-+]?[0-9]+\n        if (parsed == null) {\n            return 0;\n        }\n        try {\n            if (parsed[0] === '+') {\n                parsed = parsed.substring(1);\n            }\n            var val = parseFloat(parsed);\n            return MathUtil.safeMultiply(val, multiplier);\n        } catch (ex) {\n            throw new DateTimeParseException('Text cannot be parsed to a Duration: ' + errorText, text, 0, ex);\n        }\n    }\n\n    static _parseFraction(text, parsed, negate) {\n        // regex limits to [0-9]{0,9}\n        if (parsed == null || parsed.length === 0) {\n            return 0;\n        }\n        try {\n            parsed = (parsed + '000000000').substring(0, 9);\n            return parseFloat(parsed) * negate;\n        } catch (ex) {\n            throw new DateTimeParseException('Text cannot be parsed to a Duration: fraction', text, 0, ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * to handle function overriding this function accepts any number of arguments, checks their type and delegates to the appropriate function\n     *\n     * @return {Duration}\n     */\n    static _create() {\n        if (arguments.length <= 2) {\n            return Duration._createSecondsNanos(arguments[0], arguments[1]);\n        } else {\n            return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n        }\n    }\n\n    static _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {\n        var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));\n        if (negate) {\n            return Duration.ofSeconds(seconds, nanos).negated();\n        }\n        return Duration.ofSeconds(seconds, nanos);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} using seconds and nanoseconds.\n     *\n     * @param {Number} seconds - the length of the duration in seconds, positive or negative\n     * @param {Number} nanoAdjustment - the nanosecond adjustment within the second, from 0 to 999,999,999\n     */\n    static _createSecondsNanos(seconds = 0, nanoAdjustment = 0) {\n        if ((seconds | nanoAdjustment) === 0) {\n            return Duration.ZERO;\n        }\n        return new Duration(seconds, nanoAdjustment);\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value of the requested unit.\n     * <p>\n     * This returns a value for each of the two supported units,\n     * {@link ChronoUnit#SECONDS SECONDS} and {@link ChronoUnit#NANOS NANOS}.\n     * All other units throw an exception.\n     *\n     * @param {TemporalUnit} unit the {@code TemporalUnit} for which to return the value\n     * @return {number} the var value of the unit\n     * @throws DateTimeException if the unit is not supported\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    get(unit) {\n        if (unit === ChronoUnit.SECONDS) {\n            return this._seconds;\n        } else if (unit === ChronoUnit.NANOS) {\n            return this._nanos;\n        } else {\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n    }\n\n    units() {\n        return [ChronoUnit.SECONDS, ChronoUnit.NANOS];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this duration is zero length.\n     * <p>\n     * A {@link Duration} represents a directed distance between two points on\n     * the time-line and can therefore be positive, zero or negative.\n     * This method checks whether the length is zero.\n     *\n     * @return {boolean} true if this duration has a total length equal to zero\n     */\n    isZero() {\n        return (this._seconds | this._nanos) === 0;\n    }\n\n    /**\n     * Checks if this duration is negative, excluding zero.\n     * <p>\n     * A {@link Duration} represents a directed distance between two points on\n     * the time-line and can therefore be positive, zero or negative.\n     * This method checks whether the length is less than zero.\n     *\n     * @return {boolean} true if this duration has a total length less than zero\n     */\n    isNegative() {\n        return this._seconds < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of seconds in this duration.\n     * <p>\n     * The length of the duration is stored using two fields - seconds and nanoseconds.\n     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n     * the length in seconds.\n     * The total duration is defined by calling this method and {@link #getNano()}.\n     * <p>\n     * A {@link Duration} represents a directed distance between two points on the time-line.\n     * A negative duration is expressed by the negative sign of the seconds part.\n     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.\n     *\n     * @return {number} the whole seconds part of the length of the duration, positive or negative\n     */\n    seconds() {\n        return this._seconds;\n    }\n\n    /**\n     * Gets the number of nanoseconds within the second in this duration.\n     * <p>\n     * The length of the duration is stored using two fields - seconds and nanoseconds.\n     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n     * the length in seconds.\n     * The total duration is defined by calling this method and {@link #getSeconds()}.\n     * <p>\n     * A {@link Duration} represents a directed distance between two points on the time-line.\n     * A negative duration is expressed by the negative sign of the seconds part.\n     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.\n     *\n     * @return {number} the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999\n     */\n    nano() {\n        return this._nanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified amount of seconds.\n     * <p>\n     * This returns a duration with the specified seconds, retaining the\n     * nano-of-second part of this duration.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} seconds - the seconds to represent, may be negative\n     * @return {Duration} based on this period with the requested seconds, not null\n     */\n    withSeconds(seconds) {\n        return Duration._create(seconds, this._nanos);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified nano-of-second.\n     * <p>\n     * This returns a duration with the specified nano-of-second, retaining the\n     * seconds part of this duration.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanoOfSecond - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {Duration} based on this period with the requested nano-of-second, not null\n     * @throws DateTimeException if the nano-of-second is invalid\n     */\n    withNanos(nanoOfSecond) {\n        ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);\n        return Duration._create(this._seconds, nanoOfSecond);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Duration} duration - the duration to add, positive or negative, not null\n     * @return {Duration} based on this duration with the specified duration added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDuration(duration) {\n        return this.plus(duration.seconds(), duration.nano());\n    }\n\n\n    /**\n     * to handle function overriding this function accepts two arguments, checks their type and delegates to the appropriate function\n     * \n     * @param {!(Duration|number)} a\n     * @param {ChronoUnit|number} b\n     * @return {Duration}\n     */\n    plus(a, b){\n        if (a instanceof Duration) {\n            requireNonNull(a, 'duration');\n            return this.plusDuration(a);\n        }\n        if (b instanceof ChronoUnit) {\n            requireNonNull(a, 'amount');\n            requireNonNull(b, 'unit');\n            return this.plusAmountUnit(a, b);\n        }\n        requireNonNull(a, 'seconds');\n        requireNonNull(b, 'nanos');\n        return this.plusSecondsNanos(a, b);\n    }\n    \n    /**\n     * Returns a copy of this duration with the specified duration added.\n     * <p>\n     * The duration amount is measured in terms of the specified unit.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an {@link TemporalUnit#isDurationEstimated() exact duration} or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} amountToAdd - the amount to add, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the amount is measured in, must have an exact duration, not null\n     * @return {Duration} based on this duration with the specified duration added, not null\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmountUnit(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.DAYS) {\n            return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);\n        }\n        if (unit.isDurationEstimated()) {\n            throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');\n        }\n        if (amountToAdd === 0) {\n            return this;\n        }\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, (1000000 * 1000)) * 1000, MathUtil.intMod(amountToAdd, (1000000 * 1000)) * 1000);\n                case ChronoUnit.MILLIS: return this.plusMillis(amountToAdd);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n            }\n            return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);\n        }\n        var duration = unit.duration().multipliedBy(amountToAdd);\n        return this.plusSecondsNanos(duration.seconds(), duration.nano());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration in 24 hour days added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} daysToAdd - the days to add, positive or negative\n     * @return {Duration} based on this duration with the specified days added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDays(daysToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in hours added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} hoursToAdd - the hours to add, positive or negative\n     * @return {Duration} based on this duration with the specified hours added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusHours(hoursToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in minutes added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} minutesToAdd - the minutes to add, positive or negative\n     * @return {Duration} based on this duration with the specified minutes added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMinutes(minutesToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in seconds added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToAdd - the seconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified seconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusSeconds(secondsToAdd) {\n        return this.plusSecondsNanos(secondsToAdd, 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in milliseconds added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} millisToAdd - the milliseconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified milliseconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMillis(millisToAdd) {\n        return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in nanoseconds added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanosToAdd - the nanoseconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified nanoseconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusNanos(nanosToAdd) {\n        return this.plusSecondsNanos(0, nanosToAdd);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToAdd - the seconds to add, positive or negative\n     * @param {Number} nanosToAdd - the nanos to add, positive or negative\n     * @return {Duration} based on this duration with the specified seconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusSecondsNanos(secondsToAdd, nanosToAdd) {\n        if ((secondsToAdd | nanosToAdd) === 0) {\n            return this;\n        }\n        var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);\n        epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));\n        nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n        var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);  // safe int+LocalTime.NANOS_PER_SECOND\n        return Duration.ofSeconds(epochSec, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * to handle function overriding this function accepts two arguments, checks their type and delegates to the appropriate function\n     *\n     * @param {!(Duration|number)} a\n     * @param {ChronoUnit|number} b\n     * @return {Duration}\n     */\n    minus(a, b) {\n        if (a instanceof Duration) {\n            requireNonNull(a, 'duration');\n            return this.minusDuration(a);\n        }\n        if (b instanceof ChronoUnit) {\n            requireNonNull(a, 'amount');\n            requireNonNull(b, 'unit');\n            return this.minusAmountUnit(a, b);\n        }\n        requireNonNull(a, 'seconds');\n        requireNonNull(b, 'nanos');\n        return this.minusSecondsNanos(a, b);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Duration} duration - the duration to subtract, positive or negative, not null\n     * @return {Duration} based on this duration with the specified duration subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDuration(duration) {\n        var secsToSubtract = duration.seconds();\n        var nanosToSubtract = duration.nano();\n        if (secsToSubtract === MIN_SAFE_INTEGER) {\n            return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract).plus(1, 0);\n        }\n        return this.plus(-secsToSubtract, -nanosToSubtract);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration subtracted.\n     * <p>\n     * The duration amount is measured in terms of the specified unit.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an {@link TemporalUnit#isDurationEstimated() exact duration} or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} amountToSubtract - the amount to subtract, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the amount is measured in, must have an exact duration, not null\n     * @return {Duration} based on this duration with the specified duration subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmountUnit(amountToSubtract, unit) {\n        return (amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit).plus(1, unit) : this.plusAmountUnit(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration in 24 hour days subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} daysToSubtract - the days to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified days subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDays(daysToSubtract) {\n        return (daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER).plusDays(1) : this.plusDays(-daysToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in hours subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} hoursToSubtract - the hours to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified hours subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusHours(hoursToSubtract) {\n        return (hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER).plusHours(1) : this.plusHours(-hoursToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in minutes subtracted.\n     * <p>\n     * The number of hours is multiplied by 60 to obtain the number of seconds to subtract.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} minutesToSubtract - the minutes to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified minutes subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMinutes(minutesToSubtract) {\n        return (minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER).plusMinutes(1) : this.plusMinutes(-minutesToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in seconds subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToSubtract - the seconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified seconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusSeconds(secondsToSubtract) {\n        return (secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER).plusSeconds(1) : this.plusSeconds(-secondsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in milliseconds subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} millisToSubtract - the milliseconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified milliseconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMillis(millisToSubtract) {\n        return (millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER).plusMillis(1) : this.plusMillis(-millisToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in nanoseconds subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanosToSubtract - the nanoseconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified nanoseconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusNanos(nanosToSubtract) {\n        return (nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER).plusNanos(1) : this.plusNanos(-nanosToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration multiplied by the scalar.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} multiplicand - the value to multiply the duration by, positive or negative\n     * @return {Duration} based on this duration multiplied by the specified scalar, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    multipliedBy(multiplicand) {\n        if (multiplicand === 0) {\n            return Duration.ZERO;\n        }\n        if (multiplicand === 1) {\n            return this;\n        }\n        let secs = MathUtil.safeMultiply(this._seconds, multiplicand);\n        let nos = MathUtil.safeMultiply(this._nanos, multiplicand);\n        secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);\n        nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);\n        return Duration.ofSeconds(secs, nos);\n    }\n\n    /**\n     * Returns a copy of this duration divided by the specified value.\n     * <p>\n     * In opposite to the threeten implementation the division is realized by floating point not by \n     * fixed point arithmetic. Expect floating point rounding errors for {@link Duration.dividedBy}.\n     *\n     * @param {Number} divisor - the value to divide the duration by, positive or negative, not zero\n     * @return {Duration} based on this duration divided by the specified divisor, not null\n     * @throws ArithmeticException if the divisor is zero or if numeric overflow occurs\n     */\n    dividedBy(divisor) {\n        if (divisor === 0) {\n            throw new ArithmeticException('Cannot divide by zero');\n        }\n        if (divisor === 1) {\n            return this;\n        }\n        var secs = MathUtil.intDiv(this._seconds, divisor);\n        var secsMod = MathUtil.roundDown(((this._seconds/ divisor) - secs) * LocalTime.NANOS_PER_SECOND);\n        var nos = MathUtil.intDiv(this._nanos, divisor);\n        nos = secsMod + nos;\n        return Duration.ofSeconds(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the length negated.\n     * <p>\n     * This method swaps the sign of the total length of this duration.\n     * For example, {@code PT1.3S} will be returned as {@code PT-1.3S}.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Duration} based on this duration with the amount negated, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    negated() {\n        return this.multipliedBy(-1);\n    }\n\n    /**\n     * Returns a copy of this duration with a positive length.\n     * <p>\n     * This method returns a positive duration by effectively removing the sign from any negative total length.\n     * For example, {@code PT-1.3S} will be returned as {@code PT1.3S}.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Duration} based on this duration with an absolute length, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    abs() {\n        return this.isNegative() ? this.negated() : this;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Adds this duration to the specified temporal object.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with this duration added.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#plus(TemporalAmount)}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisDuration.addTo(dateTime);\n     *   dateTime = dateTime.plus(thisDuration);\n     * </pre>\n     * <p>\n     * The calculation will add the seconds, then nanos.\n     * Only non-zero amounts will be added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    addTo(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._seconds !== 0) {\n            temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    }\n\n    /**\n     * Subtracts this duration from the specified temporal object.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with this duration subtracted.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#minus(TemporalAmount)}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisDuration.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(thisDuration);\n     * </pre>\n     * <p>\n     * The calculation will subtract the seconds, then nanos.\n     * Only non-zero amounts will be added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    subtractFrom(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._seconds !== 0) {\n            temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of days in this duration.\n     * <p>\n     * This returns the total number of days in the duration by dividing the\n     * number of seconds by 86400.\n     * This is based on the standard definition of a day as 24 hours.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of days in the duration, may be negative\n     */\n    toDays() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);\n    }\n\n    /**\n     * Gets the number of hours in this duration.\n     * <p>\n     * This returns the total number of hours in the duration by dividing the\n     * number of seconds by 3600.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of hours in the duration, may be negative\n     */\n    toHours() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n    }\n\n    /**\n     * Gets the number of minutes in this duration.\n     * <p>\n     * This returns the total number of minutes in the duration by dividing the\n     * number of seconds by 60.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of minutes in the duration, may be negative\n     */\n    toMinutes() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n    }\n\n    /**\n     * Converts this duration to the total length in milliseconds.\n     * <p>\n     * If this duration is too large to fit in a {@code long} milliseconds, then an\n     * exception is thrown.\n     * <p>\n     * If this duration has greater than millisecond precision, then the conversion\n     * will drop any excess precision information as though the amount in nanoseconds\n     * was subject to integer division by one million.\n     *\n     * @return {number} the total length of the duration in milliseconds\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toMillis() {\n        var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));\n        millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));\n        return millis;\n    }\n\n    /**\n     * Converts this duration to the total length in nanoseconds expressed as a {@code long}.\n     * <p>\n     * If this duration is too large to fit in a {@code long} nanoseconds, then an\n     * exception is thrown.\n     *\n     * @return {number} the total length of the duration in nanoseconds\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toNanos() {\n        var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);\n        totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);\n        return totalNanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this duration to the specified {@link Duration}.\n     * <p>\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {Duration} otherDuration - the other duration to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(otherDuration) {\n        requireNonNull(otherDuration, 'otherDuration');\n        requireInstance(otherDuration, Duration, 'otherDuration');\n        var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return this._nanos - otherDuration.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this duration is equal to the specified {@link Duration}.\n     * <p>\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {*} otherDuration - the other duration, null returns false\n     * @return {boolean} true if the other duration is equal to this one\n     */\n    equals(otherDuration) {\n        if (this === otherDuration) {\n            return true;\n        }\n        if (otherDuration instanceof Duration) {\n            return this.seconds() === otherDuration.seconds() &&\n                   this.nano() === otherDuration.nano();\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A string representation of this duration using ISO-8601 seconds\n     * based representation, such as {@code PT8H6M12.345S}.\n     * <p>\n     * The format of the returned string will be {@code PTnHnMnS}, where n is\n     * the relevant hours, minutes or seconds part of the duration.\n     * Any fractional seconds are placed after a decimal povar i the seconds section.\n     * If a section has a zero value, it is omitted.\n     * The hours, minutes and seconds will all have the same sign.\n     * <p>\n     * Examples:\n     * <pre>\n     *    \"20.345 seconds\"                 -> \"PT20.345S\n     *    \"15 minutes\" (15 * 60 seconds)   -> \"PT15M\"\n     *    \"10 hours\" (10 * 3600 seconds)   -> \"PT10H\"\n     *    \"2 days\" (2 * 86400 seconds)     -> \"PT48H\"\n     * </pre>\n     * Note that multiples of 24 hours are not output as days to avoid confusion\n     * with {@code Period}.\n     *\n     * @return {string} an ISO-8601 representation of this duration, not null\n     */\n    toString() {\n        if (this === Duration.ZERO) {\n            return 'PT0S';\n        }\n        var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n        var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);\n        var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n        var rval = 'PT';\n        if (hours !== 0) {\n            rval += hours + 'H';\n        }\n        if (minutes !== 0) {\n            rval += minutes + 'M';\n        }\n        if (secs === 0 && this._nanos === 0 && rval.length > 2) {\n            return rval;\n        }\n        if (secs < 0 && this._nanos > 0) {\n            if (secs === -1) {\n                rval += '-0';\n            } else {\n                rval += secs + 1;\n            }\n        } else {\n            rval += secs;\n        }\n        if (this._nanos > 0) {\n            rval += '.';\n            let nanoString;\n            if (secs < 0) {\n                nanoString = '' + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);\n            } else {\n                nanoString = '' + (LocalTime.NANOS_PER_SECOND + this._nanos);\n            }\n            // remove the leading '1'\n            nanoString = nanoString.slice(1, nanoString.length);\n            rval += nanoString;\n            while (rval.charAt(rval.length - 1) === '0') {\n                rval = rval.slice(0, rval.length - 1);\n            }\n        }\n        rval += 'S';\n        return rval;\n    }\n\n}\n\nexport function _init() {\n    /**\n     * Constant for a duration of zero.\n     */\n    Duration.ZERO = new Duration(0, 0);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Duration.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from '../assert';\n\n/**\n * Framework-level interface defining an amount of time, such as\n * \"6 hours\", \"8 days\" or \"2 years and 3 months\".\n * <p>\n * This is the base interface type for amounts of time.\n * An amount is distinct from a date or time-of-day in that it is not tied\n * to any specific point on the time-line.\n * <p>\n * The amount can be thought of as a {@code Map} of {@link TemporalUnit} to\n * {@code long}, exposed via {@link #getUnits()} and {@link #get(TemporalUnit)}.\n * A simple case might have a single unit-value pair, such as \"6 hours\".\n * A more complex case may have multiple unit-value pairs, such as\n * \"7 years, 3 months and 5 days\".\n * <p>\n * There are two common implementations.\n * {@link Period} is a date-based implementation, storing years, months and days.\n * {@link Duration} is a time-based implementation, storing seconds and nanoseconds,\n * but providing some access using other duration based units such as minutes,\n * hours and fixed 24-hour days.\n * <p>\n * This interface is a framework-level interface that should not be widely\n * used in application code. Instead, applications should create and pass\n * around instances of concrete types, such as {@code Period} and {@code Duration}.\n *\n * @interface\n */\nexport class TemporalAmount{\n    /**\n     * Returns the value of the requested unit.\n     * The units returned from {@link #getUnits()} uniquely define the\n     * value of the {@code TemporalAmount}.  A value must be returned\n     * for each unit listed in {@code getUnits}.\n     *\n     * @implSpec\n     * Implementations may declare support for units not listed by {@link #getUnits()}.\n     * Typically, the implementation would define additional units\n     * as conversions for the convenience of developers.\n     *\n     * @param {TemporalUnit} unit - the {@code TemporalUnit} for which to return the value\n     * @return {number} the long value of the unit\n     * @throws DateTimeException if a value for the unit cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the {@code unit} is not supported\n     */\n    get(unit){\n        abstractMethodFail('adjustInto');\n    }\n\n    /**\n     * Returns the list of units uniquely defining the value of this TemporalAmount.\n     * The list of {@code TemporalUnits} is defined by the implementation class.\n     * The list is a snapshot of the units at the time {@code getUnits}\n     * is called and is not mutable.\n     * The units are ordered from longest duration to the shortest duration\n     * of the unit.\n     *\n     * @implSpec\n     * The list of units completely and uniquely represents the\n     * state of the object without omissions, overlaps or duplication.\n     * The units are in order from longest duration to shortest.\n     *\n     * @return {TemporalUnit[]} the List of {@code TemporalUnits}; not null\n     */\n    getUnits(){\n        abstractMethodFail('adjustInto');\n    }\n\n    /**\n     * Adds to the specified temporal object.\n     * <p>\n     * Adds the amount to the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     * <p>\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus(TemporalAmount)}:\n     * <pre>\n     *   // These two lines are equivalent, but the second approach is recommended\n     *   dateTime = amount.addTo(dateTime);\n     *   dateTime = dateTime.plus(adder);\n     * </pre>\n     * It is recommended to use the second approach, {@code plus(TemporalAmount)},\n     * as it is a lot clearer to read in code.\n     *\n     * @implSpec\n     * The implementation must take the input object and add to it.\n     * The implementation defines the logic of the addition and is responsible for\n     * documenting that logic. It may use any method on {@code Temporal} to\n     * query the temporal object and perform the addition.\n     * The returned object must have the same observable type as the input object\n     * <p>\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     * <p>\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by {@link TemporalQueries#chronology() querying the chronology}.\n     * <p>\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal - the temporal object to add the amount to, not null\n     * @return {Temporal} an object of the same observable type with the addition made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    addTo(temporal){\n        abstractMethodFail('adjustInto');\n    }\n\n    /**\n     * Subtracts this object from the specified temporal object.\n     * <p>\n     * Subtracts the amount from the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     * <p>\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#minus(TemporalAmount)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = amount.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(amount);\n     * </pre>\n     * It is recommended to use the second approach, {@code minus(TemporalAmount)},\n     * as it is a lot clearer to read in code.\n     *\n     * @implSpec\n     * The implementation must take the input object and subtract from it.\n     * The implementation defines the logic of the subtraction and is responsible for\n     * documenting that logic. It may use any method on {@code Temporal} to\n     * query the temporal object and perform the subtraction.\n     * The returned object must have the same observable type as the input object\n     * <p>\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     * <p>\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by {@link TemporalQueries#chronology() querying the chronology}.\n     * <p>\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal - the temporal object to subtract the amount from, not null\n     * @return {Temporal} an object of the same observable type with the subtraction made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n     subtractFrom(temporal){\n        abstractMethodFail('adjustInto');\n     }\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/TemporalAmount.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n/**\n * A year in the ISO-8601 calendar system, such as {@code 2007}.\n * <p>\n * {@code Year} is an immutable date-time object that represents a year.\n * Any field that can be derived from a year can be obtained.\n * <p>\n * <b>Note that years in the ISO chronology only align with years in the\n * Gregorian-Julian system for modern years. Parts of Russia did not switch to the\n * modern Gregorian/ISO rules until 1920.\n * As such, historical years must be treated with caution.</b>\n * <p>\n * This class does not store or represent a month, day, time or time-zone.\n * For example, the value \"2007\" can be stored in a {@code Year}.\n * <p>\n * Years represented by this class follow the ISO-8601 standard and use\n * the proleptic numbering system. Year 1 is preceded by year 0, then by year -1.\n * <p>\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * <h3>Static properties of Class {@link LocalDate}</h3>\n *\n * Year.MIN_VALUE = -999.999;\n *\n * The minimum supported year. Theoretically the minimum could be -28.542.4812 years in javascript.\n * approx LocalDateTime.ofEpochSecond(Number.MIN_SAFE_INTEGER, 0, ZoneOffset.UTC).year()\n *\n * Year.MAX_VALUE = 999.999;\n *\n * The maximum supported year. Theoretically the maximum could be 285.428.751 years in javascript.\n * approx LocalDateTime.ofEpochSecond(Number.MAX_SAFE_INTEGER, 0, ZoneOffset.UTC).year()\n *\n */\nexport class Year {}\n\nexport function _init() {\n    /**\n     * The minimum supported year\n     */\n    Year.MIN_VALUE = -999999;\n    /**\n     * The maximum supported year\n     */\n    Year.MAX_VALUE = 999999;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Year.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * A unit of date-time, such as Days or Hours.\n * <p>\n * Measurement of time is built on units, such as years, months, days, hours, minutes and seconds.\n * Implementations of this interface represent those units.\n * <p>\n * An instance of this interface represents the unit itself, rather than an amount of the unit.\n * See {@link Period} for a class that represents an amount in terms of the common units.\n * <p>\n * The most commonly used units are defined in {@link ChronoUnit}.\n * Further units are supplied in {@link IsoFields}.\n * Units can also be written by application code by implementing this interface.\n * <p>\n * The unit works using double dispatch. Client code calls methods on a date-time like\n * {@code LocalDateTime} which check if the unit is a {@code ChronoUnit}.\n * If it is, then the date-time must handle it.\n * Otherwise, the method call is re-dispatched to the matching method in this interface.\n *\n * @interface\n */\nexport class TemporalUnit {}\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/TemporalUnit.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * A field of date-time, such as month-of-year or hour-of-minute.\n * <p>\n * Date and time is expressed using fields which partition the time-line into something\n * meaningful for humans. Implementations of this interface represent those fields.\n * <p>\n * The most commonly used units are defined in {@link ChronoField}.\n * Further fields are supplied in {@link IsoFields}, {@link WeekFields} and {@link JulianFields}.\n * Fields can also be written by application code by implementing this interface.\n * <p>\n * The field works using double dispatch. Client code calls methods on a date-time like\n * {@code LocalDateTime} which check if the field is a {@code ChronoField}.\n * If it is, then the date-time must handle it.\n * Otherwise, the method call is re-dispatched to the matching method in this interface.\n *\n * @interface\n */\nexport class TemporalField {}\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/TemporalField.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert} from '../assert';\nimport {DateTimeException, IllegalArgumentException} from '../errors';\nimport {MathUtil} from '../MathUtil';\n\n/**\n * The range of valid values for a date-time field.\n * \n * All TemporalField instances have a valid range of values.\n * For example, the ISO day-of-month runs from 1 to somewhere between 28 and 31.\n * This class captures that valid range.\n * \n * It is important to be aware of the limitations of this class.\n * Only the minimum and maximum values are provided.\n * It is possible for there to be invalid values within the outer range.\n * For example, a weird field may have valid values of 1, 2, 4, 6, 7, thus\n * have a range of '1 - 7', despite that fact that values 3 and 5 are invalid.\n * \n * Instances of this class are not tied to a specific field.\n */\nexport class ValueRange {\n\n    /**\n     *\n     * @param {!number} minSmallest\n     * @param {!number} minLargest\n     * @param {!number} maxSmallest\n     * @param {!number} maxLargest\n     */\n    constructor(minSmallest, minLargest, maxSmallest, maxLargest) {\n        assert(!(minSmallest > minLargest), 'Smallest minimum value \\'' + minSmallest +\n            '\\' must be less than largest minimum value \\'' + minLargest + '\\'', IllegalArgumentException);\n        assert(!(maxSmallest > maxLargest), 'Smallest maximum value \\'' + maxSmallest +\n            '\\' must be less than largest maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n        assert(!(minLargest > maxLargest), 'Minimum value \\'' + minLargest +\n            '\\' must be less than maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n\n        this._minSmallest = minSmallest;\n        this._minLargest = minLargest;\n        this._maxLargest = maxLargest;\n        this._maxSmallest = maxSmallest;\n    }\n\n    /**\n     * Is the value range fixed and fully known.\n     * <p>\n     * For example, the ISO day-of-month runs from 1 to between 28 and 31.\n     * Since there is uncertainty about the maximum value, the range is not fixed.\n     * However, for the month of January, the range is always 1 to 31, thus it is fixed.\n     *\n     * @return {boolean} true if the set of values is fixed\n     */\n    isFixed() {\n        return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    minimum(){\n        return this._minSmallest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    largestMinimum(){\n        return this._minLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    maximum(){\n        return this._maxLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    smallestMaximum(){\n        return this._maxSmallest;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isValidValue(value) {\n        return (this.minimum() <= value && value <= this.maximum());\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @param {TemporalField} field\n     */\n    checkValidValue(value, field) {\n        var msg;\n        if (!this.isValidValue(value)) {\n            if (field != null) {\n                msg = ('Invalid value for ' + field + ' (valid values ' + (this.toString()) + '): ') + value;\n            } else {\n                msg = ('Invalid value (valid values ' + (this.toString()) + '): ') + value;\n            }\n            return assert(false, msg, DateTimeException);\n        }\n    }\n\n    /**\n     * Checks that the specified value is valid and fits in an {@code int}.\n     * <p>\n     * This validates that the value is within the valid range of values and that\n     * all valid values are within the bounds of an {@code int}.\n     * The field is only used to improve the error message.\n     *\n     * @param {number} value - the value to check\n     * @param {TemporalField} field - the field being checked, may be null\n     * @return {number} the value that was passed in\n     * @see #isValidIntValue(long)\n     */\n    checkValidIntValue(value, field) {\n        if (this.isValidIntValue(value) === false) {\n            throw new DateTimeException('Invalid int value for ' + field + ': ' + value);\n        }\n        return value;\n    }\n\n    /**\n     * Checks if the value is within the valid range and that all values\n     * in the range fit in an {@code int}.\n     * <p>\n     * This method combines {@link #isIntValue()} and {@link #isValidValue(long)}.\n     *\n     * @param {number} value - the value to check\n     * @return true if the value is valid and fits in an {@code int}\n     */\n    isValidIntValue(value) {\n        return this.isIntValue() && this.isValidValue(value);\n    }\n\n    /**\n     * Checks if all values in the range fit in an {@code int}.\n     * <p>\n     * This checks that all valid values are within the bounds of an {@code int}.\n     * <p>\n     * For example, the ISO month-of-year has values from 1 to 12, which fits in an {@code int}.\n     * By comparison, ISO nano-of-day runs from 1 to 86,400,000,000,000 which does not fit in an {@code int}.\n     * <p>\n     * This implementation uses {@link #getMinimum()} and {@link #getMaximum()}.\n     *\n     * @return boolean if a valid value always fits in an {@code int}\n     */\n    isIntValue() { // should be isSafeIntegerValue\n        return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if this range is equal to another range.\n     * <p>\n     * The comparison is based on the four values, minimum, largest minimum,\n     * smallest maximum and maximum.\n     * Only objects of type {@code ValueRange} are compared, other types return false.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other range\n     */\n    equals(other) {\n        if (other === this) {\n            return true;\n        }\n        if (other instanceof ValueRange) {\n            return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest &&\n                this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this range.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        var hash = this._minSmallest + this._minLargest << 16 + this._minLargest >> 48 + this._maxSmallest << 32 +\n            this._maxSmallest >> 32 + this._maxLargest << 48 + this._maxLargest >> 16;\n        return (hash ^ (hash >>> 32));\n    }\n    \n    /*\n     * Outputs this range as a String.\n     * \n     * The format will be '{min}/{largestMin} - {smallestMax}/{max}',\n     * where the largestMin or smallestMax sections may be omitted, together\n     * with associated slash, if they are the same as the min or max.\n     *\n     * @return {string} a string representation of this range, not null\n     */\n    toString() {\n        var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? '/' + (this.largestMinimum()) : '');\n        str += ' - ';\n        str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? '/' + (this.maximum()) : '');\n        return str;\n    }\n\n    /*\n     * called with 2 params: Obtains a fixed value range.\n     *\n     * This factory obtains a range where the minimum and maximum values are fixed.\n     * For example, the ISO month-of-year always runs from 1 to 12.\n     *\n     * @param min  the minimum value\n     * @param max  the maximum value\n     * @return the ValueRange for min, max, not null\n\n     * called with 3 params: Obtains a variable value range.\n     *\n     * This factory obtains a range where the minimum value is fixed and the maximum value may vary.\n     * For example, the ISO day-of-month always starts at 1, but ends between 28 and 31.\n     *\n     * @param min  the minimum value\n     * @param maxSmallest  the smallest maximum value\n     * @param maxLargest  the largest maximum value\n     * @return the ValueRange for min, smallest max, largest max, not null\n\n     * called with 4 params: Obtains a fully variable value range.\n     *\n     * This factory obtains a range where both the minimum and maximum value may vary.\n     *\n     * @param minSmallest  the smallest minimum value\n     * @param minLargest  the largest minimum value\n     * @param maxSmallest  the smallest maximum value\n     * @param maxLargest  the largest maximum value\n     *\n     * @return {ValueRange} the ValueRange for smallest min, largest min, smallest max, largest max, not null\n     */\n    static of() {\n        if (arguments.length === 2) {\n            return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);\n        } else if (arguments.length === 3) {\n            return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);\n        } else if (arguments.length === 4) {\n            return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);\n        } else {\n            return assert(false, 'Invalid number of arguments ' + arguments.length, IllegalArgumentException);\n        }\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/ValueRange.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {TemporalAccessor} from './TemporalAccessor';\n\n/**\n * Framework-level interface defining read-write access to a temporal object,\n * such as a date, time, offset or some combination of these.\n * <p>\n * This is the base interface type for date, time and offset objects that\n * are complete enough to be manipulated using plus and minus.\n * It is implemented by those classes that can provide and manipulate information\n * as {@link TemporalField fields} or {@link TemporalQuery queries}.\n * See {@link TemporalAccessor} for the read-only version of this interface.\n * <p>\n * Most date and time information can be represented as a number.\n * These are modeled using {@code TemporalField} with the number held using\n * a {@code long} to handle large values. Year, month and day-of-month are\n * simple examples of fields, but they also include instant and offsets.\n * See {@link ChronoField} for the standard set of fields.\n * <p>\n * Two pieces of date/time information cannot be represented by numbers,\n * the {@link Chronology chronology} and the {@link ZoneId time-zone}.\n * These can be accessed via {@link #query(TemporalQuery) queries} using\n * the static methods defined on {@link TemporalQueries}.\n * <p>\n * This interface is a framework-level interface that should not be widely\n * used in application code. Instead, applications should create and pass\n * around instances of concrete types, such as {@code LocalDate}.\n * There are many reasons for this, part of which is that implementations\n * of this interface may be in calendar systems other than ISO.\n * See {@link ChronoLocalDate} for a fuller discussion of the issues.\n *\n * <h3>When to implement</h3>\n * <p>\n * A class should implement this interface if it meets three criteria:\n * <p><ul>\n * <li>it provides access to date/time/offset information, as per {@code TemporalAccessor}\n * <li>the set of fields are contiguous from the largest to the smallest\n * <li>the set of fields are complete, such that no other field is needed to define the\n *  valid range of values for the fields that are represented\n * </ul><p>\n * <p>\n * Four examples make this clear:\n * <p><ul>\n * <li>{@code LocalDate} implements this interface as it represents a set of fields\n *  that are contiguous from days to forever and require no external information to determine\n *  the validity of each date. It is therefore able to implement plus/minus correctly.\n * <li>{@code LocalTime} implements this interface as it represents a set of fields\n *  that are contiguous from nanos to within days and require no external information to determine\n *  validity. It is able to implement plus/minus correctly, by wrapping around the day.\n * <li>{@code MonthDay}, the combination of month-of-year and day-of-month, does not implement\n *  this interface.  While the combination is contiguous, from days to months within years,\n *  the combination does not have sufficient information to define the valid range of values\n *  for day-of-month.  As such, it is unable to implement plus/minus correctly.\n * <li>The combination day-of-week and day-of-month (\"Friday the 13th\") should not implement\n *  this interface. It does not represent a contiguous set of fields, as days to weeks overlaps\n *  days to months.\n * </ul><p>\n *\n * @interface\n */\nexport class Temporal extends TemporalAccessor {}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/Temporal.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {UnsupportedTemporalTypeException} from '../errors';\n\nimport {ChronoField} from './ChronoField';\nimport {TemporalQueries} from './TemporalQueries';\n\nexport class TemporalAccessor {\n    /**\n     * Queries this date-time.\n     * <p>\n     * This queries this date-time using the specified query strategy object.\n     * <p>\n     * Queries are a key tool for extracting information from date-times.\n     * They exists to externalize the process of querying, permitting different\n     * approaches, as per the strategy design pattern.\n     * Examples might be a query that checks if the date is the day before February 29th\n     * in a leap year, or calculates the number of days to your next birthday.\n     * <p>\n     * The most common query implementations are method references, such as\n     * {@code LocalDate::from} and {@code ZoneId::from}.\n     * Further implementations are on {@link TemporalQueries}.\n     * Queries may also be defined by applications.\n     *\n     * @implSpec\n     * Implementations of this method must behave as follows:\n     * <pre>\n        if (query == TemporalQueries.zoneId()\n            || query == TemporalQueries.chronology()\n            || query == TemporalQueries.precision()) {\n                return null;\n        }\n        return query.queryFrom(this);\n     * </pre>\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    query(query) {\n        if (query === TemporalQueries.zoneId()\n                || query === TemporalQueries.chronology()\n                || query === TemporalQueries.precision()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Gets the value of the specified field as an {@code int}.\n     * <p>\n     * This queries the date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If the date-time cannot return the value, because the field is unsupported or for\n     * some other reason, an exception will be thrown.\n     *\n     * <h3>Specification for implementors</h3>\n     * Implementations must check and handle all fields defined in {@link ChronoField}.\n     * If the field is supported and has an {@code int} range, then the value of\n     * the field must be returned.\n     * If unsupported, then a {@code DateTimeException} must be thrown.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * <p>\n     * Implementations must not alter either this object.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws DateTimeException if the range of valid values for the field exceeds an {@code int}\n     * @throws DateTimeException if the value is outside the range of valid values for the field\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     * <p>\n     * All fields can be expressed as a {@code long} integer.\n     * This method returns an object that describes the valid range for that value.\n     * The value of this temporal object is used to enhance the accuracy of the returned range.\n     * If the date-time cannot return the range, because the field is unsupported or for\n     * some other reason, an exception will be thrown.\n     * <p>\n     * Note that the result only describes the minimum and maximum valid values\n     * and it is important not to read too much into them. For example, there\n     * could be values within the range that are invalid for the field.\n     *\n     * <h3>Specification for implementors</h3>\n     * Implementations must check and handle all fields defined in {@link ChronoField}.\n     * If the field is supported, then the range of the field must be returned.\n     * If unsupported, then a {@code DateTimeException} must be thrown.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessorl)}\n     * passing {@code this} as the argument.\n     * <p>\n     * Implementations must not alter either this object.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (this.isSupported(field)) {\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/TemporalAccessor.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * Common implementations of {@code TemporalQuery}.\n * <p>\n * This class provides common implementations of {@link TemporalQuery}.\n * These queries are primarily used as optimizations, allowing the internals\n * of other objects to be extracted effectively. Note that application code\n * can also use the {@code from(TemporalAccessor)} method on most temporal\n * objects as a method reference matching the query interface, such as\n * {@code LocalDate::from} and {@code ZoneId::from}.\n * <p>\n * There are two equivalent ways of using a {@code TemporalQuery}.\n * The first is to invoke the method on the interface directly.\n * The second is to use {@link TemporalAccessor#query(TemporalQuery)}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   dateTime = query.queryFrom(dateTime);\n *   dateTime = dateTime.query(query);\n * </pre>\n * It is recommended to use the second approach, {@code query(TemporalQuery)},\n * as it is a lot clearer to read in code.\n *\n */\nexport class TemporalQueries {\n\n    /**\n     * A strict query for the {@code ZoneId}.\n     * <p>\n     * This queries a {@code TemporalAccessor} for the zone.\n     * The zone is only returned if the date-time conceptually contains a {@code ZoneId}.\n     * It will not be returned if the date-time only conceptually has an {@code ZoneOffset}.\n     * Thus a {@link ZonedDateTime} will return the result of\n     * {@code getZone()}, but an {@link OffsetDateTime} will\n     * return null.\n     * <p>\n     * In most cases, applications should use {@link #ZONE} as this query is too strict.\n     * <p>\n     * The result from JDK classes implementing {@code TemporalAccessor} is as follows:<br>\n     * {@code LocalDate} returns null<br>\n     * {@code LocalTime} returns null<br>\n     * {@code LocalDateTime} returns null<br>\n     * {@code ZonedDateTime} returns the associated zone<br>\n     * {@code OffsetTime} returns null<br>\n     * {@code OffsetDateTime} returns null<br>\n     * {@code ChronoLocalDate} returns null<br>\n     * {@code ChronoLocalDateTime} returns null<br>\n     * {@code ChronoZonedDateTime} returns the associated zone<br>\n     * {@code Era} returns null<br>\n     * {@code DayOfWeek} returns null<br>\n     * {@code Month} returns null<br>\n     * {@code Year} returns null<br>\n     * {@code YearMonth} returns null<br>\n     * {@code MonthDay} returns null<br>\n     * {@code ZoneOffset} returns null<br>\n     * {@code Instant} returns null<br>\n     *\n     * @return a query that can obtain the zone ID of a temporal, not null\n     */\n    static zoneId() {\n        return TemporalQueries.ZONE_ID;\n    }\n\n    /**\n     * A query for the {@code Chronology}.\n     * <p>\n     * This queries a {@code TemporalAccessor} for the chronology.\n     * If the target {@code TemporalAccessor} represents a date, or part of a date,\n     * then it should return the chronology that the date is expressed in.\n     * As a result of this definition, objects only representing time, such as\n     * {@code LocalTime}, will return null.\n     * <p>\n     * The result from js-joda classes implementing {@code TemporalAccessor} is as follows:<br>\n     * {@code LocalDate} returns {@code IsoChronology.INSTANCE}<br>\n     * {@code LocalTime} returns null (does not represent a date)<br>\n     * {@code LocalDateTime} returns {@code IsoChronology.INSTANCE}<br>\n     * {@code ZonedDateTime} returns {@code IsoChronology.INSTANCE}<br>\n     * {@code OffsetTime} returns null (does not represent a date)<br>\n     * {@code OffsetDateTime} returns {@code IsoChronology.INSTANCE}<br>\n     * {@code ChronoLocalDate} returns the associated chronology<br>\n     * {@code ChronoLocalDateTime} returns the associated chronology<br>\n     * {@code ChronoZonedDateTime} returns the associated chronology<br>\n     * {@code Era} returns the associated chronology<br>\n     * {@code DayOfWeek} returns null (shared across chronologies)<br>\n     * {@code Month} returns {@code IsoChronology.INSTANCE}<br>\n     * {@code Year} returns {@code IsoChronology.INSTANCE}<br>\n     * {@code YearMonth} returns {@code IsoChronology.INSTANCE}<br>\n     * {@code MonthDay} returns null {@code IsoChronology.INSTANCE}<br>\n     * {@code ZoneOffset} returns null (does not represent a date)<br>\n     * {@code Instant} returns null (does not represent a date)<br>\n     * <p>\n     * The method {@link Chronology#from(TemporalAccessor)} can be used as a\n     * {@code TemporalQuery}\n     * That method is equivalent to this query, except that it throws an\n     * exception if a chronology cannot be obtained.\n     *\n     * @return {TemporalQuery} a query that can obtain the chronology of a temporal, not null\n     */\n    static chronology() {\n        return TemporalQueries.CHRONO;\n    }\n\n    /**\n     * A query for the smallest supported unit.\n     * <p>\n     * This queries a {@code TemporalAccessor} for the time precision.\n     * If the target {@code TemporalAccessor} represents a consistent or complete date-time,\n     * date or time then this must return the smallest precision actually supported.\n     * Note that fields such as {@code NANO_OF_DAY} and {@code NANO_OF_SECOND}\n     * are defined to always return ignoring the precision, thus this is the only\n     * way to find the actual smallest supported unit.\n     * For example, were {@code GregorianCalendar} to implement {@code TemporalAccessor}\n     * it would return a precision of {@code MILLIS}.\n     * <p>\n     * The result from js-joda classes implementing {@code TemporalAccessor} is as follows:<br>\n     * {@code LocalDate} returns {@code DAYS}<br>\n     * {@code LocalTime} returns {@code NANOS}<br>\n     * {@code LocalDateTime} returns {@code NANOS}<br>\n     * {@code ZonedDateTime} returns {@code NANOS}<br>\n     * {@code OffsetTime} returns {@code NANOS}<br>\n     * {@code OffsetDateTime} returns {@code NANOS}<br>\n     * {@code ChronoLocalDate} returns {@code DAYS}<br>\n     * {@code ChronoLocalDateTime} returns {@code NANOS}<br>\n     * {@code ChronoZonedDateTime} returns {@code NANOS}<br>\n     * {@code Era} returns {@code ERAS}<br>\n     * {@code DayOfWeek} returns {@code DAYS}<br>\n     * {@code Month} returns {@code MONTHS}<br>\n     * {@code Year} returns {@code YEARS}<br>\n     * {@code YearMonth} returns {@code MONTHS}<br>\n     * {@code MonthDay} returns null (does not represent a complete date or time)<br>\n     * {@code ZoneOffset} returns null (does not represent a date or time)<br>\n     * {@code Instant} returns {@code NANOS}<br>\n     *\n     * @return a query that can obtain the precision of a temporal, not null\n     */\n    static precision() {\n        return TemporalQueries.PRECISION;\n    }\n\n    /**\n     * A lenient query for the {@code ZoneId}, falling back to the {@code ZoneOffset}.\n     * <p>\n     * This queries a {@code TemporalAccessor} for the zone.\n     * It first tries to obtain the zone, using {@link #zoneId()}.\n     * If that is not found it tries to obtain the {@link #offset()}.\n     * <p>\n     * In most cases, applications should use this query rather than {@code #zoneId()}.\n     * <p>\n     * This query examines the {@link ChronoField#OFFSET_SECONDS offset-seconds}\n     * field and uses it to create a {@code ZoneOffset}.\n     * <p>\n     * The method {@link ZoneId#from(TemporalAccessor)} can be used as a\n     * {@code TemporalQuery} via a method reference, {@code ZoneId::from}.\n     * That method is equivalent to this query, except that it throws an\n     * exception if a zone cannot be obtained.\n     *\n     * @return a query that can obtain the zone ID or offset of a temporal, not null\n     */\n    static zone() {\n        return TemporalQueries.ZONE;\n    }\n\n    /**\n     * A query for {@code ZoneOffset} returning null if not found.\n     * <p>\n     * This returns a {@code TemporalQuery} that can be used to query a temporal\n     * object for the offset. The query will return null if the temporal\n     * object cannot supply an offset.\n     * <p>\n     * The query implementation examines the {@link ChronoField#OFFSET_SECONDS OFFSET_SECONDS}\n     * field and uses it to create a {@code ZoneOffset}.\n     * <p>\n     * The method {@link java.time.ZoneOffset#from(TemporalAccessor)} can be used as a\n     * {@code TemporalQuery} via a method reference, {@code ZoneOffset::from}.\n     * This query and {@code ZoneOffset::from} will return the same result if the\n     * temporal object contains an offset. If the temporal object does not contain\n     * an offset, then the method reference will throw an exception, whereas this\n     * query will return null.\n     *\n     * @return a query that can obtain the offset of a temporal, not null\n     */\n    static offset() {\n        return TemporalQueries.OFFSET;\n    }\n\n    /**\n     * A query for {@code LocalDate} returning null if not found.\n     * <p>\n     * This returns a {@code TemporalQuery} that can be used to query a temporal\n     * object for the local date. The query will return null if the temporal\n     * object cannot supply a local date.\n     * <p>\n     * The query implementation examines the {@link ChronoField#EPOCH_DAY EPOCH_DAY}\n     * field and uses it to create a {@code LocalDate}.\n     *\n     * @return a query that can obtain the date of a temporal, not null\n     */\n    static localDate() {\n        return TemporalQueries.LOCAL_DATE;\n    }\n\n    /**\n     * A query for {@code LocalTime} returning null if not found.\n     * <p>\n     * This returns a {@code TemporalQuery} that can be used to query a temporal\n     * object for the local time. The query will return null if the temporal\n     * object cannot supply a local time.\n     * <p>\n     * The query implementation examines the {@link ChronoField#NANO_OF_DAY NANO_OF_DAY}\n     * field and uses it to create a {@code LocalTime}.\n     *\n     * @return a query that can obtain the time of a temporal, not null\n     */\n    static localTime() {\n        return TemporalQueries.LOCAL_TIME;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/TemporalQueries.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {Enum} from '../Enum';\n\n/**\n * Enumeration of different ways to resolve dates and times.\n * \n * Parsing a text string occurs in two phases.\n * Phase 1 is a basic text parse according to the fields added to the builder.\n * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n * This style is used to control how phase 2, resolving, happens.\n *\n * <h3>Static properties of Class {@link DateTimeFormatter}</h3>\n *\n * ResolverStyle.STRICT = new ResolverStyle('STRICT');\n *\n * Style to resolve dates and times strictly.\n *\n * Using strict resolution will ensure that all parsed values are within\n * the outer range of valid values for the field. Individual fields may\n * be further processed for strictness.\n *\n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using strict mode will ensure that the day-of-month is valid\n * for the year-month, rejecting invalid values.\n *\n * ResolverStyle.SMART = new ResolverStyle('SMART');\n *\n * Style to resolve dates and times in a smart, or intelligent, manner.\n *\n * Using smart resolution will perform the sensible default for each\n * field, which may be the same as strict, the same as lenient, or a third\n * behavior. Individual fields will interpret this differently.\n *\n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using smart mode will ensure that the day-of-month is from\n * 1 to 31, converting any value beyond the last valid day-of-month to be\n * the last valid day-of-month.\n *\n * ResolverStyle.LENIENT = new ResolverStyle('LENIENT');\n *\n * Style to resolve dates and times leniently.\n *\n * Using lenient resolution will resolve the values in an appropriate\n * lenient manner. Individual fields will interpret this differently.\n *\n * For example, lenient mode allows the month in the ISO calendar system\n * to be outside the range 1 to 12.\n * For example, month 15 is treated as being 3 months after month 12.\n *\n */\nexport class ResolverStyle extends Enum {}\n\n/**\n * Style to resolve dates and times strictly.\n * \n * Using strict resolution will ensure that all parsed values are within\n * the outer range of valid values for the field. Individual fields may\n * be further processed for strictness.\n * \n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using strict mode will ensure that the day-of-month is valid\n * for the year-month, rejecting invalid values.\n */\nResolverStyle.STRICT = new ResolverStyle('STRICT');\n/**\n * Style to resolve dates and times in a smart, or intelligent, manner.\n * \n * Using smart resolution will perform the sensible default for each\n * field, which may be the same as strict, the same as lenient, or a third\n * behavior. Individual fields will interpret this differently.\n * \n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using smart mode will ensure that the day-of-month is from\n * 1 to 31, converting any value beyond the last valid day-of-month to be\n * the last valid day-of-month.\n */\nResolverStyle.SMART = new ResolverStyle('SMART');\n/**\n * Style to resolve dates and times leniently.\n * \n * Using lenient resolution will resolve the values in an appropriate\n * lenient manner. Individual fields will interpret this differently.\n * \n * For example, lenient mode allows the month in the ISO calendar system\n * to be outside the range 1 to 12.\n * For example, month 15 is treated as being 3 months after month 12.\n */\nResolverStyle.LENIENT = new ResolverStyle('LENIENT');\n\n\n/** WEBPACK FOOTER **\n ** ./src/format/ResolverStyle.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {ChronoField} from '../temporal/ChronoField';\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\nimport {Temporal} from '../temporal/Temporal';\n\nimport {LocalDate} from '../LocalDate';\n\n/**\n * A date without time-of-day or time-zone in an arbitrary chronology, intended\n * for advanced globalization use cases.\n * <p>\n * <b>Most applications should declare method signatures, fields and variables\n * as {@link LocalDate}, not this interface.</b>\n * <p>\n * A {@code ChronoLocalDate} is the abstract representation of a date where the\n * {@code Chronology chronology}, or calendar system, is pluggable.\n * The date is defined in terms of fields expressed by {@link TemporalField},\n * where most common implementations are defined in {@link ChronoField}.\n * The chronology defines how the calendar system operates and the meaning of\n * the standard fields.\n *\n * <h4>When to use this interface</h4>\n * The design of the API encourages the use of {@code LocalDate} rather than this\n * interface, even in the case where the application needs to deal with multiple\n * calendar systems. The rationale for this is explored in the following documentation.\n * <p>\n * The primary use case where this interface should be used is where the generic\n * type parameter {@code <C>} is fully defined as a specific chronology.\n * In that case, the assumptions of that chronology are known at development\n * time and specified in the code.\n * <p>\n * When the chronology is defined in the generic type parameter as ? or otherwise\n * unknown at development time, the rest of the discussion below applies.\n * <p>\n * To emphasize the point, declaring a method signature, field or variable as this\n * interface type can initially seem like the sensible way to globalize an application,\n * however it is usually the wrong approach.\n * As such, it should be considered an application-wide architectural decision to choose\n * to use this interface as opposed to {@code LocalDate}.\n *\n * <h4>Architectural issues to consider</h4>\n * These are some of the points that must be considered before using this interface\n * throughout an application.\n * <p>\n * 1) Applications using this interface, as opposed to using just {@code LocalDate},\n * face a significantly higher probability of bugs. This is because the calendar system\n * in use is not known at development time. A key cause of bugs is where the developer\n * applies assumptions from their day-to-day knowledge of the ISO calendar system\n * to code that is intended to deal with any arbitrary calendar system.\n * The section below outlines how those assumptions can cause problems\n * The primary mechanism for reducing this increased risk of bugs is a strong code review process.\n * This should also be considered a extra cost in maintenance for the lifetime of the code.\n * <p>\n * 2) This interface does not enforce immutability of implementations.\n * While the implementation notes indicate that all implementations must be immutable\n * there is nothing in the code or type system to enforce this. Any method declared\n * to accept a {@code ChronoLocalDate} could therefore be passed a poorly or\n * maliciously written mutable implementation.\n * <p>\n * 3) Applications using this interface  must consider the impact of eras.\n * {@code LocalDate} shields users from the concept of eras, by ensuring that {@code getYear()}\n * returns the proleptic year. That decision ensures that developers can think of\n * {@code LocalDate} instances as consisting of three fields - year, month-of-year and day-of-month.\n * By contrast, users of this interface must think of dates as consisting of four fields -\n * era, year-of-era, month-of-year and day-of-month. The extra era field is frequently\n * forgotten, yet it is of vital importance to dates in an arbitrary calendar system.\n * For example, in the Japanese calendar system, the era represents the reign of an Emperor.\n * Whenever one reign ends and another starts, the year-of-era is reset to one.\n * <p>\n * 4) The only agreed international standard for passing a date between two systems\n * is the ISO-8601 standard which requires the ISO calendar system. Using this interface\n * throughout the application will inevitably lead to the requirement to pass the date\n * across a network or component boundary, requiring an application specific protocol or format.\n * <p>\n * 5) Long term persistence, such as a database, will almost always only accept dates in the\n * ISO-8601 calendar system (or the related Julian-Gregorian). Passing around dates in other\n * calendar systems increases the complications of interacting with persistence.\n * <p>\n * 6) Most of the time, passing a {@code ChronoLocalDate} throughout an application\n * is unnecessary, as discussed in the last section below.\n *\n * <h4>False assumptions causing bugs in multi-calendar system code</h4>\n * As indicated above, there are many issues to consider when try to use and manipulate a\n * date in an arbitrary calendar system. These are some of the key issues.\n * <p>\n * Code that queries the day-of-month and assumes that the value will never be more than\n * 31 is invalid. Some calendar systems have more than 31 days in some months.\n * <p>\n * Code that adds 12 months to a date and assumes that a year has been added is invalid.\n * Some calendar systems have a different number of months, such as 13 in the Coptic or Ethiopic.\n * <p>\n * Code that adds one month to a date and assumes that the month-of-year value will increase\n * by one or wrap to the next year is invalid. Some calendar systems have a variable number\n * of months in a year, such as the Hebrew.\n * <p>\n * Code that adds one month, then adds a second one month and assumes that the day-of-month\n * will remain close to its original value is invalid. Some calendar systems have a large difference\n * between the length of the longest month and the length of the shortest month.\n * For example, the Coptic or Ethiopic have 12 months of 30 days and 1 month of 5 days.\n * <p>\n * Code that adds seven days and assumes that a week has been added is invalid.\n * Some calendar systems have weeks of other than seven days, such as the French Revolutionary.\n * <p>\n * Code that assumes that because the year of {@code date1} is greater than the year of {@code date2}\n * then {@code date1} is after {@code date2} is invalid. This is invalid for all calendar systems\n * when referring to the year-of-era, and especially untrue of the Japanese calendar system\n * where the year-of-era restarts with the reign of every new Emperor.\n * <p>\n * Code that treats month-of-year one and day-of-month one as the start of the year is invalid.\n * Not all calendar systems start the year when the month value is one.\n * <p>\n * In general, manipulating a date, and even querying a date, is wide open to bugs when the\n * calendar system is unknown at development time. This is why it is essential that code using\n * this interface is subjected to additional code reviews. It is also why an architectural\n * decision to avoid this interface type is usually the correct one.\n *\n * <h4>Using LocalDate instead</h4>\n * The primary alternative to using this interface throughout your application is as follows.\n * <p><ul>\n * <li>Declare all method signatures referring to dates in terms of {@code LocalDate}.\n * <li>Either store the chronology (calendar system) in the user profile or lookup\n *  the chronology from the user locale\n * <li>Convert the ISO {@code LocalDate} to and from the user's preferred calendar system during\n *  printing and parsing\n * </ul><p>\n * This approach treats the problem of globalized calendar systems as a localization issue\n * and confines it to the UI layer. This approach is in keeping with other localization\n * issues in the java platform.\n * <p>\n * As discussed above, performing calculations on a date where the rules of the calendar system\n * are pluggable requires skill and is not recommended.\n * Fortunately, the need to perform calculations on a date in an arbitrary calendar system\n * is extremely rare. For example, it is highly unlikely that the business rules of a library\n * book rental scheme will allow rentals to be for one month, where meaning of the month\n * is dependent on the user's preferred calendar system.\n * <p>\n * A key use case for calculations on a date in an arbitrary calendar system is producing\n * a month-by-month calendar for display and user interaction. Again, this is a UI issue,\n * and use of this interface solely within a few methods of the UI layer may be justified.\n * <p>\n * In any other part of the system, where a date must be manipulated in a calendar system\n * other than ISO, the use case will generally specify the calendar system to use.\n * For example, an application may need to calculate the next Islamic or Hebrew holiday\n * which may require manipulating the date.\n * This kind of use case can be handled as follows:\n * <p><ul>\n * <li>start from the ISO {@code LocalDate} being passed to the method\n * <li>convert the date to the alternate calendar system, which for this use case is known\n *  rather than arbitrary\n * <li>perform the calculation\n * <li>convert back to {@code LocalDate}\n * </ul><p>\n * Developers writing low-level frameworks or libraries should also avoid this interface.\n * Instead, one of the two general purpose access interfaces should be used.\n * Use {@link TemporalAccessor} if read-only access is required, or use {@link Temporal}\n * if read-write access is required.\n *\n * <h3>Specification for implementors</h3>\n * This interface must be implemented with care to ensure other classes operate correctly.\n * All implementations that can be instantiated must be final, immutable and thread-safe.\n * Subclasses should be Serializable wherever possible.\n * <p>\n * Additional calendar systems may be added to the system.\n * See {@link Chronology} for more details.\n * <p>\n * In JDK 8, this is an interface with default methods.\n * Since there are no default methods in JDK 7, an abstract class is used.\n */\nexport class ChronoLocalDate extends Temporal {\n\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.DAYS;\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toEpochDay());\n        } else if (query === TemporalQueries.localTime() || query === TemporalQueries.zone() ||\n                query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    adjustInto(temporal) {\n        return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/chrono/ChronoLocalDate.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from '../assert';\nimport {Enum} from '../Enum';\n\n\n/**\n * Strategy for querying a temporal object.\n * <p>\n * Queries are a key tool for extracting information from temporal objects.\n * They exist to externalize the process of querying, permitting different\n * approaches, as per the strategy design pattern.\n * Examples might be a query that checks if the date is the day before February 29th\n * in a leap year, or calculates the number of days to your next birthday.\n * <p>\n * The {@link TemporalField} interface provides another mechanism for querying\n * temporal objects. That interface is limited to returning a {@code long}.\n * By contrast, queries can return any type.\n * <p>\n * There are two equivalent ways of using a {@code TemporalQuery}.\n * The first is to invoke the method on this interface directly.\n * The second is to use {@link TemporalAccessor#query(TemporalQuery)}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   temporal = thisQuery.queryFrom(temporal);\n *   temporal = temporal.query(thisQuery);\n * </pre>\n * It is recommended to use the second approach, {@code query(TemporalQuery)},\n * as it is a lot clearer to read in code.\n * <p>\n * The most common implementations are method references, such as\n * {@code LocalDate::from} and {@code ZoneId::from}.\n * Further implementations are on {@link TemporalQueries}.\n * Queries may also be defined by applications.\n *\n * <h3>Specification for implementors</h3>\n * This interface places no restrictions on the mutability of implementations,\n * however immutability is strongly recommended.\n * \n * @interface\n */\nexport class TemporalQuery  extends Enum {\n    /**\n     * Queries the specified temporal object.\n     * <p>\n     * This queries the specified temporal object to return an object using the logic\n     * encapsulated in the implementing class.\n     * Examples might be a query that checks if the date is the day before February 29th\n     * in a leap year, or calculates the number of days to your next birthday.\n     * <p>\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#query(TemporalQuery)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisQuery.queryFrom(temporal);\n     *   temporal = temporal.query(thisQuery);\n     * </pre>\n     * It is recommended to use the second approach, {@code query(TemporalQuery)},\n     * as it is a lot clearer to read in code.\n     *\n     * <h3>Specification for implementors</h3>\n     * The implementation must take the input object and query it.\n     * The implementation defines the logic of the query and is responsible for\n     * documenting that logic.\n     * It may use any method on {@code TemporalAccessor} to determine the result.\n     * The input object must not be altered.\n     * <p>\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by {@link TemporalQueries#chronology() querying the chronology}.\n     * <p>\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to query, not null\n     * @return the queried value, may return null to indicate not found\n     * @throws DateTimeException if unable to query\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    queryFrom(temporal){\n        abstractMethodFail('queryFrom');\n    }\n\n}\n\n/**\n * Factory to create something similar to the JSR-310 {TemporalQuery} interface, takes a function and returns a new TemporalQuery object that presents that function\n * as the queryFrom() function.\n * @param name for the underlying Enum\n * @param queryFromFunction\n */\nexport function createTemporalQuery(name, queryFromFunction) {\n    class ExtendedTemporalQuery extends TemporalQuery {\n\n    }\n\n    ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n    return new ExtendedTemporalQuery(name);\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/TemporalQuery.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull} from '../assert';\n\nimport {DateTimeParseException, NullPointerException} from '../errors';\n\nimport {Period} from '../Period';\n\nimport {ParsePosition} from './ParsePosition';\nimport {DateTimeBuilder} from './DateTimeBuilder';\nimport {DateTimeParseContext} from './DateTimeParseContext';\nimport {DateTimePrintContext} from './DateTimePrintContext';\nimport {DateTimeFormatterBuilder} from './DateTimeFormatterBuilder';\nimport {SignStyle} from './SignStyle';\nimport {StringBuilder} from './StringBuilder';\nimport {ResolverStyle} from './ResolverStyle';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {createTemporalQuery} from '../temporal/TemporalQuery';\n\n/**\n *\n * <h3>Static properties of Class {@link DateTimeFormatter}</h3>\n *\n * DateTimeFormatter.ISO_LOCAL_DATE\n *\n * DateTimeFormatter.ISO_LOCAL_TIME\n *\n * DateTimeFormatter.ISO_LOCAL_DATE_TIME\n *\n */\nexport class DateTimeFormatter {\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query that provides access to the excess days that were parsed.\n     * <p>\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null period, with a zero period returned instead of null.\n     * <p>\n     * There are two situations where this query may return a non-zero period.\n     * <ul>\n     * <li>If the {@code ResolverStyle} is {@code LENIENT} and a time is parsed\n     *  without a date, then the complete result of the parse consists of a\n     *  {@code LocalTime} and an excess {@code Period} in days.\n     *\n     * <li>If the {@code ResolverStyle} is {@code SMART} and a time is parsed\n     *  without a date where the time is 24:00:00, then the complete result of\n     *  the parse consists of a {@code LocalTime} of 00:00:00 and an excess\n     *  {@code Period} of one day.\n     * </ul>\n     * <p>\n     * In both cases, if a complete {@code ChronoLocalDateTime} or {@code Instant}\n     * is parsed, then the excess days are added to the date part.\n     * As a result, this query will return a zero period.\n     * <p>\n     * The {@code SMART} behaviour handles the common \"end of day\" 24:00 value.\n     * Processing in {@code LENIENT} mode also produces the same result:\n     * <pre>\n     *  Text to parse        Parsed object                         Excess days\n     *  \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO\n     *  \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO\n     *  \"00:00\"              LocalTime.of(0, 0)                    ZERO\n     *  \"24:00\"              LocalTime.of(0, 0)                    Period.ofDays(1)\n     * </pre>\n     * The query can be used as follows:\n     * <pre>\n     *  TemporalAccessor parsed = formatter.parse(str);\n     *  LocalTime time = parsed.query(LocalTime.FROM);\n     *  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());\n     * </pre>\n     * @return {TemporalQuery} a query that provides access to the excess days that were parsed\n     */\n    static parsedExcessDays() {\n        return DateTimeFormatter.PARSED_EXCESS_DAYS;\n    }\n\n    /**\n     * A query that provides access to whether a leap-second was parsed.\n     * <p>\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null boolean, true if parsing saw a leap-second, false if not.\n     * <p>\n     * Instant parsing handles the special \"leap second\" time of '23:59:60'.\n     * Leap seconds occur at '23:59:60' in the UTC time-zone, but at other\n     * local times in different time-zones. To avoid this potential ambiguity,\n     * the handling of leap-seconds is limited to\n     * {@link DateTimeFormatterBuilder#appendInstant()}, as that method\n     * always parses the instant with the UTC zone offset.\n     * <p>\n     * If the time '23:59:60' is received, then a simple conversion is applied,\n     * replacing the second-of-minute of 60 with 59. This query can be used\n     * on the parse result to determine if the leap-second adjustment was made.\n     * The query will return one second of excess if it did adjust to remove\n     * the leap-second, and zero if not. Note that applying a leap-second\n     * smoothing mechanism, such as UTC-SLS, is the responsibility of the\n     * application, as follows:\n     * <pre>\n     *  TemporalAccessor parsed = formatter.parse(str);\n     *  Instant instant = parsed.query(Instant::from);\n     *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n     *    // validate leap-second is correct and apply correct smoothing\n     *  }\n     * </pre>\n     * @return a query that provides access to whether a leap-second was parsed\n     */\n    static parsedLeapSecond() {\n        return DateTimeFormatter.PARSED_LEAP_SECOND;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer/parser to use, not null\n     * @param locale  the locale to use, not null\n     * @param decimalStyle  the decimal style to use, not null\n     * @param resolverStyle  the resolver style to use, not null\n     * @param resolverFields  the fields to use during resolving, null for all fields\n     * @param chrono  the chronology to use, null for no override\n     * @param zone  the zone to use, null for no override\n     */\n    constructor(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono=IsoChronology.INSTANCE, zone) {\n        assert(printerParser != null);\n        assert(decimalStyle != null);\n        assert(resolverStyle != null);\n        /**\n         * The printer and/or parser to use, not null.\n         */\n        this._printerParser = printerParser;\n        /**\n         * The locale to use for formatting. // nyi\n         */\n        this._locale = locale;\n        /**\n         * The symbols to use for formatting, not null.\n         */\n        this._decimalStyle = decimalStyle;\n        /**\n         * The resolver style to use, not null.\n         */\n        this._resolverStyle = resolverStyle;\n        /**\n         * The fields to use in resolving, null for all fields.\n         */\n        this._resolverFields = resolverFields;\n        /**\n         * The chronology to use for formatting, null for no override.\n         */\n        this._chrono = chrono;\n        /**\n         * The zone to use for formatting, null for no override. // nyi\n         */\n        this._zone = zone;\n    }\n\n    locale() {\n        return this._locale;\n    }\n\n    decimalStyle() {\n        return this._decimalStyle;\n    }\n\n    chronology() {\n        return this._chrono;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override chronology.\n     *\n     * This returns a formatter with similar state to this formatter but\n     * with the override chronology set.\n     * By default, a formatter has no override chronology, returning null.\n     *\n     * If an override is added, then any date that is printed or parsed will be affected.\n     *\n     * When printing, if the {@code Temporal} object contains a date then it will\n     * be converted to a date in the override chronology.\n     * Any time or zone will be retained unless overridden.\n     * The converted result will behave in a manner equivalent to an implementation\n     * of {@code ChronoLocalDate},{@code ChronoLocalDateTime} or {@code ChronoZonedDateTime}.\n     *\n     * When parsing, the override chronology will be used to interpret the\n     * {@linkplain ChronoField fields} into a date unless the\n     * formatter directly parses a valid chronology.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param chrono  the new chronology, not null\n     * @return a formatter based on this formatter with the requested override chronology, not null\n     */\n    withChronology(chrono) {\n        if (this._chrono != null && this._chrono.equals(chrono)) {\n            return this;\n        }\n        return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle,\n            this._resolverStyle, this._resolverFields, chrono, this._zone);\n    }\n\n    /**\n     * not yet supported\n     * @returns {DateTimeFormatter}\n     */\n    withLocal(){\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n     /**\n      * Formats a date-time object using this formatter.\n      * <p>\n      * This formats the date-time to a String using the rules of the formatter.\n      *\n      * @param {TemporalAccessor} temporal  the temporal object to print, not null\n      * @return {String} the printed string, not null\n      * @throws DateTimeException if an error occurs during formatting\n      */\n     format(temporal) {\n         var buf = new StringBuilder(32);\n         this._formatTo(temporal, buf);\n         return buf.toString();\n     }\n\n     //-----------------------------------------------------------------------\n     /**\n      * Formats a date-time object to an {@code Appendable} using this formatter.\n      * <p>\n      * This formats the date-time to the specified destination.\n      * {@link Appendable} is a general purpose interface that is implemented by all\n      * key character output classes including {@code StringBuffer}, {@code StringBuilder},\n      * {@code PrintStream} and {@code Writer}.\n      * <p>\n      * Although {@code Appendable} methods throw an {@code IOException}, this method does not.\n      * Instead, any {@code IOException} is wrapped in a runtime exception.\n      *\n      * @param {TemporalAccessor} temporal - the temporal object to print, not null\n      * @param {StringBuilder} appendable - the appendable to print to, not null\n      * @throws DateTimeException if an error occurs during formatting\n      */\n     _formatTo(temporal, appendable) {\n         requireNonNull(temporal, 'temporal');\n         requireNonNull(appendable, 'appendable');\n         var context = new DateTimePrintContext(temporal, this);\n         this._printerParser.print(context, appendable);\n     }\n\n    /**\n     * function overloading for {@link DateTimeFormatter.parse}\n     *\n     * if called with one arg {@link DateTimeFormatter.parse1} is called\n     * otherwise {@link DateTimeFormatter.parse2}\n     *\n     * @param {string} text\n     * @param {TemporalQuery} type\n     * @return {TemporalAccessor}\n     */\n    parse(text, type){\n        if(arguments.length === 1){\n            return this.parse1(text);\n        } else {\n            return this.parse2(text, type);\n        }\n    }\n\n    /**\n     * Fully parses the text producing a temporal object.\n     * <p>\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link #parse(CharSequence, TemporalQuery)}.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     * <p>\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param {String} text  the text to parse, not null\n     * @return {TemporalAccessor} the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    parse1(text) {\n        requireNonNull(text, 'text');\n        try {\n            return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n        } catch (ex) {\n            if(ex instanceof DateTimeParseException){\n                throw ex;\n            } else {\n                throw this._createError(text, ex);\n            }\n        }\n    }\n\n    /**\n     * Fully parses the text producing a temporal object.\n     *\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link #parse(CharSequence, TemporalQuery)}.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     *\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @param type the type to extract, not null\n * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    parse2(text, type) {\n        requireNonNull(text, 'text');\n        requireNonNull(type, 'type');\n        try {\n            var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n            return builder.build(type);\n        } catch (ex) {\n            if(ex instanceof DateTimeParseException){\n                throw ex;\n            } else {\n                throw this._createError(text, ex);\n            }\n        }\n    }\n\n    _createError(text, ex) {\n        var abbr = '';\n        if (text.length > 64) {\n            abbr = text.subString(0, 64) + '...';\n        } else {\n            abbr = text;\n        }\n        return new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed: ' + ex.message, text, 0, ex);\n    }\n\n\n    /**\n     * Parses the text to a builder.\n     * <p>\n     * This parses to a {@code DateTimeBuilder} ensuring that the text is fully parsed.\n     * This method throws {@link DateTimeParseException} if unable to parse, or\n     * some other {@code DateTimeException} if another date/time problem occurs.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, null if parsing whole string\n     * @return the engine representing the result of the parse, not null\n     * @throws DateTimeParseException if the parse fails\n     */\n    _parseToBuilder(text, position) {\n        var pos = (position != null ? position : new ParsePosition(0));\n        var result = this._parseUnresolved0(text, pos);\n        if (result == null || pos.getErrorIndex() >= 0 || (position == null && pos.getIndex() < text.length)) {\n            var abbr = '';\n            if (text.length > 64) {\n                abbr = text.substr(0, 64).toString() + '...';\n            } else {\n                abbr = text;\n            }\n            if (pos.getErrorIndex() >= 0) {\n                throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed at index ' +\n                        pos.getErrorIndex(), text, pos.getErrorIndex());\n            } else {\n                throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed, unparsed text found at index ' +\n                        pos.getIndex(), text, pos.getIndex());\n            }\n        }\n        return result.toBuilder();\n    }\n\n    /**\n     * Parses the text using this formatter, without resolving the result, intended\n     * for advanced use cases.\n     * <p>\n     * Parsing is implemented as a two-phase operation.\n     * First, the text is parsed using the layout defined by the formatter, producing\n     * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.\n     * Second, the parsed data is <em>resolved</em>, by validating, combining and\n     * simplifying the various fields into more useful ones.\n     * This method performs the parsing stage but not the resolving stage.\n     * <p>\n     * The result of this method is {@code TemporalAccessor} which represents the\n     * data as seen in the input. Values are not validated, thus parsing a date string\n     * of '2012-00-65' would result in a temporal with three fields - year of '2012',\n     * month of '0' and day-of-month of '65'.\n     * <p>\n     * The text will be parsed from the specified start {@code ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@code ParsePosition}\n     * will be updated with the index at the end of parsing.\n     * <p>\n     * Errors are returned using the error index field of the {@code ParsePosition}\n     * instead of {@code DateTimeParseException}.\n     * The returned error index will be set to an index indicative of the error.\n     * Callers must check for errors before using the context.\n     * <p>\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     * <p>\n     * This method is intended for advanced use cases that need access to the\n     * internal state during parsing. Typical application code should use\n     * {@link #parse(CharSequence, TemporalQuery)} or the parse method on the target type.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed text, null if the parse results in an error\n     * @throws DateTimeException if some problem occurs during parsing\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    parseUnresolved(text, position) {\n        return this._parseUnresolved0(text, position);\n    }\n\n    _parseUnresolved0(text, position) {\n        assert(text != null, 'text', NullPointerException);\n        assert(position != null, 'position', NullPointerException);\n        var context = new DateTimeParseContext(this);\n        var pos = position.getIndex();\n        pos = this._printerParser.parse(context, text, pos);\n        if (pos < 0) {\n            position.setErrorIndex(~pos);  // index not updated from input\n            return null;\n        }\n        position.setIndex(pos);  // errorIndex not updated from input\n        return context.toParsed();\n    }\n\n    /**\n     * Returns the formatter as a composite printer parser.\n     *\n     * @param {boolean} optional  whether the printer/parser should be optional\n     * @return {CompositePrinterParser} the printer/parser, not null\n     */\n    toPrinterParser(optional) {\n        return this._printerParser.withOptional(optional);\n    }\n\n    toString() {\n        var pattern = this._printerParser.toString();\n        return pattern.indexOf('[') === 0 ? pattern : pattern.substring(1, pattern.length - 1);\n    }\n\n}\n\nexport function _init() {\n\n    DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendLiteral('-')\n        .appendValue(ChronoField.MONTH_OF_YEAR, 2)\n        .appendLiteral('-')\n        .appendValue(ChronoField.DAY_OF_MONTH, 2)\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.HOUR_OF_DAY, 2)\n        .appendLiteral(':')\n        .appendValue(ChronoField.MINUTE_OF_HOUR, 2)\n        .optionalStart()\n        .appendLiteral(':')\n        .appendValue(ChronoField.SECOND_OF_MINUTE, 2)\n        .optionalStart()\n        .appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true)\n        .toFormatter(ResolverStyle.STRICT);\n\n    DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_DATE)\n        .appendLiteral('T')\n        .append(DateTimeFormatter.ISO_LOCAL_TIME)\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .appendInstant()\n        .toFormatter(ResolverStyle.STRICT);\n\n    DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_DATE_TIME)\n        .appendOffsetId()\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder()\n        .append(DateTimeFormatter.ISO_OFFSET_DATE_TIME)\n        .optionalStart()\n        .appendLiteral('[')\n        .parseCaseSensitive()\n        .appendZoneId()\n        // .appendZoneRegionId()\n        .appendLiteral(']')\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery('PARSED_EXCESS_DAYS', (temporal) => {\n        if (temporal instanceof DateTimeBuilder) {\n            return temporal.excessDays;\n        } else {\n            return Period.ZERO;\n        }\n    });\n\n    DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery('PARSED_LEAP_SECOND', (temporal) => {\n        if (temporal instanceof DateTimeBuilder) {\n            return temporal.leapSecond;\n        } else {\n            return false;\n        }\n    });\n\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/format/DateTimeFormatter.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos  \n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MathUtil} from './MathUtil';\nimport {requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException, ArithmeticException, DateTimeParseException} from './errors';\n\nimport {IsoChronology} from './chrono/IsoChronology';\n\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalAmount} from './temporal/TemporalAmount';\n\nimport {LocalDate} from './LocalDate';\n\n/**\n * The pattern for parsing.\n */\nconst PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;\n\n/**\n * A date-based amount of time, such as '2 years, 3 months and 4 days'.\n * <p>\n * This class models a quantity or amount of time in terms of years, months and days.\n * See {@link Duration} for the time-based equivalent to this class.\n * <p>\n * Durations and period differ in their treatment of daylight savings time\n * when added to {@link ZonedDateTime}. A {@code Duration} will add an exact\n * number of seconds, thus a duration of one day is always exactly 24 hours.\n * By contrast, a {@link Period} will add a conceptual day, trying to maintain\n * the local time.\n * <p>\n * For example, consider adding a period of one day and a duration of one day to\n * 18:00 on the evening before a daylight savings gap. The {@link Period} will add\n * the conceptual day and result in a {@code ZonedDateTime} at 18:00 the following day.\n * By contrast, the {@code Duration} will add exactly 24 hours, resulting in a\n * {@code ZonedDateTime} at 19:00 the following day (assuming a one hour DST gap).\n * <p>\n * The supported units of a period are {@link ChronoUnit#YEARS YEARS},\n * {@link ChronoUnit#MONTHS MONTHS} and {@link ChronoUnit#DAYS DAYS}.\n * All three fields are always present, but may be set to zero.\n * <p>\n * The period may be used with any calendar system.\n * The meaning of a 'year' or 'month' is only applied when the object is added to a date.\n * <p>\n * The period is modeled as a directed amount of time, meaning that individual parts of the\n * period may be negative.\n * <p>\n * The months and years fields may be {@linkplain #normalized() normalized}.\n * The normalization assumes a 12 month year, so is not appropriate for all calendar systems.\n *\n * <h3>Static properties of Class {@link Period}</h3>\n *\n * Period.ZERO\n *\n * A constant for a period of zero.\n *\n */\nexport class Period extends TemporalAmount /* extends ChronoPeriod */ {\n\n    /**\n     * do not call the constructor directly\n     * use a factory method instead\n     *\n     * @param {number} years\n     * @param {number} months\n     * @param {number} days\n     * @private\n     */\n    constructor(years, months, days){\n        super();\n        if((years | months | days) === 0){\n            return Period.ZERO;\n        }\n        Period._validate(years, months, days);\n        /**\n         * The number of years.\n         */\n        this._years = years;\n        /**\n         * The number of months.\n         */\n        this._months =  months;\n        /**\n         * The number of days.\n         */\n        this._days = days;\n    }\n\n    static _validate(years, month, days){\n        requireNonNull(years, 'years');\n        requireNonNull(month, 'month');\n        requireNonNull(days, 'days');\n        MathUtil.safeToInt(years);\n        MathUtil.safeToInt(month);\n        MathUtil.safeToInt(days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} representing a number of years.\n     * <p>\n     * The resulting period will have the specified years.\n     * The months and days units will be zero.\n     *\n     * @param {number} years - the number of years, positive or negative\n     * @return {Period} the period of years, not null\n     */\n    static ofYears(years) {\n        return Period.create(years, 0, 0);\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of months.\n     * <p>\n     * The resulting period will have the specified months.\n     * The years and days units will be zero.\n     *\n     * @param {number} months - the number of months, positive or negative\n     * @return {Period} the period of months, not null\n     */\n    static ofMonths(months) {\n        return Period.create(0, months, 0);\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of weeks.\n     * <p>\n     * The resulting period will have days equal to the weeks multiplied by seven.\n     * The years and months units will be zero.\n     *\n     * @param {number} weeks - the number of weeks, positive or negative\n     * @return {Period} the period of days, not null\n     */\n    static ofWeeks(weeks) {\n        return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of days.\n     * <p>\n     * The resulting period will have the specified days.\n     * The years and months units will be zero.\n     *\n     * @param {number} days - the number of days, positive or negative\n     * @return {Period} the period of days, not null\n     */\n    static ofDays(days) {\n        return Period.create(0, 0, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} representing a number of years, months and days.\n     * <p>\n     * This creates an instance based on years, months and days.\n     *\n     * @param {!number} years - the amount of years, may be negative\n     * @param {!number} months - the amount of months, may be negative\n     * @param {!number} days - the amount of days, may be negative\n     * @return {Period} the period of years, months and days, not null\n     */\n    static of(years, months, days) {\n        return Period.create(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Period} from a temporal amount.\n     * <p>\n     * This obtains a period based on the specified amount.\n     * A {@code TemporalAmount} represents an - amount of time, which may be\n     * date-based or time-based, which this factory extracts to a {@link Period}.\n     * <p>\n     * The conversion loops around the set of units from the amount and uses\n     * the {@link ChronoUnit#YEARS YEARS}, {@link ChronoUnit#MONTHS MONTHS}\n     * and {@link ChronoUnit#DAYS DAYS} units to create a period.\n     * If any other units are found then an exception is thrown.\n     * <p>\n     * If the amount is a {@code ChronoPeriod} then it must use the ISO chronology.\n     *\n     * @param {TemporalAmount} amount - the temporal amount to convert, not null\n     * @return {Period} the equivalent period, not null\n     * @throws DateTimeException if unable to convert to a {@link Period}\n     * @throws ArithmeticException if the amount of years, months or days exceeds an int\n     */\n    static from(amount) {\n        if (amount instanceof Period) {\n            return amount;\n        }\n/*\n        if (amount instanceof ChronoPeriod) {\n            if (IsoChronology.INSTANCE !== amount.chronology()) {\n                throw new DateTimeException('Period requires ISO chronology: ' + amount);\n            }\n        }\n*/\n        requireNonNull(amount, 'amount');\n        var years = 0;\n        var months = 0;\n        var days = 0;\n        var units = amount.units();\n        for (let i=0; i<units.length; i++) {\n            var unit = units[i];\n            var unitAmount = amount.get(unit);\n            if (unit === ChronoUnit.YEARS) {\n                years = MathUtil.safeToInt(unitAmount);\n            } else if (unit === ChronoUnit.MONTHS) {\n                months = MathUtil.safeToInt(unitAmount);\n            } else if (unit === ChronoUnit.DAYS) {\n                days = MathUtil.safeToInt(unitAmount);\n            } else {\n                throw new DateTimeException('Unit must be Years, Months or Days, but was ' + unit);\n            }\n        }\n        return Period.create(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} consisting of the number of years, months,\n     * and days between two dates.\n     * <p>\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then split into years and months based on a 12 month year.\n     * A month is considered if the end day-of-month is greater than or equal to the start day-of-month.\n     * For example, from {@code 2010-01-15} to {@code 2011-03-18} is one year, two months and three days.\n     * <p>\n     * The result of this method can be a negative period if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n\n     * see {@link ChronoLocalDate.until}\n     *\n     * @param {LocalDate} startDate - the start date, inclusive, not null\n     * @param {LocalDate} endDate - the end date, exclusive, not null\n     * @return {Period} the period between this date and the end date, not null\n     */\n    static between(startDate, endDate) {\n        requireNonNull(startDate, 'startDate');\n        requireNonNull(endDate, 'endDate');\n        requireInstance(startDate, LocalDate, 'startDate');\n        requireInstance(endDate, LocalDate, 'endDate');\n        return startDate.until(endDate);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} from a text string such as {@code PnYnMnD}.\n     * <p>\n     * This will parse the string produced by {@code toString()} which is\n     * based on the ISO-8601 period formats {@code PnYnMnD} and {@code PnW}.\n     * <p>\n     * The string starts with an optional sign, denoted by the ASCII negative\n     * or positive symbol. If negative, the whole period is negated.\n     * The ASCII letter 'P' is next in upper or lower case.\n     * There are then four sections, each consisting of a number and a suffix.\n     * At least one of the four sections must be present.\n     * The sections have suffixes in ASCII of 'Y', 'M', 'W' and 'D' for\n     * years, months, weeks and days, accepted in upper or lower case.\n     * The suffixes must occur in order.\n     * The number part of each section must consist of ASCII digits.\n     * The number may be prefixed by the ASCII negative or positive symbol.\n     * The number must parse to an {@code int}.\n     * <p>\n     * The leading plus/minus sign, and negative values for other units are\n     * not part of the ISO-8601 standard. In addition, ISO-8601 does not\n     * permit mixing between the {@code PnYnMnD} and {@code PnW} formats.\n     * Any week-based input is multiplied by 7 and treated as a number of days.\n     * <p>\n     * For example, the following are valid inputs:\n     * <pre>\n     *   'P2Y'             -- Period.ofYears(2)\n     *   'P3M'             -- Period.ofMonths(3)\n     *   'P4W'             -- Period.ofWeeks(4)\n     *   'P5D'             -- Period.ofDays(5)\n     *   'P1Y2M3D'         -- Period.of(1, 2, 3)\n     *   'P1Y2M3W4D'       -- Period.of(1, 2, 25)\n     *   'P-1Y2M'          -- Period.of(-1, 2, 0)\n     *   '-P1Y2M'          -- Period.of(-1, -2, 0)\n     * </pre>\n     *\n     * @param {string} text - the text to parse, not null\n     * @return {Period} the parsed period, not null\n     * @throws DateTimeParseException if the text cannot be parsed to a period\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        try {\n            return Period._parse(text);\n        } catch (ex){\n            if(ex instanceof ArithmeticException){\n                throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0, ex);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    /**\n     * because functions that containing a try/ catch block cant be optimized,\n     * we put the code in a sub function.\n     */\n    static _parse(text){\n        var matches = PATTERN.exec(text);\n        if (matches != null) {\n            var negate = '-' === matches[1] ? -1 : 1;\n            var yearMatch = matches[2];\n            var monthMatch = matches[3];\n            var weekMatch = matches[4];\n            var dayMatch = matches[5];\n            if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {\n                var years = Period._parseNumber(text, yearMatch, negate);\n                var months = Period._parseNumber(text, monthMatch, negate);\n                var weeks = Period._parseNumber(text, weekMatch, negate);\n                var days = Period._parseNumber(text, dayMatch, negate);\n                days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));\n                return Period.create(years, months, days);\n            }\n        }\n        throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0);\n    }\n\n    static _parseNumber(text, str, negate) {\n        if (str == null) {\n            return 0;\n        }\n        var val = MathUtil.parseInt(str);\n        return MathUtil.safeMultiply(val, negate);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates an instance.\n     *\n     * @param {number} years - the amount\n     * @param {number} months - the amount\n     * @param {number} days - the amount\n     * @return {Duration}\n     */\n    static create(years, months, days) {\n        return new Period(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the list of units, from largest to smallest, that fully define this amount.\n     *\n     * @returns {ChronoUnit[]} list of units\n     */\n    units() {\n        return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];\n    }\n\n    /**\n     * Gets the chronology that defines the meaning of the supported units.\n     * <p>\n     * The period is defined by the chronology.\n     * It controls the supported units and restricts addition/subtraction\n     * to {@code ChronoLocalDate} instances of the same chronology.\n     *\n     * @return {IsoChronology} the chronology defining the period, not null\n     */\n    chronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     * Gets the value of the requested unit.\n     * <p>\n     * The supported units are chronology specific.\n     * They will typically be {@link ChronoUnit#YEARS YEARS},\n     * {@link ChronoUnit#MONTHS MONTHS} and {@link ChronoUnit#DAYS DAYS}.\n     * Requesting an unsupported unit will throw an exception.\n     *\n     * @param {TemporalUnit} unit the {@code TemporalUnit} for which to return the value\n     * @return {number} the long value of the unit\n     * @throws DateTimeException if the unit is not supported\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    get(unit) {\n        if (unit === ChronoUnit.YEARS) {\n            return this._years;\n        }\n        if (unit === ChronoUnit.MONTHS) {\n            return this._months;\n        }\n        if (unit === ChronoUnit.DAYS) {\n            return this._days;\n        }\n        throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if all three units of this period are zero.\n     * <p>\n     * A zero period has the value zero for the years, months and days units.\n     *\n     * @return {boolean} true if this period is zero-length\n     */\n    isZero() {\n        return (this === Period.ZERO);\n    }\n\n    /**\n     * Checks if any of the three units of this period are negative.\n     * <p>\n     * This checks whether the years, months or days units are less than zero.\n     *\n     * @return {boolean} true if any unit of this period is negative\n     */\n    isNegative() {\n        return this._years < 0 || this._months < 0 || this._days < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the amount of years of this period.\n     * <p>\n     * This returns the years unit.\n     * <p>\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * @return {number} the amount of years of this period, may be negative\n     */\n    years() {\n        return this._years;\n    }\n\n    /**\n     * Gets the amount of months of this period.\n     * <p>\n     * This returns the months unit.\n     * <p>\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * @return {number} the amount of months of this period, may be negative\n     */\n    months() {\n        return this._months;\n    }\n\n    /**\n     * Gets the amount of days of this period.\n     * <p>\n     * This returns the days unit.\n     *\n     * @return {number} the amount of days of this period, may be negative\n     */\n    days() {\n        return this._days;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount of years.\n     * <p>\n     * This sets the amount of the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     * <p>\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested years, not null\n     */\n    withYears(years) {\n        if (years === this._years) {\n            return this;\n        }\n        return Period.create(years, this._months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified amount of months.\n     * <p>\n     * This sets the amount of the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     * <p>\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested months, not null\n     */\n    withMonths(months) {\n        if (months === this._months) {\n            return this;\n        }\n        return Period.create(this._years, months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified amount of days.\n     * <p>\n     * This sets the amount of the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested days, not null\n     */\n    withDays(days) {\n        if (days === this._days) {\n            return this;\n        }\n        return Period.create(this._years, this._months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount added.\n     * <p>\n     * This input amount is converted to a {@link Period} using {@code from(TemporalAmount)}.\n     * This operates separately on the years, months and days.\n     * <p>\n     * For example, '1 year, 6 months and 3 days' plus '2 years, 2 months and 2 days'\n     * returns '3 years, 8 months and 5 days'.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amountToAdd - the period to add, not null\n     * @return {Period} a {@link Period} based on this period with the requested period added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plus(amountToAdd) {\n        var amount = Period.from(amountToAdd);\n        return Period.create(\n            MathUtil.safeAdd(this._years, amount._years),\n            MathUtil.safeAdd(this._months, amount._months),\n            MathUtil.safeAdd(this._days, amount._days));\n    }\n\n    /**\n     * Returns a copy of this period with the specified years added.\n     * <p>\n     * This adds the amount to the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 years returns '3 years, 6 months and 3 days'.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToAdd - the years to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified years added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified months added.\n     * <p>\n     * This adds the amount to the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 months returns '1 year, 8 months and 3 days'.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToAdd - the months to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified months added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified days added.\n     * <p>\n     * This adds the amount to the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 days returns '1 year, 6 months and 5 days'.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} daysToAdd - the days to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified days added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDays(daysToAdd) {\n        if (daysToAdd === 0) {\n            return this;\n        }\n        return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount subtracted.\n     * <p>\n     * This input amount is converted to a {@link Period} using {@code from(TemporalAmount)}.\n     * This operates separately on the years, months and days.\n     * <p>\n     * For example, '1 year, 6 months and 3 days' minus '2 years, 2 months and 2 days'\n     * returns '-1 years, 4 months and 1 day'.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amountToSubtract - the period to subtract, not null\n     * @return {Period} a {@link Period} based on this period with the requested period subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minus(amountToSubtract) {\n        var amount = Period.from(amountToSubtract);\n        return Period.create(\n                MathUtil.safeSubtract(this._years, amount._years),\n                MathUtil.safeSubtract(this._months, amount._months),\n                MathUtil.safeSubtract(this._days, amount._days));\n    }\n\n    /**\n     * Returns a copy of this period with the specified years subtracted.\n     * <p>\n     * This subtracts the amount from the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 years returns '-1 years, 6 months and 3 days'.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToSubtract - the years to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified years subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusYears(yearsToSubtract) {\n        return this.plusYears(-1 * yearsToSubtract);\n    }\n\n    /**\n     * Returns a copy of this period with the specified months subtracted.\n     * <p>\n     * This subtracts the amount from the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 months returns '1 year, 4 months and 3 days'.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToSubtract - the years to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified months subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMonths(monthsToSubtract) {\n        return this.plusMonths(-1 * monthsToSubtract);\n    }\n\n    /**\n     * Returns a copy of this period with the specified days subtracted.\n     * <p>\n     * This subtracts the amount from the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 days returns '1 year, 6 months and 1 day'.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} daysToSubtract - the months to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified days subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDays(daysToSubtract) {\n        return this.plusDays(-1 * daysToSubtract);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new instance with each element in this period multiplied\n     * by the specified scalar.\n     * <p>\n     * This simply multiplies each field, years, months, days and normalized time,\n     * by the scalar. No normalization is performed.\n     *\n     * @param {number} scalar - the scalar to multiply by, not null\n     * @return {Period} a {@link Period} based on this period with the amounts multiplied by the scalar, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    multipliedBy(scalar) {\n        if (this === Period.ZERO || scalar === 1) {\n            return this;\n        }\n        return Period.create(\n                MathUtil.safeMultiply(this._years, scalar),\n                MathUtil.safeMultiply(this._months, scalar),\n                MathUtil.safeMultiply(this._days, scalar));\n    }\n\n    /**\n     * Returns a new instance with each amount in this period negated.\n     *\n     * @return {Period} a {@link Period} based on this period with the amounts negated, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    negated() {\n        return this.multipliedBy(-1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the years and months normalized\n     * using a 12 month year.\n     * <p>\n     * This normalizes the years and months units, leaving the days unit unchanged.\n     * The months unit is adjusted to have an absolute value less than 11,\n     * with the years unit being adjusted to compensate. For example, a period of\n     * '1 Year and 15 months' will be normalized to '2 years and 3 months'.\n     * <p>\n     * The sign of the years and months units will be the same after normalization.\n     * For example, a period of '1 year and -25 months' will be normalized to\n     * '-1 year and -1 month'.\n     * <p>\n     * This normalization uses a 12 month year which is not valid for all calendar systems.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Period} a {@link Period} based on this period with excess months normalized to years, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    normalized() {\n        var totalMonths = this.toTotalMonths();\n        var splitYears = MathUtil.intDiv(totalMonths, 12);\n        var splitMonths = MathUtil.intMod(totalMonths, 12);  // no overflow\n        if (splitYears === this._years && splitMonths === this._months) {\n            return this;\n        }\n        return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);\n    }\n\n    /**\n     * Gets the total number of months in this period using a 12 month year.\n     * <p>\n     * This returns the total number of months in the period by multiplying the\n     * number of years by 12 and adding the number of months.\n     * <p>\n     * This uses a 12 month year which is not valid for all calendar systems.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the total number of months in the period, may be negative\n     */\n    toTotalMonths() {\n        return this._years * 12 + this._months;  // no overflow\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Adds this period to the specified temporal object.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with this period added.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#plus(TemporalAmount)}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisPeriod.addTo(dateTime);\n     *   dateTime = dateTime.plus(thisPeriod);\n     * </pre>\n     * <p>\n     * The calculation will add the years, then months, then days.\n     * Only non-zero amounts will be added.\n     * If the date-time has a calendar system with a fixed number of months in a\n     * year, then the years and months will be combined before being added.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    addTo(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._years !== 0) {\n            if (this._months !== 0) {\n                temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);\n            } else {\n                temporal = temporal.plus(this._years, ChronoUnit.YEARS);\n            }\n        } else if (this._months !== 0) {\n            temporal = temporal.plus(this._months, ChronoUnit.MONTHS);\n        }\n        if (this._days !== 0) {\n            temporal = temporal.plus(this._days, ChronoUnit.DAYS);\n        }\n        return temporal;\n    }\n\n    /**\n     * Subtracts this period from the specified temporal object.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with this period subtracted.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#minus(TemporalAmount)}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisPeriod.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(thisPeriod);\n     * </pre>\n     * <p>\n     * The calculation operates as follows.\n     * First, the chronology of the temporal is checked to ensure it is ISO chronology or null.\n     * Second, if the months are zero, the years are added if non-zero, otherwise\n     * the combination of years and months is added if non-zero.\n     * Finally, any days are added.\n     * \n     * The calculation will subtract the years, then months, then days.\n     * Only non-zero amounts will be subtracted.\n     * If the date-time has a calendar system with a fixed number of months in a\n     * year, then the years and months will be combined before being subtracted.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    subtractFrom(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._years !== 0) {\n            if (this._months !== 0) {\n                temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);\n            } else {\n                temporal = temporal.minus(this._years, ChronoUnit.YEARS);\n            }\n        } else if (this._months !== 0) {\n            temporal = temporal.minus(this._months, ChronoUnit.MONTHS);\n        }\n        if (this._days !== 0) {\n            temporal = temporal.minus(this._days, ChronoUnit.DAYS);\n        }\n        return temporal;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this period is equal to another period.\n     * <p>\n     * The comparison is based on the amounts held in the period.\n     * To be equal, the years, months and days units must be individually equal.\n     * Note that this means that a period of '15 Months' is not equal to a period\n     * of '1 Year and 3 Months'.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other period\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof Period) {\n            var other = obj;\n            return this._years === other._years &&\n                this._months === other._months &&\n                this._days === other._days;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this period.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._years + (this._months << 8) + (this._days << 16);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this period as a {@code String}, such as {@code P6Y3M1D}.\n     * <p>\n     * The output will be in the ISO-8601 period format.\n     * A zero period will be represented as zero days, 'P0D'.\n     *\n     * @return {string} a string representation of this period, not null\n     */\n    toString() {\n        if (this === Period.ZERO) {\n            return 'P0D';\n        } else {\n            var buf = 'P';\n            if (this._years !== 0) {\n                buf += '' + this._years + 'Y';\n            }\n            if (this._months !== 0) {\n                buf += '' + this._months + 'M';\n            }\n            if (this._days !== 0) {\n                buf += '' + this._days + 'D';\n            }\n            return buf;\n        }\n    }\n}\n\nexport function _init() {\n    /**\n     * A constant for a period of zero.\n     */\n    Period.ZERO = makeZeroPeriod();\n\n    function makeZeroPeriod() {\n        var zero = Object.create(Period.prototype);\n        TemporalAmount.call(zero);\n        zero._years = 0;\n        zero._months = 0;\n        zero._days = 0;\n        return zero;\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Period.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nexport class ParsePosition {\n    constructor(index) {\n        this._index = index;\n        this._errorIndex = -1;\n    }\n\n    getIndex(){\n        return this._index;\n    }\n\n    setIndex(index){\n        this._index = index;\n    }\n\n    getErrorIndex(){\n        return this._errorIndex;\n    }\n\n    setErrorIndex(errorIndex){\n        this._errorIndex = errorIndex;\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/format/ParsePosition.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {DateTimeException} from '../errors';\nimport {MathUtil} from '../MathUtil';\n\nimport {EnumMap} from './EnumMap';\nimport {ResolverStyle} from './ResolverStyle';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\nimport {ChronoLocalDate} from '../chrono/ChronoLocalDate';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\nimport {LocalTime} from '../LocalTime';\nimport {LocalDate} from '../LocalDate';\nimport {Period} from '../Period';\n\n//import {ZoneOffset} from '../ZoneOffset';\n\n/**\n * Builder that can holds date and time fields and related date and time objects.\n * <p>\n * The builder is used to hold onto different elements of date and time.\n * It is designed as two separate maps:\n * <p><ul>\n * <li>from {@link TemporalField} to {@code long} value, where the value may be\n * outside the valid range for the field\n * <li>from {@code Class} to {@link TemporalAccessor}, holding larger scale objects\n * like {@code LocalDateTime}.\n * </ul><p>\n *\n */\nexport class DateTimeBuilder extends Temporal {\n\n    /**\n     * Creates a new instance of the builder with a single field-value.\n     * <p>\n     * This is equivalent to using {@link #addFieldValue(TemporalField, long)} on an empty builder.\n     *\n     * @param {TemporalField} field - the field to add, not null\n     * @param {number} value - the value to add, not null\n     * @return {DateTimeBuilder}\n     */\n    static create(field, value) {\n        var dtb = new DateTimeBuilder();\n        dtb._addFieldValue(field, value);\n        return dtb;\n    }\n\n\n    constructor(){\n        super();\n\n        /**\n         * The map of other fields.\n         */\n        this.fieldValues = new EnumMap();\n        /**\n         * The chronology.\n         */\n        this.chrono = null;\n        /**\n         * The zone.\n         */\n        this.zone = null;\n        /**\n         * The date.\n         */\n        this.date = null;\n        /**\n         * The time.\n         */\n        this.time = null;\n        /**\n         * The leap second flag.\n         */\n        this.leapSecond = false;\n        /**\n         * The excess days.\n         */\n        this.excessDays = null;\n    }\n\n    /**\n     * \n     * @param {TemporalField} field\n     * @return {Number} field value\n     */\n    getFieldValue0(field) {\n        return this.fieldValues.get(field);\n    }\n\n    /**\n     * Adds a field-value pair to the builder.\n     * <p>\n     * This adds a field to the builder.\n     * If the field is not already present, then the field-value pair is added to the map.\n     * If the field is already present and it has the same value as that specified, no action occurs.\n     * If the field is already present and it has a different value to that specified, then\n     * an exception is thrown.\n     *\n     * @param {TemporalField} field - the field to add, not null\n     * @param {Number} value - the value to add, not null\n     * @return {DateTimeBuilder}, this for method chaining\n     * @throws DateTimeException if the field is already present with a different value\n     */\n    _addFieldValue(field, value) {\n        requireNonNull(field, 'field');\n        var old = this.getFieldValue0(field);  // check first for better error message\n        if (old != null && old.longValue() !== value) {\n            throw new DateTimeException('Conflict found: ' + field + ' ' + old + ' differs from ' + field + ' ' + value + ': ' + this);\n        }\n        return this._putFieldValue0(field, value);\n    }\n\n    /**\n     * @param {TemporalField} field\n     * @param {Number} value\n     * @return {DateTimeBuilder}, this for method chaining\n     */\n    _putFieldValue0(field, value) {\n        this.fieldValues.put(field, value);\n        return this;\n    }\n\n    /**\n     * Resolves the builder, evaluating the date and time.\n     * <p>\n     * This examines the contents of the builder and resolves it to produce the best\n     * available date and time, throwing an exception if a problem occurs.\n     * Calling this method changes the state of the builder.\n     *\n     * @param {ResolverStyle} resolverStyle - how to resolve\n     * @param {Set<TemporalField>} resolverFields\n     * @return {DateTimeBuilder} this, for method chaining\n     */\n    resolve(resolverStyle, resolverFields) {\n        if (resolverFields != null) {\n            this.fieldValues.retainAll(resolverFields);\n        }\n        // handle standard fields\n        // this._mergeInstantFields();\n        this._mergeDate(resolverStyle);\n        this._mergeTime(resolverStyle);\n        //if (resolveFields(resolverStyle)) {\n        //    mergeInstantFields();\n        //    mergeDate(resolverStyle);\n        //    mergeTime(resolverStyle);\n        //}\n        this._resolveTimeInferZeroes(resolverStyle);\n        //this._crossCheck();\n        if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {\n            this.date = this.date.plus(this.excessDays);\n            this.excessDays = Period.ZERO;\n        }\n        //resolveFractional();\n        //resolveInstant();\n        return this;\n    }\n\n    /**\n     *\n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _mergeDate(resolverStyle) {\n        //if (this.chrono instanceof IsoChronology) {\n        this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));\n        //} else {\n        //    if (this.fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n        //        this._checkDate(LocalDate.ofEpochDay(this.fieldValues.remove(ChronoField.EPOCH_DAY)));\n        //        return;\n        //    }\n        //}\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @private\n     */\n    _checkDate(date) {\n        if (date != null) {\n            this._addObject(date);\n            for (let field in this.fieldValues.keySet()) {\n                if (field instanceof ChronoField) {\n                    if (field.isDateBased()) {\n                        var val1;\n                        try {\n                            val1 = date.getLong(field);\n                        } catch (ex) {\n                            if(ex instanceof DateTimeException){\n                                continue;\n                            } else {\n                                throw ex;\n                            }\n                        }\n                        var val2 = this.fieldValues.get(field);\n                        if (val1 !== val2) {\n                            throw new DateTimeException('Conflict found: Field ' + field + ' ' + val1 + ' differs from ' + field + ' ' + val2 + ' derived from ' + date);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _mergeTime(resolverStyle) {\n        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {\n            let ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                if (resolverStyle === ResolverStyle.SMART && ch === 0) {\n                    // ok\n                } else {\n                    ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);\n                }\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);\n        }\n        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {\n            let ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                if (resolverStyle === ResolverStyle.SMART && ch === 0) {\n                    // ok\n                } else {\n                    ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(ch);\n                }\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_AMPM, ch === 12 ? 0 : ch);\n        }\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {\n                ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));\n            }\n            if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n                ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));\n            }\n        }\n        if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n            let ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);\n            let hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);\n        }\n//        if (timeFields.containsKey(HOUR_OF_DAY) && timeFields.containsKey(MINUTE_OF_HOUR)) {\n//            let hod = timeFields.remove(HOUR_OF_DAY);\n//            let moh = timeFields.remove(MINUTE_OF_HOUR);\n//            this._addFieldValue(MINUTE_OF_DAY, hod * 60 + moh);\n//        }\n//        if (timeFields.containsKey(MINUTE_OF_DAY) && timeFields.containsKey(SECOND_OF_MINUTE)) {\n//            let mod = timeFields.remove(MINUTE_OF_DAY);\n//            let som = timeFields.remove(SECOND_OF_MINUTE);\n//            this._addFieldValue(SECOND_OF_DAY, mod * 60 + som);\n//        }\n        if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {\n            let nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.NANO_OF_DAY.checkValidValue(nod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));\n            this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {\n            let cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MICRO_OF_DAY.checkValidValue(cod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));\n            this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {\n            let lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MILLI_OF_DAY.checkValidValue(lod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));\n            this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {\n            let sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.SECOND_OF_DAY.checkValidValue(sod);\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n            this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {\n            let mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MINUTE_OF_DAY.checkValidValue(mod);\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));\n            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));\n        }\n\n//            let sod = MathUtil.intDiv(nod, 1000000000L);\n//            this._addFieldValue(HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n//            this._addFieldValue(MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n//            this._addFieldValue(SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n//            this._addFieldValue(NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000L));\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n                ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));\n            }\n            if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n                ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));\n            }\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n            let los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n            let cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);\n            this._addFieldValue(ChronoField.MICRO_OF_SECOND, los * 1000 + (MathUtil.intMod(cos, 1000)));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n            let nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n            this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));\n            this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n            let nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n            this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(nos, 1000000));\n            this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n            let cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n            this._addFieldValue(ChronoField.NANO_OF_SECOND, cos * 1000);\n        } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n            let los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n            this._addFieldValue(ChronoField.NANO_OF_SECOND, los * 1000000);\n        }\n    }\n\n    /**\n     * \n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _resolveTimeInferZeroes(resolverStyle) {\n        let hod =  this.fieldValues.get(ChronoField.HOUR_OF_DAY);\n        let moh =  this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);\n        let som =  this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);\n        let nos =  this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n        if (hod == null) {\n            return;\n        }\n        if (moh == null && (som != null || nos != null)) {\n            return;\n        }\n        if (moh != null && som == null && nos != null) {\n            return;\n        }\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (hod != null) {\n                if (resolverStyle === ResolverStyle.SMART &&\n                                hod === 24 &&\n                                (moh == null || moh === 0) &&\n                                (som == null || som === 0) &&\n                                (nos == null || nos === 0)) {\n                    hod = 0;\n                    this.excessDays = Period.ofDays(1);\n                }\n                let hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);\n                if (moh != null) {\n                    let mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);\n                    if (som != null) {\n                        let somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);\n                        if (nos != null) {\n                            let nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);\n                            this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));\n                        } else {\n                            this._addObject(LocalTime.of(hodVal, mohVal, somVal));\n                        }\n                    } else {\n                        if (nos == null) {\n                            this._addObject(LocalTime.of(hodVal, mohVal));\n                        }\n                    }\n                } else {\n                    if (som == null && nos == null) {\n                        this._addObject(LocalTime.of(hodVal, 0));\n                    }\n                }\n            }\n        } else {\n            if (hod != null) {\n                let hodVal = hod;\n                if (moh != null) {\n                    if (som != null) {\n                        if (nos == null) {\n                            nos = 0;\n                        }\n                        let totalNanos = MathUtil.safeMultiply(hodVal, 3600000000000);\n                        totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));\n                        totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));\n                        totalNanos = MathUtil.safeAdd(totalNanos, nos);\n                        let excessDays =  MathUtil.floorDiv(totalNanos, 86400000000000);  // safe int cast\n                        let nod = MathUtil.floorMod(totalNanos, 86400000000000);\n                        this._addObject(LocalTime.ofNanoOfDay(nod));\n                        this.excessDays = Period.ofDays(excessDays);\n                    } else {\n                        let totalSecs = MathUtil.safeMultiply(hodVal, 3600);\n                        totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));\n                        let excessDays =  MathUtil.floorDiv(totalSecs, 86400);  // safe int cast\n                        let sod = MathUtil.floorMod(totalSecs, 86400);\n                        this._addObject(LocalTime.ofSecondOfDay(sod));\n                        this.excessDays = Period.ofDays(excessDays);\n                    }\n                } else {\n                    let excessDays = MathUtil.safeToInt(MathUtil.floorDiv(hodVal, 24));\n                    hodVal = MathUtil.floorMod(hodVal, 24);\n                    this._addObject(LocalTime.of(hodVal, 0));\n                    this.excessDays = Period.ofDays(excessDays);\n                }\n            }\n        }\n        this.fieldValues.remove(ChronoField.HOUR_OF_DAY);\n        this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);\n        this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);\n        this.fieldValues.remove(ChronoField.NANO_OF_SECOND);\n    }\n\n    /**\n     *\n     * @param {ChronoLocalDate|LocalTime} dateOrTime\n     * @private\n     */\n    _addObject(dateOrTime) {\n        if (dateOrTime instanceof ChronoLocalDate){\n            this.date = dateOrTime;\n        } else if (dateOrTime instanceof LocalTime){\n            this.time = dateOrTime;\n        }\n    }\n\n    /**\n     * Builds the specified type from the values in this builder.\n     *\n     * This attempts to build the specified type from this builder.\n     * If the builder cannot return the type, an exception is thrown.\n     *\n     * @param {!TemporalQuery} type - the type to invoke {@code from} on, not null\n     * @return {*} the extracted value, not null\n     * @throws DateTimeException if an error occurs\n     */\n    build(type) {\n        return type.queryFrom(this);\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {number}\n     */\n    isSupported(field) {\n        if (field == null) {\n            return false;\n        }\n        return this.fieldValues.containsKey(field) ||\n                (this.date != null && this.date.isSupported(field)) ||\n                (this.time != null && this.time.isSupported(field));\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {number}\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        var value = this.getFieldValue0(field);\n        if (value == null) {\n            if (this.date != null && this.date.isSupported(field)) {\n                return this.date.getLong(field);\n            }\n            if (this.time != null && this.time.isSupported(field)) {\n                return this.time.getLong(field);\n            }\n            throw new DateTimeException('Field not found: ' + field);\n        }\n        return value;\n    }\n\n    /**\n     *\n     * @param {!TemporalQuery} query\n     * @returns {*}\n     */\n    query(query) {\n        if (query === TemporalQueries.zoneId()) {\n            return this.zone;\n        } else if (query === TemporalQueries.chronology()) {\n            return this.chrono;\n        } else if (query === TemporalQueries.localDate()) {\n            return this.date != null ? LocalDate.from(this.date) : null;\n        } else if (query === TemporalQueries.localTime()) {\n            return this.time;\n        } else if (query === TemporalQueries.zone() || query === TemporalQueries.offset()) {\n            return query.queryFrom(this);\n        } else if (query === TemporalQueries.precision()) {\n            return null;  // not a complete date/time\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/format/DateTimeBuilder.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport class EnumMap {\n    constructor(){\n        this._map = {};\n    }\n\n    putAll(otherMap){\n        for(let key in otherMap._map){\n            this._map[key] = otherMap._map[key];\n        }\n        return this;\n    }\n\n    containsKey(key){\n        return this._map.hasOwnProperty(key.name());\n    }\n\n    get(key) {\n        return this._map[key.name()];\n    }\n\n    put(key, val) {\n        return this.set(key, val);\n    }\n\n    set(key, val) {\n        this._map[key.name()] = val;\n        return this;\n    }\n\n    retainAll(keyList){\n        var map = {};\n        for(let i=0; i<keyList.length; i++){\n            let key = keyList[i].name();\n            map[key] = this._map[key];\n        }\n        this._map = map;\n        return this;\n    }\n\n    /**\n     * due to the bad performance of delete we just set the key entry to undefined.\n     *\n     * this might lead to issues with \"null\" entries. Calling clear in the end might solve the issue\n     * @param key\n     * @returns {*}\n     */\n    remove(key){\n        var keyName = key.name();\n        var val = this._map[keyName];\n        this._map[keyName] = undefined;\n        return val;\n    }\n\n    keySet(){\n        return this._map;\n    }\n\n    clear(){\n        this._map = {};\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/format/EnumMap.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull} from '../assert';\n\nimport {DateTimeBuilder} from './DateTimeBuilder';\nimport {EnumMap} from './EnumMap';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\nexport class DateTimeParseContext{\n\n    constructor(){\n        if(arguments.length === 1){\n            if(arguments[0] instanceof DateTimeParseContext){\n                this._constructorSelf.apply(this, arguments);\n                return;\n            } else {\n                this._constructorFormatter.apply(this, arguments);\n            }\n        } else {\n            this._constructorParam.apply(this, arguments);\n        }\n\n        this._caseSensitive = true;\n        this._strict = true;\n        this._parsed = [new Parsed(this)];\n    }\n\n    _constructorParam(locale, symbols, chronology){\n        this._locale = locale;\n        this._symbols = symbols;\n        this._overrideChronology = chronology;\n    }\n\n    _constructorFormatter(formatter){\n        this._locale = formatter.locale();\n        this._symbols = formatter.decimalStyle();\n        this._overrideChronology = formatter.chronology();\n    }\n\n\n    _constructorSelf(other) {\n        this._locale = other._locale;\n        this._symbols = other._symbols;\n        this._overrideChronology = other._overrideChronology;\n        this._overrideZone = other._overrideZone;\n        this._caseSensitive = other._caseSensitive;\n        this._strict = other._strict;\n        this._parsed = [new Parsed(this)];\n    }\n\n    /**\n     * Creates a copy of this context.\n     */\n    copy() {\n        return new DateTimeParseContext(this);\n    }\n\n    symbols(){\n        return this._symbols;\n    }\n\n    isStrict(){\n        return this._strict;\n    }\n\n    setStrict(strict){\n        this._strict = strict;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Starts the parsing of an optional segment of the input.\n     */\n    startOptional() {\n        this._parsed.push(this.currentParsed().copy());\n    }\n\n    /**\n     * Ends the parsing of an optional segment of the input.\n     *\n     * @param {boolean} successful  whether the optional segment was successfully parsed\n     */\n    endOptional(successful) {\n        if (successful) {\n            this._parsed.splice(this._parsed.length - 2, 1);\n        } else {\n            this._parsed.splice(this._parsed.length - 1, 1);\n        }\n    }\n\n    /**\n     * Checks if parsing is case sensitive.\n     *\n     * @return true if parsing is case sensitive, false if case insensitive\n     */\n    isCaseSensitive() {\n        return this._caseSensitive;\n    }\n\n    /**\n     * Sets whether the parsing is case sensitive or not.\n     *\n     * @param caseSensitive  changes the parsing to be case sensitive or not from now on\n     */\n    setCaseSensitive(caseSensitive) {\n        this._caseSensitive = caseSensitive;\n    }\n\n    /**\n     * Helper to compare two {@code CharSequence} instances.\n     * This uses {@link #isCaseSensitive()}.\n     *\n     * @param cs1  the first character sequence, not null\n     * @param offset1  the offset into the first sequence, valid\n     * @param cs2  the second character sequence, not null\n     * @param offset2  the offset into the second sequence, valid\n     * @param length  the length to check, valid\n     * @return true if equal\n     */\n    subSequenceEquals(cs1, offset1, cs2, offset2, length) {\n        if (offset1 + length > cs1.length || offset2 + length > cs2.length) {\n            return false;\n        }\n        if (! this.isCaseSensitive()) {\n            cs1 = cs1.toLowerCase();\n            cs2 = cs2.toLowerCase();\n        }\n        for (let i = 0; i < length; i++) {\n            let ch1 = cs1[offset1 + i];\n            let ch2 = cs2[offset2 + i];\n            if (ch1 !== ch2) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Helper to compare two {@code char}.\n     * This uses {@link #isCaseSensitive()}.\n     *\n     * @param ch1  the first character\n     * @param ch2  the second character\n     * @return true if equal\n     */\n    charEquals(ch1, ch2) {\n        if (this.isCaseSensitive()) {\n            return ch1 === ch2;\n        }\n        return this.charEqualsIgnoreCase(ch1, ch2);\n    }\n\n    /**\n     * Compares two characters ignoring case.\n     *\n     * @param c1  the first\n     * @param c2  the second\n     * @return true if equal\n     */\n    charEqualsIgnoreCase(c1, c2) {\n        return c1 === c2 ||\n                c1.toLowerCase() === c2.toLowerCase();\n    }\n\n    setParsedField(field, value, errorPos, successPos){\n        var currentParsedFieldValues = this.currentParsed().fieldValues;\n        var old = currentParsedFieldValues.get(field);\n        currentParsedFieldValues.set(field, value);\n        return (old != null && old !== value) ? ~errorPos : successPos;\n    }\n\n    /**\n     * Stores the parsed zone.\n     * <p>\n     * This stores the zone that has been parsed.\n     * No validation is performed other than ensuring it is not null.\n     *\n     * @param {ZoneId} zone  the parsed zone, not null\n     */\n    setParsedZone(zone) {\n        requireNonNull(zone, 'zone');\n        this.currentParsed().zone = zone;\n    }\n\n    getParsed(field) {\n        return this.currentParsed().fieldValues.get(field);\n    }\n\n    toParsed() {\n        return this.currentParsed();\n    }\n\n    currentParsed() {\n        return this._parsed[this._parsed.length - 1];\n    }\n\n    /**\n     * Stores the leap second.\n     */\n    setParsedLeapSecond() {\n        this.currentParsed().leapSecond = true;\n    }\n\n    /**\n     * Gets the effective chronology during parsing.\n     *\n     * @return the effective parsing chronology, not null\n     */\n    getEffectiveChronology() {\n        var chrono = this.currentParsed().chrono;\n        if (chrono == null) {\n            chrono = this._overrideChronology;\n            if (chrono == null) {\n                chrono = IsoChronology.INSTANCE;\n            }\n        }\n        return chrono;\n    }\n\n\n}\n\nclass Parsed extends Temporal {\n    constructor(dateTimeParseContext){\n        super();\n        this.chrono = null;\n        this.zone = null;\n        this.fieldValues = new EnumMap();\n        this.leapSecond = false;\n        this.dateTimeParseContext = dateTimeParseContext;\n    }\n\n    copy() {\n        var cloned = new Parsed();\n        cloned.chrono = this.chrono;\n        cloned.zone = this.zone;\n        cloned.fieldValues.putAll(this.fieldValues);\n        cloned.leapSecond = this.leapSecond;\n        cloned.dateTimeParseContext = this.dateTimeParseContext;\n        return cloned;\n    }\n\n    toString() {\n        return `${this.fieldValues}, ${this.chrono}, ${this.zone}`;\n    }\n\n    isSupported(field) {\n        return this.fieldValues.containsKey(field);\n    }\n\n    get(field) {\n        var val = this.fieldValues.get(field);\n        assert(val != null);\n        return val;\n    }\n\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chrono;\n        }\n        if (query === TemporalQueries.zoneId() || query === TemporalQueries.zone()) {\n            return this.zone;\n        }\n        return super.query(query);\n    }\n\n    toBuilder() {\n        var builder = new DateTimeBuilder();\n        builder.fieldValues.putAll(this.fieldValues);\n        builder.chrono = this.dateTimeParseContext.getEffectiveChronology();\n        if (this.zone != null) {\n            builder.zone = this.zone;\n        } else {\n            builder.zone = this.overrideZone;\n        }\n        builder.leapSecond = this.leapSecond;\n        builder.excessDays = this.excessDays;\n        return builder;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/format/DateTimeParseContext.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {DateTimeException} from '../errors';\n\nimport {DateTimeFormatter} from './DateTimeFormatter';\n\nexport class DateTimePrintContext{\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @param {DateTimeFormatter|Locale} localeOrFormatter\n     * @param {DecimalStyle} symbols\n     */\n    constructor(temporal, localeOrFormatter, symbols) {\n        if(arguments.length === 2 && arguments[1] instanceof DateTimeFormatter){\n            this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);\n            this._locale = localeOrFormatter.locale();\n            this._symbols = localeOrFormatter.decimalStyle();\n        } else {\n            this._temporal = temporal;\n            this._locale = localeOrFormatter;\n            this._symbols = symbols;\n        }\n        this._optional = 0;\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @param {DateTimeFormatter} formatter\n     * @returns {TemporalAccessor}\n     */\n    static adjust(temporal, formatter) {\n        // TODO implement\n        return temporal;\n    }\n\n\n    symbols(){\n        return this._symbols;\n    }\n\n    /**\n     * Starts the printing of an optional segment of the input.\n     */\n    startOptional() {\n        this._optional++;\n    }\n\n    /**\n     * Ends the printing of an optional segment of the input.\n     */\n    endOptional() {\n        this._optional--;\n    }\n\n    /**\n     * Gets a value using a query.\n     *\n     * @param {TemporalQuery} query  the query to use, not null\n     * @return {*} the result, null if not found and optional is true\n     * @throws DateTimeException if the type is not available and the section is not optional\n     */\n    getValueQuery(query) {\n        var result = this._temporal.query(query);\n        if (result == null && this._optional === 0) {\n            throw new DateTimeException('Unable to extract value: ' + this._temporal);\n        }\n        return result;\n    }\n\n    /**\n     * Gets the value of the specified field.\n     *\n     * This will return the value for the specified field.\n     *\n     * @param field  the field to find, not null\n     * @return the value, null if not found and optional is true\n     * @throws DateTimeException if the field is not available and the section is not optional\n     */\n    getValue(field) {\n        try {\n            return this._temporal.getLong(field);\n        } catch (ex) {\n            if ((ex instanceof DateTimeException) && this._optional > 0) {\n                return null;\n            }\n            throw ex;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the temporal object being output.\n     *\n     * @return {TemporalAccessor} the temporal object, not null\n     */\n     temporal() {\n         return this._temporal;\n     }\n\n    //-------------------------------------------------------------------------\n    // for testing\n    /**\n     * Sets the date-time being output.\n     *\n     * @param temporal  the date-time object, not null\n     */\n    setDateTime(temporal) {\n        this._temporal = temporal;\n    }\n\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/format/DateTimePrintContext.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull} from '../assert';\nimport {ArithmeticException, DateTimeException, IllegalArgumentException, IllegalStateException} from '../errors';\n\nimport {Enum} from '../Enum';\nimport {ZoneIdFactory} from '../ZoneIdFactory';\nimport {LocalDateTime} from '../LocalDateTime';\nimport {ZoneOffset} from '../ZoneOffset';\nimport {ZoneId} from '../ZoneId';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\nimport {DateTimeFormatter} from './DateTimeFormatter';\nimport {DecimalStyle} from './DecimalStyle';\nimport {SignStyle} from './SignStyle';\nimport {ResolverStyle} from './ResolverStyle';\n\nconst MAX_WIDTH = 15; // can't parse all numbers with more then 15 digits in javascript\n\nexport class DateTimeFormatterBuilder {\n\n    /**\n     * Constructs a new instance of the builder.\n     *\n     * @param {DateTimeFormatterBuilder} parent  the parent builder, not null\n     * @param {boolean} optional  whether the formatter is optional, not null\n     */\n    constructor(parent=null, optional=false){\n        /**\n         * The currently active builder, used by the outermost builder.\n         */\n        this._active = this;\n        /**\n         * The parent builder, null for the outermost builder.\n         */\n        this._parent = parent;\n\n        /**\n         * The list of printers that will be used.\n         */\n        this._printerParsers = [];\n\n        /**\n         * Whether this builder produces an optional formatter.\n         */\n        this._optional = optional;\n        /**\n         * The width to pad the next field to.\n         */\n        this._padNextWidth = 0;\n\n        /**\n         * The character to pad the next field with.\n         */\n        this._padNextChar = null;\n\n        /**\n         * The index of the last variable width value parser.\n         */\n        this._valueParserIndex = -1;\n    }\n\n    /**\n     * Changes the parse style to be case sensitive for the remainder of the formatter.\n     * \n     * Parsing can be case sensitive or insensitive - by default it is case sensitive.\n     * This method allows the case sensitivity setting of parsing to be changed.\n     * \n     * Calling this method changes the state of the builder such that all\n     * subsequent builder method calls will parse text in case sensitive mode.\n     * See {@link #parseCaseInsensitive} for the opposite setting.\n     * The parse case sensitive/insensitive methods may be called at any point\n     * in the builder, thus the parser can swap between case parsing modes\n     * multiple times during the parse.\n     * \n     * Since the default is case sensitive, this method should only be used after\n     * a previous call to {@code #parseCaseInsensitive}.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseCaseSensitive() {\n        this._appendInternalPrinterParser(SettingsParser.SENSITIVE);\n        return this;\n    }\n\n    /**\n     * Changes the parse style to be case insensitive for the remainder of the formatter.\n     * \n     * Parsing can be case sensitive or insensitive - by default it is case sensitive.\n     * This method allows the case sensitivity setting of parsing to be changed.\n     * \n     * Calling this method changes the state of the builder such that all\n     * subsequent builder method calls will parse text in case sensitive mode.\n     * See {@link #parseCaseSensitive()} for the opposite setting.\n     * The parse case sensitive/insensitive methods may be called at any point\n     * in the builder, thus the parser can swap between case parsing modes\n     * multiple times during the parse.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseCaseInsensitive() {\n        this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Changes the parse style to be strict for the remainder of the formatter.\n     * \n     * Parsing can be strict or lenient - by default its strict.\n     * This controls the degree of flexibility in matching the text and sign styles.\n     * \n     * When used, this method changes the parsing to be strict from this point onwards.\n     * As strict is the default, this is normally only needed after calling {@link #parseLenient()}.\n     * The change will remain in force until the end of the formatter that is eventually\n     * constructed or until {@code parseLenient} is called.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseStrict() {\n        this._appendInternalPrinterParser(SettingsParser.STRICT);\n        return this;\n    }\n\n    /**\n     * Changes the parse style to be lenient for the remainder of the formatter.\n     * Note that case sensitivity is set separately to this method.\n     * \n     * Parsing can be strict or lenient - by default its strict.\n     * This controls the degree of flexibility in matching the text and sign styles.\n     * Applications calling this method should typically also call {@link #parseCaseInsensitive()}.\n     * \n     * When used, this method changes the parsing to be strict from this point onwards.\n     * The change will remain in force until the end of the formatter that is eventually\n     * constructed or until {@code parseStrict} is called.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseLenient() {\n        this._appendInternalPrinterParser(SettingsParser.LENIENT);\n        return this;\n    }\n\n    /**\n     * appendValue function overloading\n     */\n    appendValue(){\n        if(arguments.length === 1){\n            return this._appendValue1.apply(this, arguments);\n        } else if(arguments.length === 2){\n            return this._appendValue2.apply(this, arguments);\n        } else {\n            return this._appendValue4.apply(this, arguments);\n        }  \n    }\n    \n    /**\n     * Appends the value of a date-time field to the formatter using a normal\n     * output style.\n     * \n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     * \n     * The value will be printed as per the normal print of an integer value.\n     * Only negative numbers will be signed. No padding will be added.\n     * \n     * The parser for a variable width value such as this normally behaves greedily,\n     * requiring one digit, but accepting as many digits as possible.\n     * This behavior can be affected by 'adjacent value parsing'.\n     * See {@link #appendValue(TemporalField, int)} for full details.\n     *\n     * @param field  the field to append, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    _appendValue1(field) {\n        assert(field != null);\n        this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));\n        return this;\n    }\n\n    /**\n     * Appends the value of a date-time field to the formatter using a fixed\n     * width, zero-padded approach.\n     * \n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     * \n     * The value will be zero-padded on the left. If the size of the value\n     * means that it cannot be printed within the width then an exception is thrown.\n     * If the value of the field is negative then an exception is thrown during printing.\n     * \n     * This method supports a special technique of parsing known as 'adjacent value parsing'.\n     * This technique solves the problem where a variable length value is followed by one or more\n     * fixed length values. The standard parser is greedy, and thus it would normally\n     * steal the digits that are needed by the fixed width value parsers that follow the\n     * variable width one.\n     * \n     * No action is required to initiate 'adjacent value parsing'.\n     * When a call to {@code appendValue} with a variable width is made, the builder\n     * enters adjacent value parsing setup mode. If the immediately subsequent method\n     * call or calls on the same builder are to this method, then the parser will reserve\n     * space so that the fixed width values can be parsed.\n     * \n     * For example, consider {@code builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2);}\n     * The year is a variable width parse of between 1 and 19 digits.\n     * The month is a fixed width parse of 2 digits.\n     * Because these were appended to the same builder immediately after one another,\n     * the year parser will reserve two digits for the month to parse.\n     * Thus, the text '201106' will correctly parse to a year of 2011 and a month of 6.\n     * Without adjacent value parsing, the year would greedily parse all six digits and leave\n     * nothing for the month.\n     * \n     * Adjacent value parsing applies to each set of fixed width not-negative values in the parser\n     * that immediately follow any kind of variable width value.\n     * Calling any other append method will end the setup of adjacent value parsing.\n     * Thus, in the unlikely event that you need to avoid adjacent value parsing behavior,\n     * simply add the {@code appendValue} to another {@code DateTimeFormatterBuilder}\n     * and add that to this builder.\n     * \n     * If adjacent parsing is active, then parsing must match exactly the specified\n     * number of digits in both strict and lenient modes.\n     * In addition, no positive or negative sign is permitted.\n     *\n     * @param field  the field to append, not null\n     * @param width  the width of the printed field, from 1 to 19\n     * @return this, for chaining, not null\n     * @throws IllegalArgumentException if the width is invalid\n     */\n    _appendValue2(field, width) {\n        assert(field != null);\n        if (width < 1 || width > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The width must be from 1 to ${MAX_WIDTH} inclusive but was ${width}`);\n        }\n        var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * Appends the value of a date-time field to the formatter providing full\n     * control over printing.\n     * \n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     * \n     * This method provides full control of the numeric formatting, including\n     * zero-padding and the positive/negative sign.\n     * \n     * The parser for a variable width value such as this normally behaves greedily,\n     * accepting as many digits as possible.\n     * This behavior can be affected by 'adjacent value parsing'.\n     * See {@link #appendValue(TemporalField, int)} for full details.\n     * \n     * In strict parsing mode, the minimum number of parsed digits is {@code minWidth}.\n     * In lenient parsing mode, the minimum number of parsed digits is one.\n     * \n     * If this method is invoked with equal minimum and maximum widths and a sign style of\n     * {@code NOT_NEGATIVE} then it delegates to {@code appendValue(TemporalField,int)}.\n     * In this scenario, the printing and parsing behavior described there occur.\n     *\n     * @param field  the field to append, not null\n     * @param minWidth  the minimum field width of the printed field, from 1 to 19\n     * @param maxWidth  the maximum field width of the printed field, from 1 to 19\n     * @param signStyle  the positive/negative output style, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the widths are invalid\n     */\n    _appendValue4(field, minWidth, maxWidth, signStyle) {\n        assert(field != null);\n        if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {\n            return this._appendValue2(field, maxWidth);\n        }\n        if (minWidth < 1 || minWidth > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The minimum width must be from 1 to ${MAX_WIDTH} inclusive but was ${minWidth}`);\n        }\n        if (maxWidth < 1 || maxWidth > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The minimum width must be from 1 to ${MAX_WIDTH} inclusive but was ${maxWidth}`);\n        }\n        if (maxWidth < minWidth) {\n            throw new IllegalArgumentException(`The maximum width must exceed or equal the minimum width but ${maxWidth} < ${minWidth}`);\n        }\n        var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * Appends a fixed width printer-parser.\n     *\n     * @param pp  the printer-parser, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    _appendValuePrinterParser(pp) {\n        assert(pp != null);\n        if (this._active._valueParserIndex >= 0 &&\n                this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {\n            var activeValueParser = this._active._valueParserIndex;\n\n            // adjacent parsing mode, update setting in previous parsers\n            var basePP = this._active._printerParsers[activeValueParser];\n            if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {\n                // Append the width to the subsequentWidth of the active parser\n                basePP = basePP.withSubsequentWidth(pp.maxWidth());\n                // Append the new parser as a fixed width\n                this._appendInternal(pp.withFixedWidth());\n                // Retain the previous active parser\n                this._active._valueParserIndex = activeValueParser;\n            } else {\n                // Modify the active parser to be fixed width\n                basePP = basePP.withFixedWidth();\n                // The new parser becomes the mew active parser\n                this._active._valueParserIndex = this._appendInternal(pp);\n            }\n            // Replace the modified parser with the updated one\n            this._active._printerParsers[activeValueParser] = basePP;\n        } else {\n            // The new Parser becomes the active parser\n            this._active._valueParserIndex = this._appendInternal(pp);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the fractional value of a date-time field to the formatter.\n     * <p>\n     * The fractional value of the field will be output including the\n     * preceding decimal point. The preceding value is not output.\n     * For example, the second-of-minute value of 15 would be output as {@code .25}.\n     * <p>\n     * The width of the printed fraction can be controlled. Setting the\n     * minimum width to zero will cause no output to be generated.\n     * The printed fraction will have the minimum width necessary between\n     * the minimum and maximum widths - trailing zeroes are omitted.\n     * No rounding occurs due to the maximum width - digits are simply dropped.\n     * <p>\n     * When parsing in strict mode, the number of parsed digits must be between\n     * the minimum and maximum width. When parsing in lenient mode, the minimum\n     * width is considered to be zero and the maximum is nine.\n     * <p>\n     * If the value cannot be obtained then an exception will be thrown.\n     * If the value is negative an exception will be thrown.\n     * If the field does not have a fixed set of valid values then an\n     * exception will be thrown.\n     * If the field value in the date-time to be printed is invalid it\n     * cannot be printed and an exception will be thrown.\n     *\n     * @param {TemporalField} field  the field to append, not null\n     * @param {Number} minWidth  the minimum width of the field excluding the decimal point, from 0 to 9\n     * @param {Number} maxWidth  the maximum width of the field excluding the decimal point, from 1 to 9\n     * @param {boolean} decimalPoint  whether to output the localized decimal point symbol\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the field has a variable set of valid values or\n     *  either width is invalid\n     */\n    appendFraction(field, minWidth, maxWidth, decimalPoint) {\n        this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n        return this;\n    }\n\n    /**\n     * Appends an instant using ISO-8601 to the formatter with control over\n     * the number of fractional digits.\n     * <p>\n     * Instants have a fixed output format, although this method provides some\n     * control over the fractional digits. They are converted to a date-time\n     * with a zone-offset of UTC and printed using the standard ISO-8601 format.\n     * The localized decimal style is not used.\n     * <p>\n     * The {@code this.fractionalDigits} parameter allows the output of the fractional\n     * second to be controlled. Specifying zero will cause no fractional digits\n     * to be output. From 1 to 9 will output an increasing number of digits, using\n     * zero right-padding if necessary. The special value -1 is used to output as\n     * many digits as necessary to avoid any trailing zeroes.\n     * <p>\n     * When parsing in strict mode, the number of parsed digits must match the\n     * fractional digits. When parsing in lenient mode, any number of fractional\n     * digits from zero to nine are accepted.\n     * <p>\n     * The instant is obtained using {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS}\n     * and optionally (@code NANO_OF_SECOND). The value of {@code INSTANT_SECONDS}\n     * may be outside the maximum range of {@code LocalDateTime}.\n     * <p>\n     * The {@linkplain ResolverStyle resolver style} has no effect on instant parsing.\n     * The end-of-day time of '24:00' is handled as midnight at the start of the following day.\n     * The leap-second time of '23:59:59' is handled to some degree, see\n     * {@link DateTimeFormatter#parsedLeapSecond()} for full details.\n     * <p>\n     * An alternative to this method is to format/parse the instant as a single\n     * epoch-seconds value. That is achieved using {@code appendValue(INSTANT_SECONDS)}.\n     *\n     * @param {number} [fractionalDigits=-2] - the number of fractional second digits to format with,\n     *  from 0 to 9, or -1 to use as many digits as necessary\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendInstant(fractionalDigits=-2) {\n        if (fractionalDigits < -2 || fractionalDigits > 9) {\n            throw new IllegalArgumentException('Invalid fractional digits: ' + fractionalDigits);\n        }\n        this._appendInternal(new InstantPrinterParser(fractionalDigits));\n        return this;\n    }\n\n\n    /**\n     * Appends the zone offset, such as '+01:00', to the formatter.\n     * <p>\n     * This appends an instruction to print/parse the offset ID to the builder.\n     * This is equivalent to calling {@code appendOffset(\"HH:MM:ss\", \"Z\")}.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendOffsetId() {\n        this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);\n        return this;\n    }\n\n    /**\n      * Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.\n      * <p>\n      * This appends an instruction to print/parse the zone ID to the builder.\n      * The zone ID is obtained in a strict manner suitable for {@code ZonedDateTime}.\n      * By contrast, {@code OffsetDateTime} does not have a zone ID suitable\n      * for use with this method, see {@link #appendZoneOrOffsetId()}.\n      * <p>\n      * During printing, the zone is obtained using a mechanism equivalent\n      * to querying the temporal with {@link TemporalQueries#zoneId()}.\n      * It will be printed using the result of {@link ZoneId#getId()}.\n      * If the zone cannot be obtained then an exception is thrown unless the\n      * section of the formatter is optional.\n      * <p>\n      * During parsing, the zone is parsed and must match a known zone or offset.\n      * If the zone cannot be parsed then an exception is thrown unless the\n      * section of the formatter is optional.\n      *\n      * @return {DateTimeFormatterBuilder} this, for chaining, not null\n      * @see #appendZoneRegionId()\n      */\n    appendZoneId() {\n        this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), 'ZoneId()'));\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Mark the start of an optional section.\n     * <p>\n     * The output of printing can include optional sections, which may be nested.\n     * An optional section is started by calling this method and ended by calling\n     * {@link #optionalEnd()} or by ending the build process.\n     * <p>\n     * All elements in the optional section are treated as optional.\n     * During printing, the section is only output if data is available in the\n     * {@code TemporalAccessor} for all the elements in the section.\n     * During parsing, the whole section may be missing from the parsed string.\n     * <p>\n     * For example, consider a builder setup as\n     * {@code builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)}.\n     * The optional section ends automatically at the end of the builder.\n     * During printing, the minute will only be output if its value can be obtained from the date-time.\n     * During parsing, the input will be successfully parsed whether the minute is present or not.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    optionalStart() {\n        this._active.valueParserIndex = -1;\n        this._active = new DateTimeFormatterBuilder(this._active, true);\n        return this;\n    }\n\n    /**\n     * Ends an optional section.\n     * <p>\n     * The output of printing can include optional sections, which may be nested.\n     * An optional section is started by calling {@link #optionalStart()} and ended\n     * using this method (or at the end of the builder).\n     * <p>\n     * Calling this method without having previously called {@code optionalStart}\n     * will throw an exception.\n     * Calling this method immediately after calling {@code optionalStart} has no effect\n     * on the formatter other than ending the (empty) optional section.\n     * <p>\n     * All elements in the optional section are treated as optional.\n     * During printing, the section is only output if data is available in the\n     * {@code TemporalAccessor} for all the elements in the section.\n     * During parsing, the whole section may be missing from the parsed string.\n     * <p>\n     * For example, consider a builder setup as\n     * {@code builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()}.\n     * During printing, the minute will only be output if its value can be obtained from the date-time.\n     * During parsing, the input will be successfully parsed whether the minute is present or not.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalStateException if there was no previous call to {@code optionalStart}\n     */\n    optionalEnd() {\n        if (this._active._parent == null) {\n            throw new IllegalStateException('Cannot call optionalEnd() as there was no previous call to optionalStart()');\n        }\n        if (this._active._printerParsers.length > 0) {\n            var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);\n            this._active = this._active._parent;\n            this._appendInternal(cpp);\n        } else {\n            this._active = this._active._parent;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a printer and/or parser to the internal list handling padding.\n     *\n     * @param pp  the printer-parser to add, not null\n     * @return the index into the active parsers list\n     */\n    _appendInternal(pp) {\n        assert(pp != null);\n        if (this._active._padNextWidth > 0) {\n            if (pp != null) {\n                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n            }\n            this._active._padNextWidth = 0;\n            this._active._padNextChar = 0;\n        }\n        this._active._printerParsers.push(pp);\n        this._active._valueParserIndex = -1;\n        return this._active._printerParsers.length - 1;\n    }\n\n    /**\n     * Appends a string literal to the formatter.\n     * \n     * This string will be output during a print.\n     * \n     * If the literal is empty, nothing is added to the formatter.\n     *\n     * @param literal  the literal to append, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendLiteral(literal) {\n        assert(literal != null);\n        this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));\n        return this;\n    }\n    \n    /**\n     * Appends a printer and/or parser to the internal list handling padding.\n     *\n     * @param pp  the printer-parser to add, not null\n     * @return the index into the active parsers list\n     */\n    _appendInternalPrinterParser(pp) {\n        assert(pp != null);\n        if (this._active._padNextWidth > 0) {\n            if (pp != null) {\n                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n            }\n            this._active._padNextWidth = 0;\n            this._active._padNextChar = 0;\n        }\n        this._active._printerParsers.push(pp);\n        this._active._valueParserIndex = -1;\n        return this._active._printerParsers.length - 1;\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Appends all the elements of a formatter to the builder.\n     * <p>\n     * This method has the same effect as appending each of the constituent\n     * parts of the formatter directly to this builder.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to add, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    append(formatter) {\n        requireNonNull(formatter, 'formatter');\n        this._appendInternal(formatter.toPrinterParser(false));\n        return this;\n    }\n\n    /**\n     * Completes this builder by creating the DateTimeFormatter.\n     * \n     * This will create a formatter with the specified locale.\n     * Numbers will be printed and parsed using the standard non-localized set of symbols.\n     * \n     * Calling this method will end any open optional sections by repeatedly\n     * calling {@link #optionalEnd()} before creating the formatter.\n     * \n     * This builder can still be used after creating the formatter if desired,\n     * although the state may have been changed by calls to {@code optionalEnd}.\n     *\n     * @param resolverStyle  the new resolver style\n     * @return the created formatter, not null\n     */\n    toFormatter(resolverStyle=ResolverStyle.SMART) {\n        while (this._active._parent != null) {\n            this.optionalEnd();\n        }\n        var pp = new CompositePrinterParser(this._printerParsers, false);\n        return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);\n    }\n\n}\n\nconst EXCEED_POINTS = [\n    0,\n    10,\n    100,\n    1000,\n    10000,\n    100000,\n    1000000,\n    10000000,\n    100000000,\n    1000000000\n];\n\nclass CompositePrinterParser {\n\n    constructor(printerParsers, optional) {\n        this._printerParsers = printerParsers;\n        this._optional = optional;\n    }\n\n    /**\n     * Returns a copy of this printer-parser with the optional flag changed.\n     *\n     * @param {boolean} optional  the optional flag to set in the copy\n     * @return {CompositePrinterParser} the new printer-parser, not null\n     */\n    withOptional(optional) {\n        if (optional === this._optional) {\n            return this;\n        }\n        return new CompositePrinterParser(this._printerParsers, optional);\n    }\n\n    print(context, buf) {\n        var length = buf.length();\n        if (this._optional) {\n            context.startOptional();\n        }\n        try {\n            for (let i=0; i<this._printerParsers.length; i++) {\n                let pp = this._printerParsers[i];\n                if (pp.print(context, buf) === false) {\n                    buf.setLength(length);  // reset buffer\n                    return true;\n                }\n            }\n        } finally {\n            if (this._optional) {\n                context.endOptional();\n            }\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        if (this._optional) {\n            context.startOptional();\n            var pos = position;\n            for (let i=0; i<this._printerParsers.length; i++) {\n                let pp = this._printerParsers[i];\n                pos = pp.parse(context, text, pos);\n                if (pos < 0) {\n                    context.endOptional(false);\n                    return position;  // return original position\n                }\n            }\n            context.endOptional(true);\n            return pos;\n        } else {\n            for (let i=0; i<this._printerParsers.length; i++) {\n                let pp = this._printerParsers[i];\n                position = pp.parse(context, text, position);\n                if (position < 0) {\n                    break;\n                }\n            }\n            return position;\n        }\n    }\n\n    toString() {\n        var buf = '';\n        if (this._printerParsers != null) {\n            buf += this._optional ? '[' : '(';\n            for (let i=0; i<this._printerParsers.length; i++) {\n                let pp = this._printerParsers[i];\n                buf += pp.toString();\n            }\n            buf += this._optional ? ']' : ')';\n        }\n        return buf;\n    }\n}\n\n/**\n * Pads the output to a fixed width.\n */\nclass PadPrinterParserDecorator {\n\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer, not null\n     * @param padWidth  the width to pad to, 1 or greater\n     * @param padChar  the pad character\n     */\n    constructor(printerParser, padWidth, padChar) {\n        // input checked by DateTimeFormatterBuilder\n        this._printerParser = printerParser;\n        this._padWidth = padWidth;\n        this._padChar = padChar;\n    }\n\n    print(context, buf) {\n        var preLen = buf.length();\n        if (this._printerParser.print(context, buf) === false) {\n            return false;\n        }\n        var len = buf.length() - preLen;\n        if (len > this._padWidth) {\n            throw new DateTimeException(\n                `Cannot print as output of ${len} characters exceeds pad width of ${this._padWidth}`);\n        }\n        for (let i = 0; i < this._padWidth - len; i++) {\n            buf.insert(preLen, this._padChar);\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        // cache context before changed by decorated parser\n        var strict = context.isStrict();\n        var caseSensitive = context.isCaseSensitive();\n        // parse\n        assert(!(position > text.length));\n        if (position === text.length) {\n            return ~position;  // no more characters in the string\n        }\n        var endPos = position + this._padWidth;\n        if (endPos > text.length) {\n            if (strict) {\n                return ~position;  // not enough characters in the string to meet the parse width\n            }\n            endPos = text.length;\n        }\n        var pos = position;\n        while (pos < endPos &&\n                (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {\n            pos++;\n        }\n        text = text.substring(0, endPos);\n        var resultPos = this._printerParser.parse(context, text, pos);\n        if (resultPos !== endPos && strict) {\n            return ~(position + pos);  // parse of decorated field didn't parse to the end\n        }\n        return resultPos;\n    }\n\n    toString() {\n        return `Pad(${this._printerParser},${this._padWidth}${(this._padChar === ' ' ? ')' : ',\\'' + this._padChar + '\\')')}`;\n    }\n}\n\nclass SettingsParser extends Enum {\n\n    print(/*context, buf*/) {\n        return true;  // nothing to do here\n    }\n\n    parse(context, text, position) {\n        // using ordinals to avoid javac synthetic inner class\n        switch (this) {\n            case SettingsParser.SENSITIVE:   context.setCaseSensitive(true); break;\n            case SettingsParser.INSENSITIVE: context.setCaseSensitive(false); break;\n            case SettingsParser.STRICT:      context.setStrict(true); break;\n            case SettingsParser.LENIENT:     context.setStrict(false); break;\n        }\n        return position;\n    }\n\n    toString() {\n        // using ordinals to avoid javac synthetic inner class\n        switch (this) {\n            case SettingsParser.SENSITIVE:   return 'ParseCaseSensitive(true)';\n            case SettingsParser.INSENSITIVE: return 'ParseCaseSensitive(false)';\n            case SettingsParser.STRICT:      return 'ParseStrict(true)';\n            case SettingsParser.LENIENT:     return 'ParseStrict(false)';\n        }\n    }\n}\n\nSettingsParser.SENSITIVE = new SettingsParser('SENSITIVE');\nSettingsParser.INSENSITIVE = new SettingsParser('INSENSITIVE');\nSettingsParser.STRICT = new SettingsParser('STRICT');\nSettingsParser.LENIENT = new SettingsParser('LENIENT');\n\n/**\n* Prints or parses a string literal.\n*/\nclass StringLiteralPrinterParser {\n\n    constructor(literal) {\n        this._literal = literal;\n    }\n\n    print(context, buf) {\n        buf.append(this._literal);\n        return true;\n    }\n\n    parse(context, text, position) {\n        var length = text.length;\n        assert(!(position > length || position < 0));\n\n        if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {\n            return ~position;\n        }\n        return position + this._literal.length;\n    }\n\n    toString() {\n        return '\\'' + this._literal + '\\'';\n    }\n}\n\nclass NumberPrinterParser {\n\n    /**\n     * Constructor.\n     *\n     * @param field  the field to print, not null\n     * @param minWidth  the minimum field width, from 1 to 19\n     * @param maxWidth  the maximum field width, from minWidth to 19\n     * @param signStyle  the positive/negative sign style, not null\n     * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater,\n     *  -1 if fixed width due to active adjacent parsing\n     */\n    constructor(field, minWidth, maxWidth, signStyle, subsequentWidth=0){\n        this._field = field;\n        this._minWidth = minWidth;\n        this._maxWidth = maxWidth;\n        this._signStyle = signStyle;\n        this._subsequentWidth = subsequentWidth;\n    }\n\n    field(){ return this._field;}\n    minWidth(){ return this._minWidth;}\n    maxWidth(){ return this._maxWidth;}\n    signStyle(){ return this._signStyle;}\n\n    withSubsequentWidth(subsequentWidth) {\n        return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);\n    }\n\n    _isFixedWidth() {\n        return this._subsequentWidth === -1 ||\n                (this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE);\n    }\n\n    print(context, buf) {\n        var value = context.getValue(this._field);\n        if (value == null) {\n            return false;\n        }\n        var symbols = context.symbols();\n        var str = '' + Math.abs(value);\n        if (str.length > this._maxWidth) {\n            throw new DateTimeException('Field ' + this._field +\n                ' cannot be printed as the value ' + value +\n                ' exceeds the maximum print width of ' + this._maxWidth);\n        }\n        str = symbols.convertNumberToI18N(str);\n\n        if (value >= 0) {\n            switch (this._signStyle) {\n                case SignStyle.EXCEEDS_PAD:\n                    if (this._minWidth < MAX_WIDTH && value >= EXCEED_POINTS[this._minWidth]) {\n                        buf.append(symbols.positiveSign());\n                    }\n                    break;\n                case SignStyle.ALWAYS:\n                    buf.append(symbols.positiveSign());\n                    break;\n            }\n        } else {\n            switch (this._signStyle) {\n                case SignStyle.NORMAL:\n                case SignStyle.EXCEEDS_PAD:\n                case SignStyle.ALWAYS:\n                    buf.append(symbols.negativeSign());\n                    break;\n                case SignStyle.NOT_NEGATIVE:\n                    throw new DateTimeException('Field ' + this._field +\n                        ' cannot be printed as the value ' + value +\n                        ' cannot be negative according to the SignStyle');\n            }\n        }\n        for (let i = 0; i < this._minWidth - str.length; i++) {\n            buf.append(symbols.zeroDigit());\n        }\n        buf.append(str);\n        return true;\n    }\n\n    parse(context, text, position){\n        var length = text.length;\n        if (position === length) {\n            return ~position;\n        }\n        assert(position>=0 && position<length);\n        var sign = text.charAt(position);  // IOOBE if invalid position\n        var negative = false;\n        var positive = false;\n        if (sign === context.symbols().positiveSign()) {\n            if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n                return ~position;\n            }\n            positive = true;\n            position++;\n        } else if (sign === context.symbols().negativeSign()) {\n            if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n                return ~position;\n            }\n            negative = true;\n            position++;\n        } else {\n            if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {\n                return ~position;\n            }\n        }\n        var effMinWidth = (context.isStrict() || this._isFixedWidth() ? this._minWidth : 1);\n        var minEndPos = position + effMinWidth;\n        if (minEndPos > length) {\n            return ~position;\n        }\n        var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);\n        var total = 0;\n        var pos = position;\n        for (let pass = 0; pass < 2; pass++) {\n            let maxEndPos = Math.min(pos + effMaxWidth, length);\n            while (pos < maxEndPos) {\n                let ch = text.charAt(pos++);\n                let digit = context.symbols().convertToDigit(ch);\n                if (digit < 0) {\n                    pos--;\n                    if (pos < minEndPos) {\n                        return ~position;  // need at least min width digits\n                    }\n                    break;\n                }\n                if ((pos - position) > MAX_WIDTH) {\n                    throw new ArithmeticException('number text exceeds length');\n                } else {\n                    total = total * 10 + digit;\n                }\n            }\n            if (this._subsequentWidth > 0 && pass === 0) {\n                // re-parse now we know the correct width\n                let parseLen = pos - position;\n                effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);\n                pos = position;\n                total = 0;\n            } else {\n                break;\n            }\n        }\n        if (negative) {\n            if (total === 0 && context.isStrict()) {\n                return ~(position - 1);  // minus zero not allowed\n            }\n            if(total !== 0) {\n                total = -total;\n            }\n        } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {\n            let parseLen = pos - position;\n            if (positive) {\n                if (parseLen <= this._minWidth) {\n                    return ~(position - 1);  // '+' only parsed if minWidth exceeded\n                }\n            } else {\n                if (parseLen > this._minWidth) {\n                    return ~position;  // '+' must be parsed if minWidth exceeded\n                }\n            }\n        }\n        return this._setValue(context, total, position, pos);\n    }\n\n    /**\n     * Stores the value.\n     *\n     * @param context  the context to store into, not null\n     * @param value  the value\n     * @param errorPos  the position of the field being parsed\n     * @param successPos  the position after the field being parsed\n     * @return the new position\n     */\n    _setValue(context, value, errorPos, successPos) {\n        return context.setParsedField(this._field, value, errorPos, successPos);\n    }\n\n    toString() {\n        if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH && this._signStyle === SignStyle.NORMAL) {\n            return 'Value(' + this._field + ')';\n        }\n        if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {\n            return 'Value(' + this._field + ',' + this._minWidth + ')';\n        }\n        return 'Value(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + this._signStyle + ')';\n    }\n\n}\n\n//-----------------------------------------------------------------------\n\nimport {MathUtil} from '../MathUtil';\n\n/**\n * TODO optimize FractionPrinterParser, fix documentation\n *\n * Prints and parses a numeric date-time field with optional padding.\n */\nclass FractionPrinterParser {\n\n    /**\n     * Constructor.\n     *\n     * @param {TemporalField} field  the field to output, not null\n     * @param {Number} minWidth  the minimum width to output, from 0 to 9\n     * @param {Number} maxWidth  the maximum width to output, from 0 to 9\n     * @param {boolean} decimalPoint  whether to output the localized decimal point symbol\n     */\n    constructor(field, minWidth, maxWidth, decimalPoint) {\n        requireNonNull(field, 'field');\n        if (field.range().isFixed() === false) {\n            throw new IllegalArgumentException('Field must have a fixed set of values: ' + field);\n        }\n        if (minWidth < 0 || minWidth > 9) {\n            throw new IllegalArgumentException('Minimum width must be from 0 to 9 inclusive but was ' + minWidth);\n        }\n        if (maxWidth < 1 || maxWidth > 9) {\n            throw new IllegalArgumentException('Maximum width must be from 1 to 9 inclusive but was ' + maxWidth);\n        }\n        if (maxWidth < minWidth) {\n            throw new IllegalArgumentException('Maximum width must exceed or equal the minimum width but ' +\n                    maxWidth + ' < ' + minWidth);\n        }\n        this.field = field;\n        this.minWidth = minWidth;\n        this.maxWidth = maxWidth;\n        this.decimalPoint = decimalPoint;\n    }\n\n    print(context, buf) {\n        var value = context.getValue(this.field);\n        if (value === null) {\n            return false;\n        }\n        var symbols = context.symbols();\n        if (value === 0) {  // scale is zero if value is zero\n            if (this.minWidth > 0) {\n                if (this.decimalPoint) {\n                    buf.append(symbols.decimalSeparator());\n                }\n                for (let i = 0; i < this.minWidth; i++) {\n                    buf.append(symbols.zeroDigit());\n                }\n            }\n        } else {\n            var fraction = this.convertToFraction(value, symbols.zeroDigit());\n            var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);\n            fraction = fraction.substr(0, outputScale);\n            if(fraction * 1 > 0 ) {\n                while (fraction.length > this.minWidth && fraction[fraction.length - 1] === '0') {\n                    fraction = fraction.substr(0, fraction.length - 1);\n                }\n            }\n            var str = fraction;\n            str = symbols.convertNumberToI18N(str);\n            if (this.decimalPoint) {\n                buf.append(symbols.decimalSeparator());\n            }\n            buf.append(str);\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        var effectiveMin = (context.isStrict() ? this.minWidth : 0);\n        var effectiveMax = (context.isStrict() ? this.maxWidth : 9);\n        var length = text.length;\n        if (position === length) {\n            // valid if whole field is optional, invalid if minimum width\n            return (effectiveMin > 0 ? ~position : position);\n        }\n        if (this.decimalPoint) {\n            if (text[position] !== context.symbols().decimalSeparator()) {\n                // valid if whole field is optional, invalid if minimum width\n                return (effectiveMin > 0 ? ~position : position);\n            }\n            position++;\n        }\n        var minEndPos = position + effectiveMin;\n        if (minEndPos > length) {\n            return ~position;  // need at least min width digits\n        }\n        var maxEndPos = Math.min(position + effectiveMax, length);\n        var total = 0;  // can use int because we are only parsing up to 9 digits\n        var pos = position;\n        while (pos < maxEndPos) {\n            var ch = text.charAt(pos++);\n            var digit = context.symbols().convertToDigit(ch);\n            if (digit < 0) {\n                if (pos < minEndPos) {\n                    return ~position;  // need at least min width digits\n                }\n                pos--;\n                break;\n            }\n            total = total * 10 + digit;\n        }\n        var moveLeft = pos - position;\n        var scale = Math.pow(10, moveLeft);\n        var value = this.convertFromFraction(total, scale);\n        return context.setParsedField(this.field, value, position, pos);\n    }\n\n    /**\n     *\n     * @param {Number} value  the value to convert, must be valid for this rule\n     * @return {String} the value as a fraction within the range, from 0 to 1, not null\n     */\n    convertToFraction(value, zeroDigit) {\n        var range = this.field.range();\n        range.checkValidValue(value, this.field);\n        var _min = range.minimum();\n        var _range = range.maximum() - _min + 1;\n        var _value = value - _min;\n        var _scaled = MathUtil.intDiv((_value * 1000000000),  _range);\n        var fraction = '' + _scaled;\n        while(fraction.length < 9){\n            fraction = zeroDigit + fraction;\n        }\n        return fraction;\n    }\n\n    /**\n     *\n     * @param {Number} fraction  the fraction to convert, not null\n     * @return {Number} the value of the field, valid for this rule\n     * @throws DateTimeException if the value cannot be converted\n     */\n    convertFromFraction(total, scale) {\n        var range = this.field.range();\n        var _min = range.minimum();\n        var _range = range.maximum() - _min + 1;\n        var _value = MathUtil.intDiv((total * _range), scale);\n        return _value;\n    }\n\n    toString() {\n        var decimal = (this.decimalPoint ? ',DecimalPoint' : '');\n        return 'Fraction(' + this.field + ',' + this.minWidth + ',' + this.maxWidth + decimal + ')';\n    }\n}\n\n//-----------------------------------------------------------------------\n\n// days in a 400 year cycle = 146097\n// days in a 10,000 year cycle = 146097 * 25\n// seconds per day = 86400\nconst SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;\nconst SECONDS_0000_TO_1970 = ((146097 * 5) - (30 * 365 + 7)) * 86400;\n\n/**\n * Prints or parses an ISO-8601 instant.\n */\nclass InstantPrinterParser  {\n\n    constructor(fractionalDigits) {\n        this.fractionalDigits = fractionalDigits;\n    }\n\n    print(context, buf) {\n        // use INSTANT_SECONDS, thus this code is not bound by Instant.MAX\n        var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);\n        var inNanos = 0;\n        if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {\n            inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);\n        }\n        if (inSecs == null) {\n            return false;\n        }\n        var inSec = inSecs;\n        var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);\n        if (inSec >= -SECONDS_0000_TO_1970) {\n            // current era\n            let zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n            let hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n            let lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n            let ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n            if (hi > 0) {\n                buf.append('+').append(hi);\n            }\n            buf.append(ldt);\n            if (ldt.second() === 0) {\n                buf.append(':00');\n            }\n        } else {\n            // before current era\n            let zeroSecs = inSec + SECONDS_0000_TO_1970;\n            let hi = MathUtil.intDiv(zeroSecs, SECONDS_PER_10000_YEARS);\n            let lo = MathUtil.intMod(zeroSecs, SECONDS_PER_10000_YEARS);\n            let ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n            let pos = buf.length();\n            buf.append(ldt);\n            if (ldt.second() === 0) {\n                buf.append(':00');\n            }\n            if (hi < 0) {\n                if (ldt.year() === -10000) {\n                    buf.replace(pos, pos + 2, '' + (hi - 1));\n                } else if (lo === 0) {\n                    buf.insert(pos, hi);\n                } else {\n                    buf.insert(pos + 1, Math.abs(hi));\n                }\n            }\n        }\n        //fraction\n        if (this.fractionalDigits === -2) {\n            if (inNano !== 0) {\n                buf.append('.');\n                if (MathUtil.intMod(inNano, 1000000) === 0) {\n                    buf.append(('' + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));\n                } else if (MathUtil.intMod(inNano, 1000) === 0) {\n                    buf.append(('' + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));\n                } else {\n                    buf.append(('' + ((inNano) + 1000000000)).substring(1));\n                }\n            }\n        } else if (this.fractionalDigits > 0 || (this.fractionalDigits === -1 && inNano > 0)) {\n            buf.append('.');\n            let div = 100000000;\n            for (let i = 0; ((this.fractionalDigits === -1 && inNano > 0) || i < this.fractionalDigits); i++) {\n                let digit = MathUtil.intDiv(inNano, div);\n                buf.append(digit);\n                inNano = inNano - (digit * div);\n                div = MathUtil.intDiv(div, 10);\n            }\n        }\n        buf.append('Z');\n        return true;\n    }\n\n    parse(context, text, position) {\n        // new context to avoid overwriting fields like year/month/day\n        var newContext = context.copy();\n        var minDigits = (this.fractionalDigits < 0 ? 0 : this.fractionalDigits);\n        var maxDigits = (this.fractionalDigits < 0 ? 9 : this.fractionalDigits);\n        var parser = new DateTimeFormatterBuilder()\n                .append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T')\n                .appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':')\n                .appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral('Z')\n                .toFormatter().toPrinterParser(false);\n        var pos = parser.parse(newContext, text, position);\n        if (pos < 0) {\n            return pos;\n        }\n        // parser restricts most fields to 2 digits, so definitely int\n        // correctly parsed nano is also guaranteed to be valid\n        var yearParsed = newContext.getParsed(ChronoField.YEAR);\n        var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);\n        var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);\n        var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);\n        var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);\n        var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);\n        var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);\n        var sec = (secVal != null ? secVal : 0);\n        var nano = (nanoVal != null ? nanoVal : 0);\n        var year = MathUtil.intMod(yearParsed, 10000);\n        var days = 0;\n        if (hour === 24 && min === 0 && sec === 0 && nano === 0) {\n            hour = 0;\n            days = 1;\n        } else if (hour === 23 && min === 59 && sec === 60) {\n            context.setParsedLeapSecond();\n            sec = 59;\n        }\n        var instantSecs;\n        try {\n            var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);\n            instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);\n            instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);\n        } catch (ex) {\n            return ~position;\n        }\n        var successPos = pos;\n        successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);\n        return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);\n    }\n\n    toString() {\n        return 'Instant()';\n    }\n}\n\n//-----------------------------------------------------------------------\nconst PATTERNS = [\n    '+HH', '+HHmm', '+HH:mm', '+HHMM', '+HH:MM', '+HHMMss', '+HH:MM:ss', '+HHMMSS', '+HH:MM:SS'\n];\n/**\n * Prints or parses an offset ID.\n */\nclass OffsetIdPrinterParser  {\n\n    /**\n     * Constructor.\n     *\n     * @param {string} noOffsetText  the text to use for UTC, not null\n     * @param {string} pattern  the pattern\n     */\n    constructor(noOffsetText, pattern) {\n        requireNonNull(noOffsetText, 'noOffsetText');\n        requireNonNull(pattern, 'pattern');\n        this.noOffsetText = noOffsetText;\n        this.type = this._checkPattern(pattern);\n    }\n\n    /**\n     * @param {String} pattern\n     * @return {number}\n     */\n    _checkPattern(pattern) {\n        for (let i = 0; i < PATTERNS.length; i++) {\n            if (PATTERNS[i] === pattern) {\n                return i;\n            }\n        }\n        throw new IllegalArgumentException('Invalid zone offset pattern: ' + pattern);\n    }\n\n    /**\n     * @param {DateTimePrintContext} context\n     * @param {StringBuilder} buf\n     * @return {boolean} \n     */\n    print(context, buf) {\n        var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);\n        if (offsetSecs == null) {\n            return false;\n        }\n        var totalSecs = MathUtil.safeToInt(offsetSecs);\n        if (totalSecs === 0) {\n            buf.append(this.noOffsetText);\n        } else {\n            var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));  // anything larger than 99 silently dropped\n            var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));\n            var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));\n            var bufPos = buf.length();\n            var output = absHours;\n            buf.append(totalSecs < 0 ? '-' : '+')\n                .appendChar((MathUtil.intDiv(absHours, 10) + '0')).appendChar(MathUtil.intMod(absHours, 10) + '0');\n            if (this.type >= 3 || (this.type >= 1 && absMinutes > 0)) {\n                buf.append((this.type % 2) === 0 ? ':' : '')\n                    .appendChar((MathUtil.intDiv(absMinutes, 10) + '0')).appendChar((absMinutes % 10 + '0'));\n                output += absMinutes;\n                if (this.type >= 7 || (this.type >= 5 && absSeconds > 0)) {\n                    buf.append((this.type % 2) === 0 ? ':' : '')\n                        .appendChar((MathUtil.intDiv(absSeconds, 10) + '0')).appendChar((absSeconds % 10 + '0'));\n                    output += absSeconds;\n                }\n            }\n            if (output === 0) {\n                buf.setLength(bufPos);\n                buf.append(this.noOffsetText);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} position\n     * @return {number}\n     */\n    parse(context, text, position) {\n        var length = text.length;\n        var noOffsetLen = this.noOffsetText.length;\n        if (noOffsetLen === 0) {\n            if (position === length) {\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);\n            }\n        } else {\n            if (position === length) {\n                return ~position;\n            }\n            if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n            }\n        }\n\n        // parse normal plus/minus offset\n        var sign = text[position];  // IOOBE if invalid position\n        if (sign === '+' || sign === '-') {\n            // starts\n            var negative = (sign === '-' ? -1 : 1);\n            var array = [0,0,0,0];\n            array[0] = position + 1;\n            if ((this._parseNumber(array, 1, text, true) ||\n                    this._parseNumber(array, 2, text, this.type >=3) ||\n                    this._parseNumber(array, 3, text, false)) === false) {\n                // success\n                var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);\n            }\n        }\n        // handle special case of empty no offset text\n        if (noOffsetLen === 0) {\n            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n        }\n        return ~position;\n    }\n\n    /**\n     * Parse a two digit zero-prefixed number.\n     *\n     * @param {number[]} array  the array of parsed data, 0=pos,1=hours,2=mins,3=secs, not null\n     * @param {number} arrayIndex  the index to parse the value into\n     * @param {string} parseText  the offset ID, not null\n     * @param {boolean} required  whether this number is required\n     * @return {boolean} true if an error occurred\n     */\n    _parseNumber(array, arrayIndex, parseText, required) {\n        if ((this.type + 3) / 2 < arrayIndex) {\n            return false;  // ignore seconds/minutes\n        }\n        var pos = array[0];\n        if ((this.type % 2) === 0 && arrayIndex > 1) {\n            if (pos + 1 > parseText.length || parseText[pos] !== ':') {\n                return required;\n            }\n            pos++;\n        }\n        if (pos + 2 > parseText.length) {\n            return required;\n        }\n        var ch1 = parseText[pos++];\n        var ch2 = parseText[pos++];\n        if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n            return required;\n        }\n        var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n        if (value < 0 || value > 59) {\n            return required;\n        }\n        array[arrayIndex] = value;\n        array[0] = pos;\n        return false;\n    }\n\n\n    toString() {\n        var converted = this.noOffsetText.replace('\\'', '\\'\\'');\n        return 'Offset(' + PATTERNS[this.type] + ',\"' + converted + '\")';\n    }\n}\nOffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser('Z', '+HH:MM:ss');\n\n/**\n * Prints or parses a zone ID.\n */\nclass ZoneIdPrinterParser {\n\n    /**\n     *\n     * @param {TemporalQuery} query\n     * @param {string} description\n     */\n    constructor(query, description) {\n        this.query = query;\n        this.description = description;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {DateTimePrintContext } context\n     * @param {StringBuilder} buf\n     * @returns {boolean}\n     */\n    print(context, buf) {\n        var zone = context.getValueQuery(this.query);\n        if (zone == null) {\n            return false;\n        }\n        buf.append(zone.id());\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * This implementation looks for the longest matching string.\n     * For example, parsing Etc/GMT-2 will return Etc/GMC-2 rather than just\n     * Etc/GMC although both are valid.\n     * <p>\n     * This implementation uses a tree to search for valid time-zone names in\n     * the parseText. The top level node of the tree has a length equal to the\n     * length of the shortest time-zone as well as the beginning characters of\n     * all other time-zones.\n     *\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} position\n     * @return {number}\n     */\n    parse(context, text, position) {\n        var length = text.length;\n        if (position > length) {\n            return ~position;\n        }\n        if (position === length) {\n            return ~position;\n        }\n\n        // handle fixed time-zone IDs\n        var nextChar = text.charAt(position);\n        if (nextChar === '+' || nextChar === '-') {\n            var newContext = context.copy();\n            var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n            if (endPos < 0) {\n                return endPos;\n            }\n            var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n            var zone = ZoneOffset.ofTotalSeconds(offset);\n            context.setParsedZone(zone);\n            return endPos;\n        } else if (length >= position + 2) {\n            var nextNextChar = text.charAt(position + 1);\n            if (context.charEquals(nextChar, 'U') &&\n                            context.charEquals(nextNextChar, 'T')) {\n                if (length >= position + 3 &&\n                                context.charEquals(text.charAt(position + 2), 'C')) {\n                    return this._parsePrefixedOffset(context, text, position, position + 3);\n                }\n                return this._parsePrefixedOffset(context, text, position, position + 2);\n            } else if (context.charEquals(nextChar, 'G') &&\n                    length >= position + 3 &&\n                    context.charEquals(nextNextChar, 'M') &&\n                    context.charEquals(text.charAt(position + 2), 'T')) {\n                return this._parsePrefixedOffset(context, text, position, position + 3);\n            }\n        }\n        // javascript special case\n        if(text.substr(position, 6) === 'SYSTEM'){\n            context.setParsedZone(ZoneId.systemDefault());\n            return position + 6;\n        }\n\n        // ...\n        if (context.charEquals(nextChar, 'Z')) {\n            context.setParsedZone(ZoneOffset.UTC);\n            return position + 1;\n        }\n        // ...\n        return ~position;\n    }\n\n    /**\n     *\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} prefixPos\n     * @param {number} position\n     * @return {number}\n     */\n    _parsePrefixedOffset(context, text, prefixPos, position) {\n        var prefix = text.substring(prefixPos, position).toUpperCase();\n        var newContext = context.copy();\n        if (position < text.length && context.charEquals(text.charAt(position), 'Z')) {\n            context.setParsedZone(ZoneIdFactory.ofOffset(prefix, ZoneOffset.UTC));\n            return position;\n        }\n        var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n        if (endPos < 0) {\n            context.setParsedZone(ZoneIdFactory.ofOffset(prefix, ZoneOffset.UTC));\n            return position;\n        }\n        var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n        context.setParsedZone(ZoneIdFactory.ofOffset(prefix, offset));\n        return endPos;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return this.description;\n    }\n}\n\nDateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;\nDateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;\nDateTimeFormatterBuilder.SettingsParser = SettingsParser;\nDateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;\nDateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;\nDateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;\nDateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;\nDateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;\nDateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/format/DateTimeFormatterBuilder.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from './assert';\nimport {DateTimeException, IllegalArgumentException} from './errors';\nimport {StringUtil} from './StringUtil';\n\nimport {ZoneOffset} from './ZoneOffset';\nimport {ZoneRegion} from './ZoneRegion';\nimport {ZoneId} from './ZoneId';\n\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {SystemDefaultZoneId} from './zone/SystemDefaultZoneId';\n\n/**\n * @see {@link ZoneId}\n *\n * Helper class to avoid dependency cycles.\n * Static methods of the class ZoneIdFactory are added automatically to class ZoneId.\n */\nexport class ZoneIdFactory {\n\n    /**\n     * Gets the system default time-zone.\n     * <p>\n     *\n     * @return {ZoneId} the zone ID, not null\n     */\n    static systemDefault() {\n        return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n    }\n\n    /**\n     * Obtains an instance of {@code ZoneId} from an ID ensuring that the\n     * ID is valid and available for use.\n     * <p>\n     * This method parses the ID producing a {@code ZoneId} or {@code ZoneOffset}.\n     * A {@code ZoneOffset} is returned if the ID is 'Z', or starts with '+' or '-'.\n     * The result will always be a valid ID for which {@link ZoneRules} can be obtained.\n     * <p>\n     * Parsing matches the zone ID step by step as follows.\n     * <ul>\n     * <li>If the zone ID equals 'Z', the result is {@code ZoneOffset.UTC}.\n     * <li>If the zone ID consists of a single letter, the zone ID is invalid\n     *  and {@code DateTimeException} is thrown.\n     * <li>If the zone ID starts with '+' or '-', the ID is parsed as a\n     *  {@code ZoneOffset} using {@link ZoneOffset#of(String)}.\n     * <li>If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a {@code ZoneId}\n     *  with the same ID and rules equivalent to {@code ZoneOffset.UTC}.\n     * <li>If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'\n     *  then the ID is a prefixed offset-based ID. The ID is split in two, with\n     *  a two or three letter prefix and a suffix starting with the sign.\n     *  The suffix is parsed as a {@link ZoneOffset#of(String) ZoneOffset}.\n     *  The result will be a {@code ZoneId} with the specified UTC/GMT/UT prefix\n     *  and the normalized offset ID as per {@link ZoneOffset#getId()}.\n     *  The rules of the returned {@code ZoneId} will be equivalent to the\n     *  parsed {@code ZoneOffset}.\n     * <li>All other IDs are parsed as region-based zone IDs. Region IDs must\n     *  match the regular expression <code>[A-Za-z][A-Za-z0-9~/._+-]+</code>\n     *  otherwise a {@code DateTimeException} is thrown. If the zone ID is not\n     *  in the configured set of IDs, {@code ZoneRulesException} is thrown.\n     *  The detailed format of the region ID depends on the group supplying the data.\n     *  The default set of data is supplied by the IANA Time Zone Database (TZDB).\n     *  This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.\n     *  This is compatible with most IDs from {@link java.util.TimeZone}.\n     * </ul>\n     *\n     * @param {string} zoneId  the time-zone ID, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if the zone ID has an invalid format\n     * @throws ZoneRulesException if the zone ID is a region ID that cannot be found\n     */\n    static of(zoneId) {\n        requireNonNull(zoneId, 'zoneId');\n        if (zoneId === 'Z') {\n            return ZoneOffset.UTC;\n        }\n        if (zoneId.length === 1) {\n            throw new DateTimeException('Invalid zone: ' + zoneId);\n        }\n        if (StringUtil.startsWith(zoneId, '+') || StringUtil.startsWith(zoneId, '-')) {\n            return ZoneOffset.of(zoneId);\n        }\n        if (zoneId === 'UTC' || zoneId === 'GMT' || zoneId === 'UT') {\n            return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());\n        }\n        if (StringUtil.startsWith(zoneId, 'UTC+') || StringUtil.startsWith(zoneId, 'GMT+') ||\n                StringUtil.startsWith(zoneId, 'UTC-') || StringUtil.startsWith(zoneId, 'GMT-')) {\n            let offset = ZoneOffset.of(zoneId.substring(3));\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion(zoneId.substring(0, 3), offset.rules());\n            }\n            return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());\n        }\n        if (StringUtil.startsWith(zoneId, 'UT+') || StringUtil.startsWith(zoneId, 'UT-')) {\n            let offset = ZoneOffset.of(zoneId.substring(2));\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion('UT', offset.rules());\n            }\n            return new ZoneRegion('UT' + offset.id(), offset.rules());\n        }\n        // javascript special case\n        if(zoneId === 'SYSTEM'){\n            return ZoneId.systemDefault();\n        }\n        return ZoneRegion.ofId(zoneId, true);\n    }\n\n    /**\n     * Obtains an instance of {@code ZoneId} wrapping an offset.\n     * <p>\n     * If the prefix is 'GMT', 'UTC', or 'UT' a {@code ZoneId}\n     * with the prefix and the non-zero offset is returned.\n     * If the prefix is empty {@code ''} the {@code ZoneOffset} is returned.\n     *\n     * @param {string} prefix  the time-zone ID, not null\n     * @param {ZoneOffset} offset  the offset, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws IllegalArgumentException if the prefix is not one of\n     *     'GMT', 'UTC', or 'UT', or ''\n     */\n    static ofOffset(prefix, offset) {\n        requireNonNull(prefix, 'prefix');\n        requireNonNull(offset, 'offset');\n        if (prefix.length === 0) {\n            return offset;\n        }\n        if (prefix === 'GMT' || prefix === 'UTC' || prefix === 'UT') {\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion(prefix, offset.rules());\n            }\n            return new ZoneRegion(prefix + offset.id(), offset.rules());\n        }\n        throw new IllegalArgumentException('Invalid prefix, must be GMT, UTC or UT: ' + prefix);\n    }\n\n\n    /**\n     * Obtains an instance of {@code ZoneId} from a temporal object.\n     * <p>\n     * A {@code TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@code ZoneId}.\n     * <p>\n     * The conversion will try to obtain the zone in a way that favours region-based\n     * zones over offset-based zones using {@link TemporalQueries#zone()}.\n     * <p>\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@code ZoneId::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if unable to convert to a {@code ZoneId}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        var obj = temporal.query(TemporalQueries.zone());\n        if (obj == null) {\n            throw new DateTimeException('Unable to obtain ZoneId from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));\n        }\n        return obj;\n    }\n}\n\nvar SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;\n\nexport function _init(){\n    SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();\n\n    // a bit magic to stay a bit more to the threeten bp impl.\n    ZoneId.systemDefault = ZoneIdFactory.systemDefault;\n    ZoneId.of = ZoneIdFactory.of;\n    ZoneId.ofOffset = ZoneIdFactory.ofOffset;\n    ZoneId.from = ZoneIdFactory.from;\n    ZoneOffset.from = ZoneIdFactory.from;\n\n    // short cut\n    ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n    ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ZoneIdFactory.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport class StringUtil {\n\n    /**\n     *\n     * @param {string} text\n     * @param {string} pattern\n     * @return {boolean}\n     */\n    static startsWith(text, pattern){\n        return text.indexOf(pattern) === 0;\n    }\n\n    /**\n     *\n     * @param {string} text\n     * @returns {number}\n     */\n    static hashCode(text) {\n        var hash = 0, i, chr, len;\n        if (text.length === 0) return hash;\n        for (i = 0, len = text.length; i < len; i++) {\n            chr = text.charCodeAt(i);\n            hash = ((hash << 5) - hash) + chr;\n            hash |= 0; // Convert to 32bit integer\n        }\n        return hash;\n    }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/StringUtil.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from './assert';\nimport {DateTimeException} from './errors';\nimport {MathUtil} from './MathUtil';\n\nimport {LocalTime} from './LocalTime';\nimport {ZoneId} from './ZoneId';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {TemporalQueries} from './temporal/TemporalQueries';\n\nimport {ZoneRules} from './zone/ZoneRules';\n\nvar SECONDS_CACHE = {};\nvar ID_CACHE = {};\n\n/**\n *\n * <h3>Static properties of Class {@link LocalDate}</h3>\n *\n * ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n *\n * ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n *\n * ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n *\n * ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n *\n */\nexport class ZoneOffset extends ZoneId {\n    /**\n     * \n     * @param {number} totalSeconds\n     */\n    constructor(totalSeconds){\n        super();\n        ZoneOffset._validateTotalSeconds(totalSeconds);\n        this._totalSeconds = totalSeconds;\n        this._rules = ZoneRules.of(this);\n        this._id = ZoneOffset._buildId(totalSeconds);\n    }\n\n    /**\n     * \n     * @returns {number}\n     */\n    totalSeconds() {\n        return this._totalSeconds;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    id() {\n        return this._id;\n    }\n\n    /**\n     *\n     * @param {number} totalSeconds\n     * @returns {string}\n     */\n    static _buildId(totalSeconds) {\n        if (totalSeconds === 0) {\n            return 'Z';\n        } else {\n            var absTotalSeconds = Math.abs(totalSeconds);\n            var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);\n            var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n            var buf = '' + (totalSeconds < 0 ? '-' : '+')\n                + (absHours < 10 ? '0' : '') + (absHours)\n                + (absMinutes < 10 ? ':0' : ':') + (absMinutes);\n            var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);\n            if (absSeconds !== 0) {\n                buf += (absSeconds < 10 ? ':0' : ':') + (absSeconds);\n            }\n            return buf;\n        }\n    }\n\n\n    /**\n     * \n     * @param {number} totalSeconds\n     * @private\n     */\n    static _validateTotalSeconds(totalSeconds){\n        if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {\n            throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n        }\n    }\n\n    /**\n     * \n     * @param {number} hours\n     * @param {number} minutes\n     * @param {number} seconds\n     * @private\n     */\n    static _validate(hours, minutes, seconds) {\n        if (hours < -18 || hours > 18) {\n            throw new DateTimeException('Zone offset hours not in valid range: value ' + hours +\n                    ' is not in the range -18 to 18');\n        }\n        if (hours > 0) {\n            if (minutes < 0 || seconds < 0) {\n                throw new DateTimeException('Zone offset minutes and seconds must be positive because hours is positive');\n            }\n        } else if (hours < 0) {\n            if (minutes > 0 || seconds > 0) {\n                throw new DateTimeException('Zone offset minutes and seconds must be negative because hours is negative');\n            }\n        } else if ((minutes > 0 && seconds < 0) || (minutes < 0 && seconds > 0)) {\n            throw new DateTimeException('Zone offset minutes and seconds must have the same sign');\n        }\n        if (Math.abs(minutes) > 59) {\n            throw new DateTimeException('Zone offset minutes not in valid range: abs(value) ' +\n                    Math.abs(minutes) + ' is not in the range 0 to 59');\n        }\n        if (Math.abs(seconds) > 59) {\n            throw new DateTimeException('Zone offset seconds not in valid range: abs(value) ' +\n                    Math.abs(seconds) + ' is not in the range 0 to 59');\n        }\n        if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {\n            throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code ZoneOffset} using the ID.\n     * <p>\n     * This method parses the string ID of a {@code ZoneOffset} to\n     * return an instance. The parsing accepts all the formats generated by\n     * {@link #getId()}, plus some additional formats:\n     * <p><ul>\n     * <li>{@code Z} - for UTC\n     * <li>{@code +h}\n     * <li>{@code +hh}\n     * <li>{@code +hh:mm}\n     * <li>{@code -hh:mm}\n     * <li>{@code +hhmm}\n     * <li>{@code -hhmm}\n     * <li>{@code +hh:mm:ss}\n     * <li>{@code -hh:mm:ss}\n     * <li>{@code +hhmmss}\n     * <li>{@code -hhmmss}\n     * </ul><p>\n     * Note that &plusmn; means either the plus or minus symbol.\n     * <p>\n     * The ID of the returned offset will be normalized to one of the formats\n     * described by {@link #getId()}.\n     * <p>\n     * The maximum supported range is from +18:00 to -18:00 inclusive.\n     *\n     * @param {string} offsetId  the offset ID, not null\n     * @return {ZoneOffset} the zone-offset, not null\n     * @throws DateTimeException if the offset ID is invalid\n     */\n    static of(offsetId) {\n        requireNonNull(offsetId, 'offsetId');\n        // \"Z\" is always in the cache\n        var offset = ID_CACHE[offsetId];\n        if (offset != null) {\n            return offset;\n        }\n\n        // parse - +h, +hh, +hhmm, +hh:mm, +hhmmss, +hh:mm:ss\n        var hours, minutes, seconds;\n        switch (offsetId.length) {\n            case 2:\n                offsetId = offsetId[0] + '0' + offsetId[1];  // fallthru\n            case 3:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = 0;\n                seconds = 0;\n                break;\n            case 5:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n                seconds = 0;\n                break;\n            case 6:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n                seconds = 0;\n                break;\n            case 7:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n                seconds = ZoneOffset._parseNumber(offsetId, 5, false);\n                break;\n            case 9:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n                seconds = ZoneOffset._parseNumber(offsetId, 7, true);\n                break;\n            default:\n                throw new DateTimeException('Invalid ID for ZoneOffset, invalid format: ' + offsetId);\n        }\n        var first = offsetId[0];\n        if (first !== '+' && first !== '-') {\n            throw new DateTimeException('Invalid ID for ZoneOffset, plus/minus not found when expected: ' + offsetId);\n        }\n        if (first === '-') {\n            return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);\n        } else {\n            return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);\n        }\n    }\n\n    /**\n     * Parse a two digit zero-prefixed number.\n     *\n     * @param {string} offsetId - the offset ID, not null\n     * @param {number} pos - the position to parse, valid\n     * @param {boolean} precededByColon - should this number be prefixed by a precededByColon\n     * @return {number} the parsed number, from 0 to 99\n     */\n    static _parseNumber(offsetId, pos, precededByColon) {\n        if (precededByColon && offsetId[pos - 1] !== ':') {\n            throw new DateTimeException('Invalid ID for ZoneOffset, colon not found when expected: ' + offsetId);\n        }\n        var ch1 = offsetId[pos];\n        var ch2 = offsetId[pos + 1];\n        if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n            throw new DateTimeException('Invalid ID for ZoneOffset, non numeric characters found: ' + offsetId);\n        }\n        return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n    }\n\n    /**\n     * \n     * @param {number} hours\n     * @returns {ZoneOffset}\n     */\n    static ofHours(hours) {\n        return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);\n    }\n\n    /**\n     * \n     * @param {number} hours\n     * @param {number} minutes\n     * @returns {ZoneOffset}\n     */\n    static ofHoursMinutes(hours, minutes) {\n        return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);\n    }\n\n    /**\n     * \n     * @param {number} hours\n     * @param {number} minutes\n     * @param {number} seconds\n     * @returns {ZoneOffset}\n     */\n    static ofHoursMinutesSeconds(hours, minutes, seconds) {\n        ZoneOffset._validate(hours, minutes, seconds);\n        var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;\n        return ZoneOffset.ofTotalSeconds(totalSeconds);\n    }\n\n    /**\n     * \n     * @param {number} totalMinutes\n     * @returns {ZoneOffset}\n     */\n    static ofTotalMinutes(totalMinutes) {\n        var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;\n        return ZoneOffset.ofTotalSeconds(totalSeconds);\n    }\n\n    /**\n     * \n     * @param {number} totalSeconds\n     * @returns {ZoneOffset}\n     */\n    static ofTotalSeconds(totalSeconds) {\n        if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {\n            var totalSecs = totalSeconds;\n            var result = SECONDS_CACHE[totalSecs];\n            if (result == null) {\n                result = new ZoneOffset(totalSeconds);\n                SECONDS_CACHE[totalSecs] = result;\n                ID_CACHE[result.id()] = result;\n            }\n            return result;\n        } else {\n            return new ZoneOffset(totalSeconds);\n        }\n    }\n\n    /**\n     * Gets the associated time-zone rules.\n     * <p>\n     * The rules will always return this offset when queried.\n     * The implementation class is immutable, thread-safe and serializable.\n     *\n     * @return {ZoneRules} the rules, not null\n     */\n    rules() {\n        return this._rules;\n    }\n\n    /**\n      * Gets the value of the specified field from this offset as an {@code int}.\n      * <p>\n      * This queries this offset for the value for the specified field.\n      * The returned value will always be within the valid range of values for the field.\n      * If it is not possible to return the value, because the field is not supported\n      * or for some other reason, an exception is thrown.\n      * <p>\n      * If the field is a {@link ChronoField} then the query is implemented here.\n      * The {@code OFFSET_SECONDS} field returns the value of the offset.\n      * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n      * <p>\n      * If the field is not a {@code ChronoField}, then the result of this method\n      * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n      * passing {@code this} as the argument. Whether the value can be obtained,\n      * and what the value represents, is determined by the field.\n      *\n      * @param {TemporalField} field - the field to get, not null\n      * @return {number} the value for the field\n      * @throws DateTimeException if a value for the field cannot be obtained\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n     get(field) {\n         return this.getLong(field);\n     }\n\n     /**\n      * Gets the value of the specified field from this offset as a {@code long}.\n      * <p>\n      * This queries this offset for the value for the specified field.\n      * If it is not possible to return the value, because the field is not supported\n      * or for some other reason, an exception is thrown.\n      * <p>\n      * If the field is a {@link ChronoField} then the query is implemented here.\n      * The {@code OFFSET_SECONDS} field returns the value of the offset.\n      * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n      * <p>\n      * If the field is not a {@code ChronoField}, then the result of this method\n      * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n      * passing {@code this} as the argument. Whether the value can be obtained,\n      * and what the value represents, is determined by the field.\n      *\n      * @param {TemporalField} field - the field to get, not null\n      * @return {number} the value for the field\n      * @throws DateTimeException if a value for the field cannot be obtained\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n     getLong(field) {\n         if (field === ChronoField.OFFSET_SECONDS) {\n             return this._totalSeconds;\n         } else if (field instanceof ChronoField) {\n             throw new DateTimeException('Unsupported field: ' + field);\n         }\n         return field.getFrom(this);\n     }\n\n     //-----------------------------------------------------------------------\n     /**\n      * Queries this offset using the specified query.\n      * <p>\n      * This queries this offset using the specified query strategy object.\n      * The {@code TemporalQuery} object defines the logic to be used to\n      * obtain the result. Read the documentation of the query to understand\n      * what the result of this method will be.\n      * <p>\n      * The result of this method is obtained by invoking the\n      * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n      * specified query passing {@code this} as the argument.\n      *\n      * @param {TemporalQuery} query - the query to invoke, not null\n      * @return {*} the query result, null may be returned (defined by the query)\n      * @throws DateTimeException if unable to query (defined by the query)\n      * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n      */\n     query(query) {\n         requireNonNull(query, 'query');\n         if (query === TemporalQueries.offset() || query === TemporalQueries.zone()) {\n             return this;\n         } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                 query === TemporalQueries.precision() || query === TemporalQueries.chronology() || query === TemporalQueries.zoneId()) {\n             return null;\n         }\n         return query.queryFrom(this);\n     }\n\n     /**\n      * Adjusts the specified temporal object to have the same offset as this object.\n      * <p>\n      * This returns a temporal object of the same observable type as the input\n      * with the offset changed to be the same as this.\n      * <p>\n      * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n      * passing {@link ChronoField#OFFSET_SECONDS} as the field.\n      * <p>\n      * In most cases, it is clearer to reverse the calling pattern by using\n      * {@link Temporal#with(TemporalAdjuster)}:\n      * <pre>\n      *   // these two lines are equivalent, but the second approach is recommended\n      *   temporal = thisOffset.adjustInto(temporal);\n      *   temporal = temporal.with(thisOffset);\n      * </pre>\n      * <p>\n      * This instance is immutable and unaffected by this method call.\n      *\n      * @param {Temporal} temporal - the target object to be adjusted, not null\n      * @return {Temporal} the adjusted object, not null\n      * @throws DateTimeException if unable to make the adjustment\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n     adjustInto(temporal) {\n         return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);\n     }\n\n    /**\n     * Compares this offset to another offset in descending order.\n     * <p>\n     * The offsets are compared in the order that they occur for the same time\n     * of day around the world. Thus, an offset of {@code +10:00} comes before an\n     * offset of {@code +09:00} and so on down to {@code -18:00}.\n     * <p>\n     * The comparison is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {!ZoneOffset} other - the other date to compare to, not null\n     * @return {number} the comparator value, negative if less, postive if greater\n     * @throws NullPointerException if {@code other} is null\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        return other._totalSeconds - this._totalSeconds;\n    }\n\n\n    /**\n     * Checks if this offset is equal to another offset.\n     *\n     * The comparison is based on the amount of the offset in seconds.\n     * This is equivalent to a comparison by ID.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other offset\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof ZoneOffset) {\n            return this._totalSeconds === obj._totalSeconds;\n        }\n        return false;\n    }\n\n    /**\n     * @return {number}\n     */\n    hashCode(){\n        return this._totalSeconds;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    id() {\n        return this._id;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return this._id;\n    }\n}\n\nexport function _init() {\n    ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n    ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n    ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n    ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/ZoneOffset.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from './assert';\nimport {StringUtil} from './StringUtil';\n\nimport {Instant} from './Instant';\n\nexport class ZoneId {\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the time-zone rules for this ID allowing calculations to be performed.\n     * <p>\n     * The rules provide the functionality associated with a time-zone,\n     * such as finding the offset for a given instant or local date-time.\n     * <p>\n     * A time-zone can be invalid if it is deserialized in a Java Runtime which\n     * does not have the same rules loaded as the Java Runtime that stored it.\n     * In this case, calling this method will throw a {@code ZoneRulesException}.\n     * <p>\n     * The rules are supplied by {@link ZoneRulesProvider}. An advanced provider may\n     * support dynamic updates to the rules without restarting the Java Runtime.\n     * If so, then the result of this method may change over time.\n     * Each individual call will be still remain thread-safe.\n     * <p>\n     * {@link ZoneOffset} will always return a set of rules where the offset never changes.\n     *\n     * @return {!ZoneRules} the rules, not null\n     * @throws ZoneRulesException if no rules are available for this ID\n     */\n    rules(){\n        abstractMethodFail('ZoneId.rules');\n    }\n\n    /**\n      * Normalizes the time-zone ID, returning a {@code ZoneOffset} where possible.\n      * <p>\n      * The returns a normalized {@code ZoneId} that can be used in place of this ID.\n      * The result will have {@code ZoneRules} equivalent to those returned by this object,\n      * however the ID returned by {@code getId()} may be different.\n      * <p>\n      * The normalization checks if the rules of this {@code ZoneId} have a fixed offset.\n      * If they do, then the {@code ZoneOffset} equal to that offset is returned.\n      * Otherwise {@code this} is returned.\n      *\n      * @return {ZoneId} the time-zone unique ID, not null\n      */\n    normalized() {\n        var rules = this.rules();\n        if (rules.isFixedOffset()) {\n            return rules.offset(Instant.EPOCH);\n        }\n        //try {\n        //} catch (ZoneRulesException ex) {\n        //    // ignore invalid objects\n        //}\n        return this;\n    }\n\n     //-----------------------------------------------------------------------\n     /**\n      * Checks if this time-zone ID is equal to another time-zone ID.\n      * <p>\n      * The comparison is based on the ID.\n      *\n      * @param {*} other  the object to check, null returns false\n      * @return {boolean} true if this is equal to the other time-zone ID\n      */\n     equals(other) {\n         if (this === other) {\n             return true;\n         }\n         if (other instanceof ZoneId) {\n             return this.id() === other.id();\n         }\n         return false;\n     }\n\n     /**\n      * A hash code for this time-zone ID.\n      *\n      * @return {number} a suitable hash code\n      */\n     hashCode() {\n         return StringUtil.hashCode(this.id());\n     }\n\n     //-----------------------------------------------------------------------\n     /**\n      * Outputs this zone as a {@code String}, using the ID.\n      *\n      * @return {string} a string representation of this time-zone ID, not null\n      */\n     toString() {\n         return this.id();\n     }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ZoneId.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull, abstractMethodFail} from '../assert';\n\nimport {Instant} from '../Instant';\n\nexport class ZoneRules {\n\n    /**\n     * Obtains an instance of {@code ZoneRules} that always uses the same offset.\n     * <p>\n     * The returned rules always have the same offset.\n     *\n     * @param {ZoneOffset} offset - the offset, not null\n     * @return {ZoneRules} the zone rules, not null\n     */\n    static of(offset) {\n        requireNonNull(offset, 'offset');\n        return new Fixed(offset);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks of the zone rules are fixed, such that the offset never varies.\n     *\n     * @return {boolean} true if the time-zone is fixed and the offset never changes\n     */\n    isFixedOffset(){\n        abstractMethodFail('ZoneRules.isFixedOffset');\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     *\n     * @param instantOrLocalDateTime\n     * @returns {ZoneOffset}\n     */\n    offset(instantOrLocalDateTime){\n        if(instantOrLocalDateTime instanceof Instant){\n            return this.offsetOfInstant(instantOrLocalDateTime);\n        } else {\n            return this.offsetOfLocalDateTime(instantOrLocalDateTime);\n        }\n    }\n    \n    /**\n     * Gets the offset applicable at the specified instant in these rules.\n     * <p>\n     * The mapping from an instant to an offset is simple, there is only\n     * one valid offset for each instant.\n     * This method returns that offset.\n     *\n     * @param {Instant} instant - the instant to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    offsetOfInstant(instant){\n        abstractMethodFail('ZoneRules.offsetInstant');\n    }\n    \n    /**\n     * Gets the offset applicable at the specified epochMilli in these rules.\n     * \n     * The method is for javascript performance optimisation.\n     *\n     * @param {number} epochMilli - the epoch millisecond to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    offsetOfEpochMilli(epochMilli){\n        abstractMethodFail('ZoneRules.offsetOfEpochMilli');\n    }\n    \n\n    /**\n     * Gets a suitable offset for the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns the single offset in the Normal case, and in the Gap or Overlap\n     * case it returns the offset before the transition.\n     * <p>\n     * Since, in the case of Gap and Overlap, the offset returned is a \"best\" value, rather\n     * than the \"correct\" value, it should be treated with care. Applications that care\n     * about the correct offset should use a combination of this method,\n     * {@link #getValidOffsets(LocalDateTime)} and {@link #getTransition(LocalDateTime)}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the best available offset for the local date-time, not null\n     */\n    offsetOfLocalDateTime(localDateTime){\n        abstractMethodFail('ZoneRules.offsetLocalDateTime');\n    }\n\n    /**\n     * Checks if the offset date-time is valid for these rules.\n     * <p>\n     * To be valid, the local date-time must not be in a gap and the offset\n     * must match the valid offsets.\n     *\n     * @param {LocalDateTime} localDateTime - the date-time to check, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @param {ZoneOffset} offset - the offset to check, null returns false\n     * @return {boolean} true if the offset date-time is valid for these rules\n     */\n    isValidOffset(localDateTime, offset){\n        abstractMethodFail('ZoneRules.isValidOffset');\n    }\n\n}\n\n\nclass Fixed extends ZoneRules{\n    /**\n     *\n     * @param {ZoneOffset} offset\n     */\n    constructor(offset){\n        super();\n        this._offset = offset;\n    }\n\n    isFixedOffset(){\n        return true;\n    }\n\n    offsetOfInstant(){\n        return this._offset;\n    }\n\n    offsetOfEpochMilli(){\n        return this._offset;\n    }\n\n    offsetOfLocalDateTime(){\n        return this._offset;\n    }\n\n    /**\n     *\n     * @param {LocalDateTime} LocalDateTime\n     * @param {ZoneOffset} offset\n     * @return {boolean}\n     */\n    isValidOffset(dateTime, offset) {\n        return this._offset.equals(offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof Fixed) {\n            return this._offset.equals(other._offset);\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'FixedRules:' + this._offset.toString();\n    }\n\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/zone/ZoneRules.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {DateTimeException} from './errors';\n\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\n\n/**\n * A geographical region where the same time-zone rules apply.\n * <p>\n * Time-zone information is categorized as a set of rules defining when and\n * how the offset from UTC/Greenwich changes. These rules are accessed using\n * identifiers based on geographical regions, such as countries or states.\n * The most common region classification is the Time Zone Database (TZDB),\n * which defines regions such as 'Europe/Paris' and 'Asia/Tokyo'.\n * <p>\n * The region identifier, modeled by this class, is distinct from the\n * underlying rules, modeled by {@link ZoneRules}.\n * The rules are defined by governments and change frequently.\n * By contrast, the region identifier is well-defined and long-lived.\n * This separation also allows rules to be shared between regions if appropriate.\n *\n * <h3>Specification for implementors</h3>\n * This class is immutable and thread-safe.\n */\nexport class ZoneRegion extends ZoneId {\n    /**\n     * not yet implemented\n     * @params {string} zoneId\n     * @return {ZoneId}\n     */\n    static ofId(zoneId){\n        // special case as removed from data file\n        if (zoneId === 'GMT0') {\n            var rules = ZoneOffset.UTC.rules();\n            return new ZoneRegion(zoneId, rules);\n        }\n        throw new DateTimeException('ZoneRegion.ofId() is not yet implemented');\n    }\n    \n     //-------------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {string} id  the time-zone ID, not null\n     * @param {ZoneRules} rules  the rules, null for lazy lookup\n     */\n    constructor(id, rules) {\n        super();\n        this._id = id;\n        this._rules = rules;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @returns {string}\n     */\n    id() {\n        return this._id;\n    }\n\n    /**\n     *\n     * @returns {ZoneRules}\n     */\n    rules() {\n        return this._rules;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ZoneRegion.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {SystemDefaultZoneRules} from './SystemDefaultZoneRules';\nimport {ZoneId} from '../ZoneId';\n\nexport class SystemDefaultZoneId extends ZoneId {\n\n    constructor(){\n        super();\n        this._rules = new SystemDefaultZoneRules();\n    }\n\n    rules(){\n        return this._rules;\n    }\n\n    equals(other){\n        if(this === other){\n            return true;\n        }\n        return false;\n    }\n\n    id(){\n        return 'SYSTEM';\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/zone/SystemDefaultZoneId.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {ZoneRules} from './ZoneRules';\nimport {ZoneOffset} from '../ZoneOffset';\n\nexport class SystemDefaultZoneRules extends ZoneRules {\n\n    isFixedOffset(){\n        return false;\n    }\n\n    /**\n     *\n     * @param {Instant} instant\n     * @returns {ZoneOffset}\n     */\n    offsetOfInstant(instant){\n        var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n    }\n\n    /**\n     *\n     * @param {number} epochMilli\n     * @returns {ZoneOffset}\n     */\n    offsetOfEpochMilli(epochMilli){\n        var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n    }\n\n    /**\n     * This implementation is NOT returning the best value in a gap or overlap situation\n     * as specified at {@link ZoneRules.offsetOfLocalDateTime}.\n     *\n     * The calculated offset depends Date.prototype.getTimezoneOffset and its not specified\n     * at the ECMA-262 specification how to handle daylight savings gaps/ overlaps.\n     *\n     * The Chrome Browser version 49 is returning the next transition offset in a gap/overlap situation,\n     * other browsers/ engines might do it in the same way.\n     *\n     * @param {LocalDateTime} localDateTime\n     * @returns {ZoneOffset}\n     */\n    offsetOfLocalDateTime(localDateTime){\n        var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;\n        var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();\n        var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;\n        var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);\n    }\n\n    /**\n     *\n     * @param {LocalDateTime} dateTime\n     * @param {ZoneOffset} offset\n     * @return {boolean}\n     */\n    isValidOffset(dateTime, offset) {\n        return this.offsetOfLocalDateTime(dateTime).equals(offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other || other instanceof SystemDefaultZoneRules) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'SYSTEM';\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/zone/SystemDefaultZoneRules.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport class DecimalStyle {\n    constructor(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {\n        this._zeroDigit = zeroChar;\n        this._zeroDigitCharCode = zeroChar.charCodeAt(0);\n        this._positiveSign = positiveSignChar;\n        this._negativeSign = negativeSignChar;\n        this._decimalSeparator = decimalPointChar;\n    }\n\n    positiveSign(){\n        return this._positiveSign;\n    }\n\n    withPositiveSign(positiveSign) {\n        if (positiveSign === this._positiveSign) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);\n    }\n\n    negativeSign(){\n        return this._negativeSign;\n    }\n\n    withNegativeSign(negativeSign) {\n        if (negativeSign === this._negativeSign) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);\n    }\n\n    zeroDigit(){\n        return this._zeroDigit;\n    }\n\n    withZeroDigit(zeroDigit) {\n        if (zeroDigit === this._zeroDigit) {\n            return this;\n        }\n        return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);\n    }\n\n    decimalSeparator(){\n        return this._decimalSeparator;\n    }\n\n    withDecimalSeparator(decimalSeparator) {\n        if (decimalSeparator === this._decimalSeparator) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);\n    }\n\n    convertToDigit(char){\n        var val = char.charCodeAt(0) - this._zeroDigitCharCode;\n        return (val >= 0 && val <= 9) ? val : -1;\n    }\n\n    convertNumberToI18N(numericText) {\n        if (this._zeroDigit === '0') {\n            return numericText;\n        }\n        var diff = this._zeroDigitCharCode - '0'.charCodeAt(0);\n        var convertedText = '';\n        for (let i = 0; i < numericText.length; i++) {\n            convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);\n        }\n        return convertedText;\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof DecimalStyle) {\n            return (this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign &&\n                this._negativeSign === other._negativeSign && this._decimalSeparator == other._decimalSeparator);\n        }\n        return false;\n    }\n\n    hashCode() {\n        return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;\n    }\n\n    toString() {\n        return 'DecimalStyle[' + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + ']';\n    }\n\n    static of(){\n        throw new Error('not yet supported');\n    }\n    static availableLocales(){\n        throw new Error('not yet supported');\n    }\n\n}\n\nDecimalStyle.STANDARD = new DecimalStyle('0', '+', '-', '.');\n\n\n/** WEBPACK FOOTER **\n ** ./src/format/DecimalStyle.js\n **/","/**\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {Enum} from '../Enum';\n\nexport class SignStyle extends Enum{\n    /**\n     * Parse helper.\n     *\n     * @param positive  true if positive sign parsed, false for negative sign\n     * @param strict  true if strict, false if lenient\n     * @param fixedWidth  true if fixed width, false if not\n     * @return true if valid\n     */\n    parse(positive, strict, fixedWidth){\n        switch (this) {\n            case SignStyle.NORMAL: // NORMAL\n                // valid if negative or (positive and lenient)\n                return !positive || !strict;\n            case SignStyle.ALWAYS: // ALWAYS\n            case SignStyle.EXCEEDS_PAD: // EXCEEDS_PAD\n                return true;\n            default:\n                // valid if lenient and not fixed width\n                return !strict && !fixedWidth;\n        }\n\n    }\n}\n\nSignStyle.NORMAL = new SignStyle('NORMAL');\nSignStyle.NEVER = new SignStyle('NEVER');\nSignStyle.ALWAYS = new SignStyle('ALWAYS');\nSignStyle.EXCEEDS_PAD = new SignStyle('EXCEEDS_PAD');\nSignStyle.NOT_NEGATIVE = new SignStyle('NOT_NEGATIVE');\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/format/SignStyle.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport class StringBuilder {\n    constructor(){\n        this._str = '';\n    }\n\n    append(str){\n        this._str += str;\n        return this;\n    }\n\n    appendChar(str){\n        this._str += str[0];\n        return this;\n    }\n\n    insert(offset, str){\n        this._str = this._str.slice(0, offset) + str + this._str.slice(offset);\n        return this;\n    }\n\n    replace(start, end, str){\n        this._str = this._str.slice(0, start) + str + this._str.slice(end);\n        return this;\n    }\n\n    length(){\n        return this._str.length;\n    }\n\n    setLength(length){\n        this._str = this._str.slice(0, length);\n        return this;\n    }\n\n\n    toString() {\n        return this._str;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/format/StringBuilder.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos  \n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {DateTimeException, UnsupportedTemporalTypeException, NullPointerException} from './errors';\nimport {MathUtil} from './MathUtil';\nimport {assert} from './assert';\n\nimport {DateTimeFormatterBuilder} from './format/DateTimeFormatterBuilder';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\n\n/**\n * <h3>Static properties of Class {@link DayOfWeek}</h3>\n *\n * DayOfWeek.MONDAY,\n * DayOfWeek.TUESDAY,\n * DayOfWeek.WEDNESDAY,\n * DayOfWeek.THURSDAY,\n * DayOfWeek.FRIDAY,\n * DayOfWeek.SATURDAY,\n * DayOfWeek.SUNDAY\n *\n */\nexport class DayOfWeek extends Temporal {\n\n    /**\n     *\n     * @param {number} ordinal\n     * @param {string} name\n     * @private\n     */\n    constructor(ordinal, name){\n        super();\n        this._ordinal = ordinal;\n        this._name = name;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    ordinal(){\n        return this._ordinal;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    name(){\n        return this._name;\n    }\n\n    /**\n     *\n     * @returns {DayOfWeek[]}\n     */\n    static values() {\n        return ENUMS.slice();\n    }\n\n    /**\n     *\n     * @param {string} name\n     * @returns {DayOfWeek}\n     */\n    static valueOf(name) {\n        for(var ordinal=0; ordinal < ENUMS.length; ordinal++){\n            if(ENUMS[ordinal].name() === name){\n                break;\n            }\n        }\n        return DayOfWeek.of(ordinal+1);\n    }\n    \n    /**\n     * Obtains an instance of {@code DayOfWeek} from an {@code int} value.\n     * <p>\n     * {@code DayOfWeek} is an enum representing the 7 days of the week.\n     * This factory allows the enum to be obtained from the {@code int} value.\n     * The {@code int} value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).\n     *\n     * @param {!number} dayOfWeek  the day-of-week to represent, from 1 (Monday) to 7 (Sunday)\n     * @return {DayOfWeek} the day-of-week singleton, not null\n     * @throws DateTimeException if the day-of-week is invalid\n     */\n    static of(dayOfWeek) {\n        if (dayOfWeek < 1 || dayOfWeek > 7) {\n            throw new DateTimeException('Invalid value for DayOfWeek: ' + dayOfWeek);\n        }\n        return ENUMS[dayOfWeek - 1];\n    }\n    \n    /**\n     * Obtains an instance of {@code DayOfWeek} from a temporal object.\n     * <p>\n     * A {@code TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@code DayOfWeek}.\n     * <p>\n     * The conversion extracts the {@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} field.\n     * <p>\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code DayOfWeek::from}.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {DayOfWeek} the day-of-week, not null\n     * @throws DateTimeException if unable to convert to a {@code DayOfWeek}\n     */\n    static from(temporal) {\n        assert(temporal != null, 'temporal', NullPointerException);\n        if (temporal instanceof DayOfWeek) {\n            return temporal;\n        }\n        try {\n            return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));\n        } catch (ex) {\n            if(ex instanceof DateTimeException) {\n                throw new DateTimeException('Unable to obtain DayOfWeek from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''), ex);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    /**\n     * Gets the day-of-week {@code int} value.\n     * <p>\n     * The values are numbered following the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).\n     * See {@link WeekFields#dayOfWeek} for localized week-numbering.\n     *\n     * @return {number} the day-of-week, from 1 (Monday) to 7 (Sunday)\n     */\n    value() {\n        return this._ordinal + 1;\n    }\n\n    /**\n     * Gets the textual representation, such as 'Mon' or 'Friday'.\n     * <p>\n     * This returns the textual name used to identify the day-of-week.\n     * The parameters control the length of the returned text and the locale.\n     * <p>\n     * If no textual mapping is found then the {@link #getValue() numeric value} is returned.\n     *\n     * @param {TextStyle} style - the length of the text required, not null\n     * @param {Locale} locale - the locale to use, not null\n     * @return {string} the text value of the day-of-week, not null\n     */\n    getDisplayName(style, locale) {\n        return new DateTimeFormatterBuilder().appendText(ChronoField.DAY_OF_WEEK, style).toFormatter(locale).format(this);\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     * <p>\n     * This checks if this day-of-week can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range} and\n     * {@link #get(TemporalField) get} methods will throw an exception.\n     * <p>\n     * If the field is {@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} then\n     * this method returns true.\n     * All other {@code ChronoField} instances will return false.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this day-of-week, false if not\n     */\n    isSupported(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.DAY_OF_WEEK;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     * <p>\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This day-of-week is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is {@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} then the\n     * range of the day-of-week, from 1 to 7, will be returned.\n     * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return field.range();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-week as an {@code int}.\n     * <p>\n     * This queries this day-of-week for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is {@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} then the\n     * value of the day-of-week, from 1 to 7, will be returned.\n     * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws DateTimeException if the range of valid values for the field exceeds an {@code int}\n     * @throws DateTimeException if the value is outside the range of valid values for the field\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return this.value();\n        }\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-week as a {@code long}.\n     * <p>\n     * This queries this day-of-week for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is {@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} then the\n     * value of the day-of-week, from 1 to 7, will be returned.\n     * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return this.value();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the day-of-week that is the specified number of days after this one.\n     * <p>\n     * The calculation rolls around the end of the week from Sunday to Monday.\n     * The specified period may be negative.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, positive or negative\n     * @return {DayOfWeek} the resulting day-of-week, not null\n     */\n    plus(days) {\n        var amount = MathUtil.floorMod(days, 7);\n        return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];\n    }\n\n    /**\n     * Returns the day-of-week that is the specified number of days before this one.\n     * <p>\n     * The calculation rolls around the start of the year from Monday to Sunday.\n     * The specified period may be negative.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, positive or negative\n     * @return {DayOfWeek} the resulting day-of-week, not null\n     */\n    minus(days) {\n        return this.plus(-1 * MathUtil.floorMod(days, 7));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this day-of-week using the specified query.\n     * <p>\n     * This queries this day-of-week using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.DAYS;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() || query === TemporalQueries.chronology() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        assert(query != null, 'query', NullPointerException);\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this day-of-week.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with the day-of-week changed to be the same as this.\n     * <p>\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField#DAY_OF_WEEK} as the field.\n     * Note that this adjusts forwards or backwards within a Monday to Sunday week.\n     * See {@link WeekFields#dayOfWeek} for localized week start days.\n     * See {@link TemporalAdjusters} for other adjusters\n     * with more control, such as {@code next(MONDAY)}.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisDayOfWeek.adjustInto(temporal);\n     *   temporal = temporal.with(thisDayOfWeek);\n     * </pre>\n     * <p>\n     * For example, given a date that is a Wednesday, the following are output:\n     * <pre>\n     *   dateOnWed.with(MONDAY);     // two days earlier\n     *   dateOnWed.with(TUESDAY);    // one day earlier\n     *   dateOnWed.with(WEDNESDAY);  // same date\n     *   dateOnWed.with(THURSDAY);   // one day later\n     *   dateOnWed.with(FRIDAY);     // two days later\n     *   dateOnWed.with(SATURDAY);   // three days later\n     *   dateOnWed.with(SUNDAY);     // four days later\n     * </pre>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjusters} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return temporal.with(ChronoField.DAY_OF_WEEK, this.value());\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    equals(other){\n        return this === other;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return this._name;\n    }\n}\n\nvar ENUMS;\n\nexport function _init() {\n    DayOfWeek.MONDAY = new DayOfWeek(0, 'MONDAY');\n    DayOfWeek.TUESDAY = new DayOfWeek(1, 'TUESDAY');\n    DayOfWeek.WEDNESDAY = new DayOfWeek(2, 'WEDNESDAY');\n    DayOfWeek.THURSDAY = new DayOfWeek(3, 'THURSDAY');\n    DayOfWeek.FRIDAY = new DayOfWeek(4, 'FRIDAY');\n    DayOfWeek.SATURDAY = new DayOfWeek(5, 'SATURDAY');\n    DayOfWeek.SUNDAY = new DayOfWeek(6, 'SUNDAY');\n\n    DayOfWeek.FROM = createTemporalQuery('DayOfWeek.FROM', (temporal) => {\n        return DayOfWeek.from(temporal);\n    });\n\n    ENUMS = [\n        DayOfWeek.MONDAY,\n        DayOfWeek.TUESDAY,\n        DayOfWeek.WEDNESDAY,\n        DayOfWeek.THURSDAY,\n        DayOfWeek.FRIDAY,\n        DayOfWeek.SATURDAY,\n        DayOfWeek.SUNDAY\n    ];\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/DayOfWeek.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from './assert';\nimport {DateTimeException, IllegalArgumentException} from './errors';\n\nimport {Clock} from './Clock';\nimport {Instant} from './Instant';\nimport {LocalDate} from './LocalDate';\nimport {LocalDateTime} from './LocalDateTime';\nimport {LocalTime} from './LocalTime';\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\n\nimport {ChronoZonedDateTime} from './chrono/ChronoZonedDateTime';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\nimport {TemporalQueries} from './temporal/TemporalQueries';\n\n/**\n * A date-time with a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30+01:00 Europe/Paris}.\n * <p>\n * {@code ZonedDateTime} is an immutable representation of a date-time with a time-zone.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * and a time-zone, with a zone offset used to handle ambiguous local date-times.\n * For example, the value\n * '2nd October 2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone'\n * can be stored in a {@code ZonedDateTime}.\n * <p>\n * This class handles conversion from the local time-line of {@code LocalDateTime}\n * to the instant time-line of {@code Instant}.\n * The difference between the two time-lines is the offset from UTC/Greenwich,\n * represented by a {@code ZoneOffset}.\n * <p>\n * Converting between the two time-lines involves calculating the offset using the\n * {@link ZoneRules rules} accessed from the {@code ZoneId}.\n * Obtaining the offset for an instant is simple, as there is exactly one valid\n * offset for each instant. By contrast, obtaining the offset for a local date-time\n * is not straightforward. There are three cases:\n * <p><ul>\n * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n *  case applies, where there is a single valid offset for the local date-time.</li>\n * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n *  due to the spring daylight savings change from 'winter' to 'summer'.\n *  In a gap there are local date-time values with no valid offset.</li>\n * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n *  due to the autumn daylight savings change from 'summer' to 'winter'.\n *  In an overlap there are local date-time values with two valid offsets.</li>\n * </ul><p>\n * <p>\n * Any method that converts directly or implicitly from a local date-time to an\n * instant by obtaining the offset has the potential to be complicated.\n * <p>\n * For Gaps, the general strategy is that if the local date-time falls in the\n * middle of a Gap, then the resulting zoned date-time will have a local date-time\n * shifted forwards by the length of the Gap, resulting in a date-time in the later\n * offset, typically 'summer' time.\n * <p>\n * For Overlaps, the general strategy is that if the local date-time falls in the\n * middle of an Overlap, then the previous offset will be retained. If there is no\n * previous offset, or the previous offset is invalid, then the earlier offset is\n * used, typically 'summer' time.. Two additional methods,\n * {@link #withEarlierOffsetAtOverlap()} and {@link #withLaterOffsetAtOverlap()},\n * help manage the case of an overlap.\n *\n * <h3>Specification for implementors</h3>\n * A {@code ZonedDateTime} holds state equivalent to three separate objects,\n * a {@code LocalDateTime}, a {@code ZoneId} and the resolved {@code ZoneOffset}.\n * The offset and local date-time are used to define an instant when necessary.\n * The zone ID is used to obtain the rules for how and when the offset changes.\n * The offset cannot be freely set, as the zone controls which offsets are valid.\n */\nexport class ZonedDateTime extends ChronoZonedDateTime {\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone or clock\n     * or default time zone.\n     * <p>\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * The zone and offset will be set based on the time-zone in the clock.\n     * <p>\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {Clock|ZoneId} [clockOrZone=Clock.systemDefaultZone()]\n     * @return {ZonedDateTime} the current date-time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        var clock;\n        if(clockOrZone instanceof ZoneId){\n            clock = Clock.system(clockOrZone);\n        } else {\n            clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;\n        }\n        return ZonedDateTime.ofInstant(clock.instant(), clock.zone());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for static {@link ZonedDateTime.of}\n     *\n     * if called with 2 (or less) args {@link ZonedDateTime.of2} is called,\n     * if called with 3 args and the first arg is an instance of LocalDate {@link ZonedDateTime.of3} is called,\n     * otherwise {@link ZonedDateTime.of8} is called.\n     */\n    static of(){\n        if(arguments.length <= 2){\n            return ZonedDateTime.of2.apply(this, arguments);\n        } else if (arguments.length === 3 && arguments[0] instanceof LocalDate){\n            return ZonedDateTime.of3.apply(this, arguments);\n        } else {\n            return ZonedDateTime.of8.apply(this, arguments);\n        }\n    }\n    /**\n     * Obtains an instance of {@code ZonedDateTime} from a local date and time.\n     * <p>\n     * This creates a zoned date-time matching the input local date and time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     * <p>\n     * The local date time and first combined to form a local date-time.\n     * The local date-time is then resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules rules} of the zone ID.\n     *<p>\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     * <p>\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {LocalDate} date - the local date, not null\n     * @param {LocalTime} time - the local time, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the offset date-time, not null\n     */\n    static of3(date, time, zone) {\n        return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);\n    }\n\n    /**\n     * Obtains an instance of {@code ZonedDateTime} from a local date-time.\n     * <p>\n     * This creates a zoned date-time matching the input local date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     * <p>\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules rules} of the zone ID.\n     *<p>\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     * <p>\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {!LocalDateTime} localDateTime - the local date-time, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static of2(localDateTime, zone) {\n        return ZonedDateTime.ofLocal(localDateTime, zone, null);\n    }\n\n    /**\n     * Obtains an instance of {@code ZonedDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and time-zone.\n     * <p>\n     * This creates a zoned date-time matching the local date-time of the seven\n     * specified fields as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     * <p>\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules rules} of the zone ID.\n     *<p>\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     * <p>\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     * <p>\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@code LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param {number} year - the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} month - the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {number} dayOfMonth - the day-of-month to represent, from 1 to 31\n     * @param {number} hour - the hour-of-day to represent, from 0 to 23\n     * @param {number} minute - the minute-of-hour to represent, from 0 to 59\n     * @param {number} second - the second-of-minute to represent, from 0 to 59\n     * @param {number} nanoOfSecond - the nano-of-second to represent, from 0 to 999,999,999\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime } the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    static of8(\n            year, month, dayOfMonth,\n            hour, minute, second, nanoOfSecond, zone) {\n        var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return ZonedDateTime.ofLocal(dt, zone, null);\n    }\n\n    /**\n     * Obtains an instance of {@code ZonedDateTime} from a local date-time\n     * using the preferred offset if possible.\n     * <p>\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules rules} of the zone ID.\n     *<p>\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * If the preferred offset is one of the valid offsets then it is used.\n     * Otherwise the earlier valid offset is used, typically corresponding to 'summer'.\n     * <p>\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {!LocalDateTime} localDateTime - the local date-time, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @param {ZoneOffset} preferredOffset - the zone offset, null if no preference\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofLocal(localDateTime, zone, preferredOffset) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(zone, 'zone');\n        if (zone instanceof ZoneOffset) {\n            return new ZonedDateTime(localDateTime, zone, zone);\n        }\n        var rules = zone.rules();\n        var offset = rules.offsetOfLocalDateTime(localDateTime);\n\n/* TODO implement for iana tzdb\n        var validOffsets = rules.validOffsets(localDateTime);\n        if (validOffsets.size() == 1) {\n            offset = validOffsets.get(0);\n        } else if (validOffsets.size() == 0) {\n            var trans = rules.transition(localDateTime);\n            localDateTime = localDateTime.plusSeconds(trans.duration().seconds());\n            offset = trans.offsetAfter();\n        } else {\n            if (preferredOffset != null && validOffsets.contains(preferredOffset)) {\n                offset = preferredOffset;\n            } else {\n                offset = requireNonNull(validOffsets.get(0), 'offset');  // protect against bad ZoneRules\n            }\n        }\n*/\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.ofInstant}.\n     * if called with 2 args {@link ZonedDateTime.ofInstant2} is called\n     * otherwise {@link ZonedDateTime.ofInstant3}.\n     */\n    static ofInstant(){\n        if (arguments.length === 2){\n            return ZonedDateTime.ofInstant2.apply(this, arguments);\n        } else {            \n            return ZonedDateTime.ofInstant3.apply(this, arguments);\n        }\n    } \n    /**\n     * Obtains an instance of {@code ZonedDateTime} from an {@code Instant}.\n     * <p>\n     * This creates a zoned date-time with the same instant as that specified.\n     * Calling {@link #toInstant()} will return an instant equal to the one used here.\n     * <p>\n     * Converting an instant to a zoned date-time is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param {!Instant} instant - the instant to create the date-time from, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    static ofInstant2(instant, zone) {\n        requireNonNull(instant, 'instant');\n        requireNonNull(zone, 'zone');\n        return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);\n    }\n\n    /**\n     * Obtains an instance of {@code ZonedDateTime} from the instant formed by combining\n     * the local date-time and offset.\n     * <p>\n     * This creates a zoned date-time by {@link LocalDateTime#toInstant(ZoneOffset) combining}\n     * the {@code LocalDateTime} and {@code ZoneOffset}.\n     * This combination uniquely specifies an instant without ambiguity.\n     * <p>\n     * Converting an instant to a zoned date-time is simple as there is only one valid\n     * offset for each instant. If the valid offset is different to the offset specified,\n     * the the date-time and offset of the zoned date-time will differ from those specified.\n     * <p>\n     * If the {@code ZoneId} to be used is a {@code ZoneOffset}, this method is equivalent\n     * to {@link #of(LocalDateTime, ZoneId)}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofInstant3(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);\n    }\n\n    /**\n     * Obtains an instance of {@code ZonedDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * @param {number} epochSecond - the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param {number} nanoOfSecond - the nanosecond within the second, from 0 to 999,999,999\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    static _create(epochSecond, nanoOfSecond, zone) {\n        var rules = zone.rules();\n        var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);  // TODO: rules should be queryable by epochSeconds\n        var offset = rules.offset(instant);\n        var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);\n        return new ZonedDateTime(ldt, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code ZonedDateTime} strictly validating the\n     * combination of local date-time, offset and zone ID.\n     * <p>\n     * This creates a zoned date-time ensuring that the offset is valid for the\n     * local date-time according to the rules of the specified zone.\n     * If the offset is invalid, an exception is thrown.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofStrict(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        var rules = zone.rules();\n        if (rules.isValidOffset(localDateTime, offset) === false) {\n        /* TODO implement for iana tzdb\n            var trans = rules.transition(localDateTime);\n            if (trans != null && trans.isGap()) {\n                // error message says daylight savings for simplicity\n                // even though there are other kinds of gaps\n                throw new DateTimeException('LocalDateTime '' + localDateTime +\n                        '' does not exist in zone '' + zone +\n                        '' due to a gap in the local time-line, typically caused by daylight savings');\n            }\n        */\n            throw new DateTimeException('ZoneOffset \"' + offset + '\" is not valid for LocalDateTime \"' +\n                localDateTime + '\" in zone \"' + zone + '\"');\n        }\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    /**\n     * Obtains an instance of {@code ZonedDateTime} leniently, for advanced use cases,\n     * allowing any combination of local date-time, offset and zone ID.\n     * <p>\n     * This creates a zoned date-time with no checks other than no nulls.\n     * This means that the resulting zoned date-time may have an offset that is in conflict\n     * with the zone ID.\n     * <p>\n     * This method is intended for advanced use cases.\n     * For example, consider the case where a zoned date-time with valid fields is created\n     * and then stored in a database or serialization-based store. At some later point,\n     * the object is then re-loaded. However, between those points in time, the government\n     * that defined the time-zone has changed the rules, such that the originally stored\n     * local date-time now does not occur. This method can be used to create the object\n     * in an 'invalid' state, despite the change in rules.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static _ofLenient(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        if (zone instanceof ZoneOffset && offset.equals(zone) === false) {\n            throw new IllegalArgumentException('ZoneId must match ZoneOffset');\n        }\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code ZonedDateTime} from a temporal object.\n     * <p>\n     * A {@code TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@code ZonedDateTime}.\n     * <p>\n     * The conversion will first obtain a {@code ZoneId}. It will then try to obtain an instant.\n     * If that fails it will try to obtain a local date-time.\n     * The zoned date time will either be a combination of {@code ZoneId} and instant,\n     * or {@code ZoneId} and local date-time.\n     * <p>\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@code ZonedDateTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if unable to convert to an {@code ZonedDateTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof ZonedDateTime) {\n            return temporal;\n        }\n        var zone = ZoneId.from(temporal);\n        if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {\n            var zdt = ZonedDateTime._from(temporal, zone);\n            if(zdt != null) return zdt;\n        }\n        var ldt = LocalDateTime.from(temporal);\n        return ZonedDateTime.of2(ldt, zone);\n    }\n\n    static _from(temporal, zone){\n        try {\n            return ZonedDateTime.__from(temporal, zone);\n        } catch (ex) {\n            if(!(ex instanceof DateTimeException)) throw ex;\n            // ignore\n        }\n    }\n\n    static __from(temporal, zone){\n        var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);\n        var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n        return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code ZonedDateTime} from a text string such as\n     * {@code 2007-12-03T10:15:30+01:00[Europe/Paris]}.\n     * <p>\n     * The string must represent a valid date-time and is parsed using\n     * {@link org.threeten.bp.format.DateTimeFormatter#ISO_ZONED_DATE_TIME}.\n     *\n     * @param {!string} text - the text to parse such as '2007-12-03T10:15:30+01:00[Europe/Paris]', not null\n     * @param {!DateTimeFormatter} [formatter=DateTimeFormatter.ISO_ZONED_DATE_TIME] - the formatter to use\n     * @return {ZonedDateTime} the parsed zoned date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME) {\n        requireNonNull(formatter, 'fromatter');\n        return formatter.parse(text, ZonedDateTime.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {LocalDateTime} dateTime - the date-time, validated as not null\n     * @param {ZoneOffset} offset - the zone offset, validated as not null\n     * @param {ZoneUd} zone - the time-zone, validated as not null\n     */\n    constructor(dateTime, offset, zone) {\n        requireNonNull(dateTime, 'dateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n\n        super();\n\n        /**\n         * The local date-time.\n         */\n        this._dateTime = dateTime;\n        /**\n         * The offset from UTC/Greenwich.\n         */\n        this._offset = offset;\n        /**\n         * The time-zone.\n         */\n        this._zone = zone;\n    }\n\n    /**\n     * Resolves the new local date-time using this zone ID, retaining the offset if possible.\n     *\n     * @param {LocalDateTime} newDateTime - the new local date-time, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveLocal(newDateTime) {\n        requireNonNull(newDateTime, 'newDateTime');\n        return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);\n    }\n\n    /**\n     * Resolves the new local date-time using the offset to identify the instant.\n     *\n     * @param {LocalDateTime} newDateTime - the new local date-time, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveInstant(newDateTime) {\n        return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);\n    }\n\n    /**\n     * Resolves the offset into this zoned date-time.\n     * <p>\n     * This ignores the offset, unless it can be used in an overlap.\n     *\n     * @param {ZoneOffset} offset - the offset, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveOffset(offset) {\n        if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, this._offset)) {\n            return new ZonedDateTime(this._dateTime, this._offset, this._zone);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * <p>\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range} and\n     * {@link #get(TemporalField) get} methods will throw an exception.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * <ul>\n     * <li>{@code NANO_OF_SECOND}\n     * <li>{@code NANO_OF_DAY}\n     * <li>{@code MICRO_OF_SECOND}\n     * <li>{@code MICRO_OF_DAY}\n     * <li>{@code MILLI_OF_SECOND}\n     * <li>{@code MILLI_OF_DAY}\n     * <li>{@code SECOND_OF_MINUTE}\n     * <li>{@code SECOND_OF_DAY}\n     * <li>{@code MINUTE_OF_HOUR}\n     * <li>{@code MINUTE_OF_DAY}\n     * <li>{@code HOUR_OF_AMPM}\n     * <li>{@code CLOCK_HOUR_OF_AMPM}\n     * <li>{@code HOUR_OF_DAY}\n     * <li>{@code CLOCK_HOUR_OF_DAY}\n     * <li>{@code AMPM_OF_DAY}\n     * <li>{@code DAY_OF_WEEK}\n     * <li>{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * <li>{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * <li>{@code DAY_OF_MONTH}\n     * <li>{@code DAY_OF_YEAR}\n     * <li>{@code EPOCH_DAY}\n     * <li>{@code ALIGNED_WEEK_OF_MONTH}\n     * <li>{@code ALIGNED_WEEK_OF_YEAR}\n     * <li>{@code MONTH_OF_YEAR}\n     * <li>{@code EPOCH_MONTH}\n     * <li>{@code YEAR_OF_ERA}\n     * <li>{@code YEAR}\n     * <li>{@code ERA}\n     * <li>{@code INSTANT_SECONDS}\n     * <li>{@code OFFSET_SECONDS}\n     * </ul>\n     * All other {@code ChronoField} instances will return false.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date-time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if(fieldOrUnit instanceof ChronoField){\n            return true;\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return (fieldOrUnit != null && fieldOrUnit.isSupportedBy(this));\n    }\n\n\n    /**\n     * Gets the range of valid values for the specified field.\n     * <p>\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n                return field.range();\n            }\n            return this._dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * <p>\n     * This queries this date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY}, {@code EPOCH_MONTH} and {@code INSTANT_SECONDS} which are too\n     * large to fit in an {@code int} and throw a {@code DateTimeException}.\n     * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * <p>\n     * This queries this date-time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw a {@code DateTimeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.INSTANT_SECONDS: return this.toEpochSecond();\n                case ChronoField.OFFSET_SECONDS: return this._offset.totalSeconds();\n            }\n            return this._dateTime.getLong(field);\n        }\n        requireNonNull(field, 'field');\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as '+01:00'.\n     * <p>\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return {ZoneOffset}the zone offset, not null\n     */\n    offset() {\n        return this._offset;\n    }\n\n    /**\n     * Returns a copy of this date-time changing the zone offset to the\n     * earlier of the two valid offsets at a local time-line overlap.\n     * <p>\n     * This method only has any effect when the local time-line overlaps, such as\n     * at an autumn daylight savings cutover. In this scenario, there are two\n     * valid offsets for the local date-time. Calling this method will return\n     * a zoned date-time with the earlier of the two selected.\n     * <p>\n     * If this method is called when it is not an overlap, {@code this}\n     * is returned.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the earlier offset, not null\n     */\n/* TODO implement for iana tzdb\n    withEarlierOffsetAtOverlap() {\n        var trans = this._zone.rules().transition(this._dateTime);\n        if (trans != null && trans.isOverlap()) {\n            var earlierOffset = trans.offsetBefore();\n            if (earlierOffset.equals(offset) === false) {\n                return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);\n            }\n        }\n        return this;\n    }\n*/\n\n    /**\n     * Returns a copy of this date-time changing the zone offset to the\n     * later of the two valid offsets at a local time-line overlap.\n     * <p>\n     * This method only has any effect when the local time-line overlaps, such as\n     * at an autumn daylight savings cutover. In this scenario, there are two\n     * valid offsets for the local date-time. Calling this method will return\n     * a zoned date-time with the later of the two selected.\n     * <p>\n     * If this method is called when it is not an overlap, {@code this}\n     * is returned.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the later offset, not null\n     */\n/* TODO implement for iana tzdb\n    withLaterOffsetAtOverlap() {\n        var trans = zone().rules().transition(this.toLocalDateTime());\n        if (trans != null) {\n            var laterOffset = trans.offsetAfter();\n            if (laterOffset.equals(offset) === false) {\n                return new ZonedDateTime(this._dateTime, laterOffset, this._zone);\n            }\n        }\n        return this;\n    }\n*/\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the time-zone, such as 'Europe/Paris'.\n     * <p>\n     * This returns the zone ID. This identifies the time-zone {@link ZoneRules rules}\n     * that determine when and how the offset from UTC/Greenwich changes.\n     * <p>\n     * The zone ID may be same as the {@link #getOffset() offset}.\n     * If this is true, then any future calculations, such as addition or subtraction,\n     * have no complex edge cases due to time-zone rules.\n     * See also {@link #withFixedOffsetZone()}.\n     *\n     * @return {ZoneId} the time-zone, not null\n     */\n    zone() {\n        return this._zone;\n    }\n\n    /**\n     * Returns a copy of this date-time with a different time-zone,\n     * retaining the local date-time if possible.\n     * <p>\n     * This method changes the time-zone and retains the local date-time.\n     * The local date-time is only changed if it is invalid for the new zone,\n     * determined using the same approach as\n     * {@link #ofLocal(LocalDateTime, ZoneId, ZoneOffset)}.\n     * <p>\n     * To change the zone and adjust the local date-time,\n     * use {@link #withZoneSameInstant(ZoneId)}.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {ZoneId} zone - the time-zone to change to, not null\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the requested zone, not null\n     */\n    withZoneSameLocal(zone) {\n        requireNonNull(zone, 'zone');\n        return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n    }\n\n    /**\n     * Returns a copy of this date-time with a different time-zone,\n     * retaining the instant.\n     * <p>\n     * This method changes the time-zone and retains the instant.\n     * This normally results in a change to the local date-time.\n     * <p>\n     * This method is based on retaining the same instant, thus gaps and overlaps\n     * in the local time-line have no effect on the result.\n     * <p>\n     * To change the offset while keeping the local time,\n     * use {@link #withZoneSameLocal(ZoneId)}.\n     *\n     * @param {ZoneId} zone - the time-zone to change to, not null\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the requested zone, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    withZoneSameInstant(zone) {\n        requireNonNull(zone, 'zone');\n        return this._zone.equals(zone) ? this :\n            ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);\n    }\n\n    /**\n     * Returns a copy of this date-time with the zone ID set to the offset.\n     * <p>\n     * This returns a zoned date-time where the zone ID is the same as {@link #getOffset()}.\n     * The local date-time, offset and instant of the result will be the same as in this date-time.\n     * <p>\n     * Setting the date-time to a fixed single offset means that any future\n     * calculations, such as addition or subtraction, have no complex edge cases\n     * due to time-zone rules.\n     * This might also be useful when sending a zoned date-time across a network,\n     * as most protocols, such as ISO-8601, only handle offsets,\n     * and not region-based zone IDs.\n     * <p>\n     * This is equivalent to {@code ZonedDateTime.of(zdt.getDateTime(), zdt.getOffset())}.\n     *\n     * @return {ZonedDateTime} a {@code ZonedDateTime} with the zone ID set to the offset, not null\n     */\n    withFixedOffsetZone() {\n        return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     * <p>\n     * This method returns the primitive {@code int} value for the year.\n     * <p>\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA}.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._dateTime.year();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * <p>\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #month()\n     */\n    monthValue() {\n        return this._dateTime.monthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * <p>\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return {Month} the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    month() {\n        return this._dateTime.month();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * <p>\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._dateTime.dayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * <p>\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    dayOfYear() {\n        return this._dateTime.dayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * <p>\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * <p>\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        return this._dateTime.dayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._dateTime.hour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._dateTime.minute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._dateTime.second();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._dateTime.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.with}\n     *\n     * if called with 1 argument {@link ZonedDateTime.withTemporalAdjuster} is applied\n     * otherwise {@link ZonedDateTime.with2}\n     */\n    with(){\n        if(arguments.length === 1){\n            return this.withTemporalAdjuster.apply(this, arguments);\n        } else {\n            return this.with2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this date-time.\n     * <p>\n     * This returns a new {@code ZonedDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * <p>\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the 'last day of the month' and 'next Wednesday'.\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * <p>\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = zonedDateTime.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     * <p>\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@code TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * <pre>\n     *  result = zonedDateTime.with(date);\n     *  result = zonedDateTime.with(time);\n     * </pre>\n     * <p>\n     * {@link ZoneOffset} also implements {@code TemporalAdjuster} however it is less likely\n     * that setting the offset will have the effect you expect. When an offset is passed in,\n     * the local date-time is combined with the new offset to form an {@code Instant}.\n     * The instant and original zone are then used to create the result.\n     * This algorithm means that it is quite likely that the output has a different offset\n     * to the specified offset. It will however work correctly when passing in the offset\n     * applicable for the instant of the zoned date-time, and will work correctly if passing\n     * one of the two valid offsets during a daylight savings overlap when the same local time\n     * occurs twice.\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));\n        } else if (adjuster instanceof LocalTime) {\n            return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));\n        } else if (adjuster instanceof LocalDateTime) {\n            return this._resolveLocal(adjuster);\n        } else if (adjuster instanceof Instant) {\n            var instant = adjuster;\n            return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);\n        } else if (adjuster instanceof ZoneOffset) {\n            return this._resolveOffset(adjuster);\n        }\n        requireNonNull(adjuster, 'adjuster');\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * <p>\n     * This returns a {@code ZonedDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * <p>\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * <p>\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * <p>\n     * The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The zone and nano-of-second are unchanged.\n     * The result will have an offset derived from the new instant and original zone.\n     * If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.\n     * <p>\n     * The {@code OFFSET_SECONDS} field will typically be ignored.\n     * The offset of a {@code ZonedDateTime} is controlled primarily by the time-zone.\n     * As such, changing the offset does not generally make sense, because there is only\n     * one valid offset for the local date-time and zone.\n     * If the zoned date-time is in a daylight savings overlap, then the offset is used\n     * to switch between the two valid offsets. In all other cases, the offset is ignored.\n     * If the new offset value is outside the valid range then a {@code DateTimeException} will be thrown.\n     * <p>\n     * The other {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.\n     * The zone is not part of the calculation and will be unchanged.\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.INSTANT_SECONDS: return ZonedDateTime._create(newValue, this.nano(), this._zone);\n                case ChronoField.OFFSET_SECONDS: {\n                    var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));\n                    return this._resolveOffset(offset);\n                }\n            }\n            return this._resolveLocal(this._dateTime.with(field, newValue));\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the year value altered.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#withYear(int) changing the year} of the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year - the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    withYear(year) {\n        return this._resolveLocal(this._dateTime.withYear(year));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the month-of-year value altered.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#withMonth(int) changing the month} of the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this._resolveLocal(this._dateTime.withMonth(month));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the day-of-month value altered.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#withDayOfMonth(int) changing the day-of-month} of the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid\n     * @throws DateTimeException if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the day-of-year altered.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#withDayOfYear(int) changing the day-of-year} of the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfYear - the day-of-year to set in the result, from 1 to 365-366\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid\n     * @throws DateTimeException if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the hour-of-day value altered.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#withHour(int) changing the time} of the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hour - the hour-of-day to set in the result, from 0 to 23\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    withHour(hour) {\n        return this._resolveLocal(this._dateTime.withHour(hour));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the minute-of-hour value altered.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#withMinute(int) changing the time} of the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minute - the minute-of-hour to set in the result, from 0 to 59\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    withMinute(minute) {\n        return this._resolveLocal(this._dateTime.withMinute(minute));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the second-of-minute value altered.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#withSecond(int) changing the time} of the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} second - the second-of-minute to set in the result, from 0 to 59\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    withSecond(second) {\n        return this._resolveLocal(this._dateTime.withSecond(second));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the nano-of-second value altered.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#withNano(int) changing the time} of the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanoOfSecond - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    withNano(nanoOfSecond) {\n        return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the time truncated.\n     * <p>\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * <p>\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#truncatedTo(TemporalUnit) truncating}\n     * the underlying local date-time. This is then converted back to a\n     * {@code ZonedDateTime}, using the zone ID to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalUnit} unit - the unit to truncate to, not null\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     */\n    truncatedTo(unit) {\n        return this._resolveLocal(this._dateTime.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.plus}\n     *\n     * if called with 1 argument {@link ZonedDateTime.plusTemporalAmount} is applied,\n     * otherwise {@link ZonedDateTime.plus2}\n     */\n    plus(){\n        if(arguments.length === 1){\n            return this.plusTemporalAmount.apply(this, arguments);\n        } else {\n            return this.plus2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     * <p>\n     * This method returns a new date-time based on this time with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link #plus(long, TemporalUnit)}.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalAmount} amount - the amount to add, not null\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusTemporalAmount(amount) {\n        requireNonNull(amount);\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     * <p>\n     * This method returns a new date-time based on this date-time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     * <p>\n     * The calculation for date and time units differ.\n     * <p>\n     * Date units operate on the local time-line.\n     * The period is first added to the local date-time, then converted back\n     * to a zoned date-time using the zone ID.\n     * The conversion uses {@link #ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * with the offset before the addition.\n     * <p>\n     * Time units operate on the instant time-line.\n     * The period is first added to the local date-time, then converted back to\n     * a zoned date-time using the zone ID.\n     * The conversion uses {@link #ofInstant(LocalDateTime, ZoneOffset, ZoneId)}\n     * with the offset before the addition.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to add, not null\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the specified period added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        if (unit instanceof ChronoUnit) {\n            if (unit.isDateBased()) {\n                return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));\n            } else {\n                return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));\n            }\n        }\n        requireNonNull(unit, 'unit');\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in years added.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#plusYears(long) adding years} to the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to add, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusYears(years) {\n        return this._resolveLocal(this._dateTime.plusYears(years));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in months added.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#plusMonths(long) adding months} to the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusMonths(months) {\n        return this._resolveLocal(this._dateTime.plusMonths(months));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in weeks added.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#plusWeeks(long) adding weeks} to the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to add, may be negative\n     * @return {ZonedDateTime}a {@code ZonedDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusWeeks(weeks) {\n        return this._resolveLocal(this._dateTime.plusWeeks(weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in days added.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#plusDays(long) adding days} to the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, may be negative\n     * @return {ZonedDateTime}a {@code ZonedDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusDays(days) {\n        return this._resolveLocal(this._dateTime.plusDays(days));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in hours added.\n     * <p>\n     * This operates on the instant time-line, such that adding one hour will\n     * always be a duration of one hour later.\n     * This may cause the local date-time to change by an amount other than one hour.\n     * Note that this is a different approach to that used by days, months and years,\n     * thus adding one day is not the same as adding 24 hours.\n     * <p>\n     * For example, consider a time-zone where the spring DST cutover means that the\n     * local times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00.\n     * <p><ul>\n     * <li>Adding one hour to 00:30+02:00 will result in 01:30+02:00\n     * <li>Adding one hour to 01:30+02:00 will result in 01:30+01:00\n     * <li>Adding one hour to 01:30+01:00 will result in 02:30+01:00\n     * <li>Adding three hours to 00:30+02:00 will result in 02:30+01:00\n     * </ul><p>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to add, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusHours(hours) {\n        return this._resolveInstant(this._dateTime.plusHours(hours));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in minutes added.\n     * <p>\n     * This operates on the instant time-line, such that adding one minute will\n     * always be a duration of one minute later.\n     * This may cause the local date-time to change by an amount other than one minute.\n     * Note that this is a different approach to that used by days, months and years.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to add, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusMinutes(minutes) {\n        return this._resolveInstant(this._dateTime.plusMinutes(minutes));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in seconds added.\n     * <p>\n     * This operates on the instant time-line, such that adding one second will\n     * always be a duration of one second later.\n     * This may cause the local date-time to change by an amount other than one second.\n     * Note that this is a different approach to that used by days, months and years.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to add, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusSeconds(seconds) {\n        return this._resolveInstant(this._dateTime.plusSeconds(seconds));\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in nanoseconds added.\n     * <p>\n     * This operates on the instant time-line, such that adding one nano will\n     * always be a duration of one nano later.\n     * This may cause the local date-time to change by an amount other than one nano.\n     * Note that this is a different approach to that used by days, months and years.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to add, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusNanos(nanos) {\n        return this._resolveInstant(this._dateTime.plusNanos(nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.minus}\n     *\n     * if called with 1 argument {@link ZonedDateTime.minusTemporalAmount} is applied,\n     * otherwise {@link ZonedDateTime.minus2}\n     */\n    minus(){\n        if(arguments.length === 1){\n            return this.minusTemporalAmount.apply(this, arguments);\n        } else {\n            return this.minus2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     * <p>\n     * This method returns a new date-time based on this time with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link #minus(long, TemporalUnit)}.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to subtract, not null\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusTemporalAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     * <p>\n     * This method returns a new date-time based on this date-time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     * <p>\n     * The calculation for date and time units differ.\n     * <p>\n     * Date units operate on the local time-line.\n     * The period is first subtracted from the local date-time, then converted back\n     * to a zoned date-time using the zone ID.\n     * The conversion uses {@link #ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * with the offset before the subtraction.\n     * <p>\n     * Time units operate on the instant time-line.\n     * The period is first subtracted from the local date-time, then converted back to\n     * a zoned date-time using the zone ID.\n     * The conversion uses {@link #ofInstant(LocalDateTime, ZoneOffset, ZoneId)}\n     * with the offset before the subtraction.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to subtract, not null\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the specified period subtracted, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in years subtracted.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#minusYears(long) subtracting years} to the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to subtract, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusYears(years) {\n        return this.plusYears(-1 * years);\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in months subtracted.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#minusMonths(long) subtracting months} to the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusMonths(months) {\n        return this.plusMonths(-1 * months);\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in weeks subtracted.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#minusWeeks(long) subtracting weeks} to the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to subtract, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusWeeks(weeks) {\n        return this.plusWeeks(-1 * weeks);\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in days subtracted.\n     * <p>\n     * This operates on the local time-line,\n     * {@link LocalDateTime#minusDays(long) subtracting days} to the local date-time.\n     * This is then converted back to a {@code ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     * <p>\n     * When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusDays(days) {\n        return this.plusDays(-1 * days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in hours subtracted.\n     * <p>\n     * This operates on the instant time-line, such that subtracting one hour will\n     * always be a duration of one hour earlier.\n     * This may cause the local date-time to change by an amount other than one hour.\n     * Note that this is a different approach to that used by days, months and years,\n     * thus subtracting one day is not the same as adding 24 hours.\n     * <p>\n     * For example, consider a time-zone where the spring DST cutover means that the\n     * local times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00.\n     * <p><ul>\n     * <li>Subtracting one hour from 02:30+01:00 will result in 01:30+02:00\n     * <li>Subtracting one hour from 01:30+01:00 will result in 01:30+02:00\n     * <li>Subtracting one hour from 01:30+02:00 will result in 00:30+01:00\n     * <li>Subtracting three hours from 02:30+01:00 will result in 00:30+02:00\n     * </ul><p>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to subtract, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusHours(hours) {\n        return this.plusHours(-1 * hours);\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in minutes subtracted.\n     * <p>\n     * This operates on the instant time-line, such that subtracting one minute will\n     * always be a duration of one minute earlier.\n     * This may cause the local date-time to change by an amount other than one minute.\n     * Note that this is a different approach to that used by days, months and years.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to subtract, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusMinutes(minutes) {\n        return this.plusMinutes(-1 * minutes);\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in seconds subtracted.\n     * <p>\n     * This operates on the instant time-line, such that subtracting one second will\n     * always be a duration of one second earlier.\n     * This may cause the local date-time to change by an amount other than one second.\n     * Note that this is a different approach to that used by days, months and years.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to subtract, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusSeconds(seconds) {\n        return this.plusSeconds(-1 * seconds);\n    }\n\n    /**\n     * Returns a copy of this {@code ZonedDateTime} with the specified period in nanoseconds subtracted.\n     * <p>\n     * This operates on the instant time-line, such that subtracting one nano will\n     * always be a duration of one nano earlier.\n     * This may cause the local date-time to change by an amount other than one nano.\n     * Note that this is a different approach to that used by days, months and years.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to subtract, may be negative\n     * @return {ZonedDateTime} a {@code ZonedDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusNanos(nanos) {\n        return this.plusNanos(-1 * nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * <p>\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        if (query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        }\n        requireNonNull(query, 'query');\n        return super.query(query);\n    }\n\n    /**\n     * Calculates the period between this date-time and another date-time in\n     * terms of the specified unit.\n     * <p>\n     * This calculates the period between two date-times in terms of a single unit.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the period in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * <p>\n     * The {@code Temporal} passed to this method must be a {@code ZonedDateTime}.\n     * If the time-zone differs between the two zoned date-times, the specified\n     * end date-time is normalized to have the same zone as this date-time.\n     * <p>\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the period in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     * <p>\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a {@code long} representing the amount of\n     * the specified unit. By contrast, the result of {@code between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     * <p>\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * <p>\n     * The calculation for date and time units differ.\n     * <p>\n     * Date units operate on the local time-line, using the local date-time.\n     * For example, the period from noon on day 1 to noon the following day\n     * in days will always be counted as exactly one day, irrespective of whether\n     * there was a daylight savings change or not.\n     * <p>\n     * Time units operate on the instant time-line.\n     * The calculation effectively converts both zoned date-times to instants\n     * and then calculates the period between the instants.\n     * For example, the period from noon on day 1 to noon the following day\n     * in hours may be 23, 24 or 25 hours (or some other amount) depending on\n     * whether there was a daylight savings change or not.\n     * <p>\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the input temporal as\n     * the second argument.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive  the end date-time, which is converted to a {@code ZonedDateTime}, not null\n     * @param {TemporalUnit} unit  the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date-time and the end date-time\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        var end = ZonedDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end = end.withZoneSameInstant(this._zone);\n            if (unit.isDateBased()) {\n                return this._dateTime.until(end._dateTime, unit);\n            } else {\n                // TODO check with iana tzdb, this might be wrong   \n                return this._dateTime.until(end._dateTime, unit);\n                // threeten says\n                // return toOffsetDateTime().until(end.toOffsetDateTime(), unit)\n                // OffsetDateTime.until ...\n                // end = end.withOffsetSameInstant(offset);\n                // return dateTime.until(end.dateTime, unit);\n            }\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDateTime} part of this date-time.\n     * <p>\n     * This returns a {@code LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return {LocalDateTime} the local date-time part of this date-time, not null\n     */\n    toLocalDateTime() {\n        return this._dateTime;\n    }\n\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * <p>\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return {LocalDate} the date part of this date-time, not null\n     */\n    toLocalDate() {\n        return this._dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * <p>\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return {LocalTime} the time part of this date-time, not null\n     */\n    toLocalTime() {\n        return this._dateTime.toLocalTime();\n    }\n\n    /**\n     * Converts this date-time to an {@code OffsetDateTime}.\n     * <p>\n     * This creates an offset date-time using the local date-time and offset.\n     * The zone ID is ignored.\n     *\n     * @return {OffsetDateTime} an offset date-time representing the same local date-time and offset, not null\n     */\n    toOffsetDateTime() {\n        // TODO we do not support OffsetDateTime, clean up\n        return OffsetDateTime.of(this._dateTime, this._offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * <p>\n     * The comparison is based on the offset date-time and the zone.\n     * Only objects of type {@code ZonedDateTime} are compared, other types return false.\n     *\n     * @param {*} other  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ZonedDateTime) {\n            return this._dateTime.equals(other._dateTime) &&\n                this._offset.equals(other._offset) &&\n                this._zone.equals(other._zone);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        var r = 17;\n        r = 31 * r + this._dateTime.hashCode();\n        r = 31 * r + this._offset.hashCode();\n        r = 31 * r + this._zone.hashCode();\n        return r;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as\n     * {@code 2007-12-03T10:15:30+01:00[Europe/Paris]}.\n     * <p>\n     * The format consists of the {@code LocalDateTime} followed by the {@code ZoneOffset}.\n     * If the {@code ZoneId} is not the same as the offset, then the ID is output.\n     * The output is compatible with ISO-8601 if the offset and ID are the same.\n     *\n     * @return {string} a string representation of this date-time, not null\n     */\n    toString() {\n        var str = this._dateTime.toString() + this._offset.toString();\n        if (this._offset !== this._zone) {\n            str += '[' + this._zone.toString() + ']';\n        }\n        return str;\n    }\n\n    /**\n     * Outputs this date-time as a {@code String} using the formatter.\n     * <p>\n     * This date will be passed to the formatter\n     * {@link DateTimeFormatter#format(TemporalAccessor) print method}.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {string} the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        return super.format(formatter);\n    }\n\n}\n\nexport function _init(){\n    ZonedDateTime.FROM = createTemporalQuery('ZonedDateTime.FROM', (temporal) => {\n        return ZonedDateTime.from(temporal);\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ZonedDateTime.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {Instant} from '../Instant';\nimport {LocalDate} from '../LocalDate';\nimport {MathUtil} from '../MathUtil';\n\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\nexport class ChronoZonedDateTime  extends Temporal {\n    query(query) {\n        if (query === TemporalQueries.zoneId() || query === TemporalQueries.zone()) {\n            return this.zone();\n        } else if (query === TemporalQueries.chronology()) {\n            return this.toLocalDate().chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.offset()) {\n            return this.offset();\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n        } else if (query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Outputs this date-time as a {@code String} using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * <p>\n     * This returns an {@code Instant} representing the same point on the\n     * time-line as this date-time. The calculation combines the\n     * {@linkplain #toLocalDateTime() local date-time} and\n     * {@linkplain #getOffset() offset}.\n     *\n     * @return {Instant} an {@code Instant} representing the same instant, not null\n     */\n    toInstant() {\n        return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch\n     * of 1970-01-01T00:00:00Z.\n     * <p>\n     * This uses the {@linkplain #toLocalDateTime() local date-time} and\n     * {@linkplain #getOffset() offset} to calculate the epoch-second value,\n     * which is the number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier are negative.\n     *\n     * @return {number} the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    toEpochSecond() {\n        var epochDay = this.toLocalDate().toEpochDay();\n        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n        secs -= this.offset().totalSeconds();\n        return secs;\n    }\n\n    /**\n      * Compares this date-time to another date-time, including the chronology.\n      * <p>\n      * The comparison is based first on the instant, then on the local date-time,\n      * then on the zone ID, then on the chronology.\n      * It is \"consistent with equals\", as defined by {@link Comparable}.\n      * <p>\n      * If all the date-time objects being compared are in the same chronology, then the\n      * additional chronology stage is not required.\n      *\n      * @param {ChronoZonedDateTime} other - the other date-time to compare to, not null\n      * @return {number} the comparator value, negative if less, positive if greater\n      */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n        if (cmp === 0) {\n            cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n            if (cmp === 0) {\n                cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n                if (cmp === 0) {\n                    cmp = strcmp(this.zone().id(), other.zone().id());\n                    // we only support iso for now\n                    //if (cmp === 0) {\n                    //    cmp = toLocalDate().getChronology().compareTo(other.toLocalDate().getChronology());\n                    //}\n                }\n            }\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     * <p>\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this is after the specified date-time\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        var thisEpochSec = this.toEpochSecond();\n        var otherEpochSec = other.toEpochSecond();\n        return thisEpochSec > otherEpochSec ||\n            (thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     * <p>\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this point is before the specified date-time\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        var thisEpochSec = this.toEpochSecond();\n        var otherEpochSec = other.toEpochSecond();\n        return thisEpochSec < otherEpochSec ||\n            (thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     * <p>\n     * This method differs from the comparison in {@link #compareTo} and {@link #equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if the instant equals the instant of the specified date-time\n     */\n    isEqual(other) {\n        requireNonNull(other, 'other');\n        return this.toEpochSecond() === other.toEpochSecond() &&\n                this.toLocalTime().nano() === other.toLocalTime().nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * <p>\n     * The comparison is based on the offset date-time and the zone.\n     * To compare for the same instant on the time-line, use {@link #compareTo}.\n     * Only objects of type {@code ChronoZoneDateTime} are compared, other types return false.\n     *\n     * @param {*} other  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ChronoZonedDateTime) {\n            return this.compareTo(other) === 0;\n        }\n        return false;\n    }\n\n}\n\nfunction strcmp(a, b){\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/chrono/ChronoZonedDateTime.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {MathUtil} from '../MathUtil';\n\nimport {LocalDate} from '../LocalDate';\nimport {Instant} from '../Instant';\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\n/**\n * A date-time without a time-zone in an arbitrary chronology, intended\n * for advanced globalization use cases.\n * <p>\n * <b>Most applications should declare method signatures, fields and variables\n * as {@link LocalDateTime}, not this interface.</b>\n * <p>\n * A {@code ChronoLocalDateTime} is the abstract representation of a local date-time\n * where the {@code Chronology chronology}, or calendar system, is pluggable.\n * The date-time is defined in terms of fields expressed by {@link TemporalField},\n * where most common implementations are defined in {@link ChronoField}.\n * The chronology defines how the calendar system operates and the meaning of\n * the standard fields.\n *\n * <h4>When to use this interface</h4>\n * The design of the API encourages the use of {@code LocalDateTime} rather than this\n * interface, even in the case where the application needs to deal with multiple\n * calendar systems. The rationale for this is explored in detail in {@link ChronoLocalDate}.\n * <p>\n * Ensure that the discussion in {@code ChronoLocalDate} has been read and understood\n * before using this interface.\n *\n * <h3>Specification for implementors</h3>\n * This interface must be implemented with care to ensure other classes operate correctly.\n * All implementations that can be instantiated must be final, immutable and thread-safe.\n * Subclasses should be Serializable wherever possible.\n * <p>\n * In JDK 8, this is an interface with default methods.\n * Since there are no default methods in JDK 7, an abstract class is used.\n *\n * @param <D> the date type\n */\nexport class ChronoLocalDateTime extends Temporal {\n        /* <D extends ChronoLocalDate>\n        extends DefaultInterfaceTemporal\n        implements Temporal, TemporalAdjuster, Comparable<ChronoLocalDateTime<?>> */\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of this date-time.\n     * <p>\n     * The {@code Chronology} represents the calendar system in use.\n     * The era and other fields in {@link ChronoField} are defined by the chronology.\n     *\n     * @return the chronology, not null\n     */\n    chronology() {\n        return this.toLocalDate().chronology();\n    }\n\n    /**\n     *\n     * @param {TemporalQuery} query\n     * @returns {*}\n     */\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n        } else if (query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        } else if (query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    adjustInto(temporal) {\n        return temporal\n                .with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay())\n                .with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * <p>\n     * This combines this local date-time and the specified offset to form\n     * an {@code Instant}.\n     *\n     * @param {ZoneOffset} offset  the offset to use for the conversion, not null\n     * @return {Instant} an {@code Instant} representing the same instant, not null\n     */\n    toInstant(offset) {\n        return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch\n     * of 1970-01-01T00:00:00Z.\n     * <p>\n     * This combines this local date-time and the specified offset to calculate the\n     * epoch-second value, which is the number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier are negative.\n     *\n     * @param {ZoneOffset} offset  the offset to use for the conversion, not null\n     * @return {number} the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    toEpochSecond(offset) {\n        requireNonNull(offset, 'offset');\n        var epochDay = this.toLocalDate().toEpochDay();\n        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n        secs -= offset.totalSeconds();\n        return MathUtil.safeToInt(secs);\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/chrono/ChronoLocalDateTime.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull} from '../assert';\nimport {UnsupportedTemporalTypeException} from '../errors';\n\nimport {Instant} from '../Instant';\nimport {LocalDate} from '../LocalDate';\nimport {LocalTime} from '../LocalTime';\nimport {MathUtil} from '../MathUtil';\nimport {ZoneId} from '../ZoneId';\n\nimport {ChronoField} from './ChronoField';\nimport {TemporalQueries} from './TemporalQueries';\nimport {TemporalAccessor} from './TemporalAccessor';\n\n/**\n * A wrapper around a native javascript Date instance that\n * implements TemporalAccessor functionality\n */\nclass NativeJsTemporal extends TemporalAccessor {\n\n    /**\n     *\n     * @param {!(Date|moment)} date - a javascript Date or a moment instance\n     * @param {ZoneId} [zone=ZoneId.systemDefault()] - the zone of the temporal, defaults to ZoneId.systemDefault()\n     */\n    constructor(date, zone=ZoneId.systemDefault()){\n        super();\n        this._zone = zone;\n        if(date instanceof Date) {\n            this._epochMilli = date.getTime();\n            return;\n        } else if(typeof date.toDate === 'function' &&  date.toDate() instanceof Date) {\n            // it's a moment\n            this._epochMilli = date.toDate().getTime();\n            return;\n        }\n        assert(false, 'date must be either a javascript date or a moment');\n    }\n\n    /**\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n        } else if(query === TemporalQueries.localTime()){\n            return LocalTime.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n        } else if(query === TemporalQueries.zone()){\n            return LocalTime.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n        }\n        return super.query(query);\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {number}\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     *\n     * @param {!TemporalField} field\n     * @returns {number}\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.NANO_OF_SECOND: return MathUtil.floorMod(this._epochMilli, 1000) * 1000000;\n                case ChronoField.INSTANT_SECONDS: return MathUtil.floorDiv(this._epochMilli, 1000);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n}\n\n/**\n *\n * @param {!(Date|moment)} date - a javascript Date or a moment instance\n * @param {ZoneId} [zone=ZoneId.systemDefault()] - the zone of the temporal, defaults to ZoneId.systemDefault()\n * @returns {NativeJsTemporal}\n */\nexport function nativeJs(date, zone){\n    return new NativeJsTemporal(date, zone);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/NativeJsTemporal.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {UnsupportedTemporalTypeException, IllegalStateException} from '../errors';\n\nimport {DayOfWeek} from '../DayOfWeek';\nimport {Duration} from '../Duration';\nimport {MathUtil} from '../MathUtil';\nimport {LocalDate} from '../LocalDate';\n\nimport {ChronoField} from './ChronoField';\nimport {ChronoUnit} from './ChronoUnit';\nimport {TemporalField} from './TemporalField';\nimport {TemporalUnit} from './TemporalUnit';\nimport {ValueRange} from './ValueRange';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\n\nimport {ResolverStyle} from '../format/ResolverStyle';\n\n/**\n * Fields and units specific to the ISO-8601 calendar system,\n * including quarter-of-year and week-based-year.\n * <p>\n * This class defines fields and units that are specific to the ISO calendar system.\n *\n * <h3>Quarter of year</h3>\n * The ISO-8601 standard is based on the standard civic 12 month year.\n * This is commonly divided into four quarters, often abbreviated as Q1, Q2, Q3 and Q4.\n * <p>\n * January, February and March are in Q1.\n * April, May and June are in Q2.\n * July, August and September are in Q3.\n * October, November and December are in Q4.\n * <p>\n * The complete date is expressed using three fields:\n * <p><ul>\n * <li>{@link #DAY_OF_QUARTER DAY_OF_QUARTER} - the day within the quarter, from 1 to 90, 91 or 92\n * <li>{@link #QUARTER_OF_YEAR QUARTER_OF_YEAR} - the week within the week-based-year\n * <li>{@link ChronoField#YEAR YEAR} - the standard ISO year\n * </ul><p>\n *\n * <h3>Week based years</h3>\n * The ISO-8601 standard was originally intended as a data interchange format,\n * defining a string format for dates and times. However, it also defines an\n * alternate way of expressing the date, based on the concept of week-based-year.\n * <p>\n * The date is expressed using three fields:\n * <p><ul>\n * <li>{@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} - the standard field defining the\n *  day-of-week from Monday (1) to Sunday (7)\n * <li>{@link #WEEK_OF_WEEK_BASED_YEAR} - the week within the week-based-year\n * <li>{@link #WEEK_BASED_YEAR WEEK_BASED_YEAR} - the week-based-year\n * </ul><p>\n * The week-based-year itself is defined relative to the standard ISO proleptic year.\n * It differs from the standard year in that it always starts on a Monday.\n * <p>\n * The first week of a week-based-year is the first Monday-based week of the standard\n * ISO year that has at least 4 days in the new year.\n * <p><ul>\n * <li>If January 1st is Monday then week 1 starts on January 1st\n * <li>If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year\n * <li>If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year\n * <li>If January 1st is Thursday then week 1 starts on December 29th of the previous standard year\n * <li>If January 1st is Friday then week 1 starts on January 4th\n * <li>If January 1st is Saturday then week 1 starts on January 3rd\n * <li>If January 1st is Sunday then week 1 starts on January 2nd\n * </ul><p>\n * There are 52 weeks in most week-based years, however on occasion there are 53 weeks.\n * <p>\n * For example:\n * <p>\n * <table cellpadding='0' cellspacing='3' border='0' style='text-align: left; width: 50%;'>\n * <caption>Examples of Week based Years</caption>\n * <tr><th>Date</th><th>Day-of-week</th><th>Field values</th></tr>\n * <tr><th>2008-12-28</th><td>Sunday</td><td>Week 52 of week-based-year 2008</td></tr>\n * <tr><th>2008-12-29</th><td>Monday</td><td>Week 1 of week-based-year 2009</td></tr>\n * <tr><th>2008-12-31</th><td>Wednesday</td><td>Week 1 of week-based-year 2009</td></tr>\n * <tr><th>2009-01-01</th><td>Thursday</td><td>Week 1 of week-based-year 2009</td></tr>\n * <tr><th>2009-01-04</th><td>Sunday</td><td>Week 1 of week-based-year 2009</td></tr>\n * <tr><th>2009-01-05</th><td>Monday</td><td>Week 2 of week-based-year 2009</td></tr>\n * </table>\n *\n * <h3>Static properties of Class {@link IsoFields}</h3>\n *\n * IsoFields.DAY_OF_QUARTER\n *\n * The field that represents the day-of-quarter.\n * <p>\n * This field allows the day-of-quarter value to be queried and set.\n * The day-of-quarter has values from 1 to 90 in Q1 of a standard year, from 1 to 91\n * in Q1 of a leap year, from 1 to 91 in Q2 and from 1 to 92 in Q3 and Q4.\n * <p>\n * The day-of-quarter can only be calculated if the day-of-year, month-of-year and year\n * are available.\n * <p>\n * When setting this field, the value is allowed to be partially lenient, taking any\n * value from 1 to 92. If the quarter has less than 92 days, then day 92, and\n * potentially day 91, is in the following quarter.\n *\n * IsoFields.QUARTER_OF_YEAR\n *\n * The field that represents the quarter-of-year.\n * <p>\n * This field allows the quarter-of-year value to be queried and set.\n * The quarter-of-year has values from 1 to 4.\n * <p>\n * The day-of-quarter can only be calculated if the month-of-year is available.\n *\n * IsoFields.WEEK_OF_WEEK_BASED_YEAR\n *\n * The field that represents the week-of-week-based-year.\n * <p>\n * This field allows the week of the week-based-year value to be queried and set.\n *\n * IsoFields.WEEK_BASED_YEAR\n *\n * The field that represents the week-based-year.\n * <p>\n * This field allows the week-based-year value to be queried and set.\n *\n * IsoFields.WEEK_BASED_YEARS\n *\n * The unit that represents week-based-years for the purpose of addition and subtraction.\n * <p>\n * This allows a number of week-based-years to be added to, or subtracted from, a date.\n * The unit is equal to either 52 or 53 weeks.\n * The estimated duration of a week-based-year is the same as that of a standard ISO\n * year at {@code 365.2425 Days}.\n * <p>\n * The rules for addition add the number of week-based-years to the existing value\n * for the week-based-year field. If the resulting week-based-year only has 52 weeks,\n * then the date will be in week 1 of the following week-based-year.\n *\n * IsoFields.QUARTER_YEARS\n *\n * Unit that represents the concept of a quarter-year.\n * For the ISO calendar system, it is equal to 3 months.\n * The estimated duration of a quarter-year is one quarter of {@code 365.2425 Days}.\n */\nexport class IsoFields {\n}\n\n//-----------------------------------------------------------------------\n\nconst QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];\n\n/**\n * Implementation of the field.\n */\nclass Field extends TemporalField{\n\n    /**\n     *\n     * @returns {TemporalAccessor}\n     */\n    resolve() {\n        return null;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDateBased() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isTimeBased() {\n        return false;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    _isIso() {\n        return true;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {ValueRange}\n     */\n    static _getWeekRangeByLocalDate(date) {\n        var wby = Field._getWeekBasedYear(date);\n        return ValueRange.of(1, Field._getWeekRangeByYear(wby));\n    }\n\n    /**\n     *\n     * @param {number} wby\n     * @returns {number}\n     */\n    static _getWeekRangeByYear(wby) {\n        var date = LocalDate.of(wby, 1, 1);\n        // 53 weeks if standard year starts on Thursday, or Wed in a leap year\n        if (date.dayOfWeek() === DayOfWeek.THURSDAY || (date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear())) {\n            return 53;\n        }\n        return 52;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {number}\n     */\n    static _getWeek(date) {\n        var dow0 = date.dayOfWeek().ordinal();\n        var doy0 = date.dayOfYear() - 1;\n        var doyThu0 = doy0 + (3 - dow0);  // adjust to mid-week Thursday (which is 3 indexed from zero)\n        var alignedWeek = MathUtil.intDiv(doyThu0, 7);\n        var firstThuDoy0 = doyThu0 - (alignedWeek * 7);\n        var firstMonDoy0 = firstThuDoy0 - 3;\n        if (firstMonDoy0 < -3) {\n            firstMonDoy0 += 7;\n        }\n        if (doy0 < firstMonDoy0) {\n            return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();\n        }\n        var week = MathUtil.intDiv((doy0 - firstMonDoy0), 7) + 1;\n        if (week === 53) {\n            if ((firstMonDoy0 === -3 || (firstMonDoy0 === -2 && date.isLeapYear())) === false) {\n                week = 1;\n            }\n        }\n        return week;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {number}\n     */\n    static _getWeekBasedYear(date) {\n        var year = date.year();\n        var doy = date.dayOfYear();\n        if (doy <= 3) {\n            let dow = date.dayOfWeek().ordinal();\n            if (doy - dow < -2) {\n                year--;\n            }\n        } else if (doy >= 363) {\n            let dow = date.dayOfWeek().ordinal();\n            doy = doy - 363 - (date.isLeapYear() ? 1 : 0);\n            if (doy - dow >= 0) {\n                year++;\n            }\n        }\n        return year;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    getDisplayName(/*locale*/) {\n        return this.toString();\n    }\n\n    /**\n     *\n     * @returns {null}\n     */\n    resolve() {\n        return null;\n    }\n\n    name(){\n        return this.toString();\n    }\n\n}\n\n\nclass DAY_OF_QUARTER_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'DayOfQuarter';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return ChronoUnit.DAYS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return QUARTER_YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 90, 92);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) &&\n            temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    rangeRefinedBy(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n        }\n        var qoy = temporal.getLong(QUARTER_OF_YEAR);\n        if (qoy === 1) {\n            var year = temporal.getLong(ChronoField.YEAR);\n            return (IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90));\n        } else if (qoy === 2) {\n            return ValueRange.of(1, 91);\n        } else if (qoy === 3 || qoy === 4) {\n            return ValueRange.of(1, 92);\n        } // else value not from 1 to 4, so drop through\n        return this.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n        }\n        var doy = temporal.get(ChronoField.DAY_OF_YEAR);\n        var moy = temporal.get(ChronoField.MONTH_OF_YEAR);\n        var year = temporal.getLong(ChronoField.YEAR);\n        return doy - QUARTER_DAYS[MathUtil.intDiv((moy - 1), 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        var curValue = this.getFrom(temporal);\n        this.range().checkValidValue(newValue, this);\n        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));\n    }\n\n    /**\n     *\n     * @param {Map<TemporalField, number>} fieldValues\n     * @param {TemporalAccessor} partialTemporal\n     * @param {ResolverStyle} resolverStyle\n     * @returns {ValueRange}\n     */\n    resolve(fieldValues, partialTemporal, resolverStyle) {\n        var yearLong = fieldValues.get(ChronoField.YEAR);\n        var qoyLong = fieldValues.get(QUARTER_OF_YEAR);\n        if (yearLong == null || qoyLong == null) {\n            return null;\n        }\n        var y = ChronoField.YEAR.checkValidIntValue(yearLong);\n        var doq = fieldValues.get(DAY_OF_QUARTER);\n        var date;\n        if (resolverStyle === ResolverStyle.LENIENT) {\n            let qoy = qoyLong;\n            date = LocalDate.of(y, 1, 1);\n            date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));\n            date = date.plusDays(MathUtil.safeSubtract(doq, 1));\n        } else {\n            let qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                var max = 92;\n                if (qoy === 1) {\n                    max = (IsoChronology.isLeapYear(y) ? 91 : 90);\n                } else if (qoy === 2) {\n                    max = 91;\n                }\n                ValueRange.of(1, max).checkValidValue(doq, this);\n            } else {\n                this.range().checkValidValue(doq, this);  // leniently check from 1 to 92\n            }\n            date = LocalDate.of(y, ((qoy - 1) * 3) + 1, 1).plusDays(doq - 1);\n        }\n        fieldValues.remove(this);\n        fieldValues.remove(ChronoField.YEAR);\n        fieldValues.remove(QUARTER_OF_YEAR);\n        return date;\n    }\n}\n\nclass QUARTER_OF_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'QuarterOfYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return QUARTER_YEARS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return ChronoUnit.YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 4);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    rangeRefinedBy(temporal) {\n        return this.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: QuarterOfYear');\n        }\n        var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);\n        return MathUtil.intDiv((moy + 2), 3);\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        var curValue = this.getFrom(temporal);\n        this.range().checkValidValue(newValue, this);\n        return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);\n    }\n\n}\n\nclass WEEK_OF_WEEK_BASED_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'WeekOfWeekBasedYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return ChronoUnit.WEEKS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return WEEK_BASED_YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 52, 53);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    rangeRefinedBy(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n        }\n        return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n        }\n        return Field._getWeek(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        this.range().checkValidValue(newValue, this);\n        return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);\n    }\n\n    /**\n     *\n     * @param {Map<TemporalField, number>} fieldValues\n     * @param {TemporalAccessor} partialTemporal\n     * @param {ResolverStyle} resolverStyle\n     * @returns {ValueRange}\n     */\n    resolve(fieldValues, partialTemporal, resolverStyle) {\n        var wbyLong = fieldValues.get(WEEK_BASED_YEAR);\n        var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);\n        if (wbyLong == null || dowLong == null) {\n            return null;\n        }\n        var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);\n        var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);\n        var date;\n        if (resolverStyle === ResolverStyle.LENIENT) {\n            let dow = dowLong;\n            let weeks = 0;\n            if (dow > 7) {\n                weeks = MathUtil.intDiv((dow - 1), 7);\n                dow = (MathUtil.intMod((dow - 1), 7) + 1);\n            } else if (dow < 1) {\n                weeks = MathUtil.intDiv(dow, 7) - 1;\n                dow = MathUtil.intMod(dow, 7) + 7;\n            }\n            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);\n        } else {\n            let dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                let temp = LocalDate.of(wby, 1, 4);\n                let range = Field._getWeekRangeByLocalDate(temp);\n                range.checkValidValue(wowby, this);\n            } else {\n                this.range().checkValidValue(wowby, this);  // leniently check from 1 to 53\n            }\n            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, dow);\n        }\n        fieldValues.remove(this);\n        fieldValues.remove(WEEK_BASED_YEAR);\n        fieldValues.remove(ChronoField.DAY_OF_WEEK);\n        return date;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    getDisplayName() {\n        return 'Week';\n    }\n\n}\n\nclass WEEK_BASED_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'WeekBasedYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return WEEK_BASED_YEARS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return ChronoUnit.FOREVER;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ChronoField.YEAR.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    rangeRefinedBy(temporal) {\n        return ChronoField.YEAR.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n        }\n        return Field._getWeekBasedYear(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        if (this.isSupportedBy(temporal) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n        }\n        var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);  // strict check\n        var date = LocalDate.from(temporal);\n        var dow = date.get(ChronoField.DAY_OF_WEEK);\n        var week = Field._getWeek(date);\n        if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {\n            week = 52;\n        }\n        var resolved = LocalDate.of(newWby, 1, 4);  // 4th is guaranteed to be in week one\n        var days = (dow - resolved.get(ChronoField.DAY_OF_WEEK)) + ((week - 1) * 7);\n        resolved = resolved.plusDays(days);\n        return temporal.with(resolved);\n    }\n\n}\n\n//-----------------------------------------------------------------------\n/**\n * Implementation of the period unit.\n */\nclass Unit extends TemporalUnit {\n\n    /**\n     *\n     * @param {string} name\n     * @param {Duration} estimatedDuration\n     */\n    constructor(name, estimatedDuration) {\n        super();\n        this._name = name;\n        this._duration = estimatedDuration;\n    }\n\n    /**\n     *\n     * @returns {Duration}\n     */\n    duration() {\n        return this._duration;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDurationEstimated() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDateBased() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isTimeBased() {\n        return false;\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY);\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} periodToAdd\n     * @returns {number}\n     */\n    addTo(temporal, periodToAdd) {\n        switch(this) {\n            case WEEK_BASED_YEARS:\n                var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);\n                return temporal.with(WEEK_BASED_YEAR, added);\n            case QUARTER_YEARS:\n                // no overflow (256 is multiple of 4)\n                return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);\n            default:\n                throw new IllegalStateException('Unreachable');\n        }\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal1\n     * @param {Temporal} temporal2\n     * @returns {number}\n     */\n    between(temporal1, temporal2) {\n        switch(this) {\n            case WEEK_BASED_YEARS:\n                return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));\n            case QUARTER_YEARS:\n                return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);\n            default:\n                throw new IllegalStateException('Unreachable');\n        }\n    }\n\n    toString() {\n        return name;\n    }\n}\n\nvar DAY_OF_QUARTER = null;\nvar QUARTER_OF_YEAR = null;\nvar WEEK_OF_WEEK_BASED_YEAR = null;\nvar WEEK_BASED_YEAR = null;\nvar WEEK_BASED_YEARS = null;\nvar QUARTER_YEARS = null;\n\nexport function _init() {\n    DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();\n    QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();\n    WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();\n    WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();\n\n    WEEK_BASED_YEARS = new Unit('WeekBasedYears', Duration.ofSeconds(31556952));\n    QUARTER_YEARS = new Unit('QuarterYears', Duration.ofSeconds(31556952 / 4));\n\n    IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;\n    IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;\n    IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;\n    IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;\n    IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;\n    IsoFields.QUARTER_YEARS = QUARTER_YEARS;\n}\n\n// this differs from threeten, but for ease of use we bring back good old joda time functionality\n/**\n * the week of the week based year as defined by the ISO8601 Standard with a Monday-based week\n *\n * @returns {number} the week a the week based year\n */\nLocalDate.prototype.isoWeekOfWeekyear = function () {\n    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);\n};\n/**\n * the year of the week based year as defined by the ISO8601 Standard with a Monday-based week\n *\n * @returns {number} the year a the week based year\n */\nLocalDate.prototype.isoWeekyear = function () {\n    return this.get(IsoFields.WEEK_BASED_YEAR);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/IsoFields.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {IllegalStateException} from '../errors';\n\nimport {TemporalAdjuster} from './TemporalAdjuster';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {MathUtil} from '../MathUtil';\n\n/**\n * Common implementations of {@code TemporalAdjuster}.\n * <p>\n * This class provides common implementations of {@link TemporalAdjuster}.\n * They are especially useful to document the intent of business logic and\n * often link well to requirements.\n * For example, these two pieces of code do the same thing, but the second\n * one is clearer (assuming that there is a static import of this class):\n * <pre>\n *  // direct manipulation\n *  date.withDayOfMonth(1).plusMonths(1).minusDays(1);\n *  // use of an adjuster from this class\n *  date.with(lastDayOfMonth());\n * </pre>\n * There are two equivalent ways of using a {@code TemporalAdjuster}.\n * The first is to invoke the method on the interface directly.\n * The second is to use {@link Temporal#with(TemporalAdjuster)}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   dateTime = adjuster.adjustInto(dateTime);\n *   dateTime = dateTime.with(adjuster);\n * </pre>\n * It is recommended to use the second approach, {@code with(TemporalAdjuster)},\n * as it is a lot clearer to read in code.\n *\n * <h3>Specification for implementors</h3>\n * This is a thread-safe utility class.\n * All returned adjusters are immutable and thread-safe.\n * <p>\n * The JDK 8 ofDateAdjuster(UnaryOperator) method is not backported.\n */\nexport class TemporalAdjusters {\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the 'first day of month' adjuster, which returns a new date set to\n     * the first day of the current month.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-01-15 will return 2011-01-01.<br>\n     * The input 2011-02-15 will return 2011-02-01.\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_MONTH, 1);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day-of-month adjuster, not null\n     */\n    static firstDayOfMonth() {\n        return Impl.FIRST_DAY_OF_MONTH;\n    }\n\n    /**\n     * Returns the 'last day of month' adjuster, which returns a new date set to\n     * the last day of the current month.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-01-15 will return 2011-01-31.<br>\n     * The input 2011-02-15 will return 2011-02-28.<br>\n     * The input 2012-02-15 will return 2012-02-29 (leap year).<br>\n     * The input 2011-04-15 will return 2011-04-30.\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  long lastDay = temporal.range(DAY_OF_MONTH).getMaximum();\n     *  temporal.with(DAY_OF_MONTH, lastDay);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the last day-of-month adjuster, not null\n     */\n    static lastDayOfMonth() {\n        return Impl.LAST_DAY_OF_MONTH;\n    }\n\n    /**\n     * Returns the 'first day of next month' adjuster, which returns a new date set to\n     * the first day of the next month.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-01-15 will return 2011-02-01.<br>\n     * The input 2011-02-15 will return 2011-03-01.\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_MONTH, 1).plus(1, MONTHS);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day of next month adjuster, not null\n     */\n    static firstDayOfNextMonth() {\n        return Impl.FIRST_DAY_OF_NEXT_MONTH;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the 'first day of year' adjuster, which returns a new date set to\n     * the first day of the current year.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-01-15 will return 2011-01-01.<br>\n     * The input 2011-02-15 will return 2011-01-01.<br>\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_YEAR, 1);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day-of-year adjuster, not null\n     */\n    static firstDayOfYear() {\n        return Impl.FIRST_DAY_OF_YEAR;\n    }\n\n    /**\n     * Returns the 'last day of year' adjuster, which returns a new date set to\n     * the last day of the current year.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-01-15 will return 2011-12-31.<br>\n     * The input 2011-02-15 will return 2011-12-31.<br>\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  long lastDay = temporal.range(DAY_OF_YEAR).getMaximum();\n     *  temporal.with(DAY_OF_YEAR, lastDay);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the last day-of-year adjuster, not null\n     */\n    static lastDayOfYear() {\n        return Impl.LAST_DAY_OF_YEAR;\n    }\n\n    /**\n     * Returns the 'first day of next year' adjuster, which returns a new date set to\n     * the first day of the next year.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-01-15 will return 2012-01-01.\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_YEAR, 1).plus(1, YEARS);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day of next month adjuster, not null\n     */\n    static firstDayOfNextYear() {\n        return Impl.FIRST_DAY_OF_NEXT_YEAR;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the first in month adjuster, which returns a new date\n     * in the same month with the first matching day-of-week.\n     * This is used for expressions like 'first Tuesday in March'.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-12-15 for (MONDAY) will return 2011-12-05.<br>\n     * The input 2011-12-15 for (FRIDAY) will return 2011-12-02.<br>\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@code DAY_OF_WEEK} and {@code DAY_OF_MONTH} fields\n     * and the {@code DAYS} unit, and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the first in month adjuster, not null\n     */\n    static firstInMonth(dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(1, dayOfWeek);\n    }\n\n    /**\n     * Returns the last in month adjuster, which returns a new date\n     * in the same month with the last matching day-of-week.\n     * This is used for expressions like 'last Tuesday in March'.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-12-15 for (MONDAY) will return 2011-12-26.<br>\n     * The input 2011-12-15 for (FRIDAY) will return 2011-12-30.<br>\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@code DAY_OF_WEEK} and {@code DAY_OF_MONTH} fields\n     * and the {@code DAYS} unit, and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the first in month adjuster, not null\n     */\n    static lastInMonth(dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(-1, dayOfWeek);\n    }\n\n    /**\n     * Returns the day-of-week in month adjuster, which returns a new date\n     * in the same month with the ordinal day-of-week.\n     * This is used for expressions like the 'second Tuesday in March'.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-12-15 for (1,TUESDAY) will return 2011-12-06.<br>\n     * The input 2011-12-15 for (2,TUESDAY) will return 2011-12-13.<br>\n     * The input 2011-12-15 for (3,TUESDAY) will return 2011-12-20.<br>\n     * The input 2011-12-15 for (4,TUESDAY) will return 2011-12-27.<br>\n     * The input 2011-12-15 for (5,TUESDAY) will return 2012-01-03.<br>\n     * The input 2011-12-15 for (-1,TUESDAY) will return 2011-12-27 (last in month).<br>\n     * The input 2011-12-15 for (-4,TUESDAY) will return 2011-12-06 (3 weeks before last in month).<br>\n     * The input 2011-12-15 for (-5,TUESDAY) will return 2011-11-29 (4 weeks before last in month).<br>\n     * The input 2011-12-15 for (0,TUESDAY) will return 2011-11-29 (last in previous month).<br>\n     * <p>\n     * For a positive or zero ordinal, the algorithm is equivalent to finding the first\n     * day-of-week that matches within the month and then adding a number of weeks to it.\n     * For a negative ordinal, the algorithm is equivalent to finding the last\n     * day-of-week that matches within the month and then subtracting a number of weeks to it.\n     * The ordinal number of weeks is not validated and is interpreted leniently\n     * according to this algorithm. This definition means that an ordinal of zero finds\n     * the last matching day-of-week in the previous month.\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@code DAY_OF_WEEK} and {@code DAY_OF_MONTH} fields\n     * and the {@code DAYS} unit, and assumes a seven day week.\n     *\n     * @param {Number} ordinal  the week within the month, unbounded but typically from -5 to 5\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the day-of-week in month adjuster, not null\n     */\n    static dayOfWeekInMonth(ordinal, dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(ordinal, dayOfWeek);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the next day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week after the date being adjusted.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).<br>\n     * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).<br>\n     * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (seven days later).\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@code DAY_OF_WEEK} field and the {@code DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to move the date to, not null\n     * @return {TemporalAdjuster} the next day-of-week adjuster, not null\n     */\n    static next(dayOfWeek) {\n        return new RelativeDayOfWeek(2, dayOfWeek);\n    }\n\n    /**\n     * Returns the next-or-same day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week after the date being adjusted\n     * unless it is already on that day in which case the same object is returned.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).<br>\n     * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).<br>\n     * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@code DAY_OF_WEEK} field and the {@code DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to check for or move the date to, not null\n     * @return {TemporalAdjuster} the next-or-same day-of-week adjuster, not null\n     */\n    static nextOrSame(dayOfWeek) {\n        return new RelativeDayOfWeek(0, dayOfWeek);\n    }\n\n    /**\n     * Returns the previous day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week before the date being adjusted.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).<br>\n     * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).<br>\n     * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (seven days earlier).\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@code DAY_OF_WEEK} field and the {@code DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to move the date to, not null\n     * @return {TemporalAdjuster} the previous day-of-week adjuster, not null\n     */\n    static previous(dayOfWeek) {\n        return new RelativeDayOfWeek(3, dayOfWeek);\n    }\n\n    /**\n     * Returns the previous-or-same day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week before the date being adjusted\n     * unless it is already on that day in which case the same object is returned.\n     * <p>\n     * The ISO calendar system behaves as follows:<br>\n     * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).<br>\n     * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).<br>\n     * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).\n     * <p>\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@code DAY_OF_WEEK} field and the {@code DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek the day-of-week to check for or move the date to, not null\n     * @return {TemporalAdjuster} the previous-or-same day-of-week adjuster, not null\n     */\n    static previousOrSame(dayOfWeek) {\n        return new RelativeDayOfWeek(1, dayOfWeek);\n    }\n\n}\n\n//-----------------------------------------------------------------------\n/**\n * Enum implementing the adjusters.\n */\nclass Impl extends TemporalAdjuster {\n\n    constructor(ordinal) {\n        super();\n        this._ordinal = ordinal;\n    }\n\n    adjustInto(temporal) {\n        switch (this._ordinal) {\n            case 0: return temporal.with(ChronoField.DAY_OF_MONTH, 1);\n            case 1: return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n            case 2: return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);\n            case 3: return temporal.with(ChronoField.DAY_OF_YEAR, 1);\n            case 4: return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());\n            case 5: return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);\n        }\n        throw new IllegalStateException('Unreachable');\n    }\n\n}\n\n/** First day of month adjuster. */\nImpl.FIRST_DAY_OF_MONTH = new Impl(0);\n/** Last day of month adjuster. */\nImpl.LAST_DAY_OF_MONTH = new Impl(1);\n/** First day of next month adjuster. */\nImpl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);\n/** First day of year adjuster. */\nImpl.FIRST_DAY_OF_YEAR = new Impl(3);\n/** Last day of year adjuster. */\nImpl.LAST_DAY_OF_YEAR = new Impl(4);\n/** First day of next month adjuster. */\nImpl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);\n\n\n/**\n * Class implementing day-of-week in month adjuster.\n */\nclass DayOfWeekInMonth extends TemporalAdjuster {\n\n    constructor(ordinal, dow) {\n        super();\n        this._ordinal = ordinal;\n        this._dowValue = dow.value();\n    }\n    \n    adjustInto(temporal) {\n        if (this._ordinal >= 0) {\n            let temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);\n            let curDow = temp.get(ChronoField.DAY_OF_WEEK);\n            let dowDiff = MathUtil.intMod((this._dowValue - curDow + 7), 7);\n            dowDiff += (this._ordinal - 1) * 7;  // safe from overflow\n            return temp.plus(dowDiff, ChronoUnit.DAYS);\n        } else {\n            let temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n            let curDow = temp.get(ChronoField.DAY_OF_WEEK);\n            let daysDiff = this._dowValue - curDow;\n            daysDiff = (daysDiff === 0 ? 0 : (daysDiff > 0 ? daysDiff - 7 : daysDiff));\n            daysDiff -= (-this._ordinal - 1) * 7;  // safe from overflow\n            return temp.plus(daysDiff, ChronoUnit.DAYS);\n        }\n    }\n}\n\n/**\n * Implementation of next, previous or current day-of-week.\n */\nclass RelativeDayOfWeek extends TemporalAdjuster {\n\n    constructor(relative, dayOfWeek) {\n        super();\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        /** Whether the current date is a valid answer. */\n        this._relative = relative;\n        /** The day-of-week value, from 1 to 7. */\n        this._dowValue = dayOfWeek.value();\n    }\n\n    adjustInto(temporal) {\n        var calDow = temporal.get(ChronoField.DAY_OF_WEEK);\n        if (this._relative < 2 && calDow === this._dowValue) {\n            return temporal;\n        }\n        if ((this._relative & 1) === 0) {\n            let daysDiff = calDow - this._dowValue;\n            return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n        } else {\n            let daysDiff = this._dowValue - calDow;\n            return temporal.minus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n        }\n    }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/TemporalAdjusters.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos  \n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from '../assert';\n\n/**\n * Strategy for adjusting a temporal object.\n * <p>\n * Adjusters are a key tool for modifying temporal objects.\n * They exist to externalize the process of adjustment, permitting different\n * approaches, as per the strategy design pattern.\n * Examples might be an adjuster that sets the date avoiding weekends, or one that\n * sets the date to the last day of the month.\n * <p>\n * There are two equivalent ways of using a {@code TemporalAdjuster}.\n * The first is to invoke the method on this interface directly.\n * The second is to use {@link Temporal#with(TemporalAdjuster)}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   temporal = thisAdjuster.adjustInto(temporal);\n *   temporal = temporal.with(thisAdjuster);\n * </pre>\n * It is recommended to use the second approach, {@code with(TemporalAdjuster)},\n * as it is a lot clearer to read in code.\n * <p>\n * See {@link TemporalAdjusters} for a standard set of adjusters, including finding the\n * last day of the month.\n * Adjusters may also be defined by applications.\n *\n * <h3>Specification for implementors</h3>\n * This interface places no restrictions on the mutability of implementations,\n * however immutability is strongly recommended.\n *\n * @interface\n */\nexport class TemporalAdjuster {\n\n    /**\n     * Adjusts the specified temporal object.\n     * <p>\n     * This adjusts the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     * Examples might be an adjuster that sets the date avoiding weekends, or one that\n     * sets the date to the last day of the month.\n     * <p>\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#with(TemporalAdjuster)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisAdjuster.adjustInto(temporal);\n     *   temporal = temporal.with(thisAdjuster);\n     * </pre>\n     * It is recommended to use the second approach, {@code with(TemporalAdjuster)},\n     * as it is a lot clearer to read in code.\n     *\n     * <h3>Specification for implementors</h3>\n     * The implementation must take the input object and adjust it.\n     * The implementation defines the logic of the adjustment and is responsible for\n     * documenting that logic. It may use any method on {@code Temporal} to\n     * query the temporal object and perform the adjustment.\n     * The returned object must have the same observable type as the input object\n     * <p>\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     * <p>\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by {@link TemporalQueries#chronology() querying the chronology}.\n     * <p>\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal  the temporal object to adjust, not null\n     * @return {Temporal} an object of the same observable type with the adjustment made, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     *\n     * @abstract\n     */\n    adjustInto(temporal){\n        abstractMethodFail('adjustInto');\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/TemporalAdjuster.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {_init as ZoneOffsetInit} from './ZoneOffset';\nimport {_init as DayOfWeekInit} from './DayOfWeek';\nimport {_init as DurationInit} from './Duration';\nimport {_init as InstantInit} from './Instant';\nimport {_init as LocalDateInit} from './LocalDate';\nimport {_init as LocalTimeInit} from './LocalTime';\nimport {_init as LocalDateTimeInit} from './LocalDateTime';\nimport {_init as MonthInit} from './Month';\nimport {_init as PeriodInit} from './Period';\nimport {_init as YearInit} from './Year';\nimport {_init as ZonedDateTimeInit} from './ZonedDateTime';\nimport {_init as IsoChronologyInit} from './chrono/IsoChronology';\nimport {_init as DateTimeFormatterInit} from './format/DateTimeFormatter';\nimport {_init as ChronoFieldInit} from './temporal/ChronoField';\nimport {_init as ChronoUnitInit} from './temporal/ChronoUnit';\nimport {_init as IsoFieldsInit} from './temporal/IsoFields';\n\nimport {_init as TemporalQueriesInit} from './temporal/TemporalQueriesFactory';\nimport {_init as ZoneIdInit} from './ZoneIdFactory';\n\nvar isInit = false;\n\nfunction init() {\n\n    if (isInit) {\n        return;\n    }\n\n    isInit = true;\n\n    YearInit();\n    DurationInit();\n    LocalTimeInit();\n    ChronoUnitInit();\n    ChronoFieldInit();\n    IsoFieldsInit();\n    TemporalQueriesInit();\n    DayOfWeekInit();\n    InstantInit();\n    LocalDateInit();\n    LocalDateTimeInit();\n    MonthInit();\n    PeriodInit();\n    ZoneOffsetInit();\n    ZonedDateTimeInit();\n    ZoneIdInit();\n    IsoChronologyInit();\n    DateTimeFormatterInit();\n}\n\ninit();\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_init.js\n **/","/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {ChronoField} from './ChronoField';\nimport {createTemporalQuery} from './TemporalQuery';\nimport {TemporalQueries} from './TemporalQueries';\n\nimport {LocalDate} from '../LocalDate';\nimport {LocalTime} from '../LocalTime';\nimport {ZoneOffset} from '../ZoneOffset';\n\n\nexport function _init() {\n    //-----------------------------------------------------------------------\n    /**\n     * A strict query for the {@code ZoneId}.\n     */\n    TemporalQueries.ZONE_ID = createTemporalQuery('ZONE_ID', (temporal) => {\n        return temporal.query(TemporalQueries.ZONE_ID);\n    });\n\n    /**\n     * A query for the {@code Chronology}.\n     */\n    TemporalQueries.CHRONO = createTemporalQuery('CHRONO', (temporal) => {\n        return temporal.query(TemporalQueries.CHRONO);\n    });\n\n    /**\n     * A query for the smallest supported unit.\n     */\n    TemporalQueries.PRECISION = createTemporalQuery('PRECISION', (temporal) => {\n        return temporal.query(TemporalQueries.PRECISION);\n    });\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query for {@code ZoneOffset} returning null if not found.\n     */\n    TemporalQueries.OFFSET = createTemporalQuery('OFFSET', (temporal) => {\n        if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {\n            return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));\n        }\n        return null;\n    });\n\n    /**\n     * A lenient query for the {@code ZoneId}, falling back to the {@code ZoneOffset}.\n     */\n    TemporalQueries.ZONE = createTemporalQuery('ZONE', (temporal) => {\n        var zone = temporal.query(TemporalQueries.ZONE_ID);\n        return (zone != null ? zone : temporal.query(TemporalQueries.OFFSET));\n    });\n\n    /**\n     * A query for {@code LocalDate} returning null if not found.\n     */\n    TemporalQueries.LOCAL_DATE = createTemporalQuery('LOCAL_DATE', (temporal) => {\n        if (temporal.isSupported(ChronoField.EPOCH_DAY)) {\n            return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));\n        }\n        return null;\n    });\n\n    /**\n     * A query for {@code LocalTime} returning null if not found.\n     */\n    TemporalQueries.LOCAL_TIME = createTemporalQuery('LOCAL_TIME', (temporal) => {\n        if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {\n            return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));\n        }\n        return null;\n    });\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/temporal/TemporalQueriesFactory.js\n **/"],"sourceRoot":""}