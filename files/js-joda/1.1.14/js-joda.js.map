{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 93f5db3cc5065b8647af","webpack:///./src/js-joda.js","webpack:///./src/Clock.js","webpack:///./src/assert.js","webpack:///./src/errors.js","webpack:///./src/Instant.js","webpack:///./src/LocalTime.js","webpack:///./src/MathUtil.js","webpack:///./src/LocalDateTime.js","webpack:///./src/LocalDate.js","webpack:///./src/chrono/IsoChronology.js","webpack:///./src/Enum.js","webpack:///./src/DayOfWeek.js","webpack:///./src/temporal/ChronoField.js","webpack:///./src/temporal/ChronoUnit.js","webpack:///./src/Duration.js","webpack:///./src/temporal/TemporalAmount.js","webpack:///./src/temporal/TemporalUnit.js","webpack:///./src/YearConstants.js","webpack:///./src/temporal/TemporalField.js","webpack:///./src/temporal/ValueRange.js","webpack:///./src/temporal/Temporal.js","webpack:///./src/temporal/TemporalAccessor.js","webpack:///./src/temporal/TemporalQueries.js","webpack:///./src/temporal/TemporalQuery.js","webpack:///./src/Month.js","webpack:///./src/format/DateTimeFormatterBuilder.js","webpack:///./src/ZoneIdFactory.js","webpack:///./src/StringUtil.js","webpack:///./src/ZoneOffset.js","webpack:///./src/ZoneId.js","webpack:///./src/zone/ZoneRules.js","webpack:///./src/ZoneRegion.js","webpack:///./src/zone/ZoneRulesProvider.js","webpack:///./src/zone/SystemDefaultZoneId.js","webpack:///./src/zone/SystemDefaultZoneRules.js","webpack:///./src/chrono/ChronoLocalDate.js","webpack:///./src/format/DateTimeFormatter.js","webpack:///./src/Period.js","webpack:///./src/format/ParsePosition.js","webpack:///./src/format/DateTimeBuilder.js","webpack:///./src/format/EnumMap.js","webpack:///./src/format/ResolverStyle.js","webpack:///./src/format/DateTimeParseContext.js","webpack:///./src/format/DateTimePrintContext.js","webpack:///./src/format/SignStyle.js","webpack:///./src/format/StringBuilder.js","webpack:///./src/temporal/IsoFields.js","webpack:///./src/format/DecimalStyle.js","webpack:///./src/format/TextStyle.js","webpack:///./src/Year.js","webpack:///./src/MonthDay.js","webpack:///./src/YearMonth.js","webpack:///./src/temporal/TemporalAdjusters.js","webpack:///./src/temporal/TemporalAdjuster.js","webpack:///./src/ZonedDateTime.js","webpack:///./src/chrono/ChronoZonedDateTime.js","webpack:///./src/chrono/ChronoLocalDateTime.js","webpack:///./src/convert.js","webpack:///./src/temporal/NativeJsTemporal.js","webpack:///./src/_init.js","webpack:///./src/temporal/TemporalQueriesFactory.js"],"names":["Clock","DateTimeException","DateTimeParseException","IllegalArgumentException","IllegalStateException","NullPointerException","DayOfWeek","Duration","Instant","LocalDate","LocalTime","LocalDateTime","Month","MonthDay","Period","Year","YearMonth","ZonedDateTime","ZoneOffset","ZoneId","ZoneRegion","ZoneRules","ZoneRulesProvider","convert","nativeJs","ChronoField","ChronoUnit","IsoFields","TemporalAdjusters","TemporalQueries","DateTimeFormatter","DateTimeFormatterBuilder","ResolverStyle","use","used","fn","indexOf","exports","push","systemUTC","SystemClock","UTC","systemDefaultZone","systemDefault","system","zone","fixed","fixedInstant","zoneOffset","FixedClock","millis","instant","_zone","Date","getTime","ofEpochMilli","toString","zoneId","_instant","_zoneId","toEpochMilli","assert","requireNonNull","requireInstance","abstractMethodFail","assertion","msg","error","Error","value","parameterName","_class","name","constructor","methodName","TypeError","createErrorType","init","superErrorClass","E","message","captureStackTrace","stack","apply","arguments","prototype","messageWithCause","messageForDateTimeParseException","UnsupportedTemporalTypeException","ArithmeticException","cause","text","index","parsedString","errorIndex","_init","NANOS_PER_MILLI","now","clock","ofEpochSecond","epochSecond","nanoAdjustment","secs","floorDiv","NANOS_PER_SECOND","nos","floorMod","_create","epochMilli","mos","from","temporal","instantSecs","getLong","INSTANT_SECONDS","nanoOfSecond","get","NANO_OF_SECOND","ex","parse","ISO_INSTANT","FROM","seconds","EPOCH","_validate","MIN_SECONDS","MAX_SECONDS","_seconds","_nanos","isSupported","fieldOrUnit","MICRO_OF_SECOND","MILLI_OF_SECOND","isTimeBased","DAYS","isSupportedBy","range","field","intDiv","getFrom","nano","with","adjusterOrField","newValue","length","withTemporalAdjuster","with2","adjuster","adjustInto","checkValidValue","nval","truncatedTo","unit","NANOS","unitDur","duration","SECONDS_PER_DAY","dur","toNanos","intMod","NANOS_PER_DAY","nod","result","plusNanos","plus","amount","plus1","plus2","addTo","amountToAdd","MICROS","_plus","MILLIS","plusMillis","SECONDS","plusSeconds","MINUTES","safeMultiply","SECONDS_PER_MINUTE","HOURS","SECONDS_PER_HOUR","HALF_DAYS","secondsToAdd","millisToAdd","nanosToAdd","epochSec","minus","minus1","minus2","subtractFrom","amountToSubtract","minusSeconds","secondsToSubtract","minusMillis","millisToSubtract","minusNanos","nanosToSubtract","query","precision","localDate","localTime","chronology","offset","queryFrom","until","endExclusive","end","_nanosUntil","safeSubtract","_secondsUntil","between","secsDiff","totalNanos","safeAdd","nanosDiff","compareTo","otherInstant","cmp","compareNumbers","isAfter","isBefore","equals","hashCode","format","MIN","MAX","clockOrZone","_now","ofInstant","rules","secsOfDay","totalSeconds","ofSecondOfDay","of","hour","minute","second","secondOfDay","SECOND_OF_DAY","hours","minutes","ofNanoOfDay","nanoOfDay","NANO_OF_DAY","NANOS_PER_HOUR","NANOS_PER_MINUTE","time","formatter","ISO_LOCAL_TIME","_hour","_minute","_second","_nano","HOUR_OF_DAY","MINUTE_OF_HOUR","SECOND_OF_MINUTE","_get0","toNanoOfDay","MICRO_OF_DAY","MILLI_OF_DAY","toSecondOfDay","MINUTE_OF_DAY","HOUR_OF_AMPM","CLOCK_HOUR_OF_AMPM","ham","CLOCK_HOUR_OF_DAY","AMPM_OF_DAY","withNano","withSecond","withMinute","plusMinutes","plusHours","withHour","MICROS_PER_DAY","MILLIS_PER_DAY","hoursToAdd","newHour","HOURS_PER_DAY","minutesToAdd","mofd","MINUTES_PER_HOUR","newMofd","MINUTES_PER_DAY","newMinute","secondstoAdd","sofd","newSofd","newSecond","nofd","newNofd","newNano","minusHours","hoursToSubtract","minusMinutes","minutesToSubtract","nanosUntil","atDate","date","total","other","buf","hourValue","minuteValue","secondValue","nanoValue","substring","toJSON","i","makeLocalTimeConst","Object","create","call","MIDNIGHT","NOON","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","MathUtil","x","y","r","roundDown","safeZero","Math","ceil","floor","verifyInt","safeToInt","parseInt","isNaN","a","b","_ofEpochMillis","localSecond","localEpochDay","ofEpochDay","ofDateAndTime","ofNumbers","year","month","dayOfMonth","toLocalDateTime","ISO_LOCAL_DATE_TIME","_date","_time","_withDateTime","newDate","newTime","isDateBased","rangeRefinedBy","monthValue","dayOfYear","dayOfWeek","withYear","withMonth","withDayOfMonth","withDayOfYear","plusTemporalAmount","plusDays","plusYears","years","plusMonths","months","plusWeeks","weeks","days","_plusWithOverflow","nanos","minusTemporalAmount","minusYears","minusMonths","minusWeeks","minusDays","sign","totDays","totNanos","curNoD","newNoD","toLocalDate","daysUntil","timeUntil","endDate","endTime","atZone","toLocalTime","_compareTo0","isEqual","DAYS_PER_CYCLE","DAYS_0000_TO_1970","epochDay","ofYearDay","YEAR","leap","isLeapYear","moy","monthEnd","firstDayOfYear","dom","adjust","adjustCycles","doyEst","marchDoy0","marchMonth0","yearEst","zeroDay","ISO_LOCAL_DATE","_resolvePreviousValid","day","min","_year","_month","_day","MONTH_OF_YEAR","DAY_OF_MONTH","lengthOfMonth","DAY_OF_YEAR","lengthOfYear","ALIGNED_WEEK_OF_MONTH","FEBRUARY","YEAR_OF_ERA","MAX_VALUE","DAY_OF_WEEK","ALIGNED_DAY_OF_WEEK_IN_MONTH","ALIGNED_DAY_OF_WEEK_IN_YEAR","EPOCH_DAY","toEpochDay","ALIGNED_WEEK_OF_YEAR","PROLEPTIC_MONTH","_prolepticMonth","ERA","INSTANCE","dow0","fieldOrAdjuster","withFieldAndValue","f","m","p1","p2","WEEKS","MONTHS","YEARS","DECADES","CENTURIES","MILLENNIA","ERAS","yearsToAdd","newYear","checkValidIntValue","monthsToAdd","monthCount","calcMonths","newMonth","weeksToAdd","daysToAdd","mjDay","yearsToSubtract","monthsToSubtract","weeksToSubtract","daysToSubtract","until1","until2","_monthsUntil","packed1","packed2","totalMonths","calcDate","atTime","atTime1","atTime4","atStartOfDay","atStartOfDayWithZone","ldt","trans","transition","isGap","dateTimeAfter","otherDate","yearValue","dayValue","dayString","monthString","yearString","absYear","abs","slice","MIN_VALUE","EPOCH_0","IsoChronology","prolepticYear","_updateResolveMap","fieldValues","current","put","resolveDate","resolverStyle","containsKey","remove","prolepticMonth","LENIENT","yoeLong","era","STRICT","SMART","isLeap","doy","aw","ad","dow","nextOrSame","Enum","_name","ordinal","_ordinal","values","ENUMS","valueOf","getDisplayName","style","locale","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","SUNDAY","byName","fieldName","prop","hasOwnProperty","baseUnit","rangeUnit","_baseUnit","_rangeUnit","_range","displayName","dateBased","timeBased","FOREVER","OFFSET_SECONDS","estimatedDuration","_duration","isDurationEstimated","e","e2","temporal1","temporal2","ofNanos","ofSeconds","ofDays","ofHours","ofMinutes","ofMillis","ZERO","units","forEach","startInclusive","startNos","adjustedEnd","PATTERN","RegExp","matches","exec","negate","dayMatch","hourMatch","minuteMatch","secondMatch","fractionMatch","daysAsSecs","_parseNumber","hoursAsSecs","minsAsSecs","negativeSecs","charAt","_parseFraction","parsed","multiplier","errorText","parseFloat","_createSecondsNanos","_createNegateDaysHoursMinutesSecondsNanos","negated","isZero","isNegative","withSeconds","withNanos","plusDuration","durationOrNumber","unitOrNumber","plusAmountUnit","plusSecondsNanos","multipliedBy","minusDuration","minusAmountUnit","secsToSubtract","multiplicand","dividedBy","divisor","secsMod","toDays","toHours","toMinutes","toMillis","round","otherDuration","rval","nanoString","TemporalAmount","TemporalUnit","dateTime","periodToAdd","YearConstants","TemporalField","ValueRange","minSmallest","minLargest","maxSmallest","maxLargest","_minSmallest","_minLargest","_maxLargest","_maxSmallest","isFixed","minimum","largestMinimum","maximum","smallestMaximum","isValidValue","isValidIntValue","isIntValue","hash","str","Temporal","TemporalAccessor","ZONE_ID","CHRONO","PRECISION","ZONE","OFFSET","LOCAL_DATE","LOCAL_TIME","createTemporalQuery","TemporalQuery","queryFromFunction","ExtendedTemporalQuery","_value","appendText","toFormatter","newMonthVal","leapYear","APRIL","JUNE","SEPTEMBER","NOVEMBER","minLength","maxLength","JANUARY","MARCH","MAY","JULY","AUGUST","OCTOBER","DECEMBER","firstMonthOfQuarter","MAX_WIDTH","parent","optional","_active","_parent","_printerParsers","_optional","_padNextWidth","_padNextChar","_valueParserIndex","parseCaseSensitive","_appendInternalPrinterParser","SettingsParser","SENSITIVE","parseCaseInsensitive","INSENSITIVE","parseStrict","parseLenient","appendValue","_appendValue1","_appendValue2","_appendValue4","_appendValuePrinterParser","NumberPrinterParser","NORMAL","width","pp","NOT_NEGATIVE","minWidth","maxWidth","signStyle","appendValueReduced","_appendValueReducedFieldWidthMaxWidthBaseDate","_appendValueReducedFieldWidthMaxWidthBaseValue","baseValue","ReducedPrinterParser","baseDate","activeValueParser","basePP","withSubsequentWidth","_appendInternal","withFixedWidth","appendFraction","decimalPoint","FractionPrinterParser","appendInstant","fractionalDigits","InstantPrinterParser","appendOffsetId","OffsetIdPrinterParser","INSTANCE_ID","appendOffset","pattern","noOffsetText","appendZoneId","ZoneIdPrinterParser","appendPattern","_parsePattern","FIELD_MAP","QUARTER_OF_YEAR","pos","cur","start","count","pad","padNext","_parseField","appendZoneText","FULL","SHORT","appendLocalizedOffset","PATTERNS","zero","appendLiteral","replace","optionalStart","optionalEnd","BASE_DATE","EXCEEDS_PAD","NARROW","SHORT_STANDALONE","FULL_STANDALONE","NARROW_STANDALONE","appendInternal","WeekFieldsPrinterParser","_padNext1","_padNext2","padWidth","padChar","cpp","CompositePrinterParser","PadPrinterParserDecorator","literal","CharLiteralPrinterParser","StringLiteralPrinterParser","append","toPrinterParser","STANDARD","EXCEED_POINTS","printerParsers","withOptional","print","context","startOptional","setLength","endOptional","position","printerParser","_printerParser","_padWidth","_padChar","preLen","len","insert","strict","isStrict","caseSensitive","isCaseSensitive","endPos","charEquals","resultPos","setCaseSensitive","setStrict","_literal","subSequenceEquals","converted","ch","subsequentWidth","_field","_minWidth","_maxWidth","_signStyle","_subsequentWidth","_isFixedWidth","getValue","symbols","convertNumberToI18N","positiveSign","ALWAYS","negativeSign","zeroDigit","negative","positive","effMinWidth","minEndPos","effMaxWidth","max","pass","maxEndPos","digit","convertToDigit","parseLen","_setValue","errorPos","successPos","setParsedField","_baseValue","_baseDate","absValue","chrono","getEffectiveChronology","addChronologyChangedParser","lastPart","basePart","isFixedWidth","decimalSeparator","fraction","convertToFraction","outputScale","substr","effectiveMin","effectiveMax","moveLeft","scale","pow","convertFromFraction","_min","_scaled","decimal","SECONDS_PER_10000_YEARS","SECONDS_0000_TO_1970","inSecs","inNanos","inSec","inNano","zeroSecs","hi","lo","div","newContext","copy","minDigits","maxDigits","parser","yearParsed","getParsed","secVal","nanoVal","sec","setParsedLeapSecond","toEpochSecond","type","_checkPattern","offsetSecs","totalSecs","absHours","absMinutes","absSeconds","bufPos","output","appendChar","noOffsetLen","array","arrayIndex","parseText","required","ch1","ch2","charCodeAt","description","getValueQuery","id","nextChar","ofTotalSeconds","setParsedZone","nextNextChar","_parsePrefixedOffset","prefixPos","prefix","toUpperCase","ofOffset","ZoneIdFactory","SYSTEM_DEFAULT_ZONE_ID_INSTANCE","getAvailableZoneIds","startsWith","ofId","obj","SYSTEM","StringUtil","chr","SECONDS_CACHE","ID_CACHE","_validateTotalSeconds","_totalSeconds","_rules","_id","_buildId","absTotalSeconds","offsetId","first","ofHoursMinutesSeconds","precededByColon","ofHoursMinutes","ofTotalMinutes","totalMinutes","normalized","isFixedOffset","Fixed","instantOrLocalDateTime","offsetOfInstant","offsetOfLocalDateTime","offsetOfEpochMilli","localDateTime","validOffsets","standardOffset","daylightSavings","isDaylightSavings","isValidOffset","nextTransition","previousTransition","transitions","transitionRules","_offset","getRules","SystemDefaultZoneId","SystemDefaultZoneRules","offsetInMinutes","getTimezoneOffset","offsetInMinutesBeforePossibleTransition","epochMilliSystemZone","offsetInMinutesAfterPossibleTransition","_throwNotSupported","ChronoLocalDate","parsedExcessDays","PARSED_EXCESS_DAYS","parsedLeapSecond","PARSED_LEAP_SECOND","ofPattern","decimalStyle","resolverFields","_locale","_decimalStyle","_resolverStyle","_resolverFields","_chrono","withChronology","withLocale","_formatTo","appendable","parse1","parse2","_parseToBuilder","resolve","_createError","builder","build","abbr","subString","_parseUnresolved0","getErrorIndex","getIndex","toBuilder","parseUnresolved","setErrorIndex","setIndex","toParsed","ISO_OFFSET_DATE_TIME","ISO_ZONED_DATE_TIME","excessDays","leapSecond","_years","_months","_days","ofYears","ofMonths","ofWeeks","unitAmount","startDate","_parse","yearMatch","monthMatch","weekMatch","val","withYears","withMonths","withDays","scalar","toTotalMonths","splitYears","splitMonths","makeZeroPeriod","ParsePosition","_index","_errorIndex","DateTimeBuilder","dtb","_addFieldValue","getFieldValue0","old","_putFieldValue0","retainAll","_mergeDate","_mergeTime","_resolveTimeInferZeroes","_checkDate","_addObject","keySet","undefined","val1","val2","ap","hap","cod","lod","sod","mod","los","cos","hod","moh","som","hodVal","mohVal","somVal","nosVal","dateOrTime","EnumMap","_map","putAll","otherMap","key","set","keyList","map","keyName","clear","DateTimeParseContext","_constructorSelf","_constructorFormatter","_constructorParam","_caseSensitive","_strict","_parsed","Parsed","_symbols","_overrideChronology","_overrideZone","currentParsed","successful","splice","cs1","offset1","cs2","offset2","toLowerCase","charEqualsIgnoreCase","c1","c2","currentParsedFieldValues","dateTimeParseContext","cloned","overrideZone","DateTimePrintContext","localeOrFormatter","_temporal","setDateTime","SignStyle","fixedWidth","NEVER","StringBuilder","_str","QUARTER_DAYS","Field","_isIso","_getWeekRangeByLocalDate","wby","_getWeekBasedYear","_getWeekRangeByYear","_getWeek","doy0","doyThu0","alignedWeek","firstThuDoy0","firstMonDoy0","week","DAY_OF_QUARTER_FIELD","QUARTER_YEARS","qoy","curValue","partialTemporal","yearLong","qoyLong","doq","DAY_OF_QUARTER","QUARTER_OF_YEAR_FIELD","WEEK_OF_WEEK_BASED_YEAR_FIELD","WEEK_BASED_YEARS","wbyLong","WEEK_BASED_YEAR","dowLong","wowby","WEEK_OF_WEEK_BASED_YEAR","temp","WEEK_BASED_YEAR_FIELD","newWby","resolved","Unit","added","isoWeekOfWeekyear","isoWeekyear","DecimalStyle","zeroChar","positiveSignChar","negativeSignChar","decimalPointChar","_zeroDigit","_zeroDigitCharCode","_positiveSign","_negativeSign","_decimalSeparator","withPositiveSign","withNegativeSign","withZeroDigit","withDecimalSeparator","char","numericText","diff","convertedText","String","fromCharCode","availableLocales","TextStyle","isStandalone","asStandalone","asNormal","zoneIdOrClock","now0","nowZoneId","nowClock","isoYear","parseTextFormatter","PARSER","isSupportedField","isSupportedUnit","adjusterOrFieldOrNumber","withFieldValue","withAdjuster","amountOrNumber","plusAmount","plusAmountToAddUnit","minusAmount","minusAmountToSubtractUnit","isValidMonthDay","monthDay","isValidYear","atDay","atMonth","monthOrNumber","atMonthMonth","atMonthNumber","atMonthDay","atYear","otherYear","number","ofMonthNumber","ofNumberNumber","parseString","parseStringFormatter","ofNumberMonth","_getProlepticMonth","isValidDay","withYearMonth","monthsUntil","atEndOfMonth","firstDayOfMonth","Impl","FIRST_DAY_OF_MONTH","lastDayOfMonth","LAST_DAY_OF_MONTH","firstDayOfNextMonth","FIRST_DAY_OF_NEXT_MONTH","FIRST_DAY_OF_YEAR","lastDayOfYear","LAST_DAY_OF_YEAR","firstDayOfNextYear","FIRST_DAY_OF_NEXT_YEAR","firstInMonth","DayOfWeekInMonth","lastInMonth","dayOfWeekInMonth","next","RelativeDayOfWeek","previous","previousOrSame","_dowValue","curDow","dowDiff","daysDiff","relative","_relative","calDow","TemporalAdjuster","of2","of3","of8","ofLocal","dt","preferredOffset","offsetAfter","some","validOffset","ofInstant2","ofInstant3","ofStrict","ofLenient","zdt","_from","__from","_dateTime","_resolveLocal","newDateTime","_resolveInstant","_resolveOffset","withEarlierOffsetAtOverlap","isOverlap","earlierOffset","offsetBefore","withLaterOffsetAtOverlap","laterOffset","withZoneSameLocal","withZoneSameInstant","withFixedOffsetZone","difference","ChronoZonedDateTime","toInstant","strcmp","thisEpochSec","otherEpochSec","ChronoLocalDateTime","ToNativeJsConverter","zonedDateTime","toDate","NativeJsTemporal","_epochMilli","isInit"],"mappings":"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","file":"js-joda.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JSJoda\"] = factory();\n\telse\n\t\troot[\"JSJoda\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 93f5db3cc5065b8647af","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport { Clock } from './Clock';\nexport {\n    DateTimeException, DateTimeParseException, IllegalArgumentException, IllegalStateException, NullPointerException\n} from './errors';\nexport { DayOfWeek } from './DayOfWeek';\nexport { Duration } from './Duration';\nexport { Instant } from './Instant';\nexport { LocalDate } from './LocalDate';\nexport { LocalTime } from './LocalTime';\nexport { LocalDateTime } from './LocalDateTime';\nexport { Month } from './Month';\nexport { MonthDay } from './MonthDay';\nexport { Period } from './Period';\nexport { Year } from './Year';\nexport { YearMonth } from './YearMonth';\nexport { ZonedDateTime } from './ZonedDateTime';\nexport { ZoneOffset } from './ZoneOffset';\nexport { ZoneId } from './ZoneId';\nexport { ZoneRegion } from './ZoneRegion';\nexport { ZoneRules } from './zone/ZoneRules';\nexport { ZoneRulesProvider } from './zone/ZoneRulesProvider';\n\nexport {convert} from './convert';\n\nexport {nativeJs} from './temporal/NativeJsTemporal';\nexport {ChronoField} from './temporal/ChronoField';\nexport {ChronoUnit} from './temporal/ChronoUnit';\nexport {IsoFields} from './temporal/IsoFields';\nexport {TemporalAdjusters} from './temporal/TemporalAdjusters';\nexport {TemporalQueries} from './temporal/TemporalQueries';\n\nexport {DateTimeFormatter} from './format/DateTimeFormatter';\nexport {DateTimeFormatterBuilder} from './format/DateTimeFormatterBuilder';\nexport {ResolverStyle} from './format/ResolverStyle';\n\nimport './_init';\n\nconst used = [];\n/**\n * use\n *\n * Provides a way to extend the internals of js-joda\n *\n * @param {function} fn - function to extend js-joda public api\n * @returns {this} for chaining\n */\nexport function use(fn) {\n    if (!~used.indexOf(fn)) {\n        fn(exports);\n        used.push(fn);\n    }\n    return exports;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js-joda.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail, requireNonNull} from './assert';\nimport {Instant} from './Instant';\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\n\n/**\n * A clock providing access to the current instant, date and time using a time-zone.\n *\n * Instances of this class are used to find the current instant, which can be\n * interpreted using the stored time-zone to find the current date and time.\n * As such, a clock can be used instead of {@link System#currentTimeMillis}\n * and {@link TimeZone#getDefault}.\n *\n * Use of a {@link Clock} is optional. All key date-time classes also have a\n * `now()` factory method that uses the system clock in the default time zone.\n * The primary purpose of this abstraction is to allow alternate clocks to be\n * plugged in as and when required. Applications use an object to obtain the\n * current time rather than a static method. This can simplify testing.\n *\n * Best practice for applications is to pass a {@link Clock} into any method\n * that requires the current instant.\n *\n * This approach allows an alternate clock, such as {@link fixed}\n * or {@link offset} to be used during testing.\n *\n * The {@link system} factory methods provide clocks based on the best available\n * system clock This may use {@link System#currentTimeMillis}, or a higher\n * resolution clock if one is available.\n *\n * The javascript Clock implementation differs from the openjdk.\n *\n * Javascript only provides the UTC millis of epoch and the ZoneOffset in minutes of the system default time.\n * Javascript do not provide the system default ZoneId.\n *\n * the system default ZoneId is only guessable by the ZoneOffset, like moment-timezone does by returning one ZoneId\n * with the same ZoneOffset.\n *\n * Therefore we are doing a shortcut here, by defining a SystemUTCClock and a SystemDefaultClock, the Clock itself\n * is returning the ZoneOffset and not the ZoneRules as in the jdk. We should change it, when introducing the iana\n * timezone database and implementing the timezone domains.\n *\n */\n\nexport class Clock {\n    /**\n     * Obtains a clock that returns the current instant using the\n     * system clock, converting to date and time using the Date.getTime() UTC millis.\n     *\n     * This clock, rather than {@link systemDefaultZone}, should be used when\n     * you need the current instant without the date or time.\n     *\n     * @return {Clock} a clock that uses the system clock in the UTC zone, not null\n     */\n    static systemUTC() {\n        return new SystemClock(ZoneOffset.UTC);\n    }\n\n    /**\n     * Obtains a clock that returns the current instant using the best available\n     * system clock, converting to date and time using the default time-zone.\n     *\n     * This clock is based on the available system clock using the Date.getTime() UTC millis\n     *\n     * Using this method hard codes a dependency to the default time-zone into your application.\n     *\n     * The UTC clock (see {@link systemUTC}) should be used when you need the current instant\n     * without the date or time.\n     *\n     *\n     * @return {Clock} a clock that uses the system clock in the default zone, not null\n     * @see ZoneId#systemDefault()\n     */\n    static systemDefaultZone() {\n        return new SystemClock(ZoneId.systemDefault());\n    }\n\n    /**\n     *\n     * @param {ZoneId} zone\n     * @return {Clock} a clock that uses the specified time zone\n     */\n    static system(zone){\n        return new SystemClock(zone);\n    }\n\n    /**\n     * Obtains a clock that always returns the same instant.\n     *\n     * This clock simply returns the specified instant.\n     * As such, it is not a clock in the conventional sense.\n     * The main use case for this is in testing, where the fixed clock ensures\n     * tests are not dependent on the current clock.\n     *\n     * @param {Instant} fixedInstant  the instant to use as the clock, not null\n     * @param {ZoneOffset} zoneOffset  the zoneOffset to use as zone Offset, not null\n     * @return {Clock} a clock that always returns the same instant, not null\n     */\n    static fixed(fixedInstant, zoneOffset) {\n        return new FixedClock(fixedInstant, zoneOffset);\n    }\n\n    /**\n      * Gets the current millisecond instant of the clock.\n      *\n      * This returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).\n      * This is equivalent to the definition of {@link Date#getTime}.\n      *\n      * Most applications should avoid this method and use {@link Instant} to represent\n      * an instant on the time-line rather than a raw millisecond value.\n      * This method is provided to allow the use of the clock in high performance use cases\n      * where the creation of an object would be unacceptable.\n      *\n      * The default implementation currently calls {@link instant}.\n      *\n      * @return the current millisecond instant from this clock, measured from\n      *  the Java epoch of 1970-01-01T00:00Z (UTC), not null\n      */\n    millis(){\n        abstractMethodFail('Clock.millis');\n    }\n\n    /**\n     * Gets the current instant of the clock.\n     *\n     * This returns an instant representing the current instant as defined by the clock.\n     *\n     * @return {Instant} the current instant from this clock, not null\n     */\n    instant(){\n        abstractMethodFail('Clock.instant');\n    }\n\n    zone(){\n        abstractMethodFail('Clock.zone');\n    }\n}\n\n/**\n * Implementation of a clock that always returns the latest time from\n * {@link Date#getTime}.\n */\nclass SystemClock extends Clock {\n    /**\n     *\n     * @param {!ZoneId} zone\n     */\n    constructor(zone){\n        requireNonNull(zone, 'zone');\n        super();\n        this._zone = zone;\n    }\n\n    /**\n     *\n     * @returns {!ZoneId}\n     */\n    zone() {\n        return this._zone;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    millis() {\n        return new Date().getTime();\n    }\n\n    /**\n     *\n     * @returns {Instant}\n     */\n    instant() {\n        return Instant.ofEpochMilli(this.millis());\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return 'SystemClock[' + this._zone.toString() + ']';\n    }\n\n}\n\n/**\n * Implementation of a clock that always returns the same instant.\n * This is typically used for testing.\n */\nclass FixedClock extends Clock{\n    constructor(fixedInstant, zoneId) {\n        super();\n        this._instant = fixedInstant;\n        this._zoneId = zoneId;\n    }\n\n    instant() {\n        return this._instant;\n    }\n\n    millis(){\n        return this._instant.toEpochMilli();\n    }\n\n    zone() {\n        return this._zoneId;\n    }\n\n    toString(){\n        return 'FixedClock[]';\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Clock.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport {NullPointerException, IllegalArgumentException} from './errors';\n\nexport function assert(assertion, msg, error) {\n    if(!assertion){\n        if (error) {\n            throw new error(msg);\n        } else {\n            throw new Error(msg);\n        }\n    }\n}\n\nexport function requireNonNull(value, parameterName) {\n    if (value == null) {\n        throw new NullPointerException(parameterName + ' must not be null');\n    }\n    return value;\n}\n\nexport function requireInstance(value, _class, parameterName) {\n    if (!(value instanceof _class)) {\n        throw new IllegalArgumentException(parameterName + ' must be an instance of ' + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ', but is ' + value.constructor.name : ''));\n    }\n    return value;\n}\n\nexport function abstractMethodFail(methodName){\n    throw new TypeError('abstract method \"' + methodName + '\" is not implemented');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/assert.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nfunction createErrorType(name, init, superErrorClass = Error) {\n    function E(message) {\n        if (!Error.captureStackTrace){\n            this.stack = (new Error()).stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        this.message = message;\n        init && init.apply(this, arguments);\n\n    }\n    E.prototype = new superErrorClass();\n    E.prototype.name = name;\n    E.prototype.constructor = E;\n    return E;\n}\n\nexport const DateTimeException = createErrorType('DateTimeException', messageWithCause);\nexport const DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);\nexport const UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);\nexport const ArithmeticException = createErrorType('ArithmeticException');\nexport const IllegalArgumentException = createErrorType('IllegalArgumentException');\nexport const IllegalStateException = createErrorType('IllegalStateException');\nexport const NullPointerException = createErrorType('NullPointerException');\n\nfunction messageWithCause(message, cause = null) {\n    let msg = message || this.name;\n    if (cause !== null && cause instanceof Error) {\n        msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n    }\n    this.message = msg;\n}\n\nfunction messageForDateTimeParseException(message, text = '', index = 0, cause = null) {\n    let msg = message || this.name;\n    msg += ': ' + text + ', at index: ' + index;\n    if (cause !== null && cause instanceof Error) {\n        msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n    }\n    this.message = msg;\n    this.parsedString = () => {\n        return text;\n    };\n    this.errorIndex = () => {\n        return index;\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/errors.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException} from './errors';\n\nimport {Clock} from './Clock';\nimport {LocalTime} from './LocalTime';\nimport {MathUtil} from './MathUtil';\n\nimport {Temporal} from './temporal/Temporal';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {TemporalUnit} from './temporal/TemporalUnit';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\n\nconst NANOS_PER_MILLI = 1000000;\n\n/**\n * An instantaneous point on the time-line.\n *\n * This class models a single instantaneous point on the time-line.\n * This might be used to record event time-stamps in the application.\n *\n * Time-scale\n *\n * The length of the solar day is the standard way that humans measure time.\n * This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,\n * forming a 86400 second day.\n *\n * Modern timekeeping is based on atomic clocks which precisely define an SI second\n * relative to the transitions of a Caesium atom. The length of an SI second was defined\n * to be very close to the 86400th fraction of a day.\n *\n * Unfortunately, as the Earth rotates the length of the day varies.\n * In addition, over time the average length of the day is getting longer as the Earth slows.\n * As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.\n * The actual length of any given day and the amount by which the Earth is slowing\n * are not predictable and can only be determined by measurement.\n * The UT1 time-scale captures the accurate length of day, but is only available some\n * time after the day has completed.\n *\n * The UTC time-scale is a standard approach to bundle up all the additional fractions\n * of a second from UT1 into whole seconds, known as *leap-seconds*.\n * A leap-second may be added or removed depending on the Earth's rotational changes.\n * As such, UTC permits a day to have 86399 SI seconds or 86401 SI seconds where\n * necessary in order to keep the day aligned with the Sun.\n *\n * The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.\n * Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and\n * alterations to the length of the notional second. As of 2012, discussions are underway\n * to change the definition of UTC again, with the potential to remove leap seconds or\n * introduce other changes.\n *\n * Given the complexity of accurate timekeeping described above, this Java API defines\n * its own time-scale, the *Java Time-Scale*.\n *\n * The Java Time-Scale divides each calendar day into exactly 86400\n * subdivisions, known as seconds.  These seconds may differ from the\n * SI second.  It closely matches the de facto international civil time\n * scale, the definition of which changes from time to time.\n *\n * The Java Time-Scale has slightly different definitions for different\n * segments of the time-line, each based on the consensus international\n * time scale that is used as the basis for civil time. Whenever the\n * internationally-agreed time scale is modified or replaced, a new\n * segment of the Java Time-Scale must be defined for it.  Each segment\n * must meet these requirements:\n *\n * * the Java Time-Scale shall closely match the underlying international\n *   civil time scale;\n * * the Java Time-Scale shall exactly match the international civil\n *   time scale at noon each day;\n * * the Java Time-Scale shall have a precisely-defined relationship to\n *   the international civil time scale.\n *\n * There are currently, as of 2013, two segments in the Java time-scale.\n *\n * For the segment from 1972-11-03 (exact boundary discussed below) until\n * further notice, the consensus international time scale is UTC (with\n * leap seconds).  In this segment, the Java Time-Scale is identical to\n * [UTC-SLS](http://www.cl.cam.ac.uk/~mgk25/time/utc-sls/).\n * This is identical to UTC on days that do not have a leap second.\n * On days that do have a leap second, the leap second is spread equally\n * over the last 1000 seconds of the day, maintaining the appearance of\n * exactly 86400 seconds per day.\n *\n * For the segment prior to 1972-11-03, extending back arbitrarily far,\n * the consensus international time scale is defined to be UT1, applied\n * proleptically, which is equivalent to the (mean) solar time on the\n * prime meridian (Greenwich). In this segment, the Java Time-Scale is\n * identical to the consensus international time scale. The exact\n * boundary between the two segments is the instant where UT1 = UTC\n * between 1972-11-03T00:00 and 1972-11-04T12:00.\n *\n * Implementations of the Java time-scale using the JSR-310 API are not\n * required to provide any clock that is sub-second accurate, or that\n * progresses monotonically or smoothly. Implementations are therefore\n * not required to actually perform the UTC-SLS slew or to otherwise be\n * aware of leap seconds. JSR-310 does, however, require that\n * implementations must document the approach they use when defining a\n * clock representing the current instant.\n * See {@link Clock} for details on the available clocks.\n *\n * The Java time-scale is used for all date-time classes.\n * This includes {@link Instant}, {@link LocalDate}, {@link LocalTime}, {@link OffsetDateTime},\n * {@link ZonedDateTime} and {@link Duration}.\n *\n * ### Static properties of Class {@link Instant}\n *\n * Instant.EPOCH\n *\n * Instant.MIN\n *\n * Instant.MAX\n *\n * Instant.MIN_SECONDS\n *\n * Instant.MAX_SECONDS\n *\n */\nexport class Instant extends Temporal {\n\n    /**\n     * Obtains the current instant from the system clock, or if specified\n     * the current instant from the specified clock.\n     *\n     * This will query the specified clock to obtain the current time.\n     *\n     * @param {Clock} [clock=Clock.systemUTC()] - the clock to use, defaults to the system clock\n     * @return {Instant} the current instant, not null\n     */\n    static now(clock = Clock.systemUTC()){\n        return clock.instant();\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * @param {number} epochSecond - the number of seconds from 1970-01-01T00:00:00Z\n     * @param {number} nanoAdjustment nanoseconds start from the start of epochSecond, if null the nanosecond field is set to zero.\n     * @return {Instant} an instant, not null\n     * @throws DateTimeException if the instant exceeds the maximum or minimum instant\n     */\n    static ofEpochSecond(epochSecond, nanoAdjustment=0){\n        const secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        const nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        return Instant._create(secs, nos);\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} using milliseconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * The seconds and nanoseconds are extracted from the specified milliseconds.\n     *\n     * @param {number} epochMilli - the number of milliseconds from 1970-01-01T00:00:00Z\n     * @return {Instant} an instant, not null\n     * @throws DateTimeException if the instant exceeds the maximum or minimum instant\n     */\n    static ofEpochMilli(epochMilli) {\n        const secs = MathUtil.floorDiv(epochMilli, 1000);\n        const mos = MathUtil.floorMod(epochMilli, 1000);\n        return Instant._create(secs, mos * 1000000);\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link Instant}.\n     *\n     * The conversion extracts the {@link ChronoField#INSTANT_SECONDS}\n     * and {@link ChronoField#NANO_OF_SECOND} fields.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link Instant::from}.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {Instant} the instant, not null\n     * @throws DateTimeException if unable to convert to an {@link Instant}\n     */\n    static from(temporal) {\n        try {\n            let instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);\n            let nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n            return Instant.ofEpochSecond(instantSecs, nanoOfSecond);\n        } catch (ex) {\n            throw new DateTimeException('Unable to obtain Instant from TemporalAccessor: ' +\n                    temporal + ', type ' + typeof temporal, ex);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} from a text string such as\n     * `2007-12-03T10:15:30.000Z`.\n     *\n     * The string must represent a valid instant in UTC and is parsed using\n     * {@link DateTimeFormatter#ISO_INSTANT}.\n     *\n     * @param {string} text - the text to parse, not null\n     * @return {Instant} the parsed instant, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parse(text) {\n        return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);\n    }\n\n    /**\n     *\n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @returns {Instant}\n     * @private\n     */\n    static _create(seconds, nanoOfSecond){\n        if(seconds === 0 && nanoOfSecond === 0){\n            return Instant.EPOCH;\n        }\n        return new Instant(seconds, nanoOfSecond);\n    }\n\n    /**\n     *\n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @private\n     */\n    static _validate(seconds, nanoOfSecond){\n        if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {\n            throw new DateTimeException('Instant exceeds minimum or maximum instant');\n        }\n        if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {\n            throw new DateTimeException('Instant exceeds minimum or maximum instant');\n        }\n    }\n\n    /**\n     *\n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @private\n     */\n    constructor(seconds, nanoOfSecond){\n        super();\n        Instant._validate(seconds, nanoOfSecond);\n        this._seconds = seconds;\n        this._nanos = nanoOfSecond;\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this instant can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link NANO_OF_SECOND}\n     * * {@link MICRO_OF_SECOND}\n     * * {@link MILLI_OF_SECOND}\n     * * {@link INSTANT_SECONDS}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this instant, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;\n        }\n        if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This instant is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this instant as an `int`.\n     *\n     * This queries this instant for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time, except {@link INSTANT_SECONDS} which is too\n     * large to fit in an `int` and throws a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this instant as a `long`.\n     *\n     * This queries this instant for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.NANO_OF_SECOND: return this._nanos;\n                case ChronoField.MICRO_OF_SECOND: return MathUtil.intDiv(this._nanos, 1000);\n                case ChronoField.MILLI_OF_SECOND: return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n                case ChronoField.INSTANT_SECONDS: return this._seconds;\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * Gets the number of seconds from the Java epoch of 1970-01-01T00:00:00Z.\n     *\n     * The epoch second count is a simple incrementing count of seconds where\n     * second 0 is 1970-01-01T00:00:00Z.\n     * The nanosecond part of the day is returned by {@link getNanosOfSecond}.\n     *\n     * @return {number} the seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    epochSecond(){\n        return this._seconds;\n    }\n\n    /**\n     * Gets the number of nanoseconds, later along the time-line, from the start\n     * of the second.\n     *\n     * The nanosecond-of-second value measures the total number of nanoseconds from\n     * the second returned by {@link getEpochSecond}.\n     *\n     * @return {number} the nanoseconds within the second, always positive, never exceeds 999,999,999\n     */\n    nano(){\n        return this._nanos;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * function overloading for {@link Instant.with}\n     *\n     * if called with 1 argument {@link Instant.withTemporalAdjuster} is called\n     * otherwise {@link Instant.with2}\n     *\n     * @param {!(TemporalAdjuster|TemporalField)} adjusterOrField\n     * @param {number} newValue\n     * @returns {Instant}\n     */\n    with(adjusterOrField, newValue){\n        if(arguments.length === 1){\n            return this.withTemporalAdjuster(adjusterOrField);\n        } else {\n            return this.with2(adjusterOrField, newValue);\n        }\n    }\n    /**\n     * Returns an adjusted copy of this instant.\n     *\n     * This returns a new {@link Instant}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {Instant} an {@link Instant} based on `this` with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified field set to a new value.\n     *\n     * This returns a new {@link Instant}, based on this one, with the value\n     * for the specified field changed.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link NANO_OF_SECOND} -\n     *  Returns an {@link Instant} with the specified nano-of-second.\n     *  The epoch-second will be unchanged.\n     * * {@link MICRO_OF_SECOND} -\n     *  Returns an {@link Instant} with the nano-of-second replaced by the specified\n     *  micro-of-second multiplied by 1,000. The epoch-second will be unchanged.\n     * * {@link MILLI_OF_SECOND} -\n     *  Returns an {@link Instant} with the nano-of-second replaced by the specified\n     *  milli-of-second multiplied by 1,000,000. The epoch-second will be unchanged.\n     * * {@link INSTANT_SECONDS} -\n     *  Returns an {@link Instant} with the specified epoch-second.\n     *  The nano-of-second will be unchanged.\n     *\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {Instant} an {@link Instant} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.MILLI_OF_SECOND: {\n                    let nval = newValue * NANOS_PER_MILLI;\n                    return (nval !== this._nanos? Instant._create(this._seconds, nval) : this);\n                }\n                case ChronoField.MICRO_OF_SECOND: {\n                    let nval = newValue * 1000;\n                    return (nval !== this._nanos? Instant._create(this._seconds, nval) : this);\n                }\n                case ChronoField.NANO_OF_SECOND: return (newValue !== this._nanos? Instant._create(this._seconds, newValue) : this);\n                case ChronoField.INSTANT_SECONDS: return (newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link Instant} truncated to the specified unit.\n     *\n     * Truncating the instant returns a copy of the original with fields\n     * smaller than the specified unit set to zero.\n     * The fields are calculated on the basis of using a UTC offset as seen\n     * in {@link toString}.\n     * For example, truncating with {@link ChronoUnit#MINUTES} will\n     * round down to the nearest minute, setting the seconds and nanoseconds to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS}. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalUnit} unit - the unit to truncate to, not null\n     * @return {Instant} an {@link Instant} based on this instant with the time truncated, not null\n     * @throws DateTimeException if the unit is invalid for truncation\n     */\n    truncatedTo(unit) {\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.NANOS) {\n            return this;\n        }\n        let unitDur = unit.duration();\n        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n            throw new DateTimeException('Unit is too large to be used for truncation');\n        }\n        let dur = unitDur.toNanos();\n        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n            throw new DateTimeException('Unit must divide into a standard day without remainder');\n        }\n        let nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;\n        let result = MathUtil.intDiv(nod, dur) * dur;\n        return this.plusNanos(result - nod);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {TemporalAmount|number} amount\n     * @param {TemporalUnit} unit - only required if first param is a TemporalAmount\n     * @return {Instant}\n     */\n    plus(amount, unit){\n        if(arguments.length === 1){\n            return this.plus1(amount);\n        } else {\n            return this.plus2(amount, unit);\n        }\n    }\n\n    /**\n     * @param {!TemporalAmount} amount\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    plus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * @param {!number} amountToAdd\n     * @param {!TemporalUnit} unit\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    plus2(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit);\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this._plus(MathUtil.intDiv(amountToAdd, 1000000), MathUtil.intMod(amountToAdd, 1000000) * 1000);\n                case ChronoUnit.MILLIS: return this.plusMillis(amountToAdd);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));\n                case ChronoUnit.HOURS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));\n                case ChronoUnit.HALF_DAYS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));\n                case ChronoUnit.DAYS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in seconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToAdd  the seconds to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified seconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    plusSeconds(secondsToAdd) {\n        return this._plus(secondsToAdd, 0);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in milliseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} millisToAdd - the milliseconds to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified milliseconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMillis(millisToAdd) {\n        return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in nanoseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToAdd - the nanoseconds to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    plusNanos(nanosToAdd) {\n        return this._plus(0, nanosToAdd);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToAdd - the seconds to add, positive or negative\n     * @param {number} nanosToAdd - the nanos to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified seconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    _plus(secondsToAdd, nanosToAdd) {\n        if ((secondsToAdd | nanosToAdd) === 0) {\n            return this;\n        }\n        let epochSec = this._seconds + secondsToAdd;\n        epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n        const nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;\n        return Instant.ofEpochSecond(epochSec, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {TemporalAmount|number} amount\n     * @param {TemporalUnit} unit - only required if first param is a TemporalAmount\n     * @return {Instant}\n     */\n    minus(amount, unit){\n        if(arguments.length === 1){\n            return this.minus1(amount);\n        } else {\n            return this.minus2(amount, unit);\n        }\n    }\n\n    /**\n     * @param {!TemporalAmount} amount\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    minus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * @param {!number} amountToSubtract\n     * @param {!TemporalUnit} unit\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    minus2(amountToSubtract, unit) {\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in seconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToSubtract - the seconds to subtract, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    minusSeconds(secondsToSubtract) {\n        return this.plusSeconds(secondsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in milliseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} millisToSubtract - the milliseconds to subtract, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified milliseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMillis(millisToSubtract) {\n        return this.plusMillis(-1 * millisToSubtract);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in nanoseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToSubtract  the nanoseconds to subtract, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusNanos(nanosToSubtract) {\n        return this.plusNanos(-1 * nanosToSubtract);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Queries this instant using the specified query.\n     *\n     * This queries this instant using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {!TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                query === TemporalQueries.chronology() || query === TemporalQueries.zoneId() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this instant.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the instant changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * twice, passing {@link ChronoField#INSTANT_SECONDS} and\n     * {@link ChronoField#NANO_OF_SECOND} as the fields.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisInstant.adjustInto(temporal);\n     *   temporal = temporal.with(thisInstant);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);\n    }\n\n    /**\n     * Calculates the period between this instant and another instant in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two instants in terms of a single unit.\n     * The start and end points are `this` and the specified instant.\n     * The result will be negative if the end is before the start.\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two instants.\n     * The {@link Temporal} passed to this method is converted to a\n     * {@link Instant} using {@link from}.\n     * For example, the period in days between two dates can be calculated\n     * using `startInstant.until(endInstant, SECONDS)`.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, SECONDS);   // this method\n     *   dateTime.plus(SECONDS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n     * {@link MINUTES}, {@link HOURS}, {@link HALF_DAYS} and {@link DAYS}\n     * are supported. Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive - the end date, which is converted to an {@link Instant}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date and the end date\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        let end = Instant.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this._nanosUntil(end);\n                case ChronoUnit.MICROS: return MathUtil.intDiv(this._nanosUntil(end), 1000);\n                case ChronoUnit.MILLIS: return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());\n                case ChronoUnit.SECONDS: return this._secondsUntil(end);\n                case ChronoUnit.MINUTES: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);\n                case ChronoUnit.HOURS: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS: return MathUtil.intDiv(this._secondsUntil(end), (12 * LocalTime.SECONDS_PER_HOUR));\n                case ChronoUnit.DAYS: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     *\n     * @param {Temporal} end\n     * @returns {number}\n     * @private\n     */\n    _nanosUntil(end) {\n        let secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        let totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);\n        return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());\n    }\n\n    /**\n     *\n     * @param {Temporal} end\n     * @returns {number}\n     * @private\n     */\n    _secondsUntil(end) {\n        let secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        let nanosDiff = end.nano() - this.nano();\n        if (secsDiff > 0 && nanosDiff < 0) {\n            secsDiff--;\n        } else if (secsDiff < 0 && nanosDiff > 0) {\n            secsDiff++;\n        }\n        return secsDiff;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this instant with an offset to create an {@link OffsetDateTime}.\n     *\n     * This returns an {@link OffsetDateTime} formed from this instant at the\n     * specified offset from UTC/Greenwich. An exception will be thrown if the\n     * instant is too large to fit into an offset date-time.\n     *\n     * This method is equivalent to {@link OffsetDateTime#ofInstant}.\n     *\n     * @param {ZoneOffset} offset - the offset to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this instant and the specified offset, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    //atOffset(offset) {\n    //    return OffsetDateTime.ofInstant(this, offset);\n    //}\n\n    /**\n     * Combines this instant with a time-zone to create a {@link ZonedDateTime}.\n     *\n     * This returns an {@link ZonedDateTime} formed from this instant at the\n     * specified time-zone. An exception will be thrown if the instant is too\n     * large to fit into a zoned date-time.\n     *\n     * This method is equivalent to {@link ZonedDateTime#ofInstant}.\n     *\n     * @param {ZoneId} zone - the zone to combine with, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this instant and the specified zone, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    //atZone(zone) {\n    //    return ZonedDateTime.ofInstant(this, zone);\n    //}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this instant to the number of milliseconds from the epoch\n     * of 1970-01-01T00:00:00Z.\n     *\n     * If this instant represents a point on the time-line too far in the future\n     * or past to fit in a `long` milliseconds, then an exception is thrown.\n     *\n     * If this instant has greater than millisecond precision, then the conversion\n     * will drop any excess precision information as though the amount in nanoseconds\n     * was subject to integer division by one million.\n     *\n     * @return {number} the number of milliseconds since the epoch of 1970-01-01T00:00:00Z\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toEpochMilli() {\n        const millis = MathUtil.safeMultiply(this._seconds, 1000);\n        return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this instant to the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     * @throws NullPointerException if otherInstant is null\n     */\n    compareTo(otherInstant) {\n        requireNonNull(otherInstant, 'otherInstant');\n        requireInstance(otherInstant, Instant, 'otherInstant');\n        const cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return this._nanos - otherInstant._nanos;\n    }\n\n    /**\n     * Checks if this instant is after the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {boolean} true if this instant is after the specified instant\n     * @throws NullPointerException if otherInstant is null\n     */\n    isAfter(otherInstant) {\n        return this.compareTo(otherInstant) > 0;\n    }\n\n    /**\n     * Checks if this instant is before the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {boolean} true if this instant is before the specified instant\n     * @throws NullPointerException if otherInstant is null\n     */\n    isBefore(otherInstant) {\n        return this.compareTo(otherInstant) < 0;\n    }\n\n    /**\n     * Checks if this instant is equal to the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {*} otherInstant - the other instant, null/ undefined returns false\n     * @return {boolean} true if the other instant is equal to this one\n     */\n    equals(otherInstant) {\n        if(this === otherInstant){\n            return true;\n        }\n        if(otherInstant instanceof Instant){\n            return this.epochSecond() === otherInstant.epochSecond() &&\n                this.nano() === otherInstant.nano();\n        }\n        return false;\n    }\n\n    /**\n     * Returns a hash code for this instant.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return ((this._seconds ^ (this._seconds >>> 24))) + 51 * this._nanos;\n    }\n\n    /**\n     * A string representation of this instant using ISO-8601 representation.\n     *\n     * The format used is the same as {@link DateTimeFormatter#ISO_INSTANT}.\n     *\n     * @return {string} an ISO-8601 representation of this instant, not null\n     */\n    toString(){\n        return DateTimeFormatter.ISO_INSTANT.format(this);\n    }\n}\n\nexport function _init() {\n    Instant.MIN_SECONDS = -31619119219200; // -1000000-01-01T00:00:00Z\n    Instant.MAX_SECONDS = 31494816403199; // +1000000-12-31T23:59:59.999999999Z\n    Instant.EPOCH = new Instant(0, 0);\n    Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);\n    Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);\n    Instant.FROM = createTemporalQuery('Instant.FROM', (temporal) => {\n        return Instant.from(temporal);\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Instant.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n\nimport {MathUtil} from './MathUtil';\nimport {assert, requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException, IllegalArgumentException} from './errors';\n\nimport {Clock} from './Clock';\nimport {LocalDateTime} from './LocalDateTime';\nimport {ZoneId} from './ZoneId';\n\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalField} from './temporal/TemporalField';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\n\n/**\n * A time without time-zone in the ISO-8601 calendar system,\n * such as `10:15:30`.\n *\n * {@link LocalTime} is an immutable date-time object that represents a time,\n * often viewed as hour-minute-second.\n * Time is represented to nanosecond precision.\n * For example, the value '13:45.30.123456789' can be stored in a {@link LocalTime}.\n *\n * It does not store or represent a date or time-zone.\n * Instead, it is a description of the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. This API assumes that all calendar systems use the same\n * representation, this class, for time-of-day.\n *\n * ### Static properties of Class {@link LocalTime}\n *\n * LocalTime.MIN\n *\n * The minimum supported {@link LocalTime}, '00:00'.\n * This is the time of midnight at the start of the day.\n *\n * LocalTime.MAX\n *\n * The maximum supported {@link LocalTime}, '23:59:59.999999999'.\n * This is the time just before midnight at the end of the day.\n *\n * LocalTime.MIDNIGHT\n *\n * The time of midnight at the start of the day, '00:00'.\n *\n * LocalTime.NOON\n *\n * The time of noon in the middle of the day, '12:00'.\n *\n * LocalTime.HOURS_PER_DAY\n *\n * Hours per day.\n *\n * LocalTime.MINUTES_PER_HOUR\n *\n * Minutes per hour.\n *\n * LocalTime.MINUTES_PER_DAY\n *\n * Minutes per day.\n *\n * LocalTime.SECONDS_PER_MINUTE\n *\n * Seconds per minute.\n *\n * LocalTime.SECONDS_PER_HOUR\n *\n * Seconds per hour.\n *\n * LocalTime.SECONDS_PER_DAY\n *\n * Seconds per day.\n *\n * LocalTime.MILLIS_PER_DAY\n *\n * Milliseconds per day.\n *\n * LocalTime.MICROS_PER_DAY\n *\n * Microseconds per day.\n *\n * LocalTime.NANOS_PER_SECOND\n *\n * Nanos per second.\n *\n * LocalTime.NANOS_PER_MINUTE\n *\n * Nanos per minute.\n *\n * LocalTime.NANOS_PER_HOUR\n *\n * Nanos per hour.\n *\n * LocalTime.NANOS_PER_DAY\n *\n * Nanos per day.\n *\n */\nexport class LocalTime extends Temporal /** implements Temporal, TemporalAdjuster */ {\n    /**\n     * Obtains the current time from the specified clock.\n     * If no argument is specified the system default clock is queried,\n     * if a zone-id is passed a system clock with the specified zone is queried.\n     *\n     * This will query the specified clock to obtain the current time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock|ZoneId} clockOrZone - the zone ID or clock to use, if null Clock.systemDefaultZone() is used.\n     * @return {LocalDateTime} the current time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        if (clockOrZone == null){\n            return LocalTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock){\n            return LocalTime._now(clockOrZone);\n        } else {\n            return LocalTime._now(Clock.system(clockOrZone));\n        }\n    }\n\n    /**\n     * Obtains the current time from the specified clock.\n     *\n     * This will query the specified clock to obtain the current time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection (see {@link Clock}).\n     *\n     * @param {Clock} [clock=Clock.systemDefaultZone()] - the clock to use, not null\n     * @return {LocalTime} the current time, not null\n     */\n    static _now(clock = Clock.systemDefaultZone()) {\n        requireNonNull(clock, 'clock');// inline OffsetTime factory to avoid creating object and InstantProvider checks\n        return LocalTime.ofInstant(clock.instant(), clock.zone());\n    }\n\n    /**\n     * obtain a LocalTime from an Instant in the specified time-zone or, if null\n     * in the system default time-zone\n     *\n     * @param {!Instant} instant\n     * @param {ZoneId} [zone=ZoneId.systemDefault()], defaults to ZoneId.systemDefault()\n     * @returns {LocalTime} the current date, not null\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()){\n        const offset = zone.rules().offset(instant);\n        let secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);\n        secsOfDay = MathUtil.intMod((secsOfDay + offset.totalSeconds()), LocalTime.SECONDS_PER_DAY);\n        if (secsOfDay < 0) {\n            secsOfDay += LocalTime.SECONDS_PER_DAY;\n        }\n        return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from an hour, minute, second and nanosecond.\n     *\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [hour=0] - the hour-of-day to represent, from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     */\n    static of(hour, minute, second, nanoOfSecond) {\n        return new LocalTime(hour, minute, second, nanoOfSecond);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from a second-of-day value, with\n     * associated nanos of second.\n     *\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [secondOfDay=0] - the second-of-day, from `0` to `24 * 60 * 60 - 1`\n     * @param {number} [nanoOfSecond=0] - the nano-of-second, from `0` to `999,999,999`\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the either input value is invalid\n     */\n    static ofSecondOfDay(secondOfDay=0, nanoOfSecond=0) {\n        ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);\n        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        const hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);\n        secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;\n        const minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);\n        secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;\n        return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from a nanos-of-day value.\n     *\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [nanoOfDay=0] - the nano of day, from `0` to `24 * 60 * 60 * 1,000,000,000 - 1`\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the nanos of day value is invalid\n     */\n    static ofNanoOfDay(nanoOfDay=0) {\n        ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);\n        const hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);\n        nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;\n        const minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);\n        nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;\n        const seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);\n        nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;\n        return new LocalTime(hours, minutes, seconds, nanoOfDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalTime} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalTime}.\n     *\n     * The conversion uses the {@link TemporalQueries#localTime} query, which relies\n     * on extracting {@link ChronoField#NANO_OF_DAY}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link LocalTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        const time = temporal.query(TemporalQueries.localTime());\n        if (time == null) {\n            throw new DateTimeException(`Unable to obtain LocalTime TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n        return time;\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a time.\n     *\n     * @param {!String} text - the text to parse, not null\n     * @param {!String} formatter - the formatter to use, not null\n     * @return {LocalTime} the parsed local time, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter=DateTimeFormatter.ISO_LOCAL_TIME) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, LocalTime.FROM);\n    }\n\n    /**\n     * Constructor, previously validated.\n     *\n     * @param {number} [hour=0] - the hour-of-day to represent, validated from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, validated from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, validated from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, validated from 0 to 999,999,999\n     */\n    constructor(hour=0, minute=0, second=0, nanoOfSecond=0) {\n        super();\n        LocalTime._validate(hour, minute, second, nanoOfSecond);\n        if ((minute | second | nanoOfSecond) === 0) {\n            return LocalTime.HOURS[hour];\n        }\n        this._hour = hour;\n        this._minute = minute;\n        this._second = second;\n        this._nano = nanoOfSecond;\n    }\n\n    static _validate(hour, minute, second, nanoOfSecond){\n        ChronoField.HOUR_OF_DAY.checkValidValue(hour);\n        ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);\n        ChronoField.SECOND_OF_MINUTE.checkValidValue(second);\n        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this time can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link ChronoField.NANO_OF_SECOND}\n     * * {@link ChronoField.NANO_OF_DAY}\n     * * {@link ChronoField.MICRO_OF_SECOND}\n     * * {@link ChronoField.MICRO_OF_DAY}\n     * * {@link ChronoField.MILLI_OF_SECOND}\n     * * {@link ChronoField.MILLI_OF_DAY}\n     * * {@link ChronoField.SECOND_OF_MINUTE}\n     * * {@link ChronoField.SECOND_OF_DAY}\n     * * {@link ChronoField.MINUTE_OF_HOUR}\n     * * {@link ChronoField.MINUTE_OF_DAY}\n     * * {@link ChronoField.HOUR_OF_AMPM}\n     * * {@link ChronoField.CLOCK_HOUR_OF_AMPM}\n     * * {@link ChronoField.HOUR_OF_DAY}\n     * * {@link ChronoField.CLOCK_HOUR_OF_DAY}\n     * * {@link ChronoField.AMPM_OF_DAY}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing this as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {ChronoField|ChronoUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isTimeBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing this as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {ChronoField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        requireNonNull(field);\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this time as an `int`.\n     *\n     * This queries this time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this time, except {@link ChronoField.NANO_OF_DAY} and {@link ChronoField.MICRO_OF_DAY}\n     * which are too large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {ChronoField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this time as a `long`.\n     *\n     * This queries this time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.from}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {ChronoField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            return this._get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     *\n     * @param {ChronoField} field\n     * @returns {number}\n     * @private\n     */\n    _get0(field) {\n        switch (field) {\n            case ChronoField.NANO_OF_SECOND: return this._nano;\n            case ChronoField.NANO_OF_DAY: return this.toNanoOfDay();\n            case ChronoField.MICRO_OF_SECOND: return MathUtil.intDiv(this._nano, 1000);\n            case ChronoField.MICRO_OF_DAY: return MathUtil.intDiv(this.toNanoOfDay(), 1000);\n            case ChronoField.MILLI_OF_SECOND: return MathUtil.intDiv(this._nano, 1000000);\n            case ChronoField.MILLI_OF_DAY: return MathUtil.intDiv(this.toNanoOfDay(), 1000000);\n            case ChronoField.SECOND_OF_MINUTE: return this._second;\n            case ChronoField.SECOND_OF_DAY: return this.toSecondOfDay();\n            case ChronoField.MINUTE_OF_HOUR: return this._minute;\n            case ChronoField.MINUTE_OF_DAY: return this._hour * 60 + this._minute;\n            case ChronoField.HOUR_OF_AMPM: return MathUtil.intMod(this._hour, 12);\n            case ChronoField.CLOCK_HOUR_OF_AMPM: {\n                const ham = MathUtil.intMod(this._hour, 12); \n                return (ham % 12 === 0 ? 12 : ham);\n            }\n            case ChronoField.HOUR_OF_DAY: return this._hour;\n            case ChronoField.CLOCK_HOUR_OF_DAY: return (this._hour === 0 ? 24 : this._hour);\n            case ChronoField.AMPM_OF_DAY: return MathUtil.intDiv(this._hour, 12);\n        }\n        throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._hour;\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._minute;\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._second;\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._nano;\n    }\n\n    /**\n     * function overloading for {@link LocalDate.with}\n     *\n     * if called with 1 (or less) arguments {@link LocalTime.withTemporalAdjuster} is called.\n     * Otherwise {@link LocalTime.with2} is called.\n     *\n     * @param {!(TemporalAdjuster|ChronoField)} adjusterOrField\n     * @param {number} newValue - only required if called with 2 arguments\n     * @return {LocalTime}\n     */\n    with(adjusterOrField, newValue){\n        if(arguments.length < 2){\n            return this.withTemporalAdjuster(adjusterOrField);\n        } else {\n            return this.with2(adjusterOrField, newValue);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this time.\n     *\n     * This returns a new {@link LocalTime}, based on this one, with the time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the hour field.\n     * A more complex adjuster might set the time to the last hour of the day.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster.adjustInto} method on the\n     * specified adjuster passing this as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {LocalTime} a {@link LocalTime} based on this with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalTime) {\n            return adjuster;\n        }\n        assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this time with the specified field set to a new value.\n     *\n     * This returns a new {@link LocalTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the hour, minute or second.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link ChronoField.NANO_OF_SECOND} -\n     *   Returns a {@link LocalTime} with the specified nano-of-second.\n     *  The hour, minute and second will be unchanged.\n     * * {@link ChronoField.NANO_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified nano-of-day.\n     *   This completely replaces the time and is equivalent to {@link ofNanoOfDay}.\n     * * {@link ChronoField.MICRO_OF_SECOND} -\n     *   Returns a {@link LocalTime} with the nano-of-second replaced by the specified\n     *   micro-of-second multiplied by 1,000.\n     *   The hour, minute and second will be unchanged.\n     * * {@link ChronoField.MICRO_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified micro-of-day.\n     *   This completely replaces the time and is equivalent to using {@link ofNanoOfDay}\n     *   with the micro-of-day multiplied by 1,000.\n     * * {@link ChronoField.MILLI_OF_SECOND} -\n     *   Returns a {@link LocalTime} with the nano-of-second replaced by the specified\n     *   milli-of-second multiplied by 1,000,000.\n     *   The hour, minute and second will be unchanged.\n     * * {@link ChronoField.MILLI_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified milli-of-day.\n     *   This completely replaces the time and is equivalent to using {@link ofNanoOfDay}\n     *   with the milli-of-day multiplied by 1,000,000.\n     * * {@link ChronoField.SECOND_OF_MINUTE} -\n     *   Returns a {@link LocalTime} with the specified second-of-minute.\n     *   The hour, minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.SECOND_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified second-of-day.\n     *   The nano-of-second will be unchanged.\n     * * {@link ChronoField.MINUTE_OF_HOUR} -\n     *   Returns a {@link LocalTime} with the specified minute-of-hour.\n     *   The hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.MINUTE_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified minute-of-day.\n     *   The second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.HOUR_OF_AMPM} -\n     *   Returns a {@link LocalTime} with the specified hour-of-am-pm.\n     *   The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.CLOCK_HOUR_OF_AMPM} -\n     *   Returns a {@link LocalTime} with the specified clock-hour-of-am-pm.\n     *   The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.HOUR_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified hour-of-day.\n     *   The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.CLOCK_HOUR_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified clock-hour-of-day.\n     *   The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.AMPM_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified AM/PM.\n     *   The hour-of-am-pm, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing this as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalTime} a {@link LocalTime} based on this with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.NANO_OF_SECOND: return this.withNano(newValue);\n                case ChronoField.NANO_OF_DAY: return LocalTime.ofNanoOfDay(newValue);\n                case ChronoField.MICRO_OF_SECOND: return this.withNano(newValue * 1000);\n                case ChronoField.MICRO_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000);\n                case ChronoField.MILLI_OF_SECOND: return this.withNano( newValue * 1000000);\n                case ChronoField.MILLI_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000000);\n                case ChronoField.SECOND_OF_MINUTE: return this.withSecond(newValue);\n                case ChronoField.SECOND_OF_DAY: return this.plusSeconds(newValue - this.toSecondOfDay());\n                case ChronoField.MINUTE_OF_HOUR: return this.withMinute(newValue);\n                case ChronoField.MINUTE_OF_DAY: return this.plusMinutes(newValue - (this._hour * 60 + this._minute));\n                case ChronoField.HOUR_OF_AMPM: return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));\n                case ChronoField.CLOCK_HOUR_OF_AMPM: return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));\n                case ChronoField.HOUR_OF_DAY: return this.withHour(newValue);\n                case ChronoField.CLOCK_HOUR_OF_DAY: return this.withHour((newValue === 24 ? 0 : newValue));\n                case ChronoField.AMPM_OF_DAY: return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the hour-of-day value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [hour=0] - the hour-of-day to set in the result, from 0 to 23\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested hour, not null\n     * @throws {DateTimeException} if the hour value is invalid\n     */\n    withHour(hour=0) {\n        if (this._hour === hour) {\n            return this;\n        }\n        return new LocalTime(hour, this._minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the minute-of-hour value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [minute=0] - the minute-of-hour to set in the result, from 0 to 59\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested minute, not null\n     * @throws {DateTimeException} if the minute value is invalid\n     */\n    withMinute(minute=0) {\n        if (this._minute === minute) {\n            return this;\n        }\n        return new LocalTime(this._hour, minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the second-of-minute value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [second=0] - the second-of-minute to set in the result, from 0 to 59\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested second, not null\n     * @throws {DateTimeException} if the second value is invalid\n     */\n    withSecond(second=0) {\n        if (this._second === second) {\n            return this;\n        }\n        return new LocalTime(this._hour, this._minute, second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the nano-of-second value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested nanosecond, not null\n     * @throws {DateTimeException} if the nanos value is invalid\n     */\n    withNano(nanoOfSecond=0) {\n        if (this._nano === nanoOfSecond) {\n            return this;\n        }\n        return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the time truncated.\n     *\n     * Truncating the time returns a copy of the original time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit.MINUTES} minutes unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit.DAYS}. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!ChronoUnit} unit - the unit to truncate to, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the time truncated, not null\n     * @throws {DateTimeException} if unable to truncate\n     */\n    truncatedTo(unit) {\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.NANOS) {\n            return this;\n        }\n        const unitDur = unit.duration();\n        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n            throw new DateTimeException('Unit is too large to be used for truncation');\n        }\n        const dur = unitDur.toNanos();\n        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n            throw new DateTimeException('Unit must divide into a standard day without remainder');\n        }\n        const nod = this.toNanoOfDay();\n        return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * function overloading for {@link LocalDate.plus}\n     *\n     * if called with 1 (or less) arguments {@link LocalTime.plus1} is called.\n     * Otherwise {@link LocalTime.plus2} is called.\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {ChronoUnit} unit - only required if called with 2 arguments\n     * @return {LocalTime}\n     */\n    plus(amount, unit){\n        if(arguments.length < 2){\n            return this.plus1(amount);\n        } else {\n            return this.plus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this date with the specified period added.\n     *\n     * This method returns a new time based on this time with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link plus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to add, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the addition made, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    plus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this time with the specified period added.\n     *\n     * This method returns a new time based on this time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add hours, minutes or seconds.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to add, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n                case ChronoUnit.MILLIS: return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusMinutes(amountToAdd);\n                case ChronoUnit.HOURS: return this.plusHours(amountToAdd);\n                case ChronoUnit.HALF_DAYS: return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in hours added.\n     *\n     * This adds the specified number of hours to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hoursToAdd - the hours to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the hours added, not null\n     */\n    plusHours(hoursToAdd) {\n        if (hoursToAdd === 0) {\n            return this;\n        }\n\n        const newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);\n        return new LocalTime(newHour, this._minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in minutes added.\n     *\n     * This adds the specified number of minutes to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutesToAdd - the minutes to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the minutes added, not null\n     */\n    plusMinutes(minutesToAdd) {\n        if (minutesToAdd === 0) {\n            return this;\n        }\n        const mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;\n        const newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);\n        if (mofd === newMofd) {\n            return this;\n        }\n        const newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);\n        const newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);\n        return new LocalTime(newHour, newMinute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in seconds added.\n     *\n     * This adds the specified number of seconds to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondstoAdd - the seconds to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the seconds added, not null\n     */\n    plusSeconds(secondstoAdd) {\n        if (secondstoAdd === 0) {\n            return this;\n        }\n        const sofd = this._hour * LocalTime.SECONDS_PER_HOUR +\n                    this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;\n        const newSofd = MathUtil.intMod((MathUtil.intMod(secondstoAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY), LocalTime.SECONDS_PER_DAY);\n        if (sofd === newSofd) {\n            return this;\n        }\n        const newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);\n        const newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n        const newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);\n        return new LocalTime(newHour, newMinute, newSecond, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in nanoseconds added.\n     *\n     * This adds the specified number of nanoseconds to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToAdd - the nanos to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the nanoseconds added, not null\n     */\n    plusNanos(nanosToAdd) {\n        if (nanosToAdd === 0) {\n            return this;\n        }\n        const nofd = this.toNanoOfDay();\n        const newNofd = MathUtil.intMod((MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY), LocalTime.NANOS_PER_DAY);\n        if (nofd === newNofd) {\n            return this;\n        }\n        const newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);\n        const newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n        const newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);\n        const newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);\n        return new LocalTime(newHour, newMinute, newSecond, newNano);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDate.minus}\n     *\n     * if called with 1 (or less) arguments {@link LocalTime.minus1} is called.\n     * Otherwise {@link LocalTime.minus2} is called.\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {ChronoUnit} unit - only required if called with 2 arguments\n     * @return {LocalTime}\n     */\n    minus(amount, unit){\n        if(arguments.length < 2){\n            return this.minus1(amount);\n        } else {\n            return this.minus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this time with the specified period subtracted.\n     *\n     * This method returns a new time based on this time with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to subtract, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the subtraction made, not null\n     * @throws {DateTimeException} if the subtraction cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n\n    minus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this time with the specified period subtracted.\n     *\n     * This method returns a new time based on this time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract hours, minutes or seconds.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {ChronoUnit} unit - the unit of the period to subtract, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        requireNonNull(unit, 'unit');\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in hours subtracted.\n     *\n     * This subtracts the specified number of hours from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hoursToSubtract - the hours to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the hours subtracted, not null\n     */\n    minusHours(hoursToSubtract) {\n        return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in minutes subtracted.\n     *\n     * This subtracts the specified number of minutes from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutesToSubtract - the minutes to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the minutes subtracted, not null\n     */\n    minusMinutes(minutesToSubtract) {\n        return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in seconds subtracted.\n     *\n     * This subtracts the specified number of seconds from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToSubtract - the seconds to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the seconds subtracted, not null\n     */\n    minusSeconds(secondsToSubtract) {\n        return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in nanoseconds subtracted.\n     *\n     * This subtracts the specified number of nanoseconds from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToSubtract - the nanos to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the nanoseconds subtracted, not null\n     */\n    minusNanos(nanosToSubtract) {\n        return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this time using the specified query.\n     *\n     * This queries this time using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing this as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.localTime()) {\n            return this;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        if (query === TemporalQueries.chronology() || query === TemporalQueries.zoneId() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.offset() ||\n                query === TemporalQueries.localDate()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same time as this object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the time changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal.with}\n     * passing {@link ChronoField.NANO_OF_DAY} as the field.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal.with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalTime.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalTime);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());\n    }\n\n    /**\n     * Calculates the period between this time and another time in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two times in terms of a single unit.\n     * The start and end points are this and the specified time.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalTime}.\n     * For example, the period in hours between two times can be calculated\n     * using {@link startTime.until}.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two times.\n     * For example, the period in hours between 11:30 and 13:29 will only\n     * be one hour as it is one minute short of two hours.\n     *\n     * This method operates in association with {@link TemporalUnit.between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, HOURS);   // this method\n     *   dateTime.plus(HOURS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link ChronoUnit.NANOS}, {@link ChronoUnit.MICROS}, {@link ChronoUnit.MILLIS}, {@link ChronoUnit.SECONDS},\n     * {@link ChronoUnit.MINUTES}, {@link ChronoUnit.HOURS} and {@link ChronoUnit.HALF_DAYS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing this as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAccessor} endExclusive - the end time, which is converted to a {@link LocalTime}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this time and the end time\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        const end = LocalTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            const nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();  // no overflow\n            switch (unit) {\n                case ChronoUnit.NANOS: return nanosUntil;\n                case ChronoUnit.MICROS: return MathUtil.intDiv(nanosUntil, 1000);\n                case ChronoUnit.MILLIS: return MathUtil.intDiv(nanosUntil, 1000000);\n                case ChronoUnit.SECONDS: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);\n                case ChronoUnit.MINUTES: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);\n                case ChronoUnit.HOURS: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS: return MathUtil.intDiv(nanosUntil, (12 * LocalTime.NANOS_PER_HOUR));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this time with a date to create a {@link LocalDateTime}.\n     *\n     * This returns a {@link LocalDateTime} formed from this time at the specified date.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {LocalDate} date - the date to combine with, not null\n     * @return {LocalDateTime} the local date-time formed from this time and the specified date, not null\n     */\n    atDate(date) {\n        return LocalDateTime.of(date, this);\n    }\n\n    /**\n     * Combines this time with an offset to create an {@link OffsetTime}.\n     *\n     * This returns an {@link OffsetTime} formed from this time at the specified offset.\n     * All possible combinations of time and offset are valid.\n     *\n     * @param {OffsetTime} offset - the offset to combine with, not null\n     * @return {OffsetTime} the offset time formed from this time and the specified offset, not null\n     */\n/*\n    atOffset(offset) {\n        return OffsetTime.of(this, offset);\n    }\n*/\n\n    //-----------------------------------------------------------------------\n    /**\n     * Extracts the time as seconds of day, from `0` to `24 * 60 * 60 - 1`.\n     *\n     * @return {number} the second-of-day equivalent to this time\n     */\n    toSecondOfDay() {\n        let total = this._hour * LocalTime.SECONDS_PER_HOUR;\n        total += this._minute * LocalTime.SECONDS_PER_MINUTE;\n        total += this._second;\n        return total;\n    }\n\n    /**\n     * Extracts the time as nanos of day, from `0` to `24 * 60 * 60 * 1,000,000,000 - 1`.\n     *\n     * @return {number} the nano of day equivalent to this time\n     */\n    toNanoOfDay() {\n        let total = this._hour * LocalTime.NANOS_PER_HOUR;\n        total += this._minute * LocalTime.NANOS_PER_MINUTE;\n        total += this._second * LocalTime.NANOS_PER_SECOND;\n        total += this._nano;\n        return total;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this {@link LocalTime} to another time.\n     *\n     * The comparison is based on the time-line position of the local times within a day.\n     * It is 'consistent with equals', as defined by {@link Comparable}.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     * @throws {NullPointerException} if `other` is null\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalTime, 'other');\n        let cmp = MathUtil.compareNumbers(this._hour, other._hour);\n        if (cmp === 0) {\n            cmp = MathUtil.compareNumbers(this._minute, other._minute);\n            if (cmp === 0) {\n                cmp = MathUtil.compareNumbers(this._second, other._second);\n                if (cmp === 0) {\n                    cmp = MathUtil.compareNumbers(this._nano, other._nano);\n                }\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this {@link LocalTime} is after the specified time.\n     *\n     * The comparison is based on the time-line position of the time within a day.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {boolean}true if this is after the specified time\n     * @throws {NullPointerException} if `other` is null\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Checks if this {@link LocalTime} is before the specified time.\n     *\n     * The comparison is based on the time-line position of the time within a day.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {boolean}true if this point is before the specified time\n     * @throws {NullPointerException} if `other` is null\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this time is equal to another time.\n     *\n     * The comparison is based on the time-line position of the time within a day.\n     *\n     * Only objects of type {@link LocalTime} are compared, other types return false.\n     * To compare the date of two {@link TemporalAccessor} instances, use\n     * {@link ChronoField#NANO_OF_DAY} as a comparator.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean}true if this is equal to the other time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalTime) {\n            return this._hour === other._hour && this._minute === other._minute &&\n                this._second === other._second && this._nano === other._nano;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        const nod = this.toNanoOfDay();\n        return (nod ^ (nod >>> 24));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this time as a string, such as `10:15`.\n     *\n     * The output will be one of the following ISO-8601 formats:\n     *\n     * * {@link HH:mm}\n     * * {@link HH:mm:ss}\n     * * {@link HH:mm:ss.SSS}\n     * * {@link HH:mm:ss.SSSSSS}\n     * * {@link HH:mm:ss.SSSSSSSSS}\n     *\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return {string} a string representation of this time, not null\n     */\n    toString() {\n        let buf = '';\n        const hourValue = this._hour;\n        const minuteValue = this._minute;\n        const secondValue = this._second;\n        const nanoValue = this._nano;\n        buf += hourValue < 10 ? '0' : '';\n        buf += hourValue;\n        buf += minuteValue < 10 ? ':0' : ':';\n        buf += minuteValue;\n        if (secondValue > 0 || nanoValue > 0) {\n            buf += secondValue < 10 ? ':0' : ':';\n            buf += secondValue;\n            if (nanoValue > 0) {\n                buf += '.';\n                if(MathUtil.intMod(nanoValue, 1000000) === 0) {\n                    buf += ('' + (MathUtil.intDiv(nanoValue, 1000000) + 1000)).substring(1);\n                } else if (MathUtil.intMod(nanoValue, 1000) === 0) {\n                    buf += ('' + (MathUtil.intDiv(nanoValue, 1000) + 1000000)).substring(1);\n                } else {\n                    buf += ('' + (nanoValue + 1000000000)).substring(1);\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalTime.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this time as a string using the formatter.\n     *\n     * @param {DateTineFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted time string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n}\n\nexport function _init() {\n    /**\n     * Constants for the local time of each hour.\n     */\n    LocalTime.HOURS = [];\n    for (let i = 0; i < 24; i++) {\n        LocalTime.HOURS[i] = makeLocalTimeConst(i);\n    }\n\n    function makeLocalTimeConst(hour = 0, minute = 0, second = 0, nano = 0) {\n        const localTime = Object.create(LocalTime.prototype);\n        Temporal.call(localTime);\n        localTime._hour = hour;\n        localTime._minute = minute;\n        localTime._second = second;\n        localTime._nano = nano;\n        return localTime;\n    }\n\n    /**\n     * The minimum supported {@link LocalTime}, '00:00'.\n     * This is the time of midnight at the start of the day.\n     */\n    LocalTime.MIN = LocalTime.HOURS[0];\n    /**\n     * The maximum supported {@link LocalTime}, '23:59:59.999999999'.\n     * This is the time just before midnight at the end of the day.\n     */\n    LocalTime.MAX = makeLocalTimeConst(23, 59, 59, 999999999);\n    /**\n     * The time of midnight at the start of the day, '00:00'.\n     */\n    LocalTime.MIDNIGHT = LocalTime.HOURS[0];\n    /**\n     * The time of noon in the middle of the day, '12:00'.\n     */\n    LocalTime.NOON = LocalTime.HOURS[12];\n\n    LocalTime.FROM = createTemporalQuery('LocalTime.FROM', (temporal) => {\n        return LocalTime.from(temporal);\n    });\n\n    /**\n     * Hours per day.\n     */\n    LocalTime.HOURS_PER_DAY = 24;\n    /**\n     * Minutes per hour.\n     */\n    LocalTime.MINUTES_PER_HOUR = 60;\n    /**\n     * Minutes per day.\n     */\n    LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;\n    /**\n     * Seconds per minute.\n     */\n    LocalTime.SECONDS_PER_MINUTE = 60;\n    /**\n     * Seconds per hour.\n     */\n    LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\n    /**\n     * Seconds per day.\n     */\n    LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;\n    /**\n     * Milliseconds per day.\n     */\n    LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;\n    /**\n     * Microseconds per day.\n     */\n    LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;\n    /**\n     * Nanos per second.\n     */\n    LocalTime.NANOS_PER_SECOND = 1000000000;\n    /**\n     * Nanos per minute.\n     */\n    LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;\n    /**\n     * Nanos per hour.\n     */\n    LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\n    /**\n     * Nanos per day.\n     */\n    LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/LocalTime.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport {ArithmeticException} from './errors';\n\nexport const MAX_SAFE_INTEGER = 9007199254740991;\nexport const MIN_SAFE_INTEGER = -9007199254740991;\n\n/**\n * Math helper with static function for integer operations\n */\nexport class MathUtil {\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static intDiv(x, y) {\n        let r = x/y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static intMod(x, y) {\n        let r = x - MathUtil.intDiv(x, y) * y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     * \n     * @param {number} r\n     * @returns {number}\n     */\n    static roundDown(r){\n        if (r < 0) {\n            return Math.ceil(r);\n        } else {\n            return Math.floor(r);\n        }\n    }\n    \n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static floorDiv(x, y){\n        const r = Math.floor(x / y);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static floorMod(x, y){\n        const r = x - MathUtil.floorDiv(x, y) * y;\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeAdd(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        const r = MathUtil.safeToInt(x + y);\n        if (r === x || r === y) {\n            throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');\n        }\n        return r;\n    }\n\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeSubtract(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0 && y === 0) {\n            return 0;\n        } else if (x === 0) {\n            return MathUtil.safeZero(-1 * y);\n        } else if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        return MathUtil.safeToInt(x - y);\n    }\n\n    /**\n     * \n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeMultiply(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 1) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 1) {\n            return MathUtil.safeZero(x);\n        }\n        if (x === 0 || y === 0) {\n            return 0;\n        }\n        let r = MathUtil.safeToInt(x * y);\n        if (r / y !== x || (x === MIN_SAFE_INTEGER && y === -1) || (y === MIN_SAFE_INTEGER && x === -1)) {\n            throw new ArithmeticException('Multiplication overflows: ' + x + ' * ' + y);\n        }\n        return r;\n    }\n\n    /**\n     * \n     * @param {number} value\n     * @returns {number}\n     */\n    static parseInt(value) {\n        const r = parseInt(value);\n        return MathUtil.safeToInt(r);\n    }\n\n    /**\n     * \n     * @param {number} value\n     * @returns {number}\n     */\n    static safeToInt(value) {\n        MathUtil.verifyInt(value);\n        return MathUtil.safeZero(value);\n    }\n\n    /**\n     * \n     * @param {number} value\n     */\n    static verifyInt(value){\n        if (value == null) {\n            throw new ArithmeticException(`Invalid value: '${value}', using null or undefined as argument`);\n        }\n        if (isNaN(value)) {\n            throw new ArithmeticException('Invalid int value, using NaN as argument');\n        }\n        if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {\n            throw new ArithmeticException('Calculation overflows an int: ' + value);\n        }\n    }\n\n    /**\n     * convert -0 to 0 and int as string to a number ( '1' -> 1 )\n     * \n     * @param {number} value\n     * @returns {number}\n     */\n    static safeZero(value){\n        return value === 0 ? 0 : +value;\n    }\n\n    /**\n     * Compares two Numbers.\n     *\n     * @param {number} a  the first value\n     * @param {number} b  the second value\n     * @return {number} the result\n     */\n    static compareNumbers(a, b) {\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n\n}\n\nMathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nMathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/MathUtil.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MathUtil} from './MathUtil';\nimport {assert, requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException, IllegalArgumentException} from './errors';\n\nimport {Clock} from './Clock';\nimport {Instant} from './Instant';\nimport {LocalDate} from './LocalDate';\nimport {LocalTime} from './LocalTime';\nimport {ZonedDateTime} from './ZonedDateTime';\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\n\n\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\n\nimport {ChronoLocalDateTime} from './chrono/ChronoLocalDateTime';\n\n/**\n * A date-time without a time-zone in the ISO-8601 calendar system,\n * such as `2007-12-03T10:15:30`.\n *\n * {@link LocalDateTime} is an immutable date-time object that represents a date-time,\n * often viewed as year-month-day-hour-minute-second. Other date and time fields,\n * such as day-of-year, day-of-week and week-of-year, can also be accessed.\n * Time is represented to nanosecond precision.\n * For example, the value '2nd October 2007 at 13:45.30.123456789' can be\n * stored in a {@link LocalDateTime}.\n *\n * This class does not store or represent a time-zone.\n * Instead, it is a description of the date, as used for birthdays, combined with\n * the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Static properties of Class {@link LocalTime}\n *\n * LocalDateTime.MIN\n *\n * The minimum supported {@link LocalDateTime}, '-999999999-01-01T00:00:00'.\n * This is the local date-time of midnight at the start of the minimum date.\n * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n * This could be used by an application as a 'far past' date-time.\n *\n * LocalDateTime.MAX\n *\n * The maximum supported {@link LocalDateTime}, '+999999999-12-31T23:59:59.999999999'.\n * This is the local date-time just before midnight at the end of the maximum date.\n * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n * This could be used by an application as a 'far future' date-time.\n *\n */\nexport class LocalDateTime extends ChronoLocalDateTime\n/** extends ChronoLocalDateTime<LocalDate>\nimplements Temporal, TemporalAdjuster, Serializable */ {\n\n\n    /**\n     * Obtains the current date-time from from the specified clock or the system clock in the specified time-zone.\n     *\n     * If the argument is an instance of Clock this will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * If the argument is an instance of ZoneId this will query the system clock (see {@link Clock#system}) to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * If nor argument is applied, the system default time zone is used to obtain the current date-time.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {Clock|ZoneId} clockOrZone - the zone ID or clock to use, if null Clock.systemDefaultZone() is used.\n     * @return {LocalDateTime} the current date-time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        if (clockOrZone == null){\n            return LocalDateTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock){\n            return LocalDateTime._now(clockOrZone);\n        } else {\n            return LocalDateTime._now(Clock.system(clockOrZone));\n        }\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     *\n     * This will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock} clock - the clock to use, defaults to Clock.systemDefaultZone()\n     * @return {LocalDateTime} the current date-time, not null\n     */\n    static _now(clock) {\n        requireNonNull(clock, 'clock');\n        return LocalDateTime.ofInstant(clock.instant(), clock.zone());\n\n        // this is an alternative implementation with better performance.\n        // const epochMilli = clock.millis();\n        // const offset = clock.zone().rules().offsetOfEpochMilli(epochMilli);\n        // return LocalDateTime._ofEpochMillis(epochMilli, offset);\n\n    }\n\n    /**\n     * @see comment at {LocalDateTime._now}\n     * @param {number} epochMilli\n     * @param {ZoneOffset} offset\n     * @return {LocalDateTime} the  date-time, not null\n     *\n     */\n    static _ofEpochMillis(epochMilli, offset){\n        const localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();\n        const localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n        const secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n        const nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;\n        const date = LocalDate.ofEpochDay(localEpochDay);\n        const time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n        return new LocalDateTime(date, time);\n\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.of}\n     *\n     * if called with 2 arguments and first argument is an instance of LocalDate and second is an\n     * instance of LocalTime, then {@link LocalDateTime.ofDateAndTime} is executed.\n     *\n     * Otherwise {@link LocalDateTime.ofNumbers} is executed.\n     *\n     * @returns {LocalDateTime}\n     */\n    static of(){\n        if (arguments.length === 2 && (arguments[0] instanceof LocalDate || arguments[1] instanceof LocalTime)){\n            return LocalDateTime.ofDateAndTime.apply(this, arguments);\n        } else {\n            return LocalDateTime.ofNumbers.apply(this, arguments);\n        }\n    }\n    /**\n     * Obtains an instance of {@link LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     *\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param {number} [year=0] - the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} [month=0] - the month-of-year to represent, from 1 to 12 or from a Month\n     * @param {number} [dayOfMonth=0] - the day-of-month to represent, from 1 to 31\n     * @param {number} [hour=0] - the hour-of-day to represent, from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     * @throws {DateTimeException} if the day-of-month is invalid for the month-year\n     */\n    static ofNumbers(year=0, month=0, dayOfMonth=0, hour=0, minute=0, second=0, nanoOfSecond=0) {\n        const date = LocalDate.of(year, month, dayOfMonth);\n        const time = LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a date and time.\n     *\n     * @param {!LocalDate} date - the local date, not null\n     * @param {!LocalTime} time - the local time, not null\n     * @return {LocalDateTime} the local date-time, not null\n     */\n    static ofDateAndTime(date, time) {\n        requireNonNull(date, 'date');\n        requireNonNull(time, 'time');\n        return new LocalDateTime(date, time);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from an {@link Instant} and zone ID.\n     *\n     * This creates a local date-time based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date-time.\n     *\n     * @param {!Instant} instant  the instant to create the date-time from, not null\n     * @param {!ZoneId} [zone=ZoneId.systemDefault()]  the time-zone, which may be an offset, defaults to ZoneId.systemDefault()\n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()) {\n        requireNonNull(instant, 'instant');\n        requireInstance(instant, Instant, 'instant');\n        requireNonNull(zone, 'zone');\n        const offset = zone.rules().offset(instant);\n        return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * This allows the {@link ChronoField.INSTANT_SECONDS} epoch-second field\n     * to be converted to a local date-time. This is primarily intended for\n     * low-level conversions rather than general application usage.\n     *\n     * @param {number} epochSecond - the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param {number|!ZoneOffset} nanoOfSecond - the nanosecond within the second, from 0 to 999,999,999\n     * @param {ZoneOffset} offset - the zone offset, not null if called with 3 arguments\n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    static ofEpochSecond(epochSecond=0, nanoOfSecond=0, offset) {\n        if(arguments.length === 2 && nanoOfSecond instanceof ZoneOffset){\n            offset = nanoOfSecond;\n            nanoOfSecond = 0;\n        }\n        requireNonNull(offset, 'offset');\n        const localSecond = epochSecond + offset.totalSeconds();  // overflow caught later\n        const localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n        const secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n        const date = LocalDate.ofEpochDay(localEpochDay);\n        const time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalDateTime}.\n     *\n     * The conversion extracts and combines {@link LocalDate} and {@link LocalTime}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link LocalDateTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalDateTime} {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalDateTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof LocalDateTime) {\n            return temporal;\n        } else if (temporal instanceof ZonedDateTime) {\n            return temporal.toLocalDateTime();\n        }\n        try {\n            const date = LocalDate.from(temporal);\n            const time = LocalTime.from(temporal);\n            return new LocalDateTime(date, time);\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain LocalDateTime TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param {!string} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=DateTimeFormatter.ISO_LOCAL_DATE_TIME] - the formatter to use,\n     * defaults to DateTimeFormatter.ISO_LOCAL_DATE_TIME\n     * @return {LocalDateTime} the parsed local date-time, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, LocalDateTime.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {LocalDate} date - the date part of the date-time, validated not null\n     * @param {LocalTime} time - the time part of the date-time, validated not null\n     */\n    constructor(date, time) {\n        super();\n        requireInstance(date, LocalDate, 'date');\n        requireInstance(time, LocalTime, 'time');\n        this._date = date;\n        this._time = time;\n    }\n\n    /**\n     * Returns a copy of this date-time with the new date and time, checking\n     * to see if a new object is in fact required.\n     *\n     * @param {LocalDate} newDate - the date of the new date-time, not null\n     * @param {LocalTime} newTime - the time of the new date-time, not null\n     * @return {LocalDateTime} the date-time, not null\n     */\n    _withDateTime(newDate, newTime) {\n        if (this._date === newDate && this._time === newTime) {\n            return this;\n        }\n        return new LocalDateTime(newDate, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link LocalDateTime.range} range and\n     * {@link LocalDateTime.get} get methods will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link ChronoField.NANO_OF_SECOND}\n     * * {@link ChronoField.NANO_OF_DAY}\n     * * {@link ChronoField.MICRO_OF_SECOND}\n     * * {@link ChronoField.MICRO_OF_DAY}\n     * * {@link ChronoField.MILLI_OF_SECOND}\n     * * {@link ChronoField.MILLI_OF_DAY}\n     * * {@link ChronoField.SECOND_OF_MINUTE}\n     * * {@link ChronoField.SECOND_OF_DAY}\n     * * {@link ChronoField.MINUTE_OF_HOUR}\n     * * {@link ChronoField.MINUTE_OF_DAY}\n     * * {@link ChronoField.HOUR_OF_AMPM}\n     * * {@link ChronoField.CLOCK_HOUR_OF_AMPM}\n     * * {@link ChronoField.HOUR_OF_DAY}\n     * * {@link ChronoField.CLOCK_HOUR_OF_DAY}\n     * * {@link ChronoField.AMPM_OF_DAY}\n     * * {@link ChronoField.DAY_OF_WEEK}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * * {@link ChronoField.DAY_OF_MONTH}\n     * * {@link ChronoField.DAY_OF_YEAR}\n     * * {@link ChronoField.EPOCH_DAY}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_MONTH}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_YEAR}\n     * * {@link ChronoField.MONTH_OF_YEAR}\n     * * {@link ChronoField.EPOCH_MONTH}\n     * * {@link ChronoField.YEAR_OF_ERA}\n     * * {@link ChronoField.YEAR}\n     * * {@link ChronoField.ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date-time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.range(field) : this._date.range(field));\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an `int`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time, except {@link NANO_OF_DAY}, {@link MICRO_OF_DAY},\n     * {@link EPOCH_DAY} and {@link EPOCH_MONTH} which are too large to fit in\n     * an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.get(field) : this._date.get(field));\n        }\n        return super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a `long`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field));\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     *\n     * This method returns the primitive `int` value for the year.\n     *\n     * The year returned by this method is proleptic as per `get(YEAR)`.\n     * To obtain the year-of-era, use `get(YEAR_OF_ERA)`.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._date.year();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    monthValue() {\n        return this._date.monthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use\n     * {@link Month#getValue}.\n     *\n     * @return {Month} the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    month() {\n        return this._date.month();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     *\n     * This method returns the primitive `int` value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._date.dayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     *\n     * This method returns the primitive `int` value for the day-of-year.\n     *\n     * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    dayOfYear() {\n        return this._date.dayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n     *\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use\n     * {@link DayOfWeek#getValue}.\n     *\n     * Additional information can be obtained from the {@link DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        return this._date.dayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._time.hour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._time.minute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._time.second();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._time.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.with}\n     *\n     * if called with 1 argument, {@link LocalDateTime.withTemporalAdjuster} is applied,\n     * otherwise {@link LocalDateTime.with2}.\n     *\n     * @param {!(TemporalAdjuster|TemporalField)} adjusterOrField\n     * @param {number} newValue - only require if first argument is a TemporalField\n     * @returns {LocalDateTime}\n     */\n    with(adjusterOrField, newValue){\n        if(arguments.length === 1){\n            return this.withTemporalAdjuster(adjusterOrField);\n        } else {\n            return this.with2(adjusterOrField, newValue);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this date-time.\n     *\n     * This returns a new {@link LocalDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the 'last day of the month' and 'next Wednesday'.\n     * Key date-time classes also implement the {@link TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     *\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = localDateTime.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     *\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@link TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * <pre>\n     *  result = localDateTime.with(date);\n     *  result = localDateTime.with(time);\n     * </pre>\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster the adjuster to use, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on `this` with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return this._withDateTime(adjuster, this._time);\n        } else if (adjuster instanceof LocalTime) {\n            return this._withDateTime(this._date, adjuster);\n        } else if (adjuster instanceof LocalDateTime) {\n            return adjuster;\n        }\n        assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     *\n     * This returns a new {@link LocalDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields (see {@link isSupported}) will behave as in\n     * {@link LocalDate#with} or {@link LocalTime#with}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalDateTime} a {@link LocalDateTime} based on `this` with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            if (field.isTimeBased()) {\n                return this._withDateTime(this._date, this._time.with(field, newValue));\n            } else {\n                return this._withDateTime(this._date.with(field, newValue), this._time);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the year altered.\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year - the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested year, not null\n     * @throws {DateTimeException} if the year value is invalid\n     */\n    withYear(year) {\n        return this._withDateTime(this._date.withYear(year), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the month-of-year altered.\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!(number|Month)} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested month, not null\n     * @throws {DateTimeException} if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this._withDateTime(this._date.withMonth(month), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the day-of-month altered.\n     * If the resulting {@link LocalDateTime} is invalid, an exception is thrown.\n     * The time does not affect the calculation and will be the same in the result.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested day, not null\n     * @throws {DateTimeException} if the day-of-month value is invalid\n     * @throws {DateTimeException} if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the day-of-year altered.\n     * If the resulting {@link LocalDateTime} is invalid, an exception is thrown.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfYear - the day-of-year to set in the result, from 1 to 365-366\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-year value is invalid\n     * @throws {DateTimeException} if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the hour-of-day value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hour - the hour-of-day to set in the result, from 0 to 23\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested hour, not null\n     * @throws {DateTimeException} if the hour value is invalid\n     */\n    withHour(hour) {\n        const newTime = this._time.withHour(hour);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the minute-of-hour value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minute - the minute-of-hour to set in the result, from 0 to 59\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested minute, not null\n     * @throws {DateTimeException} if the minute value is invalid\n     */\n    withMinute(minute) {\n        const newTime = this._time.withMinute(minute);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the second-of-minute value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} second - the second-of-minute to set in the result, from 0 to 59\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested second, not null\n     * @throws {DateTimeException} if the second value is invalid\n     */\n    withSecond(second) {\n        const newTime = this._time.withSecond(second);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the nano-of-second value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanoOfSecond - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws {DateTimeException} if the nano value is invalid\n     */\n    withNano(nanoOfSecond) {\n        const newTime = this._time.withNano(nanoOfSecond);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the time truncated.\n     *\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with {@link ChronoUnit#MINUTES}\n     * will set the second-of-minute and nano-of-second field to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS}. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalUnit} unit - the unit to truncate to, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the time truncated, not null\n     * @throws {DateTimeException} if unable to truncate\n     */\n    truncatedTo(unit) {\n        return this._withDateTime(this._date, this._time.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.plus}\n     *\n     * if called with 1 argument {@link LocalDateTime.plusTemporalAmount} is applied,\n     * otherwise {@link LocalDateTime.plus2}\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {TemporalUnit} unit\n     * @returns {LocalDateTime}\n     */\n    plus(amount, unit){\n        if(arguments.length === 1){\n            return this.plusTemporalAmount(amount);\n        } else {\n            return this.plus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     *\n     * This method returns a new date-time based on this time with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link plus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to add, not null\n     * @return {LocalDateTime} based on this date-time with the addition made, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    plusTemporalAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     *\n     * This method returns a new date-time based on this date-time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {!TemporalUnit} unit - the unit of the period to add, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n                case ChronoUnit.MILLIS: return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusMinutes(amountToAdd);\n                case ChronoUnit.HOURS: return this.plusHours(amountToAdd);\n                case ChronoUnit.HALF_DAYS: return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);  // no overflow (256 is multiple of 2)\n            }\n            return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in years added.\n     *\n     * This method adds the specified amount to the years field in three steps:\n     *\n     * 1. Add the input years to the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the years added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusYears(years) {\n        const newDate = this._date.plusYears(years);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in months added.\n     *\n     * This method adds the specified amount to the months field in three steps:\n     *\n     * 1. Add the input months to the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the months added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMonths(months) {\n        const newDate = this._date.plusMonths(months);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in weeks added.\n     *\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the weeks added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusWeeks(weeks) {\n        const newDate = this._date.plusWeeks(weeks);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in days added.\n     *\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the days added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusDays(days) {\n        const newDate = this._date.plusDays(days);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in hours added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the hours added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusHours(hours) {\n        return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in minutes added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the minutes added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMinutes(minutes) {\n        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in seconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the seconds added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusSeconds(seconds) {\n        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in nanoseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusNanos(nanos) {\n        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.minus}\n     *\n     * if called with 1 argument {@link LocalDateTime.minusTemporalAmount} is applied,\n     * otherwise {@link LocalDateTime.minus2}\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {TemporalUnit} unit\n     * @returns {LocalDateTime}\n     */\n    minus(amount, unit){\n        if(arguments.length === 1){\n            return this.minusTemporalAmount(amount);\n        } else {\n            return this.minus2(amount, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     *\n     * This method returns a new date-time based on this time with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to subtract, not null\n     * @return {LocalDateTime} based on this date-time with the subtraction made, not null\n     * @throws {DateTimeException} if the subtraction cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    minusTemporalAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     *\n     * This method returns a new date-time based on this date-time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to subtract, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        requireNonNull(unit, 'unit');\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in years subtracted.\n     *\n     * This method subtracts the specified amount from the years field in three steps:\n     *\n     * 1. Subtract the input years from the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the years subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusYears(years) {\n        return this.plusYears(-1 * years);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in months subtracted.\n     *\n     * This method subtracts the specified amount from the months field in three steps:\n     *\n     * 1. Subtract the input months from the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the months subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMonths(months) {\n        return this.plusMonths(-1 * months);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in weeks subtracted.\n     *\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusWeeks(weeks) {\n        return this.plusWeeks(-1 * weeks);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in days subtracted.\n     *\n     * This method subtracts the specified amount from the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the days subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusDays(days) {\n        return this.plusDays(-1 * days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in hours subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the hours subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusHours(hours) {\n        return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in minutes subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMinutes(minutes) {\n        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in seconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusSeconds(seconds) {\n        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in nanoseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanos - the nanos to subtract, may be negative\n     * @return {LocalDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusNanos(nanos) {\n        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {LocalDate} newDate  the new date to base the calculation on, not null\n     * @param {Number} hours - the hours to add, may be negative\n     * @param {Number} minutes - the minutes to add, may be negative\n     * @param {Number} seconds - the seconds to add, may be negative\n     * @param {Number} nanos - the nanos to add, may be negative\n     * @param {Number} sign - the sign to determine add or subtract\n     * @return {LocalDateTime} the combined result, not null\n     */\n    _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {\n        // 9223372036854775808 long, 2147483648 int\n        if ((hours | minutes | seconds | nanos) === 0) {\n            return this._withDateTime(newDate, this._time);\n        }\n        let totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) +             //   max/24*60*60*1B\n                MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) +                //   max/24*60*60\n                MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) +                //   max/24*60\n                MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);                     //   max/24\n        totDays *= sign;                                   // total max*0.4237...\n        let totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) +                    //   max  86400000000000\n                (MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY)) * LocalTime.NANOS_PER_SECOND +   //   max  86400000000000\n                (MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY)) * LocalTime.NANOS_PER_MINUTE +   //   max  86400000000000\n                (MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY)) * LocalTime.NANOS_PER_HOUR;          //   max  86400000000000\n        const curNoD = this._time.toNanoOfDay();                       //   max  86400000000000\n        totNanos = totNanos * sign + curNoD;                    // total 432000000000000\n        totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);\n        const newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);\n        const newTime = (newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD));\n        return this._withDateTime(newDate.plusDays(totDays), newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     *\n     * This queries this date-time using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date and time as this object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the date and time changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * twice, passing {@link ChronoField#EPOCH_DAY} and\n     * {@link ChronoField#NANO_OF_DAY} as the fields.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalDateTime.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalDateTime);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return {LocalDateTime} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the period between this date-time and another date-time in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two date-times in terms of a single unit.\n     * The start and end points are `this` and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalDateTime}.\n     * For example, the period in days between two date-times can be calculated\n     * using `startDateTime.until(endDateTime, DAYS)`.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the period in months between 2012-06-15T00:00 and 2012-08-14T23:59\n     * will only be one month as it is one minute short of two months.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n     * {@link MINUTES}, {@link HOURS} and {@link HALF_DAYS}, {@link DAYS},\n     * {@link WEEKS}, {@link MONTHS}, {@link YEARS}, {@link DECADES},\n     * {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive - the end date-time, which is converted to a {@link LocalDateTime}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date-time and the end date-time\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        const end = LocalDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            if (unit.isTimeBased()) {\n                let daysUntil = this._date.daysUntil(end._date);\n                let timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();\n                if (daysUntil > 0 && timeUntil < 0) {\n                    daysUntil--;\n                    timeUntil += LocalTime.NANOS_PER_DAY;\n                } else if (daysUntil < 0 && timeUntil > 0) {\n                    daysUntil++;\n                    timeUntil -= LocalTime.NANOS_PER_DAY;\n                }\n                let amount = daysUntil;\n                switch (unit) {\n                    case ChronoUnit.NANOS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);\n                        return MathUtil.safeAdd(amount, timeUntil);\n                    case ChronoUnit.MICROS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));\n                    case ChronoUnit.MILLIS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));\n                    case ChronoUnit.SECONDS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));\n                    case ChronoUnit.MINUTES:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));\n                    case ChronoUnit.HOURS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));\n                    case ChronoUnit.HALF_DAYS:\n                        amount = MathUtil.safeMultiply(amount, 2);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, (LocalTime.NANOS_PER_HOUR * 12)));\n                }\n                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n            }\n            let endDate = end._date;\n            const endTime = end._time;\n            if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {\n                endDate = endDate.minusDays(1);\n            } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {\n                endDate = endDate.plusDays(1);\n            }\n            return this._date.until(endDate, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with an offset to create an {@link OffsetDateTime}.\n     *\n     * This returns an {@link OffsetDateTime} formed from this date-time at the specified offset.\n     * All possible combinations of date-time and offset are valid.\n     *\n     * @param {ZoneOffset} offset  the offset to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this date-time and the specified offset, not null\n     */\n/*\n    atOffset(offset) {\n        return OffsetDateTime.of(this, offset);\n    }\n*/\n\n    /**\n     * Combines this date-time with a time-zone to create a {@link ZonedDateTime}.\n     *\n     * This returns a {@link ZonedDateTime} formed from this date-time at the\n     * specified time-zone. The result will match this date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * To obtain the later offset during an overlap, call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap} on the result of this method.\n     * To throw an exception when there is a gap or overlap, use\n     * {@link ZonedDateTime#ofStrict}.\n     *\n     * @param {ZoneId} zone  the time-zone to use, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this date-time, not null\n     */\n    atZone(zone) {\n        return ZonedDateTime.of(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@link LocalDate} part of this date-time.\n     *\n     * This returns a {@link LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return {LocalDate} the date part of this date-time, not null\n     */\n    toLocalDate() {\n        return this._date;\n    }\n\n    /**\n     * Gets the {@link LocalTime} part of this date-time.\n     *\n     * This returns a {@link LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return {LocalTime} the time part of this date-time, not null\n     */\n    toLocalTime() {\n        return this._time;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     *\n     * The comparison is primarily based on the date-time, from earliest to latest.\n     * It is 'consistent with equals', as defined by {@link Comparable}.\n     *\n     * If all the date-times being compared are instances of {@link LocalDateTime},\n     * then the comparison will be entirely based on the date-time.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDateTime#compareTo}.\n     *\n     * @param {!LocalDateTime} other - the other date-time to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalDateTime, 'other');\n        return this._compareTo0(other);\n        // return super.compareTo(other); if not instance of  LocalDateTime\n    }\n\n    /**\n     *\n     * @param {!LocalDateTime} other\n     * @returns {number}\n     * @private\n     */\n    _compareTo0(other) {\n        let cmp = this._date.compareTo(other.toLocalDate());\n        if (cmp === 0) {\n            cmp = this._time.compareTo(other.toLocalTime());\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date-time is after the specified date-time.\n     *\n     * This checks to see if this date-time represents a point on the\n     * local time-line after the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isAfter(b) == false\n     *   a.isAfter(a) == false\n     *   b.isAfter(a) == true\n     * </pre>\n     *\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_TIME_COMPARATOR}.\n     *\n     * @param {LocalDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is after the specified date-time\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n        // return super.isAfter(other);  if not instance of LocalDateTime\n    }\n\n    /**\n     * Checks if this date-time is before the specified date-time.\n     *\n     * This checks to see if this date-time represents a point on the\n     * local time-line before the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isBefore(b) == true\n     *   a.isBefore(a) == false\n     *   b.isBefore(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_TIME_COMPARATOR}.\n     *\n     * @param {LocalDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is before the specified date-time\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n        // return super.isBefore(other);  if not instance of LocalDateTime\n    }\n\n    /**\n     * Checks if this date-time is equal to the specified date-time.\n     *\n     * This checks to see if this date-time represents the same point on the\n     * local time-line as the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isEqual(b) == false\n     *   a.isEqual(a) == true\n     *   b.isEqual(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_TIME_COMPARATOR}.\n     *\n     * @param {*} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is equal to the specified date-time\n     */\n    isEqual(other) {\n        return this.compareTo(other) === 0;\n        // return super.isEqual(other); if not instance of LocalDateTime\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     *\n     * Compares this {@link LocalDateTime} with another ensuring that the date-time is the same.\n     * Only objects of type {@link LocalDateTime} are compared, other types return false.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalDateTime) {\n            return this._date.equals(other._date) && this._time.equals(other._time);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._date.hashCode() ^ this._time.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a string, such as `2007-12-03T10:15:30`.\n     *\n     * The output will be one of the following ISO-8601 formats:\n     *\n     * * `yyyy-MM-dd'T'HH:mm`\n     * * `yyyy-MM-dd'T'HH:mm:ss`\n     * * `yyyy-MM-dd'T'HH:mm:ss.SSS`\n     * * `yyyy-MM-dd'T'HH:mm:ss.SSSSSS`\n     * * `yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS`\n     *\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return {string} a string representation of this date-time, not null\n     */\n    toString() {\n        return this._date.toString() + 'T' + this._time.toString();\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalDateTime.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this date-time as a string using the formatter.\n     *\n     * @param {!DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted date-time string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n}\n\nexport function _init(){\n    /**\n     * The minimum supported {@link LocalDateTime}, '-999999999-01-01T00:00:00'.\n     * This is the local date-time of midnight at the start of the minimum date.\n     * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n     * This could be used by an application as a 'far past' date-time.\n     */\n    LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n\n    /**\n     * The maximum supported {@link LocalDateTime}, '+999999999-12-31T23:59:59.999999999'.\n     * This is the local date-time just before midnight at the end of the maximum date.\n     * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n     * This could be used by an application as a 'far future' date-time.\n     */\n    LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n\n    LocalDateTime.FROM = createTemporalQuery('LocalDateTime.FROM', (temporal) => {\n        return LocalDateTime.from(temporal);\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/LocalDateTime.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull, requireInstance} from './assert';\n\nimport {MathUtil} from './MathUtil';\nimport {DateTimeException, UnsupportedTemporalTypeException, NullPointerException, IllegalArgumentException} from './errors';\n\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {ChronoLocalDate} from './chrono/ChronoLocalDate';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\nimport {ValueRange} from './temporal/ValueRange';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\n\nimport {Clock} from './Clock';\nimport {DayOfWeek} from './DayOfWeek';\nimport {Month} from './Month';\nimport {Period} from './Period';\nimport {YearConstants} from './YearConstants';\nimport {LocalTime} from './LocalTime';\nimport {LocalDateTime} from './LocalDateTime';\nimport {Year} from './Year';\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\nimport {ZonedDateTime} from './ZonedDateTime';\n\n/**\n * The number of days in a 400 year cycle.\n */\nconst  DAYS_PER_CYCLE = 146097;\n\n/**\n* The number of days from year zero to year 1970.\n* There are five 400 year cycles from year zero to 2000.\n* There are 7 leap years from 1970 to 2000.\n*/\nconst  DAYS_0000_TO_1970 = (DAYS_PER_CYCLE * 5) - (30 * 365 + 7);\n\n/**\n * A date without a time-zone in the ISO-8601 calendar system,\n * such as 2007-12-03.\n *\n * LocalDate is an immutable date-time object that represents a date,\n * often viewed as year-month-day. Other date fields, such as day-of-year,\n * day-of-week and week-of-year, can also be accessed.\n * For example, the value \"2nd October 2007\" can be stored in a LocalDate.\n *\n * This class does not store or represent a time or time-zone.\n * Instead, it is a description of the date, as used for birthdays.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Static properties of Class {@link LocalDate}\n *\n * LocalDate.MIN = LocalDate.of(Year.MIN_VALUE, 1, 1);\n *\n * The minimum supported {@link LocalDate}\n * This could be used by an application as a \"far past\" date.\n *\n * LocalDate.MAX = LocalDate.of(Year.MAX_VALUE, 12, 31);\n *\n * The maximum supported {@link LocalDate}\n * This could be used by an application as a \"far future\" date.\n *\n * LocalDate.EPOCH_0\n *\n * The date at epoch day 0, that is 1970-01-01.\n */\n\nexport class LocalDate extends ChronoLocalDate{\n\n    /**\n     * Obtains the current date from the system clock in the default time-zone or\n     * if specified, the current date from the specified clock or\n     * if argument is a ZoneId this will query a clock with the specified ZoneId.\n     *\n     * This will query the specified clock to obtain the current date - today.\n     * Using this method allows the use of an alternate clock for testing.\n     *\n     * @param {Clock|ZoneId} [clockOrZone=Clock.systemDefaultZone()] - the clock or zone to use,\n     * if null, the system clock and default time-zone is used.\n     * @return {LocalDate} the current date, not null\n     */\n    static now(clockOrZone) {\n        let clock;\n        if(clockOrZone == null){\n            clock = Clock.systemDefaultZone();\n        } else if(clockOrZone instanceof ZoneId){\n            clock = Clock.system(clockOrZone);\n        } else {\n            clock = clockOrZone;\n        }\n        return LocalDate.ofInstant(clock.instant(), clock.zone());\n    }\n\n    /**\n     * obtain a LocalDate from an Instant in the specified time-zone or, if null\n     * in the system default time-zone\n     *\n     * @param {!Instant} instant\n     * @param {ZoneId} [zone=ZoneId.systemDefault()], defaults to ZoneId.systemDefault()\n     * @returns {LocalDate} the current date, not null\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()){\n        requireNonNull(instant, 'instant');\n        const offset = zone.rules().offset(instant);\n        const epochSec = instant.epochSecond() + offset.totalSeconds();\n        const epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);\n        return LocalDate.ofEpochDay(epochDay);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a year, month and day.\n     *\n     * This returns a {@link LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param {!number} year - the year to represent, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!(Month|Number)} month - the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {!number} dayOfMonth - the day-of-month to represent, from 1 to 31\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    static of(year, month, dayOfMonth) {\n        return new LocalDate(year, month, dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a year and day-of-year.\n     *\n     * This returns a {@link LocalDate} with the specified year and day-of-year.\n     * The day-of-year must be valid for the year, otherwise an exception will be thrown.\n     *\n     * @param {!number} year - the year to represent, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!number} dayOfYear - the day-of-year to represent, from 1 to 366\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if the value of any field is out of range,\n     *  or if the day-of-year is invalid for the year\n     */\n    static ofYearDay(year, dayOfYear) {\n        ChronoField.YEAR.checkValidValue(year);\n        //TODO: ChronoField.DAY_OF_YEAR.checkValidValue(dayOfYear);\n        const leap = IsoChronology.isLeapYear(year);\n        if (dayOfYear === 366 && leap === false) {\n            assert(false, 'Invalid date \\'DayOfYear 366\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n        }\n        let moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));\n        const monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear > monthEnd) {\n            moy = moy.plus(1);\n        }\n        const dom = dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.value(), dom);\n    }\n\n    /**\n     * Obtains an instance of LocalDate from the epoch day count.\n     *\n     * This returns a LocalDate with the specified epoch-day.\n     * The {@link ChronoField.EPOCH_DAY} is a simple incrementing count\n     * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.\n     *\n     * @param {number} [epochDay=0] - the Epoch Day to convert, based on the epoch 1970-01-01\n     * @return {LocalDate} the local date, not null\n     * @throws {AssertionError} if the epoch days exceeds the supported date range\n     */\n    static ofEpochDay(epochDay=0) {\n        let adjust, adjustCycles, dom, doyEst, marchDoy0, marchMonth0, month, year, yearEst, zeroDay;\n        zeroDay = epochDay + DAYS_0000_TO_1970;\n        zeroDay -= 60;\n        adjust = 0;\n        if (zeroDay < 0) {\n            adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;\n            adjust = adjustCycles * 400;\n            zeroDay += -adjustCycles * DAYS_PER_CYCLE;\n        }\n        yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);\n        doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n        if (doyEst < 0) {\n            yearEst--;\n            doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n        }\n        yearEst += adjust;\n        marchDoy0 = doyEst;\n        marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);\n        month = (marchMonth0 + 2) % 12 + 1;\n        dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;\n        yearEst += MathUtil.intDiv(marchMonth0, 10);\n        year = yearEst;\n        return new LocalDate(year, month, dom);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalDate}.\n     *\n     * The conversion uses the {@link TemporalQueries.localDate} query, which relies\n     * on extracting the {@link ChronoField.EPOCH_DAY} field.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link LocalDate::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalDate}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        const date = temporal.query(TemporalQueries.localDate());\n        if (date == null) {\n            throw new DateTimeException(\n                `Unable to obtain LocalDate from TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n        return date;\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param {!string} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=DateTimeFormatter.ISO_LOCAL_DATE] - the formatter to use, default is\n     * {@link DateTimeFormatter.ISO_LOCAL_DATE}\n     * @return {LocalDate} the parsed local date, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_LOCAL_DATE){\n        assert(formatter != null, 'formatter', NullPointerException);\n        return formatter.parse(text, LocalDate.FROM);\n    }\n\n    /**\n     * Resolves the date, resolving days past the end of month.\n     *\n     * @param {!number} year - the year to represent, validated from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!number} month - the month-of-year to represent, validated from 1 to 12\n     * @param {!number} day - the day-of-month to represent, validated from 1 to 31\n     * @return {LocalDate} resolved date, not null\n     */\n    static _resolvePreviousValid(year, month, day) {\n        switch (month) {\n            case 2:\n                day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day = Math.min(day, 30);\n                break;\n        }\n        return LocalDate.of(year, month, day);\n    }\n\n    /**\n     * Do not call the constructor directly, use the of*() factories instead like {@link LocalDate.of}\n     *\n     * @param {!number} year\n     * @param {!(Month|number)} month\n     * @param {!number} dayOfMonth\n     * @private\n     */\n    constructor(year, month, dayOfMonth){\n        super();\n        if (month instanceof Month) {\n            month = month.value();\n        }\n        LocalDate._validate(year, month, dayOfMonth);\n        this._year = MathUtil.safeZero(year);\n        this._month = MathUtil.safeZero(month);\n        this._day = MathUtil.safeZero(dayOfMonth);\n    }\n\n\n    /**\n     *\n     * @param {!number} year\n     * @param {!number} month\n     * @param {!number} dayOfMonth\n     * @throws {DateTimeException} if date values are invalid\n     * @private\n     */\n    static _validate(year, month, dayOfMonth) {\n        let dom;\n        ChronoField.YEAR.checkValidValue(year);\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        if (dayOfMonth > 28) {\n            dom = 31;\n            switch (month) {\n                case 2:\n                    dom = IsoChronology.isLeapYear(year) ? 29 : 28;\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom = 30;\n            }\n            if (dayOfMonth > dom) {\n                if (dayOfMonth === 29) {\n                    assert(false, 'Invalid date \\'February 29\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n                } else {\n                    assert(false, 'Invalid date \\'' + year + '\\' \\'' + month + '\\' \\'' + dayOfMonth + '\\'', DateTimeException);\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link LocalDate.range} range and\n     * {@link LocalDate.get} get methods will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link ChronoField.DAY_OF_WEEK}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * * {@link ChronoField.DAY_OF_MONTH}\n     * * {@link ChronoField.DAY_OF_YEAR}\n     * * {@link ChronoField.EPOCH_DAY}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_MONTH}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_YEAR}\n     * * {@link ChronoField.MONTH_OF_YEAR}\n     * * {@link ChronoField.EPOCH_MONTH}\n     * * {@link ChronoField.YEAR_OF_ERA}\n     * * {@link ChronoField.YEAR}\n     * * {@link ChronoField.ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing this as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date, false if not\n     */\n    isSupported(field) {\n        return super.isSupported(field);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing this as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (field.isDateBased()) {\n                switch (field) {\n                    case ChronoField.DAY_OF_MONTH: return ValueRange.of(1, this.lengthOfMonth());\n                    case ChronoField.DAY_OF_YEAR: return ValueRange.of(1, this.lengthOfYear());\n                    case ChronoField.ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);\n                    case ChronoField.YEAR_OF_ERA:\n                        return (this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an `int`.\n     *\n     * This queries this date for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return valid\n     * values based on this date, except {@link ChronoField.EPOCH_DAY} and {@link ChronoField.EPOCH_MONTH}\n     * which are too large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field  the field to get, not null\n     * @return the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * see {LocalDate.get}, get and getLong are identical in javascript, because we are only limited by\n     * {@link MathUtil.MIN_SAFE_INTEGER}/ {@link MathUtil.MAX_SAFE_INTEGER}\n     *\n     * @param {!TemporalField} field\n     * @returns {*}\n     */\n    getLong(field) {\n        assert(field != null, '', NullPointerException);\n        if (field instanceof ChronoField) {\n            return this._get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * TODO tests are missing for the ALIGNED_* ChronoFields\n     *\n     * @param {!TemporalField} field\n     * @returns {*}\n     * @private\n     */\n    _get0(field) {\n        switch (field) {\n            case ChronoField.DAY_OF_WEEK: return this.dayOfWeek().value();\n            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH: return MathUtil.intMod((this._day - 1), 7) + 1;\n            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR: return MathUtil.intMod((this.dayOfYear() - 1), 7) + 1;\n            case ChronoField.DAY_OF_MONTH: return this._day;\n            case ChronoField.DAY_OF_YEAR: return this.dayOfYear();\n            case ChronoField.EPOCH_DAY: return this.toEpochDay();\n            case ChronoField.ALIGNED_WEEK_OF_MONTH: return MathUtil.intDiv((this._day - 1), 7) + 1;\n            case ChronoField.ALIGNED_WEEK_OF_YEAR: return MathUtil.intDiv((this.dayOfYear() - 1), 7) + 1;\n            case ChronoField.MONTH_OF_YEAR: return this._month;\n            case ChronoField.PROLEPTIC_MONTH: return this._prolepticMonth();\n            case ChronoField.YEAR_OF_ERA: return (this._year >= 1 ? this._year : 1 - this._year);\n            case ChronoField.YEAR: return this._year;\n            case ChronoField.ERA: return (this._year >= 1 ? 1 : 0);\n        }\n        throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    /**\n     *\n     * @return {number}\n     * @private\n     */\n    _prolepticMonth() {\n        return (this._year * 12) + (this._month - 1);\n    }\n\n    /**\n     * Gets the chronology of this date, which is the ISO calendar system.\n     *\n     * The {@link Chronology} represents the calendar system in use.\n     * The ISO-8601 calendar system is the modern civil calendar system used today\n     * in most of the world. It is equivalent to the proleptic Gregorian calendar\n     * system, in which todays's rules for leap years are applied for all time.\n     *\n     * @return {Chronology} the ISO chronology, not null\n     */\n    chronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     *\n     * @return {number} gets the year\n     */\n    year() {\n        return this._year;\n    }\n\n    /**\n     *\n     * @return {number} gets the month value\n     */\n    monthValue() {\n        return this._month;\n    }\n\n    /**\n     *\n     * @returns {Month} month\n     */\n    month() {\n        return Month.of(this._month);\n    }\n\n    /**\n     *\n     * @return {number} gets the day of month\n     */\n    dayOfMonth() {\n        return this._day;\n    }\n\n    /**\n      * Gets the day-of-year field.\n      *\n      * This method returns the primitive int value for the day-of-year.\n      *\n      * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n      */\n    dayOfYear() {\n        return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n     *\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value then the enum\n     * provides the {@link DayOfWeek.value} int value.\n     *\n     * Additional information can be obtained from the {@link DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        const dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    }\n\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    isLeapYear() {\n        return IsoChronology.isLeapYear(this._year);\n    }\n\n    /**\n     * Returns the length of the month represented by this date.\n     *\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return {number} the length of the month in days\n     */\n    lengthOfMonth() {\n        switch (this._month) {\n            case 2:\n                return (this.isLeapYear() ? 29 : 28);\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns the length of the year represented by this date.\n     *\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return {number} 366 if the year is leap, 365 otherwise\n     */\n    lengthOfYear() {\n        return (this.isLeapYear() ? 366 : 365);\n    }\n\n    /**\n     * function overloading for the {@link LocalDate.with} method.\n     *\n     * calling \"with\" with one (or less) argument, assumes that the argument is an TemporalAdjuster\n     * and {@link LocalDate.withTemporalAdjuster} is called.\n     *\n     * Otherwise a TemporalField and newValue argument is expected and\n     * {@link LocalDate.withFieldAndValue} is called.\n     *\n     * @param {!(TemporalAdjuster|TemporalField)} fieldOrAdjuster\n     * @param {number} newValue - required if first argument is a TemporalField\n     * @return {LocalDate} the new LocalDate with the newValue set.\n     */\n    with(fieldOrAdjuster, newValue){\n        if(arguments.length < 2){\n            return this.withTemporalAdjuster(fieldOrAdjuster);\n        } else {\n            return this.withFieldAndValue(fieldOrAdjuster, newValue);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this date.\n     *\n     * This returns a new {@link LocalDate}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@link TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     *\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = localDate.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster.adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * @param {!TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {LocalDate} a {@link LocalDate} based on `this` with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return adjuster;\n        }\n        assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     *\n     * This returns a new {@link LocalDate}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link DAY_OF_WEEK} -\n     *   Returns a {@link LocalDate} with the specified day-of-week.\n     *   The date is adjusted up to 6 days forward or backward within the boundary\n     *   of a Monday to Sunday week.\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n     *   Returns a {@link LocalDate} with the specified aligned-day-of-week.\n     *   The date is adjusted to the specified month-based aligned-day-of-week.\n     *   Aligned weeks are counted such that the first week of a given month starts\n     *   on the first day of that month.\n     *   This may cause the date to be moved up to 6 days into the following month.\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n     *   Returns a {@link LocalDate} with the specified aligned-day-of-week.\n     *   The date is adjusted to the specified year-based aligned-day-of-week.\n     *   Aligned weeks are counted such that the first week of a given year starts\n     *   on the first day of that year.\n     *   This may cause the date to be moved up to 6 days into the following year.\n     * * {@link DAY_OF_MONTH} -\n     *   Returns a {@link LocalDate} with the specified day-of-month.\n     *   The month and year will be unchanged. If the day-of-month is invalid for the\n     *   year and month, then a {@link DateTimeException} is thrown.\n     * * {@link DAY_OF_YEAR} -\n     *   Returns a {@link LocalDate} with the specified day-of-year.\n     *   The year will be unchanged. If the day-of-year is invalid for the\n     *   year, then a {@link DateTimeException} is thrown.\n     * * {@link EPOCH_DAY} -\n     *   Returns a {@link LocalDate} with the specified epoch-day.\n     *   This completely replaces the date and is equivalent to {@link ofEpochDay}.\n     * * {@link ALIGNED_WEEK_OF_MONTH} -\n     *   Returns a {@link LocalDate} with the specified aligned-week-of-month.\n     *   Aligned weeks are counted such that the first week of a given month starts\n     *   on the first day of that month.\n     *   This adjustment moves the date in whole week chunks to match the specified week.\n     *   The result will have the same day-of-week as this date.\n     *   This may cause the date to be moved into the following month.\n     * * {@link ALIGNED_WEEK_OF_YEAR} -\n     *   Returns a {@link LocalDate} with the specified aligned-week-of-year.\n     *   Aligned weeks are counted such that the first week of a given year starts\n     *   on the first day of that year.\n     *   This adjustment moves the date in whole week chunks to match the specified week.\n     *   The result will have the same day-of-week as this date.\n     *   This may cause the date to be moved into the following year.\n     * * {@link MONTH_OF_YEAR} -\n     *   Returns a {@link LocalDate} with the specified month-of-year.\n     *   The year will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     * * {@link PROLEPTIC_MONTH} -\n     *   Returns a {@link LocalDate} with the specified proleptic-month.\n     *   The day-of-month will be unchanged, unless it would be invalid for the new month\n     *   and year. In that case, the day-of-month is adjusted to the maximum valid value\n     *   for the new month and year.\n     * * {@link YEAR_OF_ERA} -\n     *   Returns a {@link LocalDate} with the specified year-of-era.\n     *   The era and month will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     * * {@link YEAR} -\n     *   Returns a {@link LocalDate} with the specified year.\n     *   The month will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     * * {@link ERA} -\n     *   Returns a {@link LocalDate} with the specified era.\n     *   The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalDate} a {@link LocalDate} based on `this` with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    withFieldAndValue(field, newValue) {\n        assert(field != null, 'field', NullPointerException);\n        if (field instanceof ChronoField) {\n            const f = field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case ChronoField.DAY_OF_WEEK: return this.plusDays(newValue - this.dayOfWeek().value());\n                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH: return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR: return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case ChronoField.DAY_OF_MONTH: return this.withDayOfMonth(newValue);\n                case ChronoField.DAY_OF_YEAR: return this.withDayOfYear(newValue);\n                case ChronoField.EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n                case ChronoField.ALIGNED_WEEK_OF_MONTH: return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));\n                case ChronoField.ALIGNED_WEEK_OF_YEAR: return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                case ChronoField.MONTH_OF_YEAR: return this.withMonth(newValue);\n                case ChronoField.PROLEPTIC_MONTH: return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n                case ChronoField.YEAR_OF_ERA: return this.withYear((this._year >= 1 ? newValue : 1 - newValue));\n                case ChronoField.YEAR: return this.withYear(newValue);\n                case ChronoField.ERA: return (this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    /**\n     * Returns a copy of this date with the year altered.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * @param {!number} year  the year to set in the result, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested year, not null\n     * @throws {DateTimeException} if the year value is invalid\n     */\n    withYear(year) {\n        if (this._year === year) {\n            return this;\n        }\n        ChronoField.YEAR.checkValidValue(year);\n        return LocalDate._resolvePreviousValid(year, this._month, this._day);\n    }\n\n    /**\n     * Returns a copy of this date with the month-of-year altered.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * @param {!(Month|number)} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested month, not null\n     * @throws {DateTimeException} if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        const m = (month instanceof Month) ? month.value() : month;\n        if (this._month === m) {\n            return this;\n        }\n        ChronoField.MONTH_OF_YEAR.checkValidValue(m);\n        return LocalDate._resolvePreviousValid(this._year, m, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the day-of-month altered.\n     *\n     * If the resulting date is invalid, an exception is thrown.\n     *\n     * @param {!number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {LocalDate} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        if (this._day === dayOfMonth) {\n            return this;\n        }\n        return LocalDate.of(this._year, this._month, dayOfMonth);\n    }\n\n    /**\n     * Returns a copy of this date with the day-of-year altered.\n     * If the resulting date is invalid, an exception is thrown.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-year value is invalid\n     * @throws {DateTimeException} if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        if (this.dayOfYear() === dayOfYear) {\n            return this;\n        }\n        return LocalDate.ofYearDay(this._year, dayOfYear);\n    }\n\n    /**\n     * function overloading for plus\n     *\n     * called with 1 (or less) arguments, p1 is expected to be a TemporalAmount and {@link LocalDate.plus1}\n     * is called.\n     *\n     * Otherwise {@link LocalDate.plus2} is called.\n     *\n     * @param {!(TemporalAmount|number)} p1\n     * @param {TemporalUnit} p2 - required if called with 2 arguments\n     * @return {LocalDate}\n     */\n    plus(p1, p2){\n        if(arguments.length < 2){\n            return this.plus1(p1);\n        } else {\n            return this.plus2(p1, p2);\n        }\n    }\n\n    /**\n     * Returns a copy of this date with the specified period added.\n     *\n     * This method returns a new date based on this date with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link LocalDate.plus2}.\n     *\n     * @param {!TemporalAmount} amount - the amount to add, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the addition made, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    plus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified period added.\n     *\n     * This method returns a new date based on this date with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * @param {!number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {!TemporalUnit} unit - the unit of the period to add, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.DAYS: return this.plusDays(amountToAdd);\n                case ChronoUnit.WEEKS: return this.plusWeeks(amountToAdd);\n                case ChronoUnit.MONTHS: return this.plusMonths(amountToAdd);\n                case ChronoUnit.YEARS: return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS: return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in years added.\n     *\n     * This method adds the specified amount to the years field in three steps:\n     *\n     * 1. Add the input years to the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     *\n     * @param {!number} yearsToAdd - the years to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the years added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        const newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);  // safe overflow\n        return LocalDate._resolvePreviousValid(newYear, this._month, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in months added.\n     *\n     * This method adds the specified amount to the months field in three steps:\n     *\n     * 1. Add the input months to the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     *\n     * @param {number} monthsToAdd - the months to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the months added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        const monthCount = this._year * 12 + (this._month - 1);\n        const calcMonths = monthCount + monthsToAdd;  // safe overflow\n        const newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n        const newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n        return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in weeks added.\n     *\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     *\n     * @param {!number} weeksToAdd - the weeks to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the weeks added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusWeeks(weeksToAdd) {\n        return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));\n    }\n\n\n    /**\n     * Returns a copy of this LocalDate with the specified number of days added.\n     *\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     *\n     * @param {number} daysToAdd - the days to add, may be negative\n     * @return {LocalDate} a LocalDate based on this date with the days added, not null\n     * @throws AssertionError if the result exceeds the supported date range\n     */\n    plusDays(daysToAdd) {\n        if (daysToAdd === 0) {\n            return this;\n        }\n        const mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    }\n\n    /**\n      * function overloading for minus\n      *\n      * called with 1 (or less) arguments, p1 is expected to be a TemporalAmount and {@link LocalDate.minus1}\n      * is called.\n      *\n      * Otherwise {@link LocalDate.minus2} is called.\n      *\n      * @param {!(TemporalAmount|number)} p1\n      * @param {TemporalUnit} p2 - required if called with 2 arguments\n      * @return {LocalDate}\n      */\n    minus(p1, p2){\n        if(arguments.length < 2){\n            return this.minus1(p1);\n        } else {\n            return this.minus2(p1, p2);\n        }\n    }\n\n    /**\n     * Returns a copy of this date with the specified period subtracted.\n     *\n     * This method returns a new date based on this date with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * @param {!TemporalAmount} amount - the amount to subtract, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the subtraction made, not null\n     * @throws {DateTimeException} if the subtraction cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    minus1(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified period subtracted.\n     *\n     * This method returns a new date based on this date with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * @param {!number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {!TemporalUnit} unit  the unit of the period to subtract, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in years subtracted.\n     *\n     * This method subtracts the specified amount from the years field in three steps:\n     *\n     * 1. Subtract the input years to the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     *\n     * @param {!number} yearsToSubtract - the years to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the years subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusYears(yearsToSubtract) {\n        return this.plusYears(yearsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in months subtracted.\n     *\n     * This method subtracts the specified amount from the months field in three steps:\n     *\n     * 1. Subtract the input months to the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     *\n     * @param {!number} monthsToSubtract - the months to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the months subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMonths(monthsToSubtract) {\n        return this.plusMonths(monthsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in weeks subtracted.\n     *\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     *\n     * @param {!number} weeksToSubtract - the weeks to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the weeks subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusWeeks(weeksToSubtract) {\n        return this.plusWeeks(weeksToSubtract * -1);\n    }\n\n    /*\n     * Returns a copy of this LocalDate with the specified number of days subtracted.\n     *\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     *\n     * @param {number} daysToSubtract - the days to subtract, may be negative\n     * @return {LocalDate} a LocalDate based on this date with the days subtracted, not null\n     * @throws AssertionError if the result exceeds the supported date range\n     */\n    minusDays(daysToSubtract) {\n        return this.plusDays(daysToSubtract * -1);\n    }\n\n    /**\n     * Queries this date using the specified query.\n     *\n     * This queries this date using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.localDate()) {\n            return this;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date as this object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField.EPOCH_DAY} as the field.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalDate.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalDate);\n     * </pre>\n     *\n     * @param {!TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return super.adjustInto(temporal);\n    }\n\n    /**\n     * function overloading for {@link LocalDate.until}\n     *\n     * called with 1 (or less) arguments {{@link LocalDate.until1}} is called\n     * otherwise {@link LocalDate.until2}\n     *\n     * @param {!TemporalAccessor} p1\n     * @param {TemporalUnit} p2 - not null if called with 2 arguments\n     * @return {number|Period}\n     */\n    until(p1, p2){\n        if(arguments.length < 2){\n            return this.until1(p1);\n        } else {\n            return this.until2(p1, p2);\n        }\n    }\n\n    /**\n     * Calculates the period between this date and another date in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two dates in terms of a single unit.\n     * The start and end points are `this` and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalDate}.\n     * For example, the period in days between two dates can be calculated\n     * using {@link startDate.until}.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the period in months between 2012-06-15 and 2012-08-14\n     * will only be one month as it is one day short of two months.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link DAYS}, {@link WEEKS}, {@link MONTHS}, {@link YEARS},\n     * {@link DECADES}, {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS}\n     * are supported. Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * @param {!TemporalAccessor} endExclusive - the end date, which is converted to a {@link LocalDate}, not null\n     * @param {!TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date and the end date\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until2(endExclusive, unit) {\n        const end = LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.DAYS: return this.daysUntil(end);\n                case ChronoUnit.WEEKS: return MathUtil.intDiv(this.daysUntil(end), 7);\n                case ChronoUnit.MONTHS: return this._monthsUntil(end);\n                case ChronoUnit.YEARS: return MathUtil.intDiv(this._monthsUntil(end), 12);\n                case ChronoUnit.DECADES: return MathUtil.intDiv(this._monthsUntil(end), 120);\n                case ChronoUnit.CENTURIES: return MathUtil.intDiv(this._monthsUntil(end), 1200);\n                case ChronoUnit.MILLENNIA: return MathUtil.intDiv(this._monthsUntil(end), 12000);\n                case ChronoUnit.ERAS: return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     *\n     * @param {!LocalDate} end\n     * @returns {number}\n     * @protected\n     */\n    daysUntil(end) {\n        return end.toEpochDay() - this.toEpochDay();  // no overflow\n    }\n\n    /**\n     *\n     * @param {!LocalDate} end\n     * @returns {number}\n     * @private\n     */\n    _monthsUntil(end) {\n        const packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();  // no overflow\n        const packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();  // no overflow\n        return MathUtil.intDiv((packed2 - packed1), 32);\n    }\n\n    /**\n     * Calculates the period between this date and another date as a {@link Period}.\n     *\n     * This calculates the period between two dates in terms of years, months and days.\n     * The start and end points are `this` and the specified date.\n     * The result will be negative if the end is before the start.\n     *\n     * The calculation is performed using the ISO calendar system.\n     * If necessary, the input date will be converted to ISO.\n     *\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then normalized into years and months based on a 12 month year.\n     * A month is considered to be complete if the end day-of-month is greater\n     * than or equal to the start day-of-month.\n     * For example, from `2010-01-15` to `2011-03-18` is \"1 year, 2 months and 3 days\".\n     *\n     * The result of this method can be a negative period if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link Period#between}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   period = start.until(end);\n     *   period = Period.between(start, end);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     *\n     * @param {!TemporalAccessor} endDate - the end date, exclusive, which may be in any chronology, not null\n     * @return {Period} the period between this date and the end date, not null\n     */\n    until1(endDate) {\n        const end = LocalDate.from(endDate);\n        let totalMonths = end._prolepticMonth() - this._prolepticMonth();  // safe\n        let days = end._day - this._day;\n        if (totalMonths > 0 && days < 0) {\n            totalMonths--;\n            const calcDate = this.plusMonths(totalMonths);\n            days = (end.toEpochDay() - calcDate.toEpochDay());  // safe\n        } else if (totalMonths < 0 && days > 0) {\n            totalMonths++;\n            days -= end.lengthOfMonth();\n        }\n        const years = MathUtil.intDiv(totalMonths, 12);  // safe\n        const months = MathUtil.intMod(totalMonths, 12);  // safe\n        return Period.of(MathUtil.safeToInt(years), months, days);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDate.atTime}\n     *\n     * if called with 1 argument {@link LocalDate.atTime1} is called\n     * otherwise {@link LocalDate.atTime4}\n     *\n     * @return {LocalDateTime} the local date-time formed from this date and the specified params\n     */\n    atTime(){\n        if(arguments.length===1){\n            return this.atTime1.apply(this, arguments);\n        } else {\n            return this.atTime4.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Combines this date with a time to create a {@link LocalDateTime}.\n     *\n     * This returns a {@link LocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {LocalTime} time - the time to combine with, not null\n     * @return {LocalDateTime} the local date-time formed from this date and the specified time, not null\n     */\n    atTime1(time) {\n        return LocalDateTime.of(this, time);\n    }\n\n    /**\n     * Combines this date with a time to create a {@link LocalDateTime}.\n     *\n     * This returns a {@link LocalDateTime} formed from this date at the\n     * specified hour, minute, second and nanosecond.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {!number} hour - the hour-of-day to use, from 0 to 23\n     * @param {!number} minute - the minute-of-hour to use, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalDateTime} the local date-time formed from this date and the specified time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     */\n    atTime4(hour, minute, second=0, nanoOfSecond=0) {\n        return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));\n    }\n\n    /**\n     * Combines this date with an offset time to create an {@link OffsetDateTime}.\n     *\n     * This returns an {@link OffsetDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {OffsetTime} time - the time to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this date and the specified time, not null\n     */\n/*\n    _atTimeOffsetTime(time) { // atTime(offsetTime)\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.getOffset());\n    }\n*/\n\n    /**\n     * Combines this date with the time of midnight to create a {@link LocalDateTime}\n     * at the start of this date.\n     *\n     * This returns a {@link LocalDateTime} formed from this date at the time of\n     * midnight, 00:00, at the start of this date.\n     *\n     * @param {ZoneId} zone - if zone is not null @see {@link LocalDate.atStartOfDayWithZone}\n     * @return {LocalDateTime|ZonedDateTime} the local date-time of midnight at the start of this date, not null\n     */\n    atStartOfDay(zone) {\n        if(zone != null){\n            return this.atStartOfDayWithZone(zone);\n        } else {\n            return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n        }\n    }\n\n    /**\n     * Combines this date with a time-zone to create a {@link ZonedDateTime}\n     * at the start of the day\n     *\n     * This returns a {@link ZonedDateTime} formed from this date at the\n     * specified zone, with the time set to be the earliest valid time according\n     * to the rules in the time-zone.\n     *\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     *\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     *\n     * To convert to a specific time in a given time-zone call {@link atTime}\n     * followed by {@link LocalDateTime#atZone}.\n     *\n     * @param {!ZoneId} zone - the zone ID to use, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    atStartOfDayWithZone(zone) {\n        requireNonNull(zone, 'zone');\n        let ldt = this.atTime(LocalTime.MIDNIGHT);\n        // need to handle case where there is a gap from 11:30 to 00:30\n        // standard ZDT factory would result in 01:00 rather than 00:30\n        if (zone instanceof ZoneOffset === false) {\n            const trans = zone.rules().transition(ldt);\n            if (trans != null && trans.isGap()) {\n                ldt = trans.dateTimeAfter();\n            }\n        }\n        return ZonedDateTime.of(ldt, zone);\n    }\n\n\n    /**\n     * Converts this date to the Epoch Day.\n     *\n     * The Epoch Day count is a simple incrementing count of days where day 0 is 1970-01-01 (ISO).\n     * This definition is the same for all chronologies, enabling conversion.\n     *\n     * @return {number} the Epoch Day equivalent to this date\n     */\n    toEpochDay() {\n        const y = this._year;\n        const m = this._month;\n        let total = 0;\n        total += 365 * y;\n        if (y >= 0) {\n            total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);\n        } else {\n            total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);\n        }\n        total += MathUtil.intDiv(367 * m - 362, 12);\n        total += this.dayOfMonth() - 1;\n        if (m > 2) {\n            total--;\n            if (!IsoChronology.isLeapYear(y)) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    }\n\n    /**\n     * Compares this date to another date.\n     *\n     * The comparison is primarily based on the date, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * If all the dates being compared are instances of {@link LocalDate},\n     * then the comparison will be entirely based on the date.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDate.compareTo}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalDate, 'other');\n        return this._compareTo0(other);\n        // return super.compareTo(other);  if not instanceof LocalDate\n    }\n\n    /**\n     *\n     * @param {!LocalDate} otherDate\n     * @returns {number}\n     * @private\n     */\n    _compareTo0(otherDate) {\n        let cmp = (this._year - otherDate._year);\n        if (cmp === 0) {\n            cmp = (this._month - otherDate._month);\n            if (cmp === 0) {\n                cmp = (this._day - otherDate._day);\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date is after the specified date.\n     *\n     * This checks to see if this date represents a point on the\n     * local time-line after the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isAfter(b) == false\n     *   a.isAfter(a) == false\n     *   b.isAfter(a) == true\n     * </pre>\n     *\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is after the specified date\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n        // return super.isAfter(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is before the specified date.\n     *\n     * This checks to see if this date represents a point on the\n     * local time-line before the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isBefore(b) == true\n     *   a.isBefore(a) == false\n     *   b.isBefore(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is before the specified date\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n        // return super.isBefore(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is equal to the specified date.\n     *\n     * This checks to see if this date represents the same point on the\n     * local time-line as the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isEqual(b) == false\n     *   a.isEqual(a) == true\n     *   b.isEqual(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo}\n     * but is the same approach as {@link DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is equal to the specified date\n     */\n    isEqual(other) {\n        return this.compareTo(other) === 0;\n        // return super.isEqual(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is equal to another date.\n     *\n     * Compares this LocalDate with another ensuring that the date is the same.\n     *\n     * Only objects of type LocalDate are compared, other types return false.\n     *\n     * @param {*} otherDate - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date\n     */\n    equals(otherDate) {\n        if (this === otherDate) {\n            return true;\n        }\n        if (otherDate instanceof LocalDate) {\n            return this._compareTo0(otherDate) === 0;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        const yearValue = this._year;\n        const monthValue = this._month;\n        const dayValue = this._day;\n        return (yearValue & 0xFFFFF800) ^ ((yearValue << 11) + (monthValue << 6) + (dayValue));\n    }\n\n    /**\n     * Outputs this date as a String, such as 2007-12-03.\n     * The output will be in the ISO-8601 format uuuu-MM-dd.\n     *\n     * @return {string} a string representation of this date, not null\n     */\n    toString() {\n        let dayString, monthString, yearString;\n\n        const yearValue = this._year;\n        const monthValue = this._month;\n        const dayValue = this._day;\n\n        const absYear = Math.abs(yearValue);\n\n        if (absYear < 1000) {\n            if (yearValue < 0) {\n                yearString = '-' + ('' + (yearValue - 10000)).slice(-4);\n            } else {\n                yearString = ('' + (yearValue + 10000)).slice(-4);\n            }\n        } else {\n            if (yearValue > 9999) {\n                yearString = '+' + yearValue;\n            } else {\n                yearString = '' + yearValue;\n            }\n        }\n\n        if (monthValue < 10) {\n            monthString = '-0' + monthValue;\n        } else {\n            monthString = '-' + monthValue;\n        }\n\n        if (dayValue < 10) {\n            dayString = '-0' + dayValue;\n        } else {\n            dayString = '-' + dayValue;\n        }\n\n        return yearString + monthString + dayString;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalDate.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this date as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return super.format(formatter);\n    }\n}\n\nexport function _init() {\n    /**\n     * The minimum supported {@link LocalDate}\n     * This could be used by an application as a \"far past\" date.\n     */\n    LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);\n    /**\n     * The maximum supported {@link LocalDate}\n     * This could be used by an application as a \"far future\" date.\n     */\n    LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);\n    /**\n     * The date at epoch day 0, that is 1970-01-01.\n     */\n    LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);\n\n    LocalDate.FROM = createTemporalQuery('LocalDate.FROM', (temporal) => {\n        return LocalDate.from(temporal);\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/LocalDate.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {Enum} from '../Enum';\nimport {requireNonNull} from '../assert';\nimport {DateTimeException} from '../errors';\nimport {MathUtil} from '../MathUtil';\n\nimport {DayOfWeek} from '../DayOfWeek';\nimport {LocalDate} from '../LocalDate';\nimport {Month} from '../Month';\nimport {Year} from '../Year';\n\nimport {ChronoField} from '../temporal/ChronoField';\nimport {ResolverStyle} from '../format/ResolverStyle';\nimport {TemporalAdjusters} from '../temporal/TemporalAdjusters';\n\nexport class IsoChronology extends Enum{\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @param {number} prolepticYear - the ISO proleptic year to check\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    static isLeapYear(prolepticYear) {\n        return ((prolepticYear & 3) === 0) && ((prolepticYear % 100) !== 0 || (prolepticYear % 400) === 0);\n    }\n\n    /**\n     * Updates the map of field-values during resolution.\n     *\n     * @param {EnumMap} fieldValues  the fieldValues map to update, not null\n     * @param {ChronoField} field  the field to update, not null\n     * @param {number} value  the value to update, not null\n     * @throws DateTimeException if a conflict occurs\n     */\n    _updateResolveMap(fieldValues, field, value) {\n        // TODO: this function is in Chronology in threetenbp, maybe needs to be moved?\n        requireNonNull(fieldValues, 'fieldValues');\n        requireNonNull(field, 'field');\n        let current = fieldValues.get(field);\n        if (current != null && current !== value) {\n            throw new DateTimeException('Invalid state, field: ' + field + ' ' + current + ' conflicts with ' + field + ' ' + value);\n        }\n        fieldValues.put(field, value);\n    }\n\n    resolveDate(fieldValues, resolverStyle) {\n        if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n            return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));\n        }\n\n        // normalize fields\n        let prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);\n        if (prolepticMonth != null) {\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);\n            }\n            this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);\n            this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));\n        }\n\n        // eras\n        let yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);\n        if (yoeLong != null) {\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);\n            }\n            let era = fieldValues.remove(ChronoField.ERA);\n            if (era == null) {\n                let year = fieldValues.get(ChronoField.YEAR);\n                if (resolverStyle === ResolverStyle.STRICT) {\n                    // do not invent era if strict, but do cross-check with year\n                    if (year != null) {\n                        this._updateResolveMap(fieldValues, ChronoField.YEAR, (year > 0 ? yoeLong: MathUtil.safeSubtract(1, yoeLong)));\n                    } else {\n                        // reinstate the field removed earlier, no cross-check issues\n                        fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);\n                    }\n                } else {\n                    // invent era\n                    this._updateResolveMap(fieldValues, ChronoField.YEAR, (year == null || year > 0 ? yoeLong: MathUtil.safeSubtract(1, yoeLong)));\n                }\n            } else if (era === 1) {\n                this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);\n            } else if (era === 0) {\n                this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));\n            } else {\n                throw new DateTimeException('Invalid value for era: ' + era);\n            }\n        } else if (fieldValues.containsKey(ChronoField.ERA)) {\n            ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));  // always validated\n        }\n\n        // build date\n        if (fieldValues.containsKey(ChronoField.YEAR)) {\n            if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {\n                if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {\n                    const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    const moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);\n                    let dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        const months = moy - 1;\n                        const days = dom - 1;\n                        return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);\n                    } else if (resolverStyle === ResolverStyle.SMART){\n                        ChronoField.DAY_OF_MONTH.checkValidValue(dom);\n                        if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {\n                            dom = Math.min(dom, 30);\n                        } else if (moy === 2) {\n                            dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));\n                        }\n                        return LocalDate.of(y, moy, dom);\n                    } else {\n                        return LocalDate.of(y, moy, dom);\n                    }\n                }\n/*\n                if (fieldValues.containsKey(ALIGNED_WEEK_OF_MONTH)) {\n                    if (fieldValues.containsKey(ALIGNED_DAY_OF_WEEK_IN_MONTH)) {\n                        int y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                        if (resolverStyle == ResolverStyle.LENIENT) {\n                            long months = Jdk8Methods.safeSubtract(fieldValues.remove(ChronoField.MONTH_OF_YEAR), 1);\n                            long weeks = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);\n                            long days = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH), 1);\n                            return LocalDate.of(y, 1, 1).plusMonths(months).plusWeeks(weeks).plusDays(days);\n                        }\n                        int moy = ChronoField.MONTH_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.MONTH_OF_YEAR));\n                        int aw = ALIGNED_WEEK_OF_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH));\n                        int ad = ALIGNED_DAY_OF_WEEK_IN_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                        LocalDate date = LocalDate.of(y, moy, 1).plusDays((aw - 1) * 7 + (ad - 1));\n                        if (resolverStyle == ResolverStyle.STRICT && date.get(ChronoField.MONTH_OF_YEAR) != moy) {\n                            throw new DateTimeException(\"Strict mode rejected date parsed to a different month\");\n                        }\n                        return date;\n                    }\n                    if (fieldValues.containsKey(DAY_OF_WEEK)) {\n                        int y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                        if (resolverStyle == ResolverStyle.LENIENT) {\n                            long months = Jdk8Methods.safeSubtract(fieldValues.remove(ChronoField.MONTH_OF_YEAR), 1);\n                            long weeks = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);\n                            long days = Jdk8Methods.safeSubtract(fieldValues.remove(DAY_OF_WEEK), 1);\n                            return LocalDate.of(y, 1, 1).plusMonths(months).plusWeeks(weeks).plusDays(days);\n                        }\n                        int moy = ChronoField.MONTH_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.MONTH_OF_YEAR));\n                        int aw = ALIGNED_WEEK_OF_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH));\n                        int dow = DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(DAY_OF_WEEK));\n                        LocalDate date = LocalDate.of(y, moy, 1).plusWeeks(aw - 1).with(nextOrSame(DayOfWeek.of(dow)));\n                        if (resolverStyle == ResolverStyle.STRICT && date.get(ChronoField.MONTH_OF_YEAR) != moy) {\n                            throw new DateTimeException(\"Strict mode rejected date parsed to a different month\");\n                        }\n                        return date;\n                    }\n                }\n*/\n            }\n            if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {\n                const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                if (resolverStyle === ResolverStyle.LENIENT) {\n                    const days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);\n                    return LocalDate.ofYearDay(y, 1).plusDays(days);\n                }\n                const doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));\n                return LocalDate.ofYearDay(y, doy);\n            }\n            if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {\n                if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {\n                    const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        const weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n                        const days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);\n                        return LocalDate.of(y, 1, 1).plusWeeks(weeks).plusDays(days);\n                    }\n                    const aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                    const ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                    const date = LocalDate.of(y, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));\n                    if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== y) {\n                        throw new DateTimeException('Strict mode rejected date parsed to a different year');\n                    }\n                    return date;\n                }\n                if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {\n                    const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        const weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n                        const days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);\n                        return LocalDate.of(y, 1, 1).plusWeeks(weeks).plusDays(days);\n                    }\n                    const aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                    const dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));\n                    const date = LocalDate.of(y, 1, 1).plusWeeks(aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));\n                    if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== y) {\n                        throw new DateTimeException('Strict mode rejected date parsed to a different month');\n                    }\n                    return date;\n                }\n            }\n        }\n        return null;\n    }\n\n}\n\nexport function _init() {\n    IsoChronology.INSTANCE = new IsoChronology('IsoChronology');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/chrono/IsoChronology.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n/***\n * Base class for a pseudo enum\n */\nexport class Enum {\n    constructor(name){\n        this._name = name;\n    }\n\n    equals(other){\n        return this === other;\n    }\n\n    toString() {\n        return this._name;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Enum.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {DateTimeException, UnsupportedTemporalTypeException, NullPointerException} from './errors';\nimport {MathUtil} from './MathUtil';\nimport {assert, requireNonNull} from './assert';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {IllegalArgumentException} from './errors';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\n\n/**\n * ### Static properties of Class {@link DayOfWeek}\n *\n * DayOfWeek.MONDAY,\n * DayOfWeek.TUESDAY,\n * DayOfWeek.WEDNESDAY,\n * DayOfWeek.THURSDAY,\n * DayOfWeek.FRIDAY,\n * DayOfWeek.SATURDAY,\n * DayOfWeek.SUNDAY\n *\n */\nexport class DayOfWeek extends Temporal {\n\n    /**\n     *\n     * @param {number} ordinal\n     * @param {string} name\n     * @private\n     */\n    constructor(ordinal, name){\n        super();\n        this._ordinal = ordinal;\n        this._name = name;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    ordinal(){\n        return this._ordinal;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    name(){\n        return this._name;\n    }\n\n    /**\n     *\n     * @returns {DayOfWeek[]}\n     */\n    static values() {\n        return ENUMS.slice();\n    }\n\n    /**\n     *\n     * @param {string} name\n     * @returns {DayOfWeek}\n     */\n    static valueOf(name) {\n        let ordinal = 0;\n        for(ordinal; ordinal < ENUMS.length; ordinal++){\n            if(ENUMS[ordinal].name() === name){\n                break;\n            }\n        }\n        return DayOfWeek.of(ordinal+1);\n    }\n\n    /**\n     * Obtains an instance of {@link DayOfWeek} from an `int` value.\n     *\n     * {@link DayOfWeek} is an enum representing the 7 days of the week.\n     * This factory allows the enum to be obtained from the `int` value.\n     * The `int` value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).\n     *\n     * @param {!number} dayOfWeek  the day-of-week to represent, from 1 (Monday) to 7 (Sunday)\n     * @return {DayOfWeek} the day-of-week singleton, not null\n     * @throws DateTimeException if the day-of-week is invalid\n     */\n    static of(dayOfWeek) {\n        if (dayOfWeek < 1 || dayOfWeek > 7) {\n            throw new DateTimeException('Invalid value for DayOfWeek: ' + dayOfWeek);\n        }\n        return ENUMS[dayOfWeek - 1];\n    }\n\n    /**\n     * Obtains an instance of {@link DayOfWeek} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link DayOfWeek}.\n     *\n     * The conversion extracts the {@link ChronoField#DAY_OF_WEEK} field.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link DayOfWeek::from}.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {DayOfWeek} the day-of-week, not null\n     * @throws DateTimeException if unable to convert to a {@link DayOfWeek}\n     */\n    static from(temporal) {\n        assert(temporal != null, 'temporal', NullPointerException);\n        if (temporal instanceof DayOfWeek) {\n            return temporal;\n        }\n        try {\n            return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));\n        } catch (ex) {\n            if(ex instanceof DateTimeException) {\n                throw new DateTimeException('Unable to obtain DayOfWeek from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''), ex);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    /**\n     * Gets the day-of-week `int` value.\n     *\n     * The values are numbered following the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).\n     * See {@link WeekFields#dayOfWeek} for localized week-numbering.\n     *\n     * @return {number} the day-of-week, from 1 (Monday) to 7 (Sunday)\n     */\n    value() {\n        return this._ordinal + 1;\n    }\n\n    /**\n     * Gets the textual representation, such as 'Mon' or 'Friday'.\n     *\n     * This returns the textual name used to identify the day-of-week.\n     * The parameters control the length of the returned text and the locale.\n     *\n     * If no textual mapping is found then the numeric value (see {@link getValue}) is returned.\n     *\n     * @param {TextStyle} style - the length of the text required, not null\n     * @param {Locale} locale - the locale to use, not null\n     * @return {string} the text value of the day-of-week, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    getDisplayName(style, locale) {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n        // return new DateTimeFormatterBuilder().appendText(ChronoField.DAY_OF_WEEK, style).toFormatter(locale).format(this);\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this day-of-week can be queried for the specified field.\n     * If false, then calling the {@link range} and\n     * {@link get} methods will throw an exception.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then\n     * this method returns true.\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this day-of-week, false if not\n     */\n    isSupported(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.DAY_OF_WEEK;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This day-of-week is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then the\n     * range of the day-of-week, from 1 to 7, will be returned.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return field.range();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-week as an `int`.\n     *\n     * This queries this day-of-week for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then the\n     * value of the day-of-week, from 1 to 7, will be returned.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws DateTimeException if the range of valid values for the field exceeds an `int`\n     * @throws DateTimeException if the value is outside the range of valid values for the field\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return this.value();\n        }\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-week as a `long`.\n     *\n     * This queries this day-of-week for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then the\n     * value of the day-of-week, from 1 to 7, will be returned.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return this.value();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the day-of-week that is the specified number of days after this one.\n     *\n     * The calculation rolls around the end of the week from Sunday to Monday.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, positive or negative\n     * @return {DayOfWeek} the resulting day-of-week, not null\n     */\n    plus(days) {\n        const amount = MathUtil.floorMod(days, 7);\n        return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];\n    }\n\n    /**\n     * Returns the day-of-week that is the specified number of days before this one.\n     *\n     * The calculation rolls around the start of the year from Monday to Sunday.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, positive or negative\n     * @return {DayOfWeek} the resulting day-of-week, not null\n     */\n    minus(days) {\n        return this.plus(-1 * MathUtil.floorMod(days, 7));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this day-of-week using the specified query.\n     *\n     * This queries this day-of-week using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.DAYS;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() || query === TemporalQueries.chronology() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        assert(query != null, 'query', NullPointerException);\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this day-of-week.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the day-of-week changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#DAY_OF_WEEK} as the field.\n     * Note that this adjusts forwards or backwards within a Monday to Sunday week.\n     * See {@link WeekFields#dayOfWeek} for localized week start days.\n     * See {@link TemporalAdjusters} for other adjusters\n     * with more control, such as `next(MONDAY)`.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisDayOfWeek.adjustInto(temporal);\n     *   temporal = temporal.with(thisDayOfWeek);\n     * </pre>\n     *\n     * For example, given a date that is a Wednesday, the following are output:\n     * <pre>\n     *   dateOnWed.with(MONDAY);     // two days earlier\n     *   dateOnWed.with(TUESDAY);    // one day earlier\n     *   dateOnWed.with(WEDNESDAY);  // same date\n     *   dateOnWed.with(THURSDAY);   // one day later\n     *   dateOnWed.with(FRIDAY);     // two days later\n     *   dateOnWed.with(SATURDAY);   // three days later\n     *   dateOnWed.with(SUNDAY);     // four days later\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjusters} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        return temporal.with(ChronoField.DAY_OF_WEEK, this.value());\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    equals(other){\n        return this === other;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return this._name;\n    }\n}\n\nlet ENUMS;\n\nexport function _init() {\n    DayOfWeek.MONDAY = new DayOfWeek(0, 'MONDAY');\n    DayOfWeek.TUESDAY = new DayOfWeek(1, 'TUESDAY');\n    DayOfWeek.WEDNESDAY = new DayOfWeek(2, 'WEDNESDAY');\n    DayOfWeek.THURSDAY = new DayOfWeek(3, 'THURSDAY');\n    DayOfWeek.FRIDAY = new DayOfWeek(4, 'FRIDAY');\n    DayOfWeek.SATURDAY = new DayOfWeek(5, 'SATURDAY');\n    DayOfWeek.SUNDAY = new DayOfWeek(6, 'SUNDAY');\n\n    DayOfWeek.FROM = createTemporalQuery('DayOfWeek.FROM', (temporal) => {\n        return DayOfWeek.from(temporal);\n    });\n\n    ENUMS = [\n        DayOfWeek.MONDAY,\n        DayOfWeek.TUESDAY,\n        DayOfWeek.WEDNESDAY,\n        DayOfWeek.THURSDAY,\n        DayOfWeek.FRIDAY,\n        DayOfWeek.SATURDAY,\n        DayOfWeek.SUNDAY\n    ];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/DayOfWeek.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MAX_SAFE_INTEGER, MIN_SAFE_INTEGER} from '../MathUtil';\n\nimport {ChronoUnit} from './ChronoUnit';\nimport {TemporalField} from './TemporalField';\nimport {ValueRange} from './ValueRange';\nimport {YearConstants} from '../YearConstants';\n\n/**\n * A standard set of fields.\n *\n * This set of fields provide field-based access to manipulate a date, time or date-time.\n * The standard set of fields can be extended by implementing {@link TemporalField}.\n *\n * These fields are intended to be applicable in multiple calendar systems.\n * For example, most non-ISO calendar systems define dates as a year, month and day,\n * just with slightly different rules.\n * The documentation of each field explains how it operates.\n * \n * ### Static properties of Class {@link ChronoField}\n * \n * ChronoField.NANO_OF_SECOND\n *\n * ChronoField.NANO_OF_DAY\n *\n * ChronoField.MICRO_OF_SECOND\n *\n * ChronoField.MICRO_OF_DAY\n *\n * ChronoField.MILLI_OF_SECOND\n *\n * ChronoField.MILLI_OF_DAY\n *\n * ChronoField.SECOND_OF_MINUTE\n *\n * ChronoField.SECOND_OF_DAY\n *\n * ChronoField.MINUTE_OF_HOUR\n *\n * ChronoField.MINUTE_OF_DAY\n *\n * ChronoField.HOUR_OF_AMPM\n *\n * ChronoField.CLOCK_HOUR_OF_AMPM\n *\n * ChronoField.HOUR_OF_DAY\n *\n * ChronoField.CLOCK_HOUR_OF_DAY\n *\n * ChronoField.AMPM_OF_DAY\n *\n * ChronoField.DAY_OF_WEEK\n *\n * ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH\n *\n * ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR\n *\n * ChronoField.DAY_OF_MONTH\n *\n * ChronoField.DAY_OF_YEAR\n *\n * ChronoField.EPOCH_DAY\n *\n * ChronoField.ALIGNED_WEEK_OF_MONTH\n *\n * ChronoField.ALIGNED_WEEK_OF_YEAR\n *\n * ChronoField.MONTH_OF_YEAR\n *\n * ChronoField.PROLEPTIC_MONTH\n *\n * ChronoField.YEAR_OF_ERA\n *\n * ChronoField.YEAR\n *\n * ChronoField.ERA\n *\n * ChronoField.INSTANT_SECONDS\n *\n * ChronoField.OFFSET_SECONDS\n *\n */\nexport class ChronoField extends TemporalField {\n    \n    /**\n     * helper function to get one of the static ChronoField defines by name, needed to resolve ChronoField from EnumMap\n     *\n     * @param {String} fieldName\n     * @return {ChronoField | null}\n     */\n    static byName(fieldName) {\n        for (let prop in ChronoField) {\n            if (ChronoField.hasOwnProperty(prop)) {\n                if ((ChronoField[prop] instanceof ChronoField) && ChronoField[prop].name() === fieldName) {\n                    return ChronoField[prop];\n                }\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {!string} name\n     * @param {!number} baseUnit\n     * @param {!number} rangeUnit\n     * @param {!ValueRange} range\n     */\n    constructor(name, baseUnit, rangeUnit, range) {\n        super();\n        this._name = name;\n        this._baseUnit = baseUnit;\n        this._rangeUnit = rangeUnit;\n        this._range = range;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    name(){\n        return this._name;    \n    }\n\n    /**\n     *\n     * @returns {!number}\n     */\n    baseUnit(){\n        return this._baseUnit;    \n    }\n\n    /**\n     *\n     * @returns {!number}\n     */\n    rangeUnit(){\n        return this._rangeUnit;    \n    }\n\n    /**\n     *\n     * @returns {!ValueRange}\n     */\n    range(){\n        return this._range;    \n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    displayName(){\n        return this.toString();    \n    }\n\n    /**\n     *\n     * @param {number} value\n     * @returns {*}\n     */\n    checkValidValue(value) {\n        return this.range().checkValidValue(value, this.name());\n    }\n\n    /**\n     * Checks if this field represents a component of a date.\n     *\n     * @return {boolean} true if it is a component of a date\n     */\n    isDateBased() {\n        const dateBased =\n            this === ChronoField.DAY_OF_WEEK ||\n            this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH ||\n            this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR ||\n            this === ChronoField.DAY_OF_MONTH ||\n            this === ChronoField.DAY_OF_YEAR ||\n            this === ChronoField.EPOCH_DAY ||\n            this === ChronoField.ALIGNED_WEEK_OF_MONTH ||\n            this === ChronoField.ALIGNED_WEEK_OF_YEAR ||\n            this === ChronoField.MONTH_OF_YEAR ||\n            //this === ChronoField.EPOCH_MONTH ||\n            this === ChronoField.YEAR_OF_ERA ||\n            this === ChronoField.YEAR ||\n            this === ChronoField.ERA;\n        return dateBased;\n    }\n\n    /**\n     * Checks if this field represents a component of a time.\n     *\n     * @return {boolean} true if it is a component of a time\n     */\n    isTimeBased() {\n        const timeBased =\n            this === ChronoField.NANO_OF_SECOND     ||\n            this === ChronoField.NANO_OF_DAY        ||\n            this === ChronoField.MICRO_OF_SECOND    ||\n            this === ChronoField.MICRO_OF_DAY       ||\n            this === ChronoField.MILLI_OF_SECOND    ||\n            this === ChronoField.MILLI_OF_DAY       ||\n            this === ChronoField.SECOND_OF_MINUTE   ||\n            this === ChronoField.SECOND_OF_DAY      ||\n            this === ChronoField.MINUTE_OF_HOUR     ||\n            this === ChronoField.MINUTE_OF_DAY      ||\n            this === ChronoField.HOUR_OF_AMPM       ||\n            this === ChronoField.CLOCK_HOUR_OF_AMPM ||\n            this === ChronoField.HOUR_OF_DAY        ||\n            this === ChronoField.CLOCK_HOUR_OF_DAY  ||\n            this === ChronoField.AMPM_OF_DAY;\n        return timeBased;\n    }\n\n    /**\n     * Get the range of valid values for this field using the temporal object to\n     * refine the result.\n     *\n     * This uses the temporal object to find the range of valid values for the field.\n     * This is similar to {@link range}, however this method refines the result\n     * using the temporal. For example, if the field is {@link DAY_OF_MONTH} the\n     * {@link range} method is not accurate as there are four possible month lengths,\n     * 28, 29, 30 and 31 days. Using this method with a date allows the range to be\n     * accurate, returning just one of those four options.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#range}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisField.rangeRefinedBy(temporal);\n     *   temporal = temporal.range(thisField);\n     * </pre>\n     * It is recommended to use the second approach, {@link range},\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the fields\n     * available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object used to refine the result, not null\n     * @return {ValueRange} the range of valid values for this field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    rangeRefinedBy(temporal) {\n        return temporal.range(this);\n    }\n\n    /**\n     * Checks that the specified value is valid and fits in an `int`.\n     *\n     * This validates that the value is within the outer range of valid values\n     * returned by {@link range}.\n     * It also checks that all valid values are within the bounds of an `int`.\n     *\n     * This method checks against the range of the field in the ISO-8601 calendar system.\n     * This range may be incorrect for other calendar systems.\n     * Use {@link Chronology#range} to access the correct range\n     * for a different calendar system.\n     *\n     * @param {number} value - the value to check\n     * @return {number} the value that was passed in\n     */\n    checkValidIntValue(value) {\n        return this.range().checkValidIntValue(value, this);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        return temporal.getLong(this);\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return this.name();\n    }\n\n    /**\n     *\n     * @param {*} other\n     * @returns {boolean}\n     */\n    equals(other){\n        return this === other;\n    }\n}\n\nexport function _init() {\n\n    ChronoField.NANO_OF_SECOND = new ChronoField('NanoOfSecond', ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));\n\n    ChronoField.NANO_OF_DAY = new ChronoField('NanoOfDay', ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));\n\n    ChronoField.MICRO_OF_SECOND = new ChronoField('MicroOfSecond', ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));\n\n    ChronoField.MICRO_OF_DAY = new ChronoField('MicroOfDay', ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));\n\n    ChronoField.MILLI_OF_SECOND = new ChronoField('MilliOfSecond', ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));\n\n    ChronoField.MILLI_OF_DAY = new ChronoField('MilliOfDay', ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));\n\n    ChronoField.SECOND_OF_MINUTE = new ChronoField('SecondOfMinute', ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));\n\n    ChronoField.SECOND_OF_DAY = new ChronoField('SecondOfDay', ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));\n\n    ChronoField.MINUTE_OF_HOUR = new ChronoField('MinuteOfHour', ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));\n\n    ChronoField.MINUTE_OF_DAY = new ChronoField('MinuteOfDay', ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, (24 * 60) - 1));\n\n    ChronoField.HOUR_OF_AMPM = new ChronoField('HourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));\n\n    ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField('ClockHourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));\n\n    ChronoField.HOUR_OF_DAY = new ChronoField('HourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));\n\n    ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField('ClockHourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));\n\n    ChronoField.AMPM_OF_DAY = new ChronoField('AmPmOfDay', ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));\n\n    ChronoField.DAY_OF_WEEK = new ChronoField('DayOfWeek', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField('AlignedDayOfWeekInMonth', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField('AlignedDayOfWeekInYear', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.DAY_OF_MONTH = new ChronoField('DayOfMonth', ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), 'day');\n\n    ChronoField.DAY_OF_YEAR = new ChronoField('DayOfYear', ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));\n\n    ChronoField.EPOCH_DAY = new ChronoField('EpochDay', ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(Math.floor(YearConstants.MIN_VALUE * 365.25), Math.floor(YearConstants.MAX_VALUE * 365.25)));\n\n    ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField('AlignedWeekOfMonth', ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));\n\n    ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField('AlignedWeekOfYear', ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));\n\n    ChronoField.MONTH_OF_YEAR = new ChronoField('MonthOfYear', ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), 'month');\n\n    ChronoField.PROLEPTIC_MONTH = new ChronoField('ProlepticMonth', ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));\n\n    ChronoField.YEAR_OF_ERA = new ChronoField('YearOfEra', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));\n\n    ChronoField.YEAR = new ChronoField('Year', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), 'year');\n\n    ChronoField.ERA = new ChronoField('Era', ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));\n\n    ChronoField.INSTANT_SECONDS = new ChronoField('InstantSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));\n\n    ChronoField.OFFSET_SECONDS = new ChronoField('OffsetSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/ChronoField.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MathUtil} from '../MathUtil';\n\nimport {Duration} from '../Duration';\nimport {YearConstants} from '../YearConstants';\nimport {TemporalUnit} from './TemporalUnit';\n\n/**\n * A standard set of date periods units.\n *\n * This set of units provide unit-based access to manipulate a date, time or date-time.\n * The standard set of units can be extended by implementing {@link TemporalUnit}.\n *\n * These units are intended to be applicable in multiple calendar systems.\n * For example, most non-ISO calendar systems define units of years, months and days,\n * just with slightly different rules.\n * The documentation of each unit explains how it operates.\n *\n * ### Static properties of Class {@link ChronoUnit}\n *\n * ChronoUnit.NANOS\n *\n * Unit that represents the concept of a nanosecond, the smallest supported unit of time.\n * For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.\n *\n * ChronoUnit.MICROS\n *\n * Unit that represents the concept of a microsecond.\n * For the ISO calendar system, it is equal to the 1,000,000th part of the second unit.\n *\n * ChronoUnit.MILLIS\n *\n * Unit that represents the concept of a millisecond.\n * For the ISO calendar system, it is equal to the 1000th part of the second unit.\n *\n * ChronoUnit.SECONDS\n *\n * Unit that represents the concept of a second.\n * For the ISO calendar system, it is equal to the second in the SI system\n * of units, except around a leap-second.\n *\n * ChronoUnit.MINUTES\n *\n * Unit that represents the concept of a minute.\n * For the ISO calendar system, it is equal to 60 seconds.\n *\n * ChronoUnit.HOURS\n *\n * Unit that represents the concept of an hour.\n * For the ISO calendar system, it is equal to 60 minutes.\n *\n * ChronoUnit.HALF_DAYS\n *\n * Unit that represents the concept of half a day, as used in AM/PM.\n * For the ISO calendar system, it is equal to 12 hours.\n *\n * ChronoUnit.DAYS\n *\n * Unit that represents the concept of a day.\n * For the ISO calendar system, it is the standard day from midnight to midnight.\n * The estimated duration of a day is 24 hours.\n *\n * When used with other calendar systems it must correspond to the day defined by\n * the rising and setting of the Sun on Earth. It is not required that days begin\n * at midnight - when converting between calendar systems, the date should be\n * equivalent at midday.\n *\n * ChronoUnit.WEEKS\n *\n * Unit that represents the concept of a week.\n * For the ISO calendar system, it is equal to 7 days.\n *\n * When used with other calendar systems it must correspond to an integral number of days.\n *\n * ChronoUnit.MONTHS\n *\n * Unit that represents the concept of a month.\n * For the ISO calendar system, the length of the month varies by month-of-year.\n * The estimated duration of a month is one twelfth of 365.2425 days.\n *\n * When used with other calendar systems it must correspond to an integral number of days.\n *\n * ChronoUnit.YEARS\n *\n * Unit that represents the concept of a year.\n * For the ISO calendar system, it is equal to 12 months.\n * The estimated duration of a year is 365.2425 days.\n *\n * When used with other calendar systems it must correspond to an integral number of days\n * or months roughly equal to a year defined by the passage of the Earth around the Sun.\n *\n * ChronoUnit.DECADES\n *\n * Unit that represents the concept of a decade.\n * For the ISO calendar system, it is equal to 10 years.\n *\n * When used with other calendar systems it must correspond to an integral number of days\n * and is normally an integral number of years.\n *\n * ChronoUnit.CENTURIES\n *\n * Unit that represents the concept of a century.\n * For the ISO calendar system, it is equal to 100 years.\n *\n * When used with other calendar systems it must correspond to an integral number of days\n * and is normally an integral number of years.\n *\n * ChronoUnit.MILLENNIA\n *\n * Unit that represents the concept of a millennium.\n * For the ISO calendar system, it is equal to 1000 years.\n *\n * When used with other calendar systems it must correspond to an integral number of days\n * and is normally an integral number of years.\n *\n * ChronoUnit.ERAS\n *\n * Unit that represents the concept of an era.\n * The ISO calendar system doesn't have eras thus it is impossible to add\n * an era to a date or date-time.\n * The estimated duration of the era is artificially defined as {Year.MAX_VALUE} + 1.\n *\n * When used with other calendar systems there are no restrictions on the unit.\n *\n * ChronoUnit.FOREVER\n *\n * Artificial unit that represents the concept of forever.\n * This is primarily used with {@link TemporalField} to represent unbounded fields\n * such as the year or era.\n * The estimated duration of the era is artificially defined as the largest duration\n * supported by {@link Duration}.\n *\n */\nexport class ChronoUnit extends TemporalUnit {\n\n    /**\n     *\n     * @param {String} name\n     * @param {Duration} estimatedDuration\n     */\n    constructor (name, estimatedDuration) {\n        super();\n        this._name = name;\n        this._duration = estimatedDuration;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the estimated duration of this unit in the ISO calendar system.\n     *\n     * All of the units in this class have an estimated duration.\n     * Days vary due to daylight saving time, while months have different lengths.\n     *\n     * @return {Duration} the estimated duration of this unit, not null\n     */\n    duration() {\n        return this._duration;\n    }\n\n    /**\n     * Checks if the duration of the unit is an estimate.\n     *\n     * All time units in this class are considered to be accurate, while all date\n     * units in this class are considered to be estimated.\n     *\n     * This definition ignores leap seconds, but considers that Days vary due to\n     * daylight saving time and months have different lengths.\n     *\n     * @return {boolean} true if the duration is estimated, false if accurate\n     */\n    isDurationEstimated() {\n        return this.isDateBased() || this === ChronoUnit.FOREVER;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this unit is a date unit.\n     *\n     * @return true if a date unit, false if a time unit\n     */\n    isDateBased() {\n        return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;\n    }\n\n    /**\n     * Checks if this unit is a time unit.\n     *\n     * @return true if a time unit, false if a date unit\n     */\n    isTimeBased() {\n        return this.compareTo(ChronoUnit.DAYS) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this unit is supported by the specified temporal object.\n     *\n     * This checks that the implementing date-time can add/subtract this unit.\n     * This can be used to avoid throwing an exception.\n     *\n     * This default implementation derives the value using\n     * {@link Temporal#plus}.\n     *\n     * @param {Temporal} temporal  the temporal object to check, not null\n     * @return {boolean} true if the unit is supported\n     */\n    isSupportedBy(temporal) {\n        if (this === ChronoUnit.FOREVER) {\n            return false;\n        }\n        /* TODO: classes not implemented yet */\n/*\n        if (temporal instanceof ChronoLocalDate) {\n            return isDateBased();\n        }\n        if (temporal instanceof ChronoLocalDateTime || temporal instanceof ChronoZonedDateTime) {\n            return true;\n        }\n*/\n        try {\n            temporal.plus(1, this);\n            return true;\n        } catch (e) {\n            try {\n                temporal.plus(-1, this);\n                return true;\n            } catch (e2) {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Returns a copy of the specified temporal object with the specified period added.\n     *\n     * The period added is a multiple of this unit. For example, this method\n     * could be used to add \"3 days\" to a date by calling this method on the\n     * instance representing \"days\", passing the date and the period \"3\".\n     * The period to be added may be negative, which is equivalent to subtraction.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisUnit.addTo(temporal);\n     *   temporal = temporal.plus(thisUnit);\n     * </pre>\n     * It is recommended to use the second approach, {@link plus},\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the units\n     * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the unit is not supported an {@link UnsupportedTemporalTypeException} must be thrown.\n     *\n     * Implementations must not alter the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {Temporal} temporal  the temporal object to adjust, not null\n     * @param {Number} amount  the amount of this unit to add, positive or negative\n     * @return {Temporal} the adjusted temporal object, not null\n     * @throws DateTimeException if the amount cannot be added\n     * @throws UnsupportedTemporalTypeException if the unit is not supported by the temporal\n     */\n    addTo(temporal, amount) {\n        return temporal.plus(amount, this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the amount of time between two temporal objects.\n     *\n     * This calculates the amount in terms of this unit. The start and end\n     * points are supplied as temporal objects and must be of compatible types.\n     * The implementation will convert the second type to be an instance of the\n     * first type before the calculating the amount.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in hours between two temporal objects can be\n     * calculated using {@link HOURS.between}.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two temporals.\n     * For example, the amount in hours between the times 11:30 and 13:29\n     * will only be one hour as it is one minute short of two hours.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#until}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   between = thisUnit.between(start, end);\n     *   between = start.until(end, thisUnit);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     *\n     * For example, this method allows the number of days between two dates to\n     * be calculated:\n     * <pre>\n     *  daysBetween = DAYS.between(start, end);\n     *  // or alternatively\n     *  daysBetween = start.until(end, DAYS);\n     * </pre>\n     *\n     * Implementations should perform any queries or calculations using the units\n     * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the unit is not supported an {@link UnsupportedTemporalTypeException} must be thrown.\n     * Implementations must not alter the specified temporal objects.\n     *\n     * @implSpec\n     * Implementations must begin by checking to if the two temporals have the\n     * same type using `.constructor.name`. If they do not, then the result must be\n     * obtained by calling `temporal1.until`.\n     *\n     * @param {Temporal} temporal1  the base temporal object, not null\n     * @param {Temporal} temporal2  the other temporal object, exclusive, not null\n     * @return {Number} the amount of time between temporal1 and temporal2\n     *  in terms of this unit; positive if temporal2 is later than\n     *  temporal1, negative if earlier\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to the same type as the start temporal\n     * @throws UnsupportedTemporalTypeException if the unit is not supported by the temporal\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    between(temporal1, temporal2) {\n        return temporal1.until(temporal2, this);\n    }\n\n    //-----------------------------------------------------------------------\n    toString() {\n        return this._name;\n    }\n\n    /**\n     * Compares this ChronoUnit to the specified {TemporalUnit}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {TemporalUnit} other  the other unit to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        return this.duration().compareTo(other.duration());\n    }\n\n}\n\nexport function _init() {\n    /**\n     * Unit that represents the concept of a nanosecond, the smallest supported unit of time.\n     * For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.\n     */\n    ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));\n    /**\n     * Unit that represents the concept of a microsecond.\n     * For the ISO calendar system, it is equal to the 1,000,000th part of the second unit.\n     */\n    ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));\n    /**\n     * Unit that represents the concept of a millisecond.\n     * For the ISO calendar system, it is equal to the 1000th part of the second unit.\n     */\n    ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));\n    /**\n     * Unit that represents the concept of a second.\n     * For the ISO calendar system, it is equal to the second in the SI system\n     * of units, except around a leap-second.\n     */\n    ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));\n    /**\n     * Unit that represents the concept of a minute.\n     * For the ISO calendar system, it is equal to 60 seconds.\n     */\n    ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));\n    /**\n     * Unit that represents the concept of an hour.\n     * For the ISO calendar system, it is equal to 60 minutes.\n     */\n    ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));\n    /**\n     * Unit that represents the concept of half a day, as used in AM/PM.\n     * For the ISO calendar system, it is equal to 12 hours.\n     */\n    ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));\n    /**\n     * Unit that represents the concept of a day.\n     * For the ISO calendar system, it is the standard day from midnight to midnight.\n     * The estimated duration of a day is 24 hours.\n     *\n     * When used with other calendar systems it must correspond to the day defined by\n     * the rising and setting of the Sun on Earth. It is not required that days begin\n     * at midnight - when converting between calendar systems, the date should be\n     * equivalent at midday.\n     */\n    ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));\n    /**\n     * Unit that represents the concept of a week.\n     * For the ISO calendar system, it is equal to 7 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days.\n     */\n    ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));\n    /**\n     * Unit that represents the concept of a month.\n     * For the ISO calendar system, the length of the month varies by month-of-year.\n     * The estimated duration of a month is one twelfth of 365.2425 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days.\n     */\n    ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));\n    /**\n     * Unit that represents the concept of a year.\n     * For the ISO calendar system, it is equal to 12 months.\n     * The estimated duration of a year is 365.2425 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * or months roughly equal to a year defined by the passage of the Earth around the Sun.\n     */\n    ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));\n    /**\n     * Unit that represents the concept of a decade.\n     * For the ISO calendar system, it is equal to 10 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));\n    /**\n     * Unit that represents the concept of a century.\n     * For the ISO calendar system, it is equal to 100 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));\n    /**\n     * Unit that represents the concept of a millennium.\n     * For the ISO calendar system, it is equal to 1000 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));\n    /**\n     * Unit that represents the concept of an era.\n     * The ISO calendar system doesn't have eras thus it is impossible to add\n     * an era to a date or date-time.\n     * The estimated duration of the era is artificially defined as {Year.MAX_VALUE} + 1.\n     *\n     * When used with other calendar systems there are no restrictions on the unit.\n     */\n    ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));\n    /**\n     * Artificial unit that represents the concept of forever.\n     * This is primarily used with {@link TemporalField} to represent unbounded fields\n     * such as the year or era.\n     * The estimated duration of the era is artificially defined as the largest duration\n     * supported by {@link Duration}.\n     */\n    ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/ChronoUnit.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport {requireNonNull, requireInstance} from './assert';\nimport {ArithmeticException, DateTimeParseException, UnsupportedTemporalTypeException} from './errors';\nimport {MathUtil, MAX_SAFE_INTEGER, MIN_SAFE_INTEGER} from './MathUtil';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalAmount} from './temporal/TemporalAmount';\nimport {TemporalUnit} from './temporal/TemporalUnit';\n\nimport {LocalTime} from './LocalTime';\n\n/**\n * A time-based amount of time, such as '34.5 seconds'.\n *\n * This class models a quantity or amount of time in terms of seconds and nanoseconds.\n * It can be accessed using other duration-based units, such as minutes and hours.\n * In addition, the {@link ChronoUnit#DAYS} unit can be used and is treated as\n * exactly equal to 24 hours, thus ignoring daylight savings effects.\n * See {@link Period} for the date-based equivalent to this class.\n *\n * A physical duration could be of infinite length.\n * For practicality, the duration is stored with constraints similar to {@link Instant}.\n * The duration uses nanosecond resolution with a maximum value of the seconds that can\n * be held in a `long`. This is greater than the current estimated age of the universe.\n *\n * The range of a duration requires the storage of a number larger than a `long`.\n * To achieve this, the class stores a `long` representing seconds and an `int`\n * representing nanosecond-of-second, which will always be between 0 and 999,999,999.\n *\n * The duration is measured in \"seconds\", but these are not necessarily identical to\n * the scientific \"SI second\" definition based on atomic clocks.\n * This difference only impacts durations measured near a leap-second and should not affect\n * most applications.\n * See {@link Instant} for a discussion as to the meaning of the second and time-scales.\n *\n * ### Static properties of Class {@link Duration}\n *\n * Duration.ZERO\n *\n * Constant for a duration of zero.\n *\n */\nexport class Duration extends TemporalAmount /*implements TemporalAmount, Comparable<Duration>, Serializable */ {\n\n    /**\n     * Constructs an instance of {@link Duration} using seconds and nanoseconds.\n     *\n     * @param {Number} seconds - the length of the duration in seconds, positive or negative\n     * @param {Number} nanos - the nanoseconds within the second, from 0 to 999,999,999\n     * @private\n     */\n    constructor(seconds, nanos) {\n        super();\n        this._seconds = seconds;\n        this._nanos = nanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard 24 hour days.\n     *\n     * The seconds are calculated based on the standard definition of a day,\n     * where each day is 86400 seconds which implies a 24 hour day.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} days - the number of days, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input days exceeds the capacity of {@link Duration}\n     */\n    static ofDays(days) {\n        return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard hours.\n     *\n     * The seconds are calculated based on the standard definition of an hour,\n     * where each hour is 3600 seconds.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} hours - the number of hours, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input hours exceeds the capacity of {@link Duration}\n     */\n    static ofHours(hours) {\n        return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard minutes.\n     *\n     * The seconds are calculated based on the standard definition of a minute,\n     * where each minute is 60 seconds.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} minutes - the number of minutes, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input minutes exceeds the capacity of {@link Duration}\n     */\n    static ofMinutes(minutes) {\n        return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of seconds\n     * and an adjustment in nanoseconds.\n     *\n     * This method allows an arbitrary number of nanoseconds to be passed in.\n     * The factory will alter the values of the second and nanosecond in order\n     * to ensure that the stored nanosecond is in the range 0 to 999,999,999.\n     * For example, the following will result in the exactly the same duration:\n     * <pre>\n     *  Duration.ofSeconds(3, 1);\n     *  Duration.ofSeconds(4, -999_999_999);\n     *  Duration.ofSeconds(2, 1000_000_001);\n     * </pre>\n     *\n     * @param {Number} seconds - the number of seconds, positive or negative\n     * @param {Number} nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the adjustment causes the seconds to exceed the capacity of {@link Duration}\n     */\n    static ofSeconds(seconds, nanoAdjustment = 0) {\n        const secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));\n        const nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        return Duration._create(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of milliseconds.\n     *\n     * The seconds and nanoseconds are extracted from the specified milliseconds.\n     *\n     * @param {Number} millis - the number of milliseconds, positive or negative\n     * @return {!Duration}\n     */\n    static ofMillis(millis) {\n        let secs = MathUtil.intDiv(millis, 1000);\n        let mos = MathUtil.intMod(millis, 1000);\n        if (mos < 0) {\n            mos += 1000;\n            secs--;\n        }\n        return Duration._create(secs, mos * 1000000);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of nanoseconds.\n     *\n     * The seconds and nanoseconds are extracted from the specified nanoseconds.\n     *\n     * @param {Number} nanos - the number of nanoseconds, positive or negative\n     * @return {!Duration}\n     */\n    static ofNanos(nanos) {\n        let secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);\n        let nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);\n        if (nos < 0) {\n            nos += LocalTime.NANOS_PER_SECOND;\n            secs--;\n        }\n        return this._create(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a duration in the specified unit.\n     *\n     * The parameters represent the two parts of a phrase like '6 Hours'. For example:\n     * <pre>\n     *  Duration.of(3, SECONDS);\n     *  Duration.of(465, HOURS);\n     * </pre>\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * @param {Number} amount - the amount of the duration, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the duration is measured in, must have an exact duration, not null\n     * @return {!Duration}\n     * @throws DateTimeException if the period unit has an estimated duration\n     * @throws ArithmeticException if a numeric overflow occurs\n     */\n    static of(amount, unit) {\n        return Duration.ZERO.plus(amount, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from an amount.\n     *\n     * This obtains a duration based on the specified amount.\n     * A TemporalAmount represents an amount of time, which may be date-based\n     * or time-based, which this factory extracts to a duration.\n     *\n     * The conversion loops around the set of units from the amount and uses\n     * the duration of the unit to calculate the total Duration.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration or be ChronoUnit.DAYS which\n     * is treated as 24 hours. If any other units are found then an exception is thrown.\n     *\n     * @param {TemporalAmount} amount - the temporal amount to convert, not null\n     * @return {Duration} the resulting duration, not null\n     * @throws DateTimeException if the amount cannot be converted\n     * @throws ArithmeticException if a numeric overflow occurs\n     */\n    static from(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount);\n        let duration = Duration.ZERO;\n        amount.units().forEach((unit) => {\n            duration = duration.plus(amount.get(unit), unit);\n        });\n        return duration;\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} representing the duration between two instants.\n     *\n     * Obtains a {@link Duration} representing the duration between two instants.\n     * This calculates the duration between two temporal objects of the same type.\n     * The difference in seconds is calculated using {@link Temporal#until}.\n     * The difference in nanoseconds is calculated using by querying the\n     * {@link ChronoField#NANO_OF_SECOND} field.\n     *\n     * The result of this method can be a negative period if the end is before the start.\n     * To guarantee to obtain a positive duration call abs() on the result.\n     *\n     * @param {Temporal} startInclusive - the start instant, inclusive, not null\n     * @param {Temporal} endExclusive - the end instant, exclusive, not null\n     * @return {!Duration}\n     * @throws DateTimeException if the seconds between the temporals cannot be obtained\n     * @throws ArithmeticException if the calculation exceeds the capacity of {@link Duration}\n     */\n    static between(startInclusive, endExclusive) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(endExclusive, 'endExclusive');\n        let secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);\n        let nanos = 0;\n        if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {\n            try {\n                let startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);\n                nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;\n                if (secs > 0 && nanos < 0) {\n                    nanos += LocalTime.NANOS_PER_SECOND;\n                } else if (secs < 0 && nanos > 0) {\n                    nanos -= LocalTime.NANOS_PER_SECOND;\n                } else if (secs === 0 && nanos !== 0) {\n                    // two possible meanings for result, so recalculate secs\n                    let adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);\n                    secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);\n                }\n            } catch (e) {\n                // ignore and only use seconds\n            }\n        }\n        return this.ofSeconds(secs, nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Duration} from a text string such as {@link PnDTnHnMn.nS}.\n     *\n     * This will parse a textual representation of a duration, including the\n     * string produced by {@link toString}. The formats accepted are based\n     * on the ISO-8601 duration format {@link PnDTnHnMn.nS} with days\n     * considered to be exactly 24 hours.\n     *\n     * The string starts with an optional sign, denoted by the ASCII negative\n     * or positive symbol. If negative, the whole period is negated.\n     * The ASCII letter \"P\" is next in upper or lower case.\n     * There are then four sections, each consisting of a number and a suffix.\n     * The sections have suffixes in ASCII of \"D\", \"H\", \"M\" and \"S\" for\n     * days, hours, minutes and seconds, accepted in upper or lower case.\n     * The suffixes must occur in order. The ASCII letter \"T\" must occur before\n     * the first occurrence, if any, of an hour, minute or second section.\n     * At least one of the four sections must be present, and if \"T\" is present\n     * there must be at least one section after the \"T\".\n     * The number part of each section must consist of one or more ASCII digits.\n     * The number may be prefixed by the ASCII negative or positive symbol.\n     * The number of days, hours and minutes must parse to a `long`.\n     * The number of seconds must parse to a `long` with optional fraction.\n     * The decimal point may be either a dot or a comma.\n     * The fractional part may have from zero to 9 digits.\n     *\n     * The leading plus/minus sign, and negative values for other units are\n     * not part of the ISO-8601 standard.\n     *\n     * Examples:\n     * <pre>\n     *    \"PT20.345S\" -> parses as \"20.345 seconds\"\n     *    \"PT15M\"     -> parses as \"15 minutes\" (where a minute is 60 seconds)\n     *    \"PT10H\"     -> parses as \"10 hours\" (where an hour is 3600 seconds)\n     *    \"P2D\"       -> parses as \"2 days\" (where a day is 24 hours or 86400 seconds)\n     *    \"P2DT3H4M\"  -> parses as \"2 days, 3 hours and 4 minutes\"\n     *    \"P-6H3M\"    -> parses as \"-6 hours and +3 minutes\"\n     *    \"-P6H3M\"    -> parses as \"-6 hours and -3 minutes\"\n     *    \"-P-6H+3M\"  -> parses as \"+6 hours and -3 minutes\"\n     * </pre>\n     *\n     * @param {String} text - the text to parse, not null\n     * @return {Duration} the parsed duration, not null\n     * @throws DateTimeParseException if the text cannot be parsed to a duration\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        /**\n         * The pattern for parsing.\n         */\n        const PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');\n        const matches = PATTERN.exec(text);\n        if (matches !== null) {\n            // check for letter T but no time sections\n            if ('T' === matches[3] === false) {\n                const negate = '-' === matches[1];\n                const dayMatch = matches[2];\n                const hourMatch = matches[4];\n                const minuteMatch = matches[5];\n                const secondMatch = matches[6];\n                const fractionMatch = matches[7];\n                if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {\n                    const daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');\n                    const hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');\n                    const minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');\n                    const seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');\n                    const negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';\n                    const nanos = Duration._parseFraction(text,  fractionMatch, negativeSecs ? -1 : 1);\n                    try {\n                        return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);\n                    } catch (ex) {\n                        throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);\n                    }\n                }\n            }\n        }\n        throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);\n    }\n\n    static _parseNumber(text, parsed, multiplier, errorText) {\n        // regex limits to [-+]?[0-9]+\n        if (parsed == null) {\n            return 0;\n        }\n        try {\n            if (parsed[0] === '+') {\n                parsed = parsed.substring(1);\n            }\n            return MathUtil.safeMultiply(parseFloat(parsed), multiplier);\n        } catch (ex) {\n            throw new DateTimeParseException('Text cannot be parsed to a Duration: ' + errorText, text, 0, ex);\n        }\n    }\n\n    static _parseFraction(text, parsed, negate) {\n        // regex limits to [0-9]{0,9}\n        if (parsed == null || parsed.length === 0) {\n            return 0;\n        }\n        parsed = (parsed + '000000000').substring(0, 9);\n        return parseFloat(parsed) * negate;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * to handle function overriding this function accepts any number of arguments, checks their type and delegates to the appropriate\n     * function\n     *\n     * @return {Duration}\n     */\n    static _create() {\n        if (arguments.length <= 2) {\n            return Duration._createSecondsNanos(arguments[0], arguments[1]);\n        } else {\n            return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n        }\n    }\n\n    static _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {\n        const seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));\n        if (negate) {\n            return Duration.ofSeconds(seconds, nanos).negated();\n        }\n        return Duration.ofSeconds(seconds, nanos);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} using seconds and nanoseconds.\n     *\n     * @param {Number} seconds - the length of the duration in seconds, positive or negative\n     * @param {Number} nanoAdjustment - the nanosecond adjustment within the second, from 0 to 999,999,999\n     */\n    static _createSecondsNanos(seconds = 0, nanoAdjustment = 0) {\n        if ((seconds | nanoAdjustment) === 0) {\n            return Duration.ZERO;\n        }\n        return new Duration(seconds, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value of the requested unit.\n     *\n     * This returns a value for each of the two supported units,\n     * {@link ChronoUnit#SECONDS} and {@link ChronoUnit#NANOS}.\n     * All other units throw an exception.\n     *\n     * @param {TemporalUnit} unit the {@link TemporalUnit} for which to return the value\n     * @return {number} the const value of the unit\n     * @throws DateTimeException if the unit is not supported\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    get(unit) {\n        if (unit === ChronoUnit.SECONDS) {\n            return this._seconds;\n        } else if (unit === ChronoUnit.NANOS) {\n            return this._nanos;\n        } else {\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n    }\n\n    units() {\n        return [ChronoUnit.SECONDS, ChronoUnit.NANOS];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this duration is zero length.\n     *\n     * A {@link Duration} represents a directed distance between two points on\n     * the time-line and can therefore be positive, zero or negative.\n     * This method checks whether the length is zero.\n     *\n     * @return {boolean} true if this duration has a total length equal to zero\n     */\n    isZero() {\n        return (this._seconds | this._nanos) === 0;\n    }\n\n    /**\n     * Checks if this duration is negative, excluding zero.\n     *\n     * A {@link Duration} represents a directed distance between two points on\n     * the time-line and can therefore be positive, zero or negative.\n     * This method checks whether the length is less than zero.\n     *\n     * @return {boolean} true if this duration has a total length less than zero\n     */\n    isNegative() {\n        return this._seconds < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of seconds in this duration.\n     *\n     * The length of the duration is stored using two fields - seconds and nanoseconds.\n     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n     * the length in seconds.\n     * The total duration is defined by calling this method and {@link getNano}.\n     *\n     * A {@link Duration} represents a directed distance between two points on the time-line.\n     * A negative duration is expressed by the negative sign of the seconds part.\n     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.\n     *\n     * @return {number} the whole seconds part of the length of the duration, positive or negative\n     */\n    seconds() {\n        return this._seconds;\n    }\n\n    /**\n     * Gets the number of nanoseconds within the second in this duration.\n     *\n     * The length of the duration is stored using two fields - seconds and nanoseconds.\n     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n     * the length in seconds.\n     * The total duration is defined by calling this method and {@link getSeconds}.\n     *\n     * A {@link Duration} represents a directed distance between two points on the time-line.\n     * A negative duration is expressed by the negative sign of the seconds part.\n     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.\n     *\n     * @return {number} the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999\n     */\n    nano() {\n        return this._nanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified amount of seconds.\n     *\n     * This returns a duration with the specified seconds, retaining the\n     * nano-of-second part of this duration.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} seconds - the seconds to represent, may be negative\n     * @return {Duration} based on this period with the requested seconds, not null\n     */\n    withSeconds(seconds) {\n        return Duration._create(seconds, this._nanos);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified nano-of-second.\n     *\n     * This returns a duration with the specified nano-of-second, retaining the\n     * seconds part of this duration.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanoOfSecond - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {Duration} based on this period with the requested nano-of-second, not null\n     * @throws DateTimeException if the nano-of-second is invalid\n     */\n    withNanos(nanoOfSecond) {\n        ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);\n        return Duration._create(this._seconds, nanoOfSecond);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Duration} duration - the duration to add, positive or negative, not null\n     * @return {Duration} based on this duration with the specified duration added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDuration(duration) {\n        requireNonNull(duration, 'duration');\n        return this.plus(duration.seconds(), duration.nano());\n    }\n\n\n    /**\n     * function overloading for {@link Duration.plus}\n     *\n     * if called with 1 arguments, then {@link Duration.plusDuration} is executed.\n     *\n     * if called with 2 arguments and second argument is an instance of TemporalUnit, then {@link Duration.plusAmountUnit} is executed.\n     *\n     * Otherwise {@link Duration.plusSecondsNanos} is executed.\n     *\n     * @param {!(Duration|number)} durationOrNumber\n     * @param {!TemporaloUnit|number} unitOrNumber\n     * @returns {Duration}\n     */\n    plus(durationOrNumber, unitOrNumber) {\n        if (arguments.length === 1) {\n            return this.plusDuration(durationOrNumber);\n        }\n        else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {\n            return this.plusAmountUnit(durationOrNumber, unitOrNumber);\n        } else {\n            return this.plusSecondsNanos(durationOrNumber, unitOrNumber);\n        }\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * The duration amount is measured in terms of the specified unit.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} amountToAdd - the amount to add, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the amount is measured in, must have an exact duration, not null\n     * @return {Duration} based on this duration with the specified duration added, not null\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmountUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.DAYS) {\n            return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);\n        }\n        if (unit.isDurationEstimated()) {\n            throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');\n        }\n        if (amountToAdd === 0) {\n            return this;\n        }\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, (1000000 * 1000)) * 1000, MathUtil.intMod(amountToAdd, (1000000 * 1000)) * 1000);\n                case ChronoUnit.MILLIS: return this.plusMillis(amountToAdd);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n            }\n            return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);\n        }\n        const duration = unit.duration().multipliedBy(amountToAdd);\n        return this.plusSecondsNanos(duration.seconds(), duration.nano());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration in 24 hour days added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} daysToAdd - the days to add, positive or negative\n     * @return {Duration} based on this duration with the specified days added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDays(daysToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in hours added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} hoursToAdd - the hours to add, positive or negative\n     * @return {Duration} based on this duration with the specified hours added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusHours(hoursToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in minutes added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} minutesToAdd - the minutes to add, positive or negative\n     * @return {Duration} based on this duration with the specified minutes added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMinutes(minutesToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in seconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToAdd - the seconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified seconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusSeconds(secondsToAdd) {\n        return this.plusSecondsNanos(secondsToAdd, 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in milliseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} millisToAdd - the milliseconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified milliseconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMillis(millisToAdd) {\n        return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in nanoseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanosToAdd - the nanoseconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified nanoseconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusNanos(nanosToAdd) {\n        return this.plusSecondsNanos(0, nanosToAdd);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToAdd - the seconds to add, positive or negative\n     * @param {Number} nanosToAdd - the nanos to add, positive or negative\n     * @return {Duration} based on this duration with the specified seconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusSecondsNanos(secondsToAdd, nanosToAdd) {\n        requireNonNull(secondsToAdd, 'secondsToAdd');\n        requireNonNull(nanosToAdd, 'nanosToAdd');\n        if ((secondsToAdd | nanosToAdd) === 0) {\n            return this;\n        }\n        let epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);\n        epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));\n        nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n        const nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);  // safe int+LocalTime.NANOS_PER_SECOND\n        return Duration.ofSeconds(epochSec, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Duration.minus}\n     *\n     * if called with 1 arguments and first argument is an instance of Duration, then {@link Duration.minusDuration} is executed.\n     *\n     * Otherwise {@link Duration.minusAmountUnit} is executed.\n     *\n     * @param {!(Duration|number)} durationOrNumber\n     * @param {?ChronoUnit} unit\n     * @return {Duration}\n     */\n    minus(durationOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.minusDuration(durationOrNumber);\n        } else {\n            return this.minusAmountUnit(durationOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Duration} duration - the duration to subtract, positive or negative, not null\n     * @return {Duration} based on this duration with the specified duration subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDuration(duration) {\n        requireNonNull(duration, 'duration');\n        const secsToSubtract = duration.seconds();\n        const nanosToSubtract = duration.nano();\n        if (secsToSubtract === MIN_SAFE_INTEGER) {\n            return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);\n        }\n        return this.plus(-secsToSubtract, -nanosToSubtract);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration subtracted.\n     *\n     * The duration amount is measured in terms of the specified unit.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} amountToSubtract - the amount to subtract, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the amount is measured in, must have an exact duration, not null\n     * @return {Duration} based on this duration with the specified duration subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmountUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        return (amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration in 24 hour days subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} daysToSubtract - the days to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified days subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDays(daysToSubtract) {\n        return (daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in hours subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} hoursToSubtract - the hours to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified hours subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusHours(hoursToSubtract) {\n        return (hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in minutes subtracted.\n     *\n     * The number of hours is multiplied by 60 to obtain the number of seconds to subtract.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} minutesToSubtract - the minutes to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified minutes subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMinutes(minutesToSubtract) {\n        return (minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in seconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToSubtract - the seconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified seconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusSeconds(secondsToSubtract) {\n        return (secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in milliseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} millisToSubtract - the milliseconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified milliseconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMillis(millisToSubtract) {\n        return (millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in nanoseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanosToSubtract - the nanoseconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified nanoseconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusNanos(nanosToSubtract) {\n        return (nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration multiplied by the scalar.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} multiplicand - the value to multiply the duration by, positive or negative\n     * @return {Duration} based on this duration multiplied by the specified scalar, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    multipliedBy(multiplicand) {\n        if (multiplicand === 0) {\n            return Duration.ZERO;\n        }\n        if (multiplicand === 1) {\n            return this;\n        }\n        let secs = MathUtil.safeMultiply(this._seconds, multiplicand);\n        let nos = MathUtil.safeMultiply(this._nanos, multiplicand);\n        secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);\n        nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);\n        return Duration.ofSeconds(secs, nos);\n    }\n\n    /**\n     * Returns a copy of this duration divided by the specified value.\n     *\n     * In opposite to the threeten implementation the division is realized by floating point not by\n     * fixed point arithmetic. Expect floating point rounding errors for {@link Duration.dividedBy}.\n     *\n     * @param {Number} divisor - the value to divide the duration by, positive or negative, not zero\n     * @return {Duration} based on this duration divided by the specified divisor, not null\n     * @throws ArithmeticException if the divisor is zero or if numeric overflow occurs\n     */\n    dividedBy(divisor) {\n        if (divisor === 0) {\n            throw new ArithmeticException('Cannot divide by zero');\n        }\n        if (divisor === 1) {\n            return this;\n        }\n        const secs = MathUtil.intDiv(this._seconds, divisor);\n        const secsMod = MathUtil.roundDown(((this._seconds/ divisor) - secs) * LocalTime.NANOS_PER_SECOND);\n        let nos = MathUtil.intDiv(this._nanos, divisor);\n        nos = secsMod + nos;\n        return Duration.ofSeconds(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the length negated.\n     *\n     * This method swaps the sign of the total length of this duration.\n     * For example, {@link PT1.3S} will be returned as {@link PT-1.3S}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Duration} based on this duration with the amount negated, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    negated() {\n        return this.multipliedBy(-1);\n    }\n\n    /**\n     * Returns a copy of this duration with a positive length.\n     *\n     * This method returns a positive duration by effectively removing the sign from any negative total length.\n     * For example, {@link PT-1.3S} will be returned as {@link PT1.3S}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Duration} based on this duration with an absolute length, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    abs() {\n        return this.isNegative() ? this.negated() : this;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Adds this duration to the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this duration added.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#plus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisDuration.addTo(dateTime);\n     *   dateTime = dateTime.plus(thisDuration);\n     * </pre>\n     *\n     * The calculation will add the seconds, then nanos.\n     * Only non-zero amounts will be added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    addTo(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._seconds !== 0) {\n            temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    }\n\n    /**\n     * Subtracts this duration from the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this duration subtracted.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#minus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisDuration.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(thisDuration);\n     * </pre>\n     *\n     * The calculation will subtract the seconds, then nanos.\n     * Only non-zero amounts will be added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    subtractFrom(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._seconds !== 0) {\n            temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of days in this duration.\n     *\n     * This returns the total number of days in the duration by dividing the\n     * number of seconds by 86400.\n     * This is based on the standard definition of a day as 24 hours.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of days in the duration, may be negative\n     */\n    toDays() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);\n    }\n\n    /**\n     * Gets the number of hours in this duration.\n     *\n     * This returns the total number of hours in the duration by dividing the\n     * number of seconds by 3600.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of hours in the duration, may be negative\n     */\n    toHours() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n    }\n\n    /**\n     * Gets the number of minutes in this duration.\n     *\n     * This returns the total number of minutes in the duration by dividing the\n     * number of seconds by 60.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of minutes in the duration, may be negative\n     */\n    toMinutes() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n    }\n\n    /**\n     * Converts this duration to the total length in milliseconds.\n     *\n     * If this duration is too large to fit in a `long` milliseconds, then an\n     * exception is thrown.\n     *\n     * If this duration has greater than millisecond precision, then the conversion\n     * will drop any excess precision information as though the amount in nanoseconds\n     * was subject to integer division by one million.\n     *\n     * @return {number} the total length of the duration in milliseconds\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toMillis() {\n        let millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));\n        millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));\n        return millis;\n    }\n\n    /**\n     * Converts this duration to the total length in nanoseconds expressed as a `long`.\n     *\n     * If this duration is too large to fit in a `long` nanoseconds, then an\n     * exception is thrown.\n     *\n     * @return {number} the total length of the duration in nanoseconds\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toNanos() {\n        let totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);\n        totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);\n        return totalNanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this duration to the specified {@link Duration}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {Duration} otherDuration - the other duration to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(otherDuration) {\n        requireNonNull(otherDuration, 'otherDuration');\n        requireInstance(otherDuration, Duration, 'otherDuration');\n        const cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return this._nanos - otherDuration.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this duration is equal to the specified {@link Duration}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {*} otherDuration - the other duration, null returns false\n     * @return {boolean} true if the other duration is equal to this one\n     */\n    equals(otherDuration) {\n        if (this === otherDuration) {\n            return true;\n        }\n        if (otherDuration instanceof Duration) {\n            return this.seconds() === otherDuration.seconds() &&\n                   this.nano() === otherDuration.nano();\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A string representation of this duration using ISO-8601 seconds\n     * based representation, such as {@link PT8H6M12.345S}.\n     *\n     * The format of the returned string will be {@link PTnHnMnS}, where n is\n     * the relevant hours, minutes or seconds part of the duration.\n     * Any fractional seconds are placed after a decimal povar i the seconds section.\n     * If a section has a zero value, it is omitted.\n     * The hours, minutes and seconds will all have the same sign.\n     *\n     * Examples:\n     * <pre>\n     *    \"20.345 seconds\"                 -> \"PT20.345S\n     *    \"15 minutes\" (15 * 60 seconds)   -> \"PT15M\"\n     *    \"10 hours\" (10 * 3600 seconds)   -> \"PT10H\"\n     *    \"2 days\" (2 * 86400 seconds)     -> \"PT48H\"\n     * </pre>\n     * Note that multiples of 24 hours are not output as days to avoid confusion\n     * with {@link Period}.\n     *\n     * @return {string} an ISO-8601 representation of this duration, not null\n     */\n    toString() {\n        if (this === Duration.ZERO) {\n            return 'PT0S';\n        }\n        const hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n        const minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);\n        const secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n        let rval = 'PT';\n        if (hours !== 0) {\n            rval += hours + 'H';\n        }\n        if (minutes !== 0) {\n            rval += minutes + 'M';\n        }\n        if (secs === 0 && this._nanos === 0 && rval.length > 2) {\n            return rval;\n        }\n        if (secs < 0 && this._nanos > 0) {\n            if (secs === -1) {\n                rval += '-0';\n            } else {\n                rval += secs + 1;\n            }\n        } else {\n            rval += secs;\n        }\n        if (this._nanos > 0) {\n            rval += '.';\n            let nanoString;\n            if (secs < 0) {\n                nanoString = '' + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);\n            } else {\n                nanoString = '' + (LocalTime.NANOS_PER_SECOND + this._nanos);\n            }\n            // remove the leading '1'\n            nanoString = nanoString.slice(1, nanoString.length);\n            rval += nanoString;\n            while (rval.charAt(rval.length - 1) === '0') {\n                rval = rval.slice(0, rval.length - 1);\n            }\n        }\n        rval += 'S';\n        return rval;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link Duration.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n}\n\nexport function _init() {\n    /**\n     * Constant for a duration of zero.\n     */\n    Duration.ZERO = new Duration(0, 0);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Duration.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from '../assert';\n\n/**\n * Framework-level interface defining an amount of time, such as\n * \"6 hours\", \"8 days\" or \"2 years and 3 months\".\n *\n * This is the base interface type for amounts of time.\n * An amount is distinct from a date or time-of-day in that it is not tied\n * to any specific point on the time-line.\n *\n * The amount can be thought of as a {@link Map} of {@link TemporalUnit} to\n * `long`, exposed via {@link getUnits} and {@link get}.\n * A simple case might have a single unit-value pair, such as \"6 hours\".\n * A more complex case may have multiple unit-value pairs, such as\n * \"7 years, 3 months and 5 days\".\n *\n * There are two common implementations.\n * {@link Period} is a date-based implementation, storing years, months and days.\n * {@link Duration} is a time-based implementation, storing seconds and nanoseconds,\n * but providing some access using other duration based units such as minutes,\n * hours and fixed 24-hour days.\n *\n * This interface is a framework-level interface that should not be widely\n * used in application code. Instead, applications should create and pass\n * around instances of concrete types, such as {@link Period} and {@link Duration}.\n *\n * @interface\n */\nexport class TemporalAmount {\n    /**\n     * Returns the value of the requested unit.\n     * The units returned from {@link getUnits} uniquely define the\n     * value of the {@link TemporalAmount}.  A value must be returned\n     * for each unit listed in {@link getUnits}.\n     *\n     * @implSpec\n     * Implementations may declare support for units not listed by {@link getUnits}.\n     * Typically, the implementation would define additional units\n     * as conversions for the convenience of developers.\n     *\n     * @param {TemporalUnit} unit - the {@link TemporalUnit} for which to return the value\n     * @return {number} the long value of the unit\n     * @throws DateTimeException if a value for the unit cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the {@link unit} is not supported\n     */\n    // eslint-disable-next-line no-unused-vars\n    get(unit) {\n        abstractMethodFail('get');\n    }\n    \n    /**\n     * Returns the list of units uniquely defining the value of this TemporalAmount.\n     * The list of {@link TemporalUnits} is defined by the implementation class.\n     * The list is a snapshot of the units at the time {@link getUnits}\n     * is called and is not mutable.\n     * The units are ordered from longest duration to the shortest duration\n     * of the unit.\n     *\n     * @implSpec\n     * The list of units completely and uniquely represents the\n     * state of the object without omissions, overlaps or duplication.\n     * The units are in order from longest duration to shortest.\n     *\n     * @return {TemporalUnit[]} the List of {@link TemporalUnits}; not null\n     */\n    units() {\n        abstractMethodFail('units');\n    }\n    \n    /**\n     * Adds to the specified temporal object.\n     *\n     * Adds the amount to the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus}:\n     * <pre>\n     *   // These two lines are equivalent, but the second approach is recommended\n     *   dateTime = amount.addTo(dateTime);\n     *   dateTime = dateTime.plus(adder);\n     * </pre>\n     * It is recommended to use the second approach, {@link plus},\n     * as it is a lot clearer to read in code.\n     *\n     * @implSpec\n     * The implementation must take the input object and add to it.\n     * The implementation defines the logic of the addition and is responsible for\n     * documenting that logic. It may use any method on {@link Temporal} to\n     * query the temporal object and perform the addition.\n     * The returned object must have the same observable type as the input object\n     *\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal - the temporal object to add the amount to, not null\n     * @return {Temporal} an object of the same observable type with the addition made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    addTo(temporal) {\n        abstractMethodFail('addTo');\n    }\n    \n    /**\n     * Subtracts this object from the specified temporal object.\n     *\n     * Subtracts the amount from the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#minus}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = amount.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(amount);\n     * </pre>\n     * It is recommended to use the second approach, {@link minus},\n     * as it is a lot clearer to read in code.\n     *\n     * @implSpec\n     * The implementation must take the input object and subtract from it.\n     * The implementation defines the logic of the subtraction and is responsible for\n     * documenting that logic. It may use any method on {@link Temporal} to\n     * query the temporal object and perform the subtraction.\n     * The returned object must have the same observable type as the input object\n     *\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal - the temporal object to subtract the amount from, not null\n     * @return {Temporal} an object of the same observable type with the subtraction made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    subtractFrom(temporal) {\n        abstractMethodFail('subtractFrom');\n    }\n    \n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/TemporalAmount.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from '../assert';\n\n/**\n * A unit of date-time, such as Days or Hours.\n *\n * Measurement of time is built on units, such as years, months, days, hours, minutes and seconds.\n * Implementations of this interface represent those units.\n *\n * An instance of this interface represents the unit itself, rather than an amount of the unit.\n * See {@link Period} for a class that represents an amount in terms of the common units.\n *\n * The most commonly used units are defined in {@link ChronoUnit}.\n * Further units are supplied in {@link IsoFields}.\n * Units can also be written by application code by implementing this interface.\n *\n * The unit works using double dispatch. Client code calls methods on a date-time like\n * {@link LocalDateTime} which check if the unit is a {@link ChronoUnit}.\n * If it is, then the date-time must handle it.\n * Otherwise, the method call is re-dispatched to the matching method in this interface.\n *\n * @interface\n */\nexport class TemporalUnit {\n    /**\n     * Gets the duration of this unit, which may be an estimate.\n     *\n     * All units return a duration measured in standard nanoseconds from this method.\n     * The duration will be positive and non-zero.\n     * For example, an hour has a duration of `60 * 60 * 1,000,000,000ns`.\n     *\n     * Some units may return an accurate duration while others return an estimate.\n     * For example, days have an estimated duration due to the possibility of\n     * daylight saving time changes.\n     * To determine if the duration is an estimate, use {@link isDurationEstimated}.\n     *\n     * @return {Duration} the duration of this unit, which may be an estimate, not null\n     */\n    duration() {\n        abstractMethodFail('duration');\n    }\n\n    /**\n     * Checks if the duration of the unit is an estimate.\n     *\n     * All units have a duration, however the duration is not always accurate.\n     * For example, days have an estimated duration due to the possibility of\n     * daylight saving time changes.\n     * This method returns true if the duration is an estimate and false if it is\n     * accurate. Note that accurate/estimated ignores leap seconds.\n     *\n     * @return {boolean} true if the duration is estimated, false if accurate\n     */\n    isDurationEstimated() {\n        abstractMethodFail('isDurationEstimated');\n    }\n\n    /**\n     * Checks if this unit is date-based.\n     *\n     * @return {boolean} true if date-based\n     */\n    isDateBased() {\n        abstractMethodFail('isDateBased');\n    }\n\n    /**\n     * Checks if this unit is time-based.\n     *\n     * @return {boolean} true if time-based\n     */\n    isTimeBased() {\n        abstractMethodFail('isTimeBased');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this unit is supported by the specified temporal object.\n     *\n     * This checks that the implementing date-time can add/subtract this unit.\n     * This can be used to avoid throwing an exception.\n     *\n     * @param {Temporal} temporal  the temporal object to check, not null\n     * @return {boolean} true if the unit is supported\n     */\n    // eslint-disable-next-line no-unused-vars\n    isSupportedBy(temporal) {\n        abstractMethodFail('isSupportedBy');\n    }\n\n    /**\n     * Returns a copy of the specified temporal object with the specified period added.\n     *\n     * The period added is a multiple of this unit. For example, this method\n     * could be used to add \"3 days\" to a date by calling this method on the\n     * instance representing \"days\", passing the date and the period \"3\".\n     * The period to be added may be negative, which is equivalent to subtraction.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisUnit.doPlus(temporal);\n     *   temporal = temporal.plus(thisUnit);\n     * </pre>\n     * It is recommended to use the second approach, {@link plus},\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the units\n     * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * Implementations must not alter the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {Temporal} dateTime  the temporal object to adjust, not null\n     * @param {number} periodToAdd  the period of this unit to add, positive or negative\n     * @return {Temporal} the adjusted temporal object, not null\n     * @throws DateTimeException if the period cannot be added\n     */\n    // eslint-disable-next-line no-unused-vars\n    addTo(dateTime, periodToAdd) {\n        abstractMethodFail('addTo');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the period in terms of this unit between two temporal objects of the same type.\n     *\n     * This calculates the period between two temporals in terms of this unit.\n     * The start and end points are supplied as temporal objects and must be of the same type.\n     * The result will be negative if the end is before the start.\n     * For example, the period in hours between two temporal objects can be calculated\n     * using {@link HOURS.between}.\n     *\n     * The calculation returns a whole number, representing the number of complete units between the two temporals.\n     * For example, the period in hours between the times 11:30 and 13:29 will only b\n     * one hour as it is one minute short of two hours.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#until}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   between = thisUnit.between(start, end);\n     *   between = start.until(end, thisUnit);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     *\n     * For example, this method allows the number of days between two dates to be calculated:\n     * <pre>\n     *   long daysBetween = DAYS.between(start, end);\n     *   // or alternatively\n     *   long daysBetween = start.until(end, DAYS);\n     * </pre>\n     * Implementations should perform any queries or calculations using the units available in\n     * {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the unit is not supported a DateTimeException must be thrown.\n     * Implementations must not alter the specified temporal objects.\n     *\n     * @param {Temporal} temporal1  the base temporal object, not null\n     * @param {Temporal} temporal2  the other temporal object, not null\n     * @return {number} the period between temporal1 and temporal2 in terms of this unit;\n     *  positive if temporal2 is later than temporal1, negative if earlier\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    between(temporal1, temporal2) {\n        abstractMethodFail('between');\n    }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/TemporalUnit.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\n/**\n * attempt to avoid dependency cycles... define all constants here and they could be used\n * so instead of using e.g. Year.MAX_VALUE we could use YearConstants.MAX_VALUE to avoid the cycle\n */\nexport class YearConstants {}\n\nexport function _init() {\n    /**\n     * The minimum supported year\n     */\n    YearConstants.MIN_VALUE = -999999;\n    /**\n     * The maximum supported year\n     */\n    YearConstants.MAX_VALUE = 999999;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/YearConstants.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * A field of date-time, such as month-of-year or hour-of-minute.\n *\n * Date and time is expressed using fields which partition the time-line into something\n * meaningful for humans. Implementations of this interface represent those fields.\n *\n * The most commonly used units are defined in {@link ChronoField}.\n * Further fields are supplied in {@link IsoFields}, {@link WeekFields} and {@link JulianFields}.\n * Fields can also be written by application code by implementing this interface.\n *\n * The field works using double dispatch. Client code calls methods on a date-time like\n * {@link LocalDateTime} which check if the field is a {@link ChronoField}.\n * If it is, then the date-time must handle it.\n * Otherwise, the method call is re-dispatched to the matching method in this interface.\n *\n * @interface\n */\nexport class TemporalField {}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/TemporalField.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert} from '../assert';\nimport {DateTimeException, IllegalArgumentException} from '../errors';\nimport {MathUtil} from '../MathUtil';\n\n/**\n * The range of valid values for a date-time field.\n * \n * All TemporalField instances have a valid range of values.\n * For example, the ISO day-of-month runs from 1 to somewhere between 28 and 31.\n * This class captures that valid range.\n * \n * It is important to be aware of the limitations of this class.\n * Only the minimum and maximum values are provided.\n * It is possible for there to be invalid values within the outer range.\n * For example, a weird field may have valid values of 1, 2, 4, 6, 7, thus\n * have a range of '1 - 7', despite that fact that values 3 and 5 are invalid.\n * \n * Instances of this class are not tied to a specific field.\n */\nexport class ValueRange {\n\n    /**\n     *\n     * @param {!number} minSmallest\n     * @param {!number} minLargest\n     * @param {!number} maxSmallest\n     * @param {!number} maxLargest\n     */\n    constructor(minSmallest, minLargest, maxSmallest, maxLargest) {\n        assert(!(minSmallest > minLargest), 'Smallest minimum value \\'' + minSmallest +\n            '\\' must be less than largest minimum value \\'' + minLargest + '\\'', IllegalArgumentException);\n        assert(!(maxSmallest > maxLargest), 'Smallest maximum value \\'' + maxSmallest +\n            '\\' must be less than largest maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n        assert(!(minLargest > maxLargest), 'Minimum value \\'' + minLargest +\n            '\\' must be less than maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n\n        this._minSmallest = minSmallest;\n        this._minLargest = minLargest;\n        this._maxLargest = maxLargest;\n        this._maxSmallest = maxSmallest;\n    }\n\n    /**\n     * Is the value range fixed and fully known.\n     *\n     * For example, the ISO day-of-month runs from 1 to between 28 and 31.\n     * Since there is uncertainty about the maximum value, the range is not fixed.\n     * However, for the month of January, the range is always 1 to 31, thus it is fixed.\n     *\n     * @return {boolean} true if the set of values is fixed\n     */\n    isFixed() {\n        return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    minimum(){\n        return this._minSmallest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    largestMinimum(){\n        return this._minLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    maximum(){\n        return this._maxLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    smallestMaximum(){\n        return this._maxSmallest;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isValidValue(value) {\n        return (this.minimum() <= value && value <= this.maximum());\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @param {TemporalField} field\n     */\n    checkValidValue(value, field) {\n        let msg;\n        if (!this.isValidValue(value)) {\n            if (field != null) {\n                msg = ('Invalid value for ' + field + ' (valid values ' + (this.toString()) + '): ') + value;\n            } else {\n                msg = ('Invalid value (valid values ' + (this.toString()) + '): ') + value;\n            }\n            return assert(false, msg, DateTimeException);\n        }\n    }\n\n    /**\n     * Checks that the specified value is valid and fits in an `int`.\n     *\n     * This validates that the value is within the valid range of values and that\n     * all valid values are within the bounds of an `int`.\n     * The field is only used to improve the error message.\n     *\n     * @param {number} value - the value to check\n     * @param {TemporalField} field - the field being checked, may be null\n     * @return {number} the value that was passed in\n     * @see #isValidIntValue(long)\n     */\n    checkValidIntValue(value, field) {\n        if (this.isValidIntValue(value) === false) {\n            throw new DateTimeException('Invalid int value for ' + field + ': ' + value);\n        }\n        return value;\n    }\n\n    /**\n     * Checks if the value is within the valid range and that all values\n     * in the range fit in an `int`.\n     *\n     * This method combines {@link isIntValue} and {@link isValidValue}.\n     *\n     * @param {number} value - the value to check\n     * @return true if the value is valid and fits in an `int`\n     */\n    isValidIntValue(value) {\n        return this.isIntValue() && this.isValidValue(value);\n    }\n\n    /**\n     * Checks if all values in the range fit in an `int`.\n     *\n     * This checks that all valid values are within the bounds of an `int`.\n     *\n     * For example, the ISO month-of-year has values from 1 to 12, which fits in an `int`.\n     * By comparison, ISO nano-of-day runs from 1 to 86,400,000,000,000 which does not fit in an `int`.\n     *\n     * This implementation uses {@link getMinimum} and {@link getMaximum}.\n     *\n     * @return boolean if a valid value always fits in an `int`\n     */\n    isIntValue() { // should be isSafeIntegerValue\n        return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if this range is equal to another range.\n     *\n     * The comparison is based on the four values, minimum, largest minimum,\n     * smallest maximum and maximum.\n     * Only objects of type {@link ValueRange} are compared, other types return false.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other range\n     */\n    equals(other) {\n        if (other === this) {\n            return true;\n        }\n        if (other instanceof ValueRange) {\n            return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest &&\n                this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this range.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        const hash = this._minSmallest + this._minLargest << 16 + this._minLargest >> 48 + this._maxSmallest << 32 +\n            this._maxSmallest >> 32 + this._maxLargest << 48 + this._maxLargest >> 16;\n        return (hash ^ (hash >>> 32));\n    }\n    \n    /*\n     * Outputs this range as a String.\n     * \n     * The format will be '{min}/{largestMin} - {smallestMax}/{max}',\n     * where the largestMin or smallestMax sections may be omitted, together\n     * with associated slash, if they are the same as the min or max.\n     *\n     * @return {string} a string representation of this range, not null\n     */\n    toString() {\n        let str = this.minimum() + (this.minimum() !== this.largestMinimum() ? '/' + (this.largestMinimum()) : '');\n        str += ' - ';\n        str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? '/' + (this.maximum()) : '');\n        return str;\n    }\n\n    /*\n     * called with 2 params: Obtains a fixed value range.\n     *\n     * This factory obtains a range where the minimum and maximum values are fixed.\n     * For example, the ISO month-of-year always runs from 1 to 12.\n     *\n     * @param min  the minimum value\n     * @param max  the maximum value\n     * @return the ValueRange for min, max, not null\n\n     * called with 3 params: Obtains a variable value range.\n     *\n     * This factory obtains a range where the minimum value is fixed and the maximum value may vary.\n     * For example, the ISO day-of-month always starts at 1, but ends between 28 and 31.\n     *\n     * @param min  the minimum value\n     * @param maxSmallest  the smallest maximum value\n     * @param maxLargest  the largest maximum value\n     * @return the ValueRange for min, smallest max, largest max, not null\n\n     * called with 4 params: Obtains a fully variable value range.\n     *\n     * This factory obtains a range where both the minimum and maximum value may vary.\n     *\n     * @param minSmallest  the smallest minimum value\n     * @param minLargest  the largest minimum value\n     * @param maxSmallest  the smallest maximum value\n     * @param maxLargest  the largest maximum value\n     *\n     * @return {ValueRange} the ValueRange for smallest min, largest min, smallest max, largest max, not null\n     */\n    static of() {\n        if (arguments.length === 2) {\n            return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);\n        } else if (arguments.length === 3) {\n            return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);\n        } else if (arguments.length === 4) {\n            return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);\n        } else {\n            return assert(false, 'Invalid number of arguments ' + arguments.length, IllegalArgumentException);\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/ValueRange.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {TemporalAccessor} from './TemporalAccessor';\n\n/**\n * Framework-level interface defining read-write access to a temporal object,\n * such as a date, time, offset or some combination of these.\n *\n * This is the base interface type for date, time and offset objects that\n * are complete enough to be manipulated using plus and minus.\n * It is implemented by those classes that can provide and manipulate information\n * as fields (see {@link TemporalField}) or queries (see {@link TemporalQuery}).\n * See {@link TemporalAccessor} for the read-only version of this interface.\n *\n * Most date and time information can be represented as a number.\n * These are modeled using {@link TemporalField} with the number held using\n * a `long` to handle large values. Year, month and day-of-month are\n * simple examples of fields, but they also include instant and offsets.\n * See {@link ChronoField} for the standard set of fields.\n *\n * Two pieces of date/time information cannot be represented by numbers,\n * the {@link Chronology} and the {@link ZoneId}.\n * These can be accessed using the static methods defined on {@link TemporalQueries}.\n *\n * This interface is a framework-level interface that should not be widely\n * used in application code. Instead, applications should create and pass\n * around instances of concrete types, such as {@link LocalDate}.\n * There are many reasons for this, part of which is that implementations\n * of this interface may be in calendar systems other than ISO.\n * See {@link ChronoLocalDate} for a fuller discussion of the issues.\n *\n * ### When to implement\n *\n * A class should implement this interface if it meets three criteria:\n *\n * * it provides access to date/time/offset information, as per {@link TemporalAccessor}\n * * the set of fields are contiguous from the largest to the smallest\n * * the set of fields are complete, such that no other field is needed to define the\n *   valid range of values for the fields that are represented\n *\n * Four examples make this clear:\n *\n * * {@link LocalDate} implements this interface as it represents a set of fields\n *   that are contiguous from days to forever and require no external information to determine\n *   the validity of each date. It is therefore able to implement plus/minus correctly.\n * * {@link LocalTime} implements this interface as it represents a set of fields\n *   that are contiguous from nanos to within days and require no external information to determine\n *   validity. It is able to implement plus/minus correctly, by wrapping around the day.\n * * {@link MonthDay}, the combination of month-of-year and day-of-month, does not implement\n *   this interface.  While the combination is contiguous, from days to months within years,\n *   the combination does not have sufficient information to define the valid range of values\n *   for day-of-month.  As such, it is unable to implement plus/minus correctly.\n * * The combination day-of-week and day-of-month (\"Friday the 13th\") should not implement\n *   this interface. It does not represent a contiguous set of fields, as days to weeks overlaps\n *   days to months.\n *\n * @interface\n */\nexport class Temporal extends TemporalAccessor {}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/Temporal.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {UnsupportedTemporalTypeException} from '../errors';\n\nimport {ChronoField} from './ChronoField';\nimport {TemporalQueries} from './TemporalQueries';\n\nexport class TemporalAccessor {\n    /**\n     * Queries this date-time.\n     *\n     * This queries this date-time using the specified query strategy object.\n     *\n     * Queries are a key tool for extracting information from date-times.\n     * They exists to externalize the process of querying, permitting different\n     * approaches, as per the strategy design pattern.\n     * Examples might be a query that checks if the date is the day before February 29th\n     * in a leap year, or calculates the number of days to your next birthday.\n     *\n     * The most common query implementations are method references, such as\n     * {@link LocalDate::from} and {@link ZoneId::from}.\n     * Further implementations are on {@link TemporalQueries}.\n     * Queries may also be defined by applications.\n     *\n     * @implSpec\n     * Implementations of this method must behave as follows:\n     * <pre>\n        if (query == TemporalQueries.zoneId()\n            || query == TemporalQueries.chronology()\n            || query == TemporalQueries.precision()) {\n                return null;\n        }\n        return query.queryFrom(this);\n     * </pre>\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    query(query) {\n        if (query === TemporalQueries.zoneId()\n                || query === TemporalQueries.chronology()\n                || query === TemporalQueries.precision()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Gets the value of the specified field as an `int`.\n     *\n     * This queries the date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If the date-time cannot return the value, because the field is unsupported or for\n     * some other reason, an exception will be thrown.\n     *\n     * ### Specification for implementors\n     *\n     * Implementations must check and handle all fields defined in {@link ChronoField}.\n     * If the field is supported and has an `int` range, then the value of\n     * the field must be returned.\n     * If unsupported, then a {@link DateTimeException} must be thrown.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument.\n     *\n     * Implementations must not alter either this object.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws DateTimeException if the range of valid values for the field exceeds an `int`\n     * @throws DateTimeException if the value is outside the range of valid values for the field\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * All fields can be expressed as a `long` integer.\n     * This method returns an object that describes the valid range for that value.\n     * The value of this temporal object is used to enhance the accuracy of the returned range.\n     * If the date-time cannot return the range, because the field is unsupported or for\n     * some other reason, an exception will be thrown.\n     *\n     * Note that the result only describes the minimum and maximum valid values\n     * and it is important not to read too much into them. For example, there\n     * could be values within the range that are invalid for the field.\n     *\n     * ### Specification for implementors\n     *\n     * Implementations must check and handle all fields defined in {@link ChronoField}.\n     * If the field is supported, then the range of the field must be returned.\n     * If unsupported, then a {@link DateTimeException} must be thrown.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     *\n     * Implementations must not alter either this object.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (this.isSupported(field)) {\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/TemporalAccessor.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * Common implementations of {@link TemporalQuery}.\n *\n * This class provides common implementations of {@link TemporalQuery}.\n * These queries are primarily used as optimizations, allowing the internals\n * of other objects to be extracted effectively. Note that application code\n * can also use the {@link from} method on most temporal\n * objects as a method reference matching the query interface, such as\n * {@link LocalDate::from} and {@link ZoneId::from}.\n *\n * There are two equivalent ways of using a {@link TemporalQuery}.\n * The first is to invoke the method on the interface directly.\n * The second is to use {@link TemporalAccessor#query}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   dateTime = query.queryFrom(dateTime);\n *   dateTime = dateTime.query(query);\n * </pre>\n * It is recommended to use the second approach, {@link query},\n * as it is a lot clearer to read in code.\n *\n */\nexport class TemporalQueries {\n\n    /**\n     * A strict query for the {@link ZoneId}.\n     *\n     * This queries a {@link TemporalAccessor} for the zone.\n     * The zone is only returned if the date-time conceptually contains a {@link ZoneId}.\n     * It will not be returned if the date-time only conceptually has an {@link ZoneOffset}.\n     * Thus a {@link ZonedDateTime} will return the result of\n     * {@link getZone}, but an {@link OffsetDateTime} will\n     * return null.\n     *\n     * In most cases, applications should use {@link ZONE} as this query is too strict.\n     *\n     * The result from JDK classes implementing {@link TemporalAccessor} is as follows:\n     * * * {@link LocalDate} returns null\n     * * {@link LocalTime} returns null\n     * * {@link LocalDateTime} returns null\n     * * {@link ZonedDateTime} returns the associated zone\n     * * {@link OffsetTime} returns null\n     * * {@link OffsetDateTime} returns null\n     * * {@link ChronoLocalDate} returns null\n     * * {@link ChronoLocalDateTime} returns null\n     * * {@link ChronoZonedDateTime} returns the associated zone\n     * * {@link Era} returns null\n     * * {@link DayOfWeek} returns null\n     * * {@link Month} returns null\n     * * {@link Year} returns null\n     * * {@link YearMonth} returns null\n     * * {@link MonthDay} returns null\n     * * {@link ZoneOffset} returns null\n     * * {@link Instant} returns null\n     *\n     * @return a query that can obtain the zone ID of a temporal, not null\n     */\n    static zoneId() {\n        return TemporalQueries.ZONE_ID;\n    }\n\n    /**\n     * A query for the {@link Chronology}.\n     *\n     * This queries a {@link TemporalAccessor} for the chronology.\n     * If the target {@link TemporalAccessor} represents a date, or part of a date,\n     * then it should return the chronology that the date is expressed in.\n     * As a result of this definition, objects only representing time, such as\n     * {@link LocalTime}, will return null.\n     *\n     * The result from js-joda classes implementing {@link TemporalAccessor} is as follows:\n     *\n     * * {@link LocalDate} returns * {@link IsoChronology.INSTANCE}\n     * * {@link LocalTime} returns null (does not represent a date)\n     * * {@link LocalDateTime} returns * {@link IsoChronology.INSTANCE}\n     * * {@link ZonedDateTime} returns * {@link IsoChronology.INSTANCE}\n     * * {@link OffsetTime} returns null (does not represent a date)\n     * * {@link OffsetDateTime} returns * {@link IsoChronology.INSTANCE}\n     * * {@link ChronoLocalDate} returns the associated chronology\n     * * {@link ChronoLocalDateTime} returns the associated chronology\n     * * {@link ChronoZonedDateTime} returns the associated chronology\n     * * {@link Era} returns the associated chronology\n     * * {@link DayOfWeek} returns null (shared across chronologies)\n     * * {@link Month} returns * {@link IsoChronology.INSTANCE}\n     * * {@link Year} returns * {@link IsoChronology.INSTANCE}\n     * * {@link YearMonth} returns * {@link IsoChronology.INSTANCE}\n     * * {@link MonthDay} returns null * {@link IsoChronology.INSTANCE}\n     * * {@link ZoneOffset} returns null (does not represent a date)\n     * * {@link Instant} returns null (does not represent a date)\n     *\n     * The method {@link Chronology#from} can be used as a\n     * {@link TemporalQuery}\n     * That method is equivalent to this query, except that it throws an\n     * exception if a chronology cannot be obtained.\n     *\n     * @return {TemporalQuery} a query that can obtain the chronology of a temporal, not null\n     */\n    static chronology() {\n        return TemporalQueries.CHRONO;\n    }\n\n    /**\n     * A query for the smallest supported unit.\n     *\n     * This queries a {@link TemporalAccessor} for the time precision.\n     * If the target {@link TemporalAccessor} represents a consistent or complete date-time,\n     * date or time then this must return the smallest precision actually supported.\n     * Note that fields such as {@link NANO_OF_DAY} and {@link NANO_OF_SECOND}\n     * are defined to always return ignoring the precision, thus this is the only\n     * way to find the actual smallest supported unit.\n     * For example, were {@link GregorianCalendar} to implement {@link TemporalAccessor}\n     * it would return a precision of {@link MILLIS}.\n     *\n     * The result from js-joda classes implementing {@link TemporalAccessor} is as follows:\n     *\n     * {@link LocalDate} returns {@link DAYS}\n     * {@link LocalTime} returns {@link NANOS}\n     * {@link LocalDateTime} returns {@link NANOS}\n     * {@link ZonedDateTime} returns {@link NANOS}\n     * {@link OffsetTime} returns {@link NANOS}\n     * {@link OffsetDateTime} returns {@link NANOS}\n     * {@link ChronoLocalDate} returns {@link DAYS}\n     * {@link ChronoLocalDateTime} returns {@link NANOS}\n     * {@link ChronoZonedDateTime} returns {@link NANOS}\n     * {@link Era} returns {@link ERAS}\n     * {@link DayOfWeek} returns {@link DAYS}\n     * {@link Month} returns {@link MONTHS}\n     * {@link Year} returns {@link YEARS}\n     * {@link YearMonth} returns {@link MONTHS}\n     * {@link MonthDay} returns null (does not represent a complete date or time)\n     * {@link ZoneOffset} returns null (does not represent a date or time)\n     * {@link Instant} returns {@link NANOS}\n     *\n     * @return a query that can obtain the precision of a temporal, not null\n     */\n    static precision() {\n        return TemporalQueries.PRECISION;\n    }\n\n    /**\n     * A lenient query for the {@link ZoneId}, falling back to the {@link ZoneOffset}.\n     *\n     * This queries a {@link TemporalAccessor} for the zone.\n     * It first tries to obtain the zone, using {@link zoneId}.\n     * If that is not found it tries to obtain the {@link offset}.\n     *\n     * In most cases, applications should use this query rather than {@link zoneId}.\n     *\n     * This query examines the {@link ChronoField#OFFSET_SECONDS}\n     * field and uses it to create a {@link ZoneOffset}.\n     *\n     * The method {@link ZoneId#from} can be used as a\n     * {@link TemporalQuery} via a method reference, {@link ZoneId::from}.\n     * That method is equivalent to this query, except that it throws an\n     * exception if a zone cannot be obtained.\n     *\n     * @return a query that can obtain the zone ID or offset of a temporal, not null\n     */\n    static zone() {\n        return TemporalQueries.ZONE;\n    }\n\n    /**\n     * A query for {@link ZoneOffset} returning null if not found.\n     *\n     * This returns a {@link TemporalQuery} that can be used to query a temporal\n     * object for the offset. The query will return null if the temporal\n     * object cannot supply an offset.\n     *\n     * The query implementation examines the {@link ChronoField#OFFSET_SECONDS}\n     * field and uses it to create a {@link ZoneOffset}.\n     *\n     * The method {@link java.time.ZoneOffset#from} can be used as a\n     * {@link TemporalQuery} via a method reference, {@link ZoneOffset::from}.\n     * This query and {@link ZoneOffset::from} will return the same result if the\n     * temporal object contains an offset. If the temporal object does not contain\n     * an offset, then the method reference will throw an exception, whereas this\n     * query will return null.\n     *\n     * @return a query that can obtain the offset of a temporal, not null\n     */\n    static offset() {\n        return TemporalQueries.OFFSET;\n    }\n\n    /**\n     * A query for {@link LocalDate} returning null if not found.\n     *\n     * This returns a {@link TemporalQuery} that can be used to query a temporal\n     * object for the local date. The query will return null if the temporal\n     * object cannot supply a local date.\n     *\n     * The query implementation examines the {@link ChronoField#EPOCH_DAY}\n     * field and uses it to create a {@link LocalDate}.\n     *\n     * @return a query that can obtain the date of a temporal, not null\n     */\n    static localDate() {\n        return TemporalQueries.LOCAL_DATE;\n    }\n\n    /**\n     * A query for {@link LocalTime} returning null if not found.\n     *\n     * This returns a {@link TemporalQuery} that can be used to query a temporal\n     * object for the local time. The query will return null if the temporal\n     * object cannot supply a local time.\n     *\n     * The query implementation examines the {@link ChronoField#NANO_OF_DAY}\n     * field and uses it to create a {@link LocalTime}.\n     *\n     * @return a query that can obtain the time of a temporal, not null\n     */\n    static localTime() {\n        return TemporalQueries.LOCAL_TIME;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/TemporalQueries.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from '../assert';\nimport {Enum} from '../Enum';\n\n\n/**\n * Strategy for querying a temporal object.\n *\n * Queries are a key tool for extracting information from temporal objects.\n * They exist to externalize the process of querying, permitting different\n * approaches, as per the strategy design pattern.\n * Examples might be a query that checks if the date is the day before February 29th\n * in a leap year, or calculates the number of days to your next birthday.\n *\n * The {@link TemporalField} interface provides another mechanism for querying\n * temporal objects. That interface is limited to returning a `long`.\n * By contrast, queries can return any type.\n *\n * There are two equivalent ways of using a {@link TemporalQuery}.\n * The first is to invoke the method on this interface directly.\n * The second is to use {@link TemporalAccessor#query}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   temporal = thisQuery.queryFrom(temporal);\n *   temporal = temporal.query(thisQuery);\n * </pre>\n * It is recommended to use the second approach, {@link query},\n * as it is a lot clearer to read in code.\n *\n * The most common implementations are method references, such as\n * {@link LocalDate::from} and {@link ZoneId::from}.\n * Further implementations are on {@link TemporalQueries}.\n * Queries may also be defined by applications.\n *\n * ### Specification for implementors\n *\n * This interface places no restrictions on the mutability of implementations,\n * however immutability is strongly recommended.\n *\n * @interface\n */\nexport class TemporalQuery  extends Enum {\n    /**\n     * Queries the specified temporal object.\n     *\n     * This queries the specified temporal object to return an object using the logic\n     * encapsulated in the implementing class.\n     * Examples might be a query that checks if the date is the day before February 29th\n     * in a leap year, or calculates the number of days to your next birthday.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#query}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisQuery.queryFrom(temporal);\n     *   temporal = temporal.query(thisQuery);\n     * </pre>\n     * It is recommended to use the second approach, {@link query},\n     * as it is a lot clearer to read in code.\n     *\n     * ### Specification for implementors\n     *\n     * The implementation must take the input object and query it.\n     * The implementation defines the logic of the query and is responsible for\n     * documenting that logic.\n     * It may use any method on {@link TemporalAccessor} to determine the result.\n     * The input object must not be altered.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to query, not null\n     * @return the queried value, may return null to indicate not found\n     * @throws DateTimeException if unable to query\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    queryFrom(temporal){\n        abstractMethodFail('queryFrom');\n    }\n\n}\n\n/**\n * Factory to create something similar to the JSR-310 {TemporalQuery} interface, takes a function and returns a new TemporalQuery object that presents that function\n * as the queryFrom() function.\n * @param name for the underlying Enum\n * @param queryFromFunction\n */\nexport function createTemporalQuery(name, queryFromFunction) {\n    class ExtendedTemporalQuery extends TemporalQuery {\n\n    }\n\n    ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n    return new ExtendedTemporalQuery(name);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/TemporalQuery.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert} from './assert';\nimport {MathUtil} from './MathUtil';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {DateTimeException, IllegalArgumentException, UnsupportedTemporalTypeException} from './errors';\nimport {DateTimeFormatterBuilder} from './format/DateTimeFormatterBuilder';\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalQueries} from './temporal/TemporalQueries';\n\n/**\n * A month-of-year, such as 'July'.\n *\n * {@link Month} is representing the 12 months of the year -\n * January, February, March, April, May, June, July, August, September, October,\n * November and December.\n *\n * In addition to the textual name, each month-of-year has an `int` value.\n * The `int` value follows normal usage and the ISO-8601 standard,\n * from 1 (January) to 12 (December). It is recommended that applications use the static values defined by this class\n * rather than the `int` value to ensure code clarity.\n *\n * This class represents a common concept that is found in many calendar systems.\n * As such, this class may be used by any calendar system that has the month-of-year\n * concept defined exactly equivalent to the ISO-8601 calendar system.\n *\n * ### Static properties of Class {@link Month}\n *\n * Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE,\n * Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER\n *\n */\nexport class Month extends Temporal {\n    \n    /**\n     *\n     * @param {number} value\n     */\n    constructor(value) {\n        super();\n        this._value = value;\n    }\n\n    /**\n     *\n     * @return {number} gets the value\n     */\n    value() {\n        return this._value;\n    }\n    \n    /**\n     * Gets the textual representation, such as 'Jan' or 'December'.\n     *\n     * This returns the textual name used to identify the month-of-year.\n     * The parameters control the length of the returned text and the locale.\n     *\n     * If no textual mapping is found then the numeric value (see {@link getValue}) is returned.\n     *\n     * @param {TextStyle} style - the length of the text required, not null\n     * @param {Locale} locale - the locale to use, not null\n     * @return {string} the text value of the day-of-week, not null\n     */\n    getDisplayName(style, locale) {\n        // TODO:\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n        //eslint-disable-next-line no-unreachable\n        return new DateTimeFormatterBuilder().appendText(ChronoField.MONTH_OF_YEAR, style).toFormatter(locale).format(this);\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this month-of-year can be queried for the specified field.\n     * If false, then calling the range (see {@link range}) and\n     * get (see {@link get}) methods will throw an exception.\n     *\n     * If the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then\n     * this method returns true.\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this month-of-year, false if not\n     */\n    isSupported(field) {\n        if (null === field) {\n            return false;\n        }\n        if (field instanceof ChronoField) {\n            return field === ChronoField.MONTH_OF_YEAR;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-of-year as an `int`.\n     *\n     * This queries this month for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then the\n     * value of the month-of-year, from 1 to 12, will be returned.\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {Number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an `int`\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return this.value();\n        }\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-of-year as a `long`.\n     *\n     * This queries this month for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then the\n     * value of the month-of-year, from 1 to 12, will be returned.\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {Number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return this.value();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n    \n    /**\n     * Returns the month-of-year that is the specified number of months after this one.\n     *\n     * The calculation rolls around the end of the year from December to January.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, positive or negative\n     * @return {Month} the resulting month, not null\n     */\n    plus(months) {\n        const amount = MathUtil.intMod(months, 12) + 12; // + 12 to make sure negative arguments are positive, the total is \"corrected\" by the next % 12\n        let newMonthVal = MathUtil.intMod((this.value() + amount), 12);\n        /* December is 12, not 0, but 12 % 12 = 0 */\n        newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;\n        return Month.of(newMonthVal);\n    }\n\n    /**\n     * Returns the month-of-year that is the specified number of months before this one.\n     *\n     * The calculation rolls around the start of the year from January to December.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, positive or negative\n     * @return {Month} the resulting month, not null\n     */\n    minus(months) {\n        return this.plus(-1 * MathUtil.intMod(months, 12));\n    }\n\n    /**\n     * Gets the length of this month in days.\n     *\n     * This takes a flag to determine whether to return the length for a leap year or not.\n     *\n     * February has 28 days in a standard year and 29 days in a leap year.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @param {boolean} leapYear - true if the length is required for a leap year\n     * @return {number} the length of this month in days, from 28 to 31\n     */\n    length(leapYear) {\n        switch (this) {\n            case Month.FEBRUARY:\n                return (leapYear ? 29 : 28);\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the minimum length of this month in days.\n     *\n     * February has a minimum length of 28 days.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @return {number} the minimum length of this month in days, from 28 to 31\n     */\n    minLength() {\n        switch (this) {\n            case Month.FEBRUARY:\n                return 28;\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the maximum length of this month in days.\n     *\n     * February has a maximum length of 29 days.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @return {number} the maximum length of this month in days, from 29 to 31\n     */\n    maxLength() {\n        switch (this) {\n            case Month.FEBRUARY:\n                return 29;\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the day-of-year corresponding to the first day of this month.\n     *\n     * This returns the day-of-year that this month begins on, using the leap\n     * year flag to determine the length of February.\n     *\n     * @param {boolean} leapYear - true if the length is required for a leap year\n     * @return {number} the day of year corresponding to the first day of this month, from 1 to 336\n     */\n    firstDayOfYear(leapYear) {\n        const leap = leapYear ? 1 : 0;\n        switch (this) {\n            case Month.JANUARY:\n                return 1;\n            case Month.FEBRUARY:\n                return 32;\n            case Month.MARCH:\n                return 60 + leap;\n            case Month.APRIL:\n                return 91 + leap;\n            case Month.MAY:\n                return 121 + leap;\n            case Month.JUNE:\n                return 152 + leap;\n            case Month.JULY:\n                return 182 + leap;\n            case Month.AUGUST:\n                return 213 + leap;\n            case Month.SEPTEMBER:\n                return 244 + leap;\n            case Month.OCTOBER:\n                return 274 + leap;\n            case Month.NOVEMBER:\n                return 305 + leap;\n            case Month.DECEMBER:\n            default:\n                return 335 + leap;\n        }\n    }\n\n    /**\n     * Gets the month corresponding to the first month of this quarter.\n     *\n     * The year can be divided into four quarters.\n     * This method returns the first month of the quarter for the base month.\n     * January, February and March return January.\n     * April, May and June return April.\n     * July, August and September return July.\n     * October, November and December return October.\n     *\n     * @return {Month} the first month of the quarter corresponding to this month, not null\n     */\n    firstMonthOfQuarter() {\n        switch (this) {\n            case Month.JANUARY:\n            case Month.FEBRUARY:\n            case Month.MARCH:\n                return Month.JANUARY;\n            case Month.APRIL:\n            case Month.MAY:\n            case Month.JUNE:\n                return Month.APRIL;\n            case Month.JULY:\n            case Month.AUGUST:\n            case Month.SEPTEMBER:\n                return Month.JULY;\n            case Month.OCTOBER:\n            case Month.NOVEMBER:\n            case Month.DECEMBER:\n            default:\n                return Month.OCTOBER;\n        }\n    }\n    \n    /**\n     * Queries this month-of-year using the specified query.\n     *\n     * This queries this month-of-year using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        assert(query != null, 'query() parameter must not be null', DateTimeException);\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.MONTHS;\n        }\n        return super.query(query);\n    }\n\n\n\n    /**\n     * toString implementation... in JDK this is inherited from the Enum class\n     * \n     * @return {String}\n     */\n    toString() {\n        switch (this) {\n            case Month.JANUARY:\n                return 'JANUARY';\n            case Month.FEBRUARY:\n                return 'FEBRUARY';\n            case Month.MARCH:\n                return 'MARCH';\n            case Month.APRIL:\n                return 'APRIL';\n            case Month.MAY:\n                return 'MAY';\n            case Month.JUNE:\n                return 'JUNE';\n            case Month.JULY:\n                return 'JULY';\n            case Month.AUGUST:\n                return 'AUGUST';\n            case Month.SEPTEMBER:\n                return 'SEPTEMBER';\n            case Month.OCTOBER:\n                return 'OCTOBER';\n            case Month.NOVEMBER:\n                return 'NOVEMBER';\n            case Month.DECEMBER:\n                return 'DECEMBER';\n            default:\n                return 'unknown Month, value: ' + this.value();\n        }\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this month-of-year.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the month-of-year changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#MONTH_OF_YEAR} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisMonth.adjustInto(temporal);\n     *   temporal = temporal.with(thisMonth);\n     * </pre>\n     *\n     * For example, given a date in May, the following are output:\n     * <pre>\n     *   dateInMay.with(JANUARY);    // four months earlier\n     *   dateInMay.with(APRIL);      // one months earlier\n     *   dateInMay.with(MAY);        // same date\n     *   dateInMay.with(JUNE);       // one month later\n     *   dateInMay.with(DECEMBER);   // seven months later\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        /* we support only ISO for now\n            if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) === false) {\n                throw new DateTimeException('Adjustment only supported on ISO date-time');\n            }\n        */\n        return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());\n    }\n    \n    /**\n     * replacement for enum values\n     * @return {Month[]}\n     */\n    static values(){\n        return MONTHS.slice();\n    }\n\n    /**\n     *\n     * @param {number} month\n     * @return {Month} not null\n     **/\n    static of(month) {\n        if (month < 1 || month > 12) {\n            assert(false, 'Invalid value for MonthOfYear: ' + month, DateTimeException);\n        }\n        return MONTHS[month-1];\n    }\n    \n    /**\n     * Obtains an instance of {@link Month} from a temporal object.\n     *\n     * This obtains a month based on the specified temporal.\n     * A {@link TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@link Month}.\n     *\n     * The conversion extracts the MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) field.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link Month::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {Month} the month-of-year, not null\n     * @throws DateTimeException if unable to convert to a {@link Month}\n     */\n    static from(temporal) {\n        if (temporal instanceof Month) {\n            return temporal;\n        }\n        try {\n            /* only ISO for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return Month.of(temporal.get(ChronoField.MONTH_OF_YEAR));\n        } catch (ex) {\n            throw new DateTimeException('Unable to obtain Month from TemporalAccessor: ' +\n                    temporal + ' of type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''), ex);\n        }\n    }\n}\n\nlet MONTHS;\n\nexport function _init() {\n    Month.JANUARY = new Month(1);\n    Month.FEBRUARY = new Month(2);\n    Month.MARCH = new Month(3);\n    Month.APRIL = new Month(4);\n    Month.MAY = new Month(5);\n    Month.JUNE = new Month(6);\n    Month.JULY = new Month(7);\n    Month.AUGUST = new Month(8);\n    Month.SEPTEMBER = new Month(9);\n    Month.OCTOBER = new Month(10);\n    Month.NOVEMBER = new Month(11);\n    Month.DECEMBER = new Month(12);\n\n    MONTHS = [\n        Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE,\n        Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER\n    ];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Month.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull, requireInstance} from '../assert';\nimport {ArithmeticException, DateTimeException, IllegalArgumentException, IllegalStateException} from '../errors';\nimport {MathUtil} from '../MathUtil';\n\nimport {Enum} from '../Enum';\nimport {ZoneIdFactory} from '../ZoneIdFactory';\nimport {LocalDate} from '../LocalDate';\nimport {LocalDateTime} from '../LocalDateTime';\nimport {ZoneOffset} from '../ZoneOffset';\nimport {ZoneId} from '../ZoneId';\nimport {ChronoLocalDate} from '../chrono/ChronoLocalDate';\nimport {IsoChronology} from '../chrono/IsoChronology';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {IsoFields} from '../temporal/IsoFields';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\nimport {DateTimeFormatter} from './DateTimeFormatter';\nimport {DecimalStyle} from './DecimalStyle';\nimport {SignStyle} from './SignStyle';\nimport {TextStyle} from './TextStyle';\nimport {ResolverStyle} from './ResolverStyle';\n\nconst MAX_WIDTH = 15; // can't parse all numbers with more then 15 digits in javascript\n\nexport class DateTimeFormatterBuilder {\n\n    /**\n     * Constructs a new instance of the builder.\n     *\n     * @param {DateTimeFormatterBuilder} parent  the parent builder, not null\n     * @param {boolean} optional  whether the formatter is optional, not null\n     */\n    constructor(parent=null, optional=false){\n        /**\n         * The currently active builder, used by the outermost builder.\n         */\n        this._active = this;\n        /**\n         * The parent builder, null for the outermost builder.\n         */\n        this._parent = parent;\n\n        /**\n         * The list of printers that will be used.\n         */\n        this._printerParsers = [];\n\n        /**\n         * Whether this builder produces an optional formatter.\n         */\n        this._optional = optional;\n        /**\n         * The width to pad the next field to.\n         */\n        this._padNextWidth = 0;\n\n        /**\n         * The character to pad the next field with.\n         */\n        this._padNextChar = null;\n\n        /**\n         * The index of the last variable width value parser.\n         */\n        this._valueParserIndex = -1;\n    }\n\n    /**\n     * Changes the parse style to be case sensitive for the remainder of the formatter.\n     *\n     * Parsing can be case sensitive or insensitive - by default it is case sensitive.\n     * This method allows the case sensitivity setting of parsing to be changed.\n     *\n     * Calling this method changes the state of the builder such that all\n     * subsequent builder method calls will parse text in case sensitive mode.\n     * See {@link parseCaseInsensitive} for the opposite setting.\n     * The parse case sensitive/insensitive methods may be called at any point\n     * in the builder, thus the parser can swap between case parsing modes\n     * multiple times during the parse.\n     *\n     * Since the default is case sensitive, this method should only be used after\n     * a previous call to {@link parseCaseInsensitive}.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseCaseSensitive() {\n        this._appendInternalPrinterParser(SettingsParser.SENSITIVE);\n        return this;\n    }\n\n    /**\n     * Changes the parse style to be case insensitive for the remainder of the formatter.\n     *\n     * Parsing can be case sensitive or insensitive - by default it is case sensitive.\n     * This method allows the case sensitivity setting of parsing to be changed.\n     *\n     * Calling this method changes the state of the builder such that all\n     * subsequent builder method calls will parse text in case sensitive mode.\n     * See {@link parseCaseSensitive} for the opposite setting.\n     * The parse case sensitive/insensitive methods may be called at any point\n     * in the builder, thus the parser can swap between case parsing modes\n     * multiple times during the parse.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseCaseInsensitive() {\n        this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Changes the parse style to be strict for the remainder of the formatter.\n     *\n     * Parsing can be strict or lenient - by default its strict.\n     * This controls the degree of flexibility in matching the text and sign styles.\n     *\n     * When used, this method changes the parsing to be strict from this point onwards.\n     * As strict is the default, this is normally only needed after calling {@link parseLenient}.\n     * The change will remain in force until the end of the formatter that is eventually\n     * constructed or until {@link parseLenient} is called.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseStrict() {\n        this._appendInternalPrinterParser(SettingsParser.STRICT);\n        return this;\n    }\n\n    /**\n     * Changes the parse style to be lenient for the remainder of the formatter.\n     * Note that case sensitivity is set separately to this method.\n     *\n     * Parsing can be strict or lenient - by default its strict.\n     * This controls the degree of flexibility in matching the text and sign styles.\n     * Applications calling this method should typically also call {@link parseCaseInsensitive}.\n     *\n     * When used, this method changes the parsing to be strict from this point onwards.\n     * The change will remain in force until the end of the formatter that is eventually\n     * constructed or until {@link parseStrict} is called.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseLenient() {\n        this._appendInternalPrinterParser(SettingsParser.LENIENT);\n        return this;\n    }\n\n    /**\n     * appendValue function overloading\n     */\n    appendValue(){\n        if(arguments.length === 1){\n            return this._appendValue1.apply(this, arguments);\n        } else if(arguments.length === 2){\n            return this._appendValue2.apply(this, arguments);\n        } else {\n            return this._appendValue4.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Appends the value of a date-time field to the formatter using a normal\n     * output style.\n     *\n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     *\n     * The value will be printed as per the normal print of an integer value.\n     * Only negative numbers will be signed. No padding will be added.\n     *\n     * The parser for a variable width value such as this normally behaves greedily,\n     * requiring one digit, but accepting as many digits as possible.\n     * This behavior can be affected by 'adjacent value parsing'.\n     * See {@link appendValue} for full details.\n     *\n     * @param field  the field to append, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    _appendValue1(field) {\n        requireNonNull(field);\n        this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));\n        return this;\n    }\n\n    /**\n     * Appends the value of a date-time field to the formatter using a fixed\n     * width, zero-padded approach.\n     *\n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     *\n     * The value will be zero-padded on the left. If the size of the value\n     * means that it cannot be printed within the width then an exception is thrown.\n     * If the value of the field is negative then an exception is thrown during printing.\n     *\n     * This method supports a special technique of parsing known as 'adjacent value parsing'.\n     * This technique solves the problem where a variable length value is followed by one or more\n     * fixed length values. The standard parser is greedy, and thus it would normally\n     * steal the digits that are needed by the fixed width value parsers that follow the\n     * variable width one.\n     *\n     * No action is required to initiate 'adjacent value parsing'.\n     * When a call to {@link appendValue} with a variable width is made, the builder\n     * enters adjacent value parsing setup mode. If the immediately subsequent method\n     * call or calls on the same builder are to this method, then the parser will reserve\n     * space so that the fixed width values can be parsed.\n     *\n     * For example, consider `builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2)`.\n     * The year is a variable width parse of between 1 and 19 digits.\n     * The month is a fixed width parse of 2 digits.\n     * Because these were appended to the same builder immediately after one another,\n     * the year parser will reserve two digits for the month to parse.\n     * Thus, the text '201106' will correctly parse to a year of 2011 and a month of 6.\n     * Without adjacent value parsing, the year would greedily parse all six digits and leave\n     * nothing for the month.\n     *\n     * Adjacent value parsing applies to each set of fixed width not-negative values in the parser\n     * that immediately follow any kind of variable width value.\n     * Calling any other append method will end the setup of adjacent value parsing.\n     * Thus, in the unlikely event that you need to avoid adjacent value parsing behavior,\n     * simply add the `appendValue` to another {@link DateTimeFormatterBuilder}\n     * and add that to this builder.\n     *\n     * If adjacent parsing is active, then parsing must match exactly the specified\n     * number of digits in both strict and lenient modes.\n     * In addition, no positive or negative sign is permitted.\n     *\n     * @param field  the field to append, not null\n     * @param width  the width of the printed field, from 1 to 19\n     * @return this, for chaining, not null\n     * @throws IllegalArgumentException if the width is invalid\n     */\n    _appendValue2(field, width) {\n        requireNonNull(field);\n        if (width < 1 || width > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The width must be from 1 to ${MAX_WIDTH} inclusive but was ${width}`);\n        }\n        const pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * Appends the value of a date-time field to the formatter providing full\n     * control over printing.\n     *\n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     *\n     * This method provides full control of the numeric formatting, including\n     * zero-padding and the positive/negative sign.\n     *\n     * The parser for a variable width value such as this normally behaves greedily,\n     * accepting as many digits as possible.\n     * This behavior can be affected by 'adjacent value parsing'.\n     * See {@link appendValue} for full details.\n     *\n     * In strict parsing mode, the minimum number of parsed digits is `minWidth`.\n     * In lenient parsing mode, the minimum number of parsed digits is one.\n     *\n     * If this method is invoked with equal minimum and maximum widths and a sign style of\n     * `NOT_NEGATIVE` then it delegates to `appendValue(TemporalField, int)`.\n     * In this scenario, the printing and parsing behavior described there occur.\n     *\n     * @param field  the field to append, not null\n     * @param minWidth  the minimum field width of the printed field, from 1 to 19\n     * @param maxWidth  the maximum field width of the printed field, from 1 to 19\n     * @param signStyle  the positive/negative output style, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the widths are invalid\n     */\n    _appendValue4(field, minWidth, maxWidth, signStyle) {\n        requireNonNull(field);\n        requireNonNull(signStyle);\n        if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {\n            return this._appendValue2(field, maxWidth);\n        }\n        if (minWidth < 1 || minWidth > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The minimum width must be from 1 to ${MAX_WIDTH} inclusive but was ${minWidth}`);\n        }\n        if (maxWidth < 1 || maxWidth > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The minimum width must be from 1 to ${MAX_WIDTH} inclusive but was ${maxWidth}`);\n        }\n        if (maxWidth < minWidth) {\n            throw new IllegalArgumentException(`The maximum width must exceed or equal the minimum width but ${maxWidth} < ${minWidth}`);\n        }\n        const pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * appendValueReduced function overloading\n     */\n    appendValueReduced() {\n        if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {\n            return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);\n        } else {\n            return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Appends the reduced value of a date-time field to the formatter.\n     *\n     * Since fields such as year vary by chronology, it is recommended to use the\n     * {@link appendValueReduced} date}\n     * variant of this method in most cases. This variant is suitable for\n     * simple fields or working with only the ISO chronology.\n     *\n     * For formatting, the `width` and `maxWidth` are used to\n     * determine the number of characters to format.\n     * If they are equal then the format is fixed width.\n     * If the value of the field is within the range of the `baseValue` using\n     * `width` characters then the reduced value is formatted otherwise the value is\n     * truncated to fit `maxWidth`.\n     * The rightmost characters are output to match the width, left padding with zero.\n     *\n     * For strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.\n     * For lenient parsing, the number of characters must be at least 1 and less than 10.\n     * If the number of digits parsed is equal to `width` and the value is positive,\n     * the value of the field is computed to be the first number greater than\n     * or equal to the `baseValue` with the same least significant characters,\n     * otherwise the value parsed is the field value.\n     * This allows a reduced value to be entered for values in range of the baseValue\n     * and width and absolute values can be entered for values outside the range.\n     *\n     * For example, a base value of `1980` and a width of `2` will have\n     * valid values from `1980` to `2079`.\n     * During parsing, the text `\"12\"` will result in the value `2012` as that\n     * is the value within the range where the last two characters are \"12\".\n     * By contrast, parsing the text `\"1915\"` will result in the value `1915`.\n     *\n     * @param {TemporalField} field  the field to append, not null\n     * @param {number} width  the field width of the printed and parsed field, from 1 to 10\n     * @param {number} maxWidth  the maximum field width of the printed field, from 1 to 10\n     * @param {number} baseValue  the base value of the range of valid values\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the width or base value is invalid\n     */\n    _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {\n        requireNonNull(field, 'field');\n        const pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * Appends the reduced value of a date-time field to the formatter.\n     *\n     * This is typically used for formatting and parsing a two digit year.\n     *\n     * The base date is used to calculate the full value during parsing.\n     * For example, if the base date is 1950-01-01 then parsed values for\n     * a two digit year parse will be in the range 1950-01-01 to 2049-12-31.\n     * Only the year would be extracted from the date, thus a base date of\n     * 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.\n     * This behavior is necessary to support fields such as week-based-year\n     * or other calendar systems where the parsed value does not align with\n     * standard ISO years.\n     *\n     * The exact behavior is as follows. Parse the full set of fields and\n     * determine the effective chronology using the last chronology if\n     * it appears more than once. Then convert the base date to the\n     * effective chronology. Then extract the specified field from the\n     * chronology-specific base date and use it to determine the\n     * `baseValue` used below.\n     *\n     * For formatting, the `width` and `maxWidth` are used to\n     * determine the number of characters to format.\n     * If they are equal then the format is fixed width.\n     * If the value of the field is within the range of the `baseValue` using\n     * `width` characters then the reduced value is formatted otherwise the value is\n     * truncated to fit `maxWidth`.\n     * The rightmost characters are output to match the width, left padding with zero.\n     *\n     * For strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.\n     * For lenient parsing, the number of characters must be at least 1 and less than 10.\n     * If the number of digits parsed is equal to `width` and the value is positive,\n     * the value of the field is computed to be the first number greater than\n     * or equal to the `baseValue` with the same least significant characters,\n     * otherwise the value parsed is the field value.\n     * This allows a reduced value to be entered for values in range of the baseValue\n     * and width and absolute values can be entered for values outside the range.\n     *\n     * For example, a base value of `1980` and a width of `2` will have\n     * valid values from `1980` to `2079`.\n     * During parsing, the text `\"12\"` will result in the value `2012` as that\n     * is the value within the range where the last two characters are \"12\".\n     * By contrast, parsing the text `\"1915\"` will result in the value `1915`.\n     *\n     * @param {TemporaField} field  the field to append, not null\n     * @param {number} width  the field width of the printed and parsed field, from 1 to 10\n     * @param {number} maxWidth  the maximum field width of the printed field, from 1 to 10\n     * @param {ChronoLocalDate} baseDate  the base date used to calculate the base value for the range\n     *  of valid values in the parsed chronology, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the width or base value is invalid\n     */\n    _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {\n        requireNonNull(field, 'field');\n        requireNonNull(baseDate, 'baseDate');\n        requireInstance(baseDate, ChronoLocalDate, 'baseDate');\n        const pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * Appends a fixed width printer-parser.\n     *\n     * @param pp  the printer-parser, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    _appendValuePrinterParser(pp) {\n        assert(pp != null);\n        if (this._active._valueParserIndex >= 0 &&\n                this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {\n            const activeValueParser = this._active._valueParserIndex;\n\n            // adjacent parsing mode, update setting in previous parsers\n            let basePP = this._active._printerParsers[activeValueParser];\n            if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {\n                // Append the width to the subsequentWidth of the active parser\n                basePP = basePP.withSubsequentWidth(pp.maxWidth());\n                // Append the new parser as a fixed width\n                this._appendInternal(pp.withFixedWidth());\n                // Retain the previous active parser\n                this._active._valueParserIndex = activeValueParser;\n            } else {\n                // Modify the active parser to be fixed width\n                basePP = basePP.withFixedWidth();\n                // The new parser becomes the mew active parser\n                this._active._valueParserIndex = this._appendInternal(pp);\n            }\n            // Replace the modified parser with the updated one\n            this._active._printerParsers[activeValueParser] = basePP;\n        } else {\n            // The new Parser becomes the active parser\n            this._active._valueParserIndex = this._appendInternal(pp);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the fractional value of a date-time field to the formatter.\n     *\n     * The fractional value of the field will be output including the\n     * preceding decimal point. The preceding value is not output.\n     * For example, the second-of-minute value of 15 would be output as `.25`.\n     *\n     * The width of the printed fraction can be controlled. Setting the\n     * minimum width to zero will cause no output to be generated.\n     * The printed fraction will have the minimum width necessary between\n     * the minimum and maximum widths - trailing zeroes are omitted.\n     * No rounding occurs due to the maximum width - digits are simply dropped.\n     *\n     * When parsing in strict mode, the number of parsed digits must be between\n     * the minimum and maximum width. When parsing in lenient mode, the minimum\n     * width is considered to be zero and the maximum is nine.\n     *\n     * If the value cannot be obtained then an exception will be thrown.\n     * If the value is negative an exception will be thrown.\n     * If the field does not have a fixed set of valid values then an\n     * exception will be thrown.\n     * If the field value in the date-time to be printed is invalid it\n     * cannot be printed and an exception will be thrown.\n     *\n     * @param {TemporalField} field  the field to append, not null\n     * @param {Number} minWidth  the minimum width of the field excluding the decimal point, from 0 to 9\n     * @param {Number} maxWidth  the maximum width of the field excluding the decimal point, from 1 to 9\n     * @param {boolean} decimalPoint  whether to output the localized decimal point symbol\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the field has a variable set of valid values or\n     *  either width is invalid\n     */\n    appendFraction(field, minWidth, maxWidth, decimalPoint) {\n        this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n        return this;\n    }\n\n    /**\n     * Appends an instant using ISO-8601 to the formatter with control over\n     * the number of fractional digits.\n     *\n     * Instants have a fixed output format, although this method provides some\n     * control over the fractional digits. They are converted to a date-time\n     * with a zone-offset of UTC and printed using the standard ISO-8601 format.\n     * The localized decimal style is not used.\n     *\n     * The {@link this.fractionalDigits} parameter allows the output of the fractional\n     * second to be controlled. Specifying zero will cause no fractional digits\n     * to be output. From 1 to 9 will output an increasing number of digits, using\n     * zero right-padding if necessary. The special value -1 is used to output as\n     * many digits as necessary to avoid any trailing zeroes.\n     *\n     * When parsing in strict mode, the number of parsed digits must match the\n     * fractional digits. When parsing in lenient mode, any number of fractional\n     * digits from zero to nine are accepted.\n     *\n     * The instant is obtained using {@link ChronoField#INSTANT_SECONDS}\n     * and optionally (@code NANO_OF_SECOND). The value of {@link INSTANT_SECONDS}\n     * may be outside the maximum range of {@link LocalDateTime}.\n     *\n     * The {@link ResolverStyle} has no effect on instant parsing.\n     * The end-of-day time of '24:00' is handled as midnight at the start of the following day.\n     * The leap-second time of '23:59:59' is handled to some degree, see\n     * {@link DateTimeFormatter#parsedLeapSecond} for full details.\n     *\n     * An alternative to this method is to format/parse the instant as a single\n     * epoch-seconds value. That is achieved using `appendValue(INSTANT_SECONDS)`.\n     *\n     * @param {number} [fractionalDigits=-2] - the number of fractional second digits to format with,\n     *  from 0 to 9, or -1 to use as many digits as necessary\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendInstant(fractionalDigits=-2) {\n        if (fractionalDigits < -2 || fractionalDigits > 9) {\n            throw new IllegalArgumentException('Invalid fractional digits: ' + fractionalDigits);\n        }\n        this._appendInternal(new InstantPrinterParser(fractionalDigits));\n        return this;\n    }\n\n\n    /**\n     * Appends the zone offset, such as '+01:00', to the formatter.\n     *\n     * This appends an instruction to print/parse the offset ID to the builder.\n     * This is equivalent to calling `appendOffset(\"HH:MM:ss\", \"Z\")`.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendOffsetId() {\n        this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);\n        return this;\n    }\n\n    /**\n     * Appends the zone offset, such as '+01:00', to the formatter.\n     *\n     * This appends an instruction to print/parse the offset ID to the builder.\n     *\n     * During printing, the offset is obtained using a mechanism equivalent\n     * to querying the temporal with {@link TemporalQueries#offset}.\n     * It will be printed using the format defined below.\n     * If the offset cannot be obtained then an exception is thrown unless the\n     * section of the formatter is optional.\n     *\n     * During parsing, the offset is parsed using the format defined below.\n     * If the offset cannot be parsed then an exception is thrown unless the\n     * section of the formatter is optional.\n     *\n     * The format of the offset is controlled by a pattern which must be one\n     * of the following:\n     *\n     * * `+HH` - hour only, ignoring minute and second\n     * * `+HHmm` - hour, with minute if non-zero, ignoring second, no colon\n     * * `+HH:mm` - hour, with minute if non-zero, ignoring second, with colon\n     * * `+HHMM` - hour and minute, ignoring second, no colon\n     * * `+HH:MM` - hour and minute, ignoring second, with colon\n     * * `+HHMMss` - hour and minute, with second if non-zero, no colon\n     * * `+HH:MM:ss` - hour and minute, with second if non-zero, with colon\n     * * `+HHMMSS` - hour, minute and second, no colon\n     * * `+HH:MM:SS` - hour, minute and second, with colon\n     *\n     * The \"no offset\" text controls what text is printed when the total amount of\n     * the offset fields to be output is zero.\n     * Example values would be 'Z', '+00:00', 'UTC' or 'GMT'.\n     * Three formats are accepted for parsing UTC - the \"no offset\" text, and the\n     * plus and minus versions of zero defined by the pattern.\n     *\n     * @param {String} pattern  the pattern to use, not null\n     * @param {String} noOffsetText  the text to use when the offset is zero, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendOffset(pattern, noOffsetText) {\n        this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));\n        return this;\n    }\n\n    /**\n      * Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.\n      *\n      * This appends an instruction to print/parse the zone ID to the builder.\n      * The zone ID is obtained in a strict manner suitable for {@link ZonedDateTime}.\n      * By contrast, {@link OffsetDateTime} does not have a zone ID suitable\n      * for use with this method, see {@link appendZoneOrOffsetId}.\n      *\n      * During printing, the zone is obtained using a mechanism equivalent\n      * to querying the temporal with {@link TemporalQueries#zoneId}.\n      * It will be printed using the result of {@link ZoneId#getId}.\n      * If the zone cannot be obtained then an exception is thrown unless the\n      * section of the formatter is optional.\n      *\n      * During parsing, the zone is parsed and must match a known zone or offset.\n      * If the zone cannot be parsed then an exception is thrown unless the\n      * section of the formatter is optional.\n      *\n      * @return {DateTimeFormatterBuilder} this, for chaining, not null\n      * @see #appendZoneRegionId()\n      */\n    appendZoneId() {\n        this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), 'ZoneId()'));\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the elements defined by the specified pattern to the builder.\n     *\n     * All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.\n     * The characters '{' and '}' are reserved for future use.\n     * The characters '[' and ']' indicate optional patterns.\n     * The following pattern letters are defined:\n     * <pre>\n     *  Symbol  Meaning                     Presentation      Examples\n     *  ------  -------                     ------------      -------\n     *   G       era                         number/text       1; 01; AD; Anno Domini\n     *   y       year                        year              2004; 04\n     *   D       day-of-year                 number            189\n     *   M       month-of-year               number/text       7; 07; Jul; July; J\n     *   d       day-of-month                number            10\n     *\n     *   Q       quarter-of-year             number/text       3; 03; Q3\n     *   Y       week-based-year             year              1996; 96\n     *   w       week-of-year                number            27\n     *   W       week-of-month               number            27\n     *   e       localized day-of-week       number            2; Tue; Tuesday; T\n     *   E       day-of-week                 number/text       2; Tue; Tuesday; T\n     *   F       week-of-month               number            3\n     *\n     *   a       am-pm-of-day                text              PM\n     *   h       clock-hour-of-am-pm (1-12)  number            12\n     *   K       hour-of-am-pm (0-11)        number            0\n     *   k       clock-hour-of-am-pm (1-24)  number            0\n     *\n     *   H       hour-of-day (0-23)          number            0\n     *   m       minute-of-hour              number            30\n     *   s       second-of-minute            number            55\n     *   S       fraction-of-second          fraction          978\n     *   A       milli-of-day                number            1234\n     *   n       nano-of-second              number            987654321\n     *   N       nano-of-day                 number            1234000000\n     *\n     *   V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30\n     *   z       time-zone name              zone-name         Pacific Standard Time; PST\n     *   X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15;\n     *   x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15;\n     *   Z       zone-offset                 offset-Z          +0000; -0800; -08:00;\n     *\n     *   p       pad next                    pad modifier      1\n     *\n     *   '       escape for text             delimiter\n     *   ''      single quote                literal           '\n     *   [       optional section start\n     *   ]       optional section end\n     *   {}      reserved for future use\n     * </pre>\n     *\n     * The count of pattern letters determine the format.\n     *\n     * **Text**: The text style is determined based on the number of pattern letters used.\n     * Less than 4 pattern letters will use the short form (see {@link TextStyle#SHORT}).\n     * Exactly 4 pattern letters will use the full form (see {@link TextStyle#FULL}).\n     * Exactly 5 pattern letters will use the narrow form (see {@link TextStyle#NARROW}).\n     *\n     * **Number**: If the count of letters is one, then the value is printed using the minimum number\n     * of digits and without padding as per {@link appendValue}. Otherwise, the\n     * count of digits is used as the width of the output field as per {@link appendValue}.\n     *\n     * **Number/Text**: If the count of pattern letters is 3 or greater, use the Text rules above.\n     * Otherwise use the Number rules above.\n     *\n     * **Fraction**: Outputs the nano-of-second field as a fraction-of-second.\n     * The nano-of-second value has nine digits, thus the count of pattern letters is from 1 to 9.\n     * If it is less than 9, then the nano-of-second value is truncated, with only the most\n     * significant digits being output.\n     * When parsing in strict mode, the number of parsed digits must match the count of pattern letters.\n     * When parsing in lenient mode, the number of parsed digits must be at least the count of pattern\n     * letters, up to 9 digits.\n     *\n     * **Year**: The count of letters determines the minimum field width below which padding is used.\n     * If the count of letters is two, then a reduced (see {@link appendValueReduced}) two digit form is used.\n     * For printing, this outputs the rightmost two digits. For parsing, this will parse using the\n     * base value of 2000, resulting in a year within the range 2000 to 2099 inclusive.\n     * If the count of letters is less than four (but not two), then the sign is only output for negative\n     * years as per {@link SignStyle#NORMAL}.\n     * Otherwise, the sign is output if the pad width is exceeded, as per {@link SignStyle#EXCEEDS_PAD}\n     *\n     * **ZoneId**: This outputs the time-zone ID, such as 'Europe/Paris'.\n     * If the count of letters is two, then the time-zone ID is output.\n     * Any other count of letters throws {@link IllegalArgumentException}.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   VV          appendZoneId()\n     * </pre>\n     *\n     * **Zone names**: This outputs the display name of the time-zone ID.\n     * If the count of letters is one, two or three, then the short name is output.\n     * If the count of letters is four, then the full name is output.\n     * Five or more letters throws {@link IllegalArgumentException}.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   z           appendZoneText(TextStyle.SHORT)\n     *   zz          appendZoneText(TextStyle.SHORT)\n     *   zzz         appendZoneText(TextStyle.SHORT)\n     *   zzzz        appendZoneText(TextStyle.FULL)\n     * </pre>\n     *\n     * **Offset X and x**: This formats the offset based on the number of pattern letters.\n     * One letter outputs just the hour', such as '+01', unless the minute is non-zero\n     * in which case the minute is also output, such as '+0130'.\n     * Two letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Three letters outputs the hour and minute, with a colon, such as '+01:30'.\n     * Four letters outputs the hour and minute and optional second, without a colon, such as '+013015'.\n     * Five letters outputs the hour and minute and optional second, with a colon, such as '+01:30:15'.\n     * Six or more letters throws {@link IllegalArgumentException}.\n     * Pattern letter 'X' (upper case) will output 'Z' when the offset to be output would be zero,\n     * whereas pattern letter 'x' (lower case) will output '+00', '+0000', or '+00:00'.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   X           appendOffset(\"+HHmm\",\"Z\")\n     *   XX          appendOffset(\"+HHMM\",\"Z\")\n     *   XXX         appendOffset(\"+HH:MM\",\"Z\")\n     *   XXXX        appendOffset(\"+HHMMss\",\"Z\")\n     *   XXXXX       appendOffset(\"+HH:MM:ss\",\"Z\")\n     *   x           appendOffset(\"+HHmm\",\"+00\")\n     *   xx          appendOffset(\"+HHMM\",\"+0000\")\n     *   xxx         appendOffset(\"+HH:MM\",\"+00:00\")\n     *   xxxx        appendOffset(\"+HHMMss\",\"+0000\")\n     *   xxxxx       appendOffset(\"+HH:MM:ss\",\"+00:00\")\n     * </pre>\n     *\n     * **Offset Z**: This formats the offset based on the number of pattern letters.\n     * One, two or three letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Four or more letters throws {@link IllegalArgumentException}.\n     * The output will be '+0000' when the offset is zero.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   Z           appendOffset(\"+HHMM\",\"+0000\")\n     *   ZZ          appendOffset(\"+HHMM\",\"+0000\")\n     *   ZZZ         appendOffset(\"+HHMM\",\"+0000\")\n     * </pre>\n     *\n     * **Optional section**: The optional section markers work exactly like calling {@link optionalStart}\n     * and {@link optionalEnd}.\n     *\n     * **Pad modifier**: Modifies the pattern that immediately follows to be padded with spaces.\n     * The pad width is determined by the number of pattern letters.\n     * This is the same as calling {@link padNext}.\n     *\n     * For example, 'ppH' outputs the hour-of-day padded on the left with spaces to a width of 2.\n     *\n     * Any unrecognized letter is an error.\n     * Any non-letter character, other than '[', ']', '{', '}' and the single quote will be output directly.\n     * Despite this, it is recommended to use single quotes around all characters that you want to\n     * output directly to ensure that future changes do not break your application.\n     *\n     * Note that the pattern string is similar, but not identical, to\n     * {@link java.text.SimpleDateFormat}.\n     * The pattern string is also similar, but not identical, to that defined by the\n     * Unicode Common Locale Data Repository (CLDR/LDML).\n     * Pattern letters 'E' and 'u' are merged, which changes the meaning of \"E\" and \"EE\" to be numeric.\n     * Pattern letters 'X' is aligned with Unicode CLDR/LDML, which affects pattern 'X'.\n     * Pattern letter 'y' and 'Y' parse years of two digits and more than 4 digits differently.\n     * Pattern letters 'n', 'A', 'N', 'I' and 'p' are added.\n     * Number types will reject large numbers.\n     *\n     * @param {String} pattern  the pattern to add, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     */\n    appendPattern(pattern) {\n        requireNonNull(pattern, 'pattern');\n        this._parsePattern(pattern);\n        return this;\n    }\n\n    _parsePattern(pattern) {\n        /** Map of letters to fields. */\n        const FIELD_MAP = {\n            'G': ChronoField.ERA,\n            'y': ChronoField.YEAR_OF_ERA,\n            'u': ChronoField.YEAR,\n            'Q': IsoFields.QUARTER_OF_YEAR,\n            'q': IsoFields.QUARTER_OF_YEAR,\n            'M': ChronoField.MONTH_OF_YEAR,\n            'L': ChronoField.MONTH_OF_YEAR,\n            'D': ChronoField.DAY_OF_YEAR,\n            'd': ChronoField.DAY_OF_MONTH,\n            'F': ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,\n            'E': ChronoField.DAY_OF_WEEK,\n            'c': ChronoField.DAY_OF_WEEK,\n            'e': ChronoField.DAY_OF_WEEK,\n            'a': ChronoField.AMPM_OF_DAY,\n            'H': ChronoField.HOUR_OF_DAY,\n            'k': ChronoField.CLOCK_HOUR_OF_DAY,\n            'K': ChronoField.HOUR_OF_AMPM,\n            'h': ChronoField.CLOCK_HOUR_OF_AMPM,\n            'm': ChronoField.MINUTE_OF_HOUR,\n            's': ChronoField.SECOND_OF_MINUTE,\n            'S': ChronoField.NANO_OF_SECOND,\n            'A': ChronoField.MILLI_OF_DAY,\n            'n': ChronoField.NANO_OF_SECOND,\n            'N': ChronoField.NANO_OF_DAY\n        };\n\n        for (let pos = 0; pos < pattern.length; pos++) {\n            let cur = pattern.charAt(pos);\n            if ((cur >= 'A' && cur <= 'Z') || (cur >= 'a' && cur <= 'z')) {\n                let start = pos++;\n                for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++);  // short loop\n                let count = pos - start;\n                // padding\n                if (cur === 'p') {\n                    let pad = 0;\n                    if (pos < pattern.length) {\n                        cur = pattern.charAt(pos);\n                        if ((cur >= 'A' && cur <= 'Z') || (cur >= 'a' && cur <= 'z')) {\n                            pad = count;\n                            start = pos++;\n                            for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++);  // short loop\n                            count = pos - start;\n                        }\n                    }\n                    if (pad === 0) {\n                        throw new IllegalArgumentException(\n                            'Pad letter \\'p\\' must be followed by valid pad pattern: ' + pattern);\n                    }\n                    this.padNext(pad); // pad and continue parsing\n                }\n                // main rules\n                const field = FIELD_MAP[cur];\n                if (field != null) {\n                    this._parseField(cur, count, field);\n                } else if (cur === 'z') {\n                    if (count > 4) {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    } else if (count === 4) {\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendZoneText(TextStyle.FULL);\n                    } else {\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendZoneText(TextStyle.SHORT);\n                    }\n                } else if (cur === 'V') {\n                    if (count !== 2) {\n                        throw new IllegalArgumentException('Pattern letter count must be 2: ' + cur);\n                    }\n                    this.appendZoneId();\n                } else if (cur === 'Z') {\n                    if (count < 4) {\n                        this.appendOffset('+HHMM', '+0000');\n                    } else if (count === 4) {\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendLocalizedOffset(TextStyle.FULL);\n                    } else if (count === 5) {\n                        this.appendOffset('+HH:MM:ss', 'Z');\n                    } else {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    }\n                } else if (cur === 'O') {\n                    if (count === 1) {\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendLocalizedOffset(TextStyle.SHORT);\n                    } else if (count === 4) {\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendLocalizedOffset(TextStyle.FULL);\n                    } else {\n                        throw new IllegalArgumentException('Pattern letter count must be 1 or 4: ' + cur);\n                    }\n                } else if (cur === 'X') {\n                    if (count > 5) {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    }\n                    this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], 'Z');\n                } else if (cur === 'x') {\n                    if (count > 5) {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    }\n                    let zero = (count === 1 ? '+00' : (count % 2 === 0 ? '+0000' : '+00:00'));\n                    this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);\n                } else if (cur === 'W') {\n                    if (count > 1) {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    }\n                    this._appendInternal(new OffsetIdPrinterParser('W', count));\n                } else if (cur === 'w') {\n                    if (count > 2) {\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                    }\n                    this._appendInternal(new OffsetIdPrinterParser('w', count));\n                } else if (cur === 'Y') {\n                    this._appendInternal(new OffsetIdPrinterParser('Y', count));\n                } else {\n                    throw new IllegalArgumentException('Unknown pattern letter: ' + cur);\n                }\n                pos--;\n\n            } else if (cur === '\\'') {\n                // parse literals\n                const start = pos++;\n                for (; pos < pattern.length; pos++) {\n                    if (pattern.charAt(pos) === '\\'') {\n                        if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === '\\'') {\n                            pos++;\n                        } else {\n                            break;  // end of literal\n                        }\n                    }\n                }\n                if (pos >= pattern.length) {\n                    throw new IllegalArgumentException('Pattern ends with an incomplete string literal: ' + pattern);\n                }\n                const str = pattern.substring(start + 1, pos);\n                if (str.length === 0) {\n                    this.appendLiteral('\\'');\n                } else {\n                    this.appendLiteral(str.replace('\\'\\'', '\\''));\n                }\n\n            } else if (cur === '[') {\n                this.optionalStart();\n\n            } else if (cur === ']') {\n                if (this._active._parent === null) {\n                    throw new IllegalArgumentException('Pattern invalid as it contains ] without previous [');\n                }\n                this.optionalEnd();\n\n            } else if (cur === '{' || cur === '}' || cur === '#') {\n                throw new IllegalArgumentException('Pattern includes reserved character: \\'' + cur + '\\'');\n            } else {\n                this.appendLiteral(cur);\n            }\n        }\n    }\n\n    _parseField(cur, count, field) {\n        switch (cur) {\n            case 'u':\n            case 'y':\n                if (count === 2) {\n                    this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);\n                } else if (count < 4) {\n                    this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);\n                } else {\n                    this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);\n                }\n                break;\n            case 'M':\n            case 'Q':\n                switch (count) {\n                    case 1:\n                        this.appendValue(field);\n                        break;\n                    case 2:\n                        this.appendValue(field, 2);\n                        break;\n                    case 3:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                break;\n            case 'L':\n            case 'q':\n                switch (count) {\n                    case 1:\n                        this.appendValue(field);\n                        break;\n                    case 2:\n                        this.appendValue(field, 2);\n                        break;\n                    case 3:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.SHORT_STANDALONE);\n                        break;\n                    case 4:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.FULL_STANDALONE);\n                        break;\n                    case 5:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.NARROW_STANDALONE);\n                        break;\n                    default:\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                break;\n            case 'e':\n                switch (count) {\n                    case 1:\n                    case 2:\n                        // TODO: WeekFieldsPrinterParser\n                        throw new IllegalArgumentException('Pattern using WeekFields not implemented yet!');\n                        // eslint-disable-next-line no-unreachable, no-undef\n                        this.appendInternal(new WeekFieldsPrinterParser('e', count));\n                        break;\n                    case 3:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'c':\n                switch (count) {\n                    case 1:\n                        // TODO: WeekFieldsPrinterParser\n                        throw new IllegalArgumentException('Pattern using WeekFields not implemented yet!');\n                        // eslint-disable-next-line no-unreachable, no-undef\n                        this.appendInternal(new WeekFieldsPrinterParser('c', count));\n                        break;\n                    case 2:\n                        throw new IllegalArgumentException('Invalid number of pattern letters: ' + cur);\n                    case 3:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.SHORT_STANDALONE);\n                        break;\n                    case 4:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.FULL_STANDALONE);\n                        break;\n                    case 5:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.NARROW_STANDALONE);\n                        break;\n                    default:\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'a':\n                if (count === 1) {\n                    //TODO:\n                    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                    // eslint-disable-next-line no-unreachable\n                    this.appendText(field, TextStyle.SHORT);\n                } else {\n                    throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'E':\n            case 'G':\n                switch (count) {\n                    case 1:\n                    case 2:\n                    case 3:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        //TODO:\n                        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n                        // eslint-disable-next-line no-unreachable\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'S':\n                this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);\n                break;\n            case 'F':\n                if (count === 1) {\n                    this.appendValue(field);\n                } else {\n                    throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                break;\n            case 'd':\n            case 'h':\n            case 'H':\n            case 'k':\n            case 'K':\n            case 'm':\n            case 's':\n                if (count === 1) {\n                    this.appendValue(field);\n                } else if (count === 2) {\n                    this.appendValue(field, count);\n                } else {\n                    throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                break;\n            case 'D':\n                if (count === 1) {\n                    this.appendValue(field);\n                } else if (count <= 3) {\n                    this.appendValue(field, count);\n                } else {\n                    throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n                }\n                break;\n            default:\n                if (count === 1) {\n                    this.appendValue(field);\n                } else {\n                    this.appendValue(field, count);\n                }\n                break;\n        }\n    }\n\n    /**\n     * padNext function overloading\n     */\n    padNext() {\n        if (arguments.length === 1) {\n            return this._padNext1.apply(this, arguments);\n        } else {\n            return this._padNext2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Causes the next added printer/parser to pad to a fixed width using a space.\n     *\n     * This padding will pad to a fixed width using spaces.\n     *\n     * During formatting, the decorated element will be output and then padded\n     * to the specified width. An exception will be thrown during printing if\n     * the pad width is exceeded.\n     *\n     * During parsing, the padding and decorated element are parsed.\n     * If parsing is lenient, then the pad width is treated as a maximum.\n     * If parsing is case insensitive, then the pad character is matched ignoring case.\n     * The padding is parsed greedily. Thus, if the decorated element starts with\n     * the pad character, it will not be parsed.\n     *\n     * @param {number} padWidth  the pad width, 1 or greater\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if pad width is too small\n     */\n    _padNext1(padWidth) {\n        return this._padNext2(padWidth, ' ');\n    }\n\n    /**\n     * Causes the next added printer/parser to pad to a fixed width.\n     *\n     * This padding is intended for padding other than zero-padding.\n     * Zero-padding should be achieved using the appendValue methods.\n     *\n     * During formatting, the decorated element will be output and then padded\n     * to the specified width. An exception will be thrown during printing if\n     * the pad width is exceeded.\n     *\n     * During parsing, the padding and decorated element are parsed.\n     * If parsing is lenient, then the pad width is treated as a maximum.\n     * If parsing is case insensitive, then the pad character is matched ignoring case.\n     * The padding is parsed greedily. Thus, if the decorated element starts with\n     * the pad character, it will not be parsed.\n     *\n     * @param {number} padWidth  the pad width, 1 or greater\n     * @param {String} padChar  the pad character\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if pad width is too small\n     */\n    _padNext2(padWidth, padChar) {\n        if (padWidth < 1) {\n            throw new IllegalArgumentException('The pad width must be at least one but was ' + padWidth);\n        }\n        this._active._padNextWidth = padWidth;\n        this._active._padNextChar = padChar;\n        this._active._valueParserIndex = -1;\n        return this;\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Mark the start of an optional section.\n     *\n     * The output of printing can include optional sections, which may be nested.\n     * An optional section is started by calling this method and ended by calling\n     * {@link optionalEnd} or by ending the build process.\n     *\n     * All elements in the optional section are treated as optional.\n     * During printing, the section is only output if data is available in the\n     * {@link TemporalAccessor} for all the elements in the section.\n     * During parsing, the whole section may be missing from the parsed string.\n     *\n     * For example, consider a builder setup as\n     * `builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)`.\n     * The optional section ends automatically at the end of the builder.\n     * During printing, the minute will only be output if its value can be obtained from the date-time.\n     * During parsing, the input will be successfully parsed whether the minute is present or not.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    optionalStart() {\n        this._active._valueParserIndex = -1;\n        this._active = new DateTimeFormatterBuilder(this._active, true);\n        return this;\n    }\n\n    /**\n     * Ends an optional section.\n     *\n     * The output of printing can include optional sections, which may be nested.\n     * An optional section is started by calling {@link optionalStart} and ended\n     * using this method (or at the end of the builder).\n     *\n     * Calling this method without having previously called `optionalStart`\n     * will throw an exception.\n     * Calling this method immediately after calling `optionalStart` has no effect\n     * on the formatter other than ending the (empty) optional section.\n     *\n     * All elements in the optional section are treated as optional.\n     * During printing, the section is only output if data is available in the\n     * {@link TemporalAccessor} for all the elements in the section.\n     * During parsing, the whole section may be missing from the parsed string.\n     *\n     * For example, consider a builder setup as\n     * `builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()`.\n     * During printing, the minute will only be output if its value can be obtained from the date-time.\n     * During parsing, the input will be successfully parsed whether the minute is present or not.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalStateException if there was no previous call to `optionalStart`\n     */\n    optionalEnd() {\n        if (this._active._parent == null) {\n            throw new IllegalStateException('Cannot call optionalEnd() as there was no previous call to optionalStart()');\n        }\n        if (this._active._printerParsers.length > 0) {\n            const cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);\n            this._active = this._active._parent;\n            this._appendInternal(cpp);\n        } else {\n            this._active = this._active._parent;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a printer and/or parser to the internal list handling padding.\n     *\n     * @param pp  the printer-parser to add, not null\n     * @return the index into the active parsers list\n     */\n    _appendInternal(pp) {\n        assert(pp != null);\n        if (this._active._padNextWidth > 0) {\n            if (pp != null) {\n                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n            }\n            this._active._padNextWidth = 0;\n            this._active._padNextChar = 0;\n        }\n        this._active._printerParsers.push(pp);\n        this._active._valueParserIndex = -1;\n        return this._active._printerParsers.length - 1;\n    }\n\n    /**\n     * Appends a string literal to the formatter.\n     *\n     * This string will be output during a print.\n     *\n     * If the literal is empty, nothing is added to the formatter.\n     *\n     * @param literal  the literal to append, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendLiteral(literal) {\n        assert(literal != null);\n        if (literal.length > 0) {\n            if (literal.length === 1) {\n                this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));\n            } else {\n                this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends a printer and/or parser to the internal list handling padding.\n     *\n     * @param pp  the printer-parser to add, not null\n     * @return the index into the active parsers list\n     */\n    _appendInternalPrinterParser(pp) {\n        assert(pp != null);\n        if (this._active._padNextWidth > 0) {\n            if (pp != null) {\n                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n            }\n            this._active._padNextWidth = 0;\n            this._active._padNextChar = 0;\n        }\n        this._active._printerParsers.push(pp);\n        this._active._valueParserIndex = -1;\n        return this._active._printerParsers.length - 1;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends all the elements of a formatter to the builder.\n     *\n     * This method has the same effect as appending each of the constituent\n     * parts of the formatter directly to this builder.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to add, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    append(formatter) {\n        requireNonNull(formatter, 'formatter');\n        this._appendInternal(formatter.toPrinterParser(false));\n        return this;\n    }\n\n    /**\n     * Completes this builder by creating the DateTimeFormatter.\n     *\n     * This will create a formatter with the specified locale.\n     * Numbers will be printed and parsed using the standard non-localized set of symbols.\n     *\n     * Calling this method will end any open optional sections by repeatedly\n     * calling {@link optionalEnd} before creating the formatter.\n     *\n     * This builder can still be used after creating the formatter if desired,\n     * although the state may have been changed by calls to `optionalEnd`.\n     *\n     * @param resolverStyle  the new resolver style\n     * @return the created formatter, not null\n     */\n    toFormatter(resolverStyle=ResolverStyle.SMART) {\n        while (this._active._parent != null) {\n            this.optionalEnd();\n        }\n        const pp = new CompositePrinterParser(this._printerParsers, false);\n        return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);\n    }\n\n}\n\nconst EXCEED_POINTS = [\n    0,\n    10,\n    100,\n    1000,\n    10000,\n    100000,\n    1000000,\n    10000000,\n    100000000,\n    1000000000\n];\n\nclass CompositePrinterParser {\n\n    constructor(printerParsers, optional) {\n        this._printerParsers = printerParsers;\n        this._optional = optional;\n    }\n\n    /**\n     * Returns a copy of this printer-parser with the optional flag changed.\n     *\n     * @param {boolean} optional  the optional flag to set in the copy\n     * @return {CompositePrinterParser} the new printer-parser, not null\n     */\n    withOptional(optional) {\n        if (optional === this._optional) {\n            return this;\n        }\n        return new CompositePrinterParser(this._printerParsers, optional);\n    }\n\n    print(context, buf) {\n        const length = buf.length();\n        if (this._optional) {\n            context.startOptional();\n        }\n        try {\n            for (let i=0; i<this._printerParsers.length; i++) {\n                let pp = this._printerParsers[i];\n                if (pp.print(context, buf) === false) {\n                    buf.setLength(length);  // reset buffer\n                    return true;\n                }\n            }\n        } finally {\n            if (this._optional) {\n                context.endOptional();\n            }\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        if (this._optional) {\n            context.startOptional();\n            let pos = position;\n            for (let i=0; i<this._printerParsers.length; i++) {\n                let pp = this._printerParsers[i];\n                pos = pp.parse(context, text, pos);\n                if (pos < 0) {\n                    context.endOptional(false);\n                    return position;  // return original position\n                }\n            }\n            context.endOptional(true);\n            return pos;\n        } else {\n            for (let i=0; i<this._printerParsers.length; i++) {\n                const pp = this._printerParsers[i];\n                position = pp.parse(context, text, position);\n                if (position < 0) {\n                    break;\n                }\n            }\n            return position;\n        }\n    }\n\n    toString() {\n        let buf = '';\n        if (this._printerParsers != null) {\n            buf += this._optional ? '[' : '(';\n            for (let i=0; i<this._printerParsers.length; i++) {\n                const pp = this._printerParsers[i];\n                buf += pp.toString();\n            }\n            buf += this._optional ? ']' : ')';\n        }\n        return buf;\n    }\n}\n\n/**\n * Pads the output to a fixed width.\n */\nclass PadPrinterParserDecorator {\n\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer, not null\n     * @param padWidth  the width to pad to, 1 or greater\n     * @param padChar  the pad character\n     */\n    constructor(printerParser, padWidth, padChar) {\n        // input checked by DateTimeFormatterBuilder\n        this._printerParser = printerParser;\n        this._padWidth = padWidth;\n        this._padChar = padChar;\n    }\n\n    print(context, buf) {\n        const preLen = buf.length();\n        if (this._printerParser.print(context, buf) === false) {\n            return false;\n        }\n        const len = buf.length() - preLen;\n        if (len > this._padWidth) {\n            throw new DateTimeException(\n                `Cannot print as output of ${len} characters exceeds pad width of ${this._padWidth}`);\n        }\n        for (let i = 0; i < this._padWidth - len; i++) {\n            buf.insert(preLen, this._padChar);\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        // cache context before changed by decorated parser\n        const strict = context.isStrict();\n        const caseSensitive = context.isCaseSensitive();\n        // parse\n        assert(!(position > text.length));\n        assert(position >= 0);\n        if (position === text.length) {\n            return ~position;  // no more characters in the string\n        }\n        let endPos = position + this._padWidth;\n        if (endPos > text.length) {\n            if (strict) {\n                return ~position;  // not enough characters in the string to meet the parse width\n            }\n            endPos = text.length;\n        }\n        let pos = position;\n        while (pos < endPos &&\n                (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {\n            pos++;\n        }\n        text = text.substring(0, endPos);\n        const resultPos = this._printerParser.parse(context, text, pos);\n        if (resultPos !== endPos && strict) {\n            return ~(position + pos);  // parse of decorated field didn't parse to the end\n        }\n        return resultPos;\n    }\n\n    toString() {\n        return `Pad(${this._printerParser},${this._padWidth}${(this._padChar === ' ' ? ')' : ',\\'' + this._padChar + '\\')')}`;\n    }\n}\n\nclass SettingsParser extends Enum {\n\n    print(/*context, buf*/) {\n        return true;  // nothing to do here\n    }\n\n    parse(context, text, position) {\n        // using ordinals to avoid javac synthetic inner class\n        switch (this) {\n            case SettingsParser.SENSITIVE:   context.setCaseSensitive(true); break;\n            case SettingsParser.INSENSITIVE: context.setCaseSensitive(false); break;\n            case SettingsParser.STRICT:      context.setStrict(true); break;\n            case SettingsParser.LENIENT:     context.setStrict(false); break;\n        }\n        return position;\n    }\n\n    toString() {\n        // using ordinals to avoid javac synthetic inner class\n        switch (this) {\n            case SettingsParser.SENSITIVE:   return 'ParseCaseSensitive(true)';\n            case SettingsParser.INSENSITIVE: return 'ParseCaseSensitive(false)';\n            case SettingsParser.STRICT:      return 'ParseStrict(true)';\n            case SettingsParser.LENIENT:     return 'ParseStrict(false)';\n        }\n    }\n}\n\nSettingsParser.SENSITIVE = new SettingsParser('SENSITIVE');\nSettingsParser.INSENSITIVE = new SettingsParser('INSENSITIVE');\nSettingsParser.STRICT = new SettingsParser('STRICT');\nSettingsParser.LENIENT = new SettingsParser('LENIENT');\n\n/**\n* Prints or parses a string literal.\n*/\nclass StringLiteralPrinterParser {\n\n    constructor(literal) {\n        this._literal = literal;\n    }\n\n    print(context, buf) {\n        buf.append(this._literal);\n        return true;\n    }\n\n    parse(context, text, position) {\n        const length = text.length;\n        assert(!(position > length || position < 0));\n\n        if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {\n            return ~position;\n        }\n        return position + this._literal.length;\n    }\n\n    toString() {\n        let converted = this._literal.replace(\"'\", \"''\");\n        return '\\'' + converted + '\\'';\n    }\n}\n\n/**\n * Prints or parses a char literal.\n */\nclass CharLiteralPrinterParser {\n\n    constructor(literal) {\n        if (literal.length > 1) {\n            throw new IllegalArgumentException('invalid literal, too long: \"' + literal + '\"');\n        }\n        this._literal = literal;\n    }\n\n    print(context, buf) {\n        buf.append(this._literal);\n        return true;\n    }\n\n    parse(context, text, position) {\n        const length = text.length;\n        if (position === length) {\n            return ~position;\n        }\n        let ch = text.charAt(position);\n        if (context.charEquals(this._literal, ch) === false) {\n            return ~position;\n        }\n        return position + this._literal.length;\n    }\n\n    toString() {\n        if (this._literal === '\\'') {\n            return \"''\";\n        }\n        return \"'\" + this._literal + \"'\";\n    }\n}\n\nclass NumberPrinterParser {\n\n    /**\n     * Constructor.\n     *\n     * @param field  the field to print, not null\n     * @param minWidth  the minimum field width, from 1 to 19\n     * @param maxWidth  the maximum field width, from minWidth to 19\n     * @param signStyle  the positive/negative sign style, not null\n     * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater,\n     *  -1 if fixed width due to active adjacent parsing\n     */\n    constructor(field, minWidth, maxWidth, signStyle, subsequentWidth=0){\n        this._field = field;\n        this._minWidth = minWidth;\n        this._maxWidth = maxWidth;\n        this._signStyle = signStyle;\n        this._subsequentWidth = subsequentWidth;\n    }\n\n    field(){ return this._field;}\n    minWidth(){ return this._minWidth;}\n    maxWidth(){ return this._maxWidth;}\n    signStyle(){ return this._signStyle;}\n\n    withFixedWidth() {\n        if (this._subsequentWidth === -1) {\n            return this;\n        }\n        return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);\n    }\n\n    withSubsequentWidth(subsequentWidth) {\n        return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);\n    }\n\n    _isFixedWidth() {\n        return this._subsequentWidth === -1 ||\n                (this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE);\n    }\n\n    print(context, buf) {\n        const value = context.getValue(this._field);\n        if (value == null) {\n            return false;\n        }\n        const symbols = context.symbols();\n        let str = '' + Math.abs(value);\n        if (str.length > this._maxWidth) {\n            throw new DateTimeException('Field ' + this._field +\n                ' cannot be printed as the value ' + value +\n                ' exceeds the maximum print width of ' + this._maxWidth);\n        }\n        str = symbols.convertNumberToI18N(str);\n\n        if (value >= 0) {\n            switch (this._signStyle) {\n                case SignStyle.EXCEEDS_PAD:\n                    if (this._minWidth < MAX_WIDTH && value >= EXCEED_POINTS[this._minWidth]) {\n                        buf.append(symbols.positiveSign());\n                    }\n                    break;\n                case SignStyle.ALWAYS:\n                    buf.append(symbols.positiveSign());\n                    break;\n            }\n        } else {\n            switch (this._signStyle) {\n                case SignStyle.NORMAL:\n                case SignStyle.EXCEEDS_PAD:\n                case SignStyle.ALWAYS:\n                    buf.append(symbols.negativeSign());\n                    break;\n                case SignStyle.NOT_NEGATIVE:\n                    throw new DateTimeException('Field ' + this._field +\n                        ' cannot be printed as the value ' + value +\n                        ' cannot be negative according to the SignStyle');\n            }\n        }\n        for (let i = 0; i < this._minWidth - str.length; i++) {\n            buf.append(symbols.zeroDigit());\n        }\n        buf.append(str);\n        return true;\n    }\n\n    parse(context, text, position){\n        const length = text.length;\n        if (position === length) {\n            return ~position;\n        }\n        assert(position>=0 && position<length);\n        const sign = text.charAt(position);  // IOOBE if invalid position\n        let negative = false;\n        let positive = false;\n        if (sign === context.symbols().positiveSign()) {\n            if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n                return ~position;\n            }\n            positive = true;\n            position++;\n        } else if (sign === context.symbols().negativeSign()) {\n            if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n                return ~position;\n            }\n            negative = true;\n            position++;\n        } else {\n            if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {\n                return ~position;\n            }\n        }\n        const effMinWidth = (context.isStrict() || this._isFixedWidth() ? this._minWidth : 1);\n        const minEndPos = position + effMinWidth;\n        if (minEndPos > length) {\n            return ~position;\n        }\n        let effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);\n        let total = 0;\n        let pos = position;\n        for (let pass = 0; pass < 2; pass++) {\n            let maxEndPos = Math.min(pos + effMaxWidth, length);\n            while (pos < maxEndPos) {\n                let ch = text.charAt(pos++);\n                let digit = context.symbols().convertToDigit(ch);\n                if (digit < 0) {\n                    pos--;\n                    if (pos < minEndPos) {\n                        return ~position;  // need at least min width digits\n                    }\n                    break;\n                }\n                if ((pos - position) > MAX_WIDTH) {\n                    throw new ArithmeticException('number text exceeds length');\n                } else {\n                    total = total * 10 + digit;\n                }\n            }\n            if (this._subsequentWidth > 0 && pass === 0) {\n                // re-parse now we know the correct width\n                let parseLen = pos - position;\n                effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);\n                pos = position;\n                total = 0;\n            } else {\n                break;\n            }\n        }\n        if (negative) {\n            if (total === 0 && context.isStrict()) {\n                return ~(position - 1);  // minus zero not allowed\n            }\n            if(total !== 0) {\n                total = -total;\n            }\n        } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {\n            let parseLen = pos - position;\n            if (positive) {\n                if (parseLen <= this._minWidth) {\n                    return ~(position - 1);  // '+' only parsed if minWidth exceeded\n                }\n            } else {\n                if (parseLen > this._minWidth) {\n                    return ~position;  // '+' must be parsed if minWidth exceeded\n                }\n            }\n        }\n        return this._setValue(context, total, position, pos);\n    }\n\n    /**\n     * Stores the value.\n     *\n     * @param context  the context to store into, not null\n     * @param value  the value\n     * @param errorPos  the position of the field being parsed\n     * @param successPos  the position after the field being parsed\n     * @return the new position\n     */\n    _setValue(context, value, errorPos, successPos) {\n        return context.setParsedField(this._field, value, errorPos, successPos);\n    }\n\n    toString() {\n        if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH && this._signStyle === SignStyle.NORMAL) {\n            return 'Value(' + this._field + ')';\n        }\n        if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {\n            return 'Value(' + this._field + ',' + this._minWidth + ')';\n        }\n        return 'Value(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + this._signStyle + ')';\n    }\n\n}\n//-----------------------------------------------------------------------\n/**\n * Prints and parses a reduced numeric date-time field.\n */\nclass ReducedPrinterParser extends NumberPrinterParser {\n\n    /**\n     * Constructor.\n     *\n     * @param {TemporalField} field  the field to print, validated not null\n     * @param {number} width  the field width, from 1 to 10\n     * @param {number} maxWidth  the field max width, from 1 to 10\n     * @param {number} baseValue  the base value\n     * @param {ChronoLocalDate} baseDate  the base date\n     */\n    constructor(field, width, maxWidth, baseValue, baseDate) {\n        super(field, width, maxWidth, SignStyle.NOT_NEGATIVE);\n        if (width < 1 || width > 10) {\n            throw new IllegalArgumentException('The width must be from 1 to 10 inclusive but was ' + width);\n        }\n        if (maxWidth < 1 || maxWidth > 10) {\n            throw new IllegalArgumentException('The maxWidth must be from 1 to 10 inclusive but was ' + maxWidth);\n        }\n        if (maxWidth < width) {\n            throw new IllegalArgumentException('The maxWidth must be greater than the width');\n        }\n        if (baseDate === null) {\n            if (field.range().isValidValue(baseValue) === false) {\n                throw new IllegalArgumentException('The base value must be within the range of the field');\n            }\n            if ((baseValue + EXCEED_POINTS[width]) > MathUtil.MAX_SAFE_INTEGER) {\n                throw new DateTimeException('Unable to add printer-parser as the range exceeds the capacity of an int');\n            }\n        }\n        this._baseValue = baseValue;\n        this._baseDate = baseDate;\n    }\n\n    /**\n     *\n     * @param {DateTimePrintContext} context\n     * @param {number} value\n     */\n    getValue(context, value) {\n        let absValue = Math.abs(value);\n        let baseValue = this._baseValue;\n        if (this._baseDate !== null) {\n            // TODO: in threetenbp the following line is used, but we dont have Chronology yet,\n            // let chrono = Chronology.from(context.getTemporal());\n            // so let's use IsoChronology for now\n            context.temporal();\n            let chrono = IsoChronology.INSTANCE;\n            baseValue = chrono.date(this._baseDate).get(this._field);\n        }\n        if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {\n            return absValue % EXCEED_POINTS[this._minWidth];\n        }\n        return absValue % EXCEED_POINTS[this._maxWidth];\n    }\n\n    /**\n     *\n     * @param {DateTimeParseContext} context\n     * @param {number} value\n     * @param {number} errorPos\n     * @param {number} successPos\n     */\n    _setValue(context, value, errorPos, successPos) {\n        let baseValue = this._baseValue;\n        if (this._baseDate != null) {\n            let chrono = context.getEffectiveChronology();\n            baseValue = chrono.date(this._baseDate).get(this._field);\n            context.addChronologyChangedParser(this, value, errorPos, successPos);\n        }\n        let parseLen = successPos - errorPos;\n        if (parseLen === this._minWidth && value >= 0) {\n            let range = EXCEED_POINTS[this._minWidth];\n            let lastPart = baseValue % range;\n            let basePart = baseValue - lastPart;\n            if (baseValue > 0) {\n                value = basePart + value;\n            } else {\n                value = basePart - value;\n            }\n            if (value < baseValue) {\n                value += range;\n            }\n        }\n        return context.setParsedField(this._field, value, errorPos, successPos);\n    }\n\n    withFixedWidth() {\n        if (this._subsequentWidth === -1) {\n            return this;\n        }\n        return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, -1);\n    }\n\n    /**\n     *\n     * @param {number} subsequentWidth\n     * @returns {ReducedPrinterParser}\n     */\n    withSubsequentWidth(subsequentWidth) {\n        return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate,\n            this._subsequentWidth + subsequentWidth);\n    }\n\n    /**\n     *\n     * @param {DateTimeParseContext} context\n     */\n    isFixedWidth(context) {\n        if (context.isStrict() === false) {\n            return false;\n        }\n        return super.isFixedWidth(context);\n    }\n\n    toString() {\n        return 'ReducedValue(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + (this._baseDate != null ? this._baseDate : this._baseValue) + ')';\n    }\n}\n\n\n//-----------------------------------------------------------------------\n\n/**\n * TODO optimize FractionPrinterParser, fix documentation\n *\n * Prints and parses a numeric date-time field with optional padding.\n */\nclass FractionPrinterParser {\n\n    /**\n     * Constructor.\n     *\n     * @param {TemporalField} field  the field to output, not null\n     * @param {Number} minWidth  the minimum width to output, from 0 to 9\n     * @param {Number} maxWidth  the maximum width to output, from 0 to 9\n     * @param {boolean} decimalPoint  whether to output the localized decimal point symbol\n     */\n    constructor(field, minWidth, maxWidth, decimalPoint) {\n        requireNonNull(field, 'field');\n        if (field.range().isFixed() === false) {\n            throw new IllegalArgumentException('Field must have a fixed set of values: ' + field);\n        }\n        if (minWidth < 0 || minWidth > 9) {\n            throw new IllegalArgumentException('Minimum width must be from 0 to 9 inclusive but was ' + minWidth);\n        }\n        if (maxWidth < 1 || maxWidth > 9) {\n            throw new IllegalArgumentException('Maximum width must be from 1 to 9 inclusive but was ' + maxWidth);\n        }\n        if (maxWidth < minWidth) {\n            throw new IllegalArgumentException('Maximum width must exceed or equal the minimum width but ' +\n                    maxWidth + ' < ' + minWidth);\n        }\n        this.field = field;\n        this.minWidth = minWidth;\n        this.maxWidth = maxWidth;\n        this.decimalPoint = decimalPoint;\n    }\n\n    print(context, buf) {\n        const value = context.getValue(this.field);\n        if (value === null) {\n            return false;\n        }\n        const symbols = context.symbols();\n        if (value === 0) {  // scale is zero if value is zero\n            if (this.minWidth > 0) {\n                if (this.decimalPoint) {\n                    buf.append(symbols.decimalSeparator());\n                }\n                for (let i = 0; i < this.minWidth; i++) {\n                    buf.append(symbols.zeroDigit());\n                }\n            }\n        } else {\n            let fraction = this.convertToFraction(value, symbols.zeroDigit());\n            const outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);\n            fraction = fraction.substr(0, outputScale);\n            if(fraction * 1 > 0 ) {\n                while (fraction.length > this.minWidth && fraction[fraction.length - 1] === '0') {\n                    fraction = fraction.substr(0, fraction.length - 1);\n                }\n            }\n            let str = fraction;\n            str = symbols.convertNumberToI18N(str);\n            if (this.decimalPoint) {\n                buf.append(symbols.decimalSeparator());\n            }\n            buf.append(str);\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        const effectiveMin = (context.isStrict() ? this.minWidth : 0);\n        const effectiveMax = (context.isStrict() ? this.maxWidth : 9);\n        const length = text.length;\n        if (position === length) {\n            // valid if whole field is optional, invalid if minimum width\n            return (effectiveMin > 0 ? ~position : position);\n        }\n        if (this.decimalPoint) {\n            if (text[position] !== context.symbols().decimalSeparator()) {\n                // valid if whole field is optional, invalid if minimum width\n                return (effectiveMin > 0 ? ~position : position);\n            }\n            position++;\n        }\n        const minEndPos = position + effectiveMin;\n        if (minEndPos > length) {\n            return ~position;  // need at least min width digits\n        }\n        const maxEndPos = Math.min(position + effectiveMax, length);\n        let total = 0;  // can use int because we are only parsing up to 9 digits\n        let pos = position;\n        while (pos < maxEndPos) {\n            const ch = text.charAt(pos++);\n            const digit = context.symbols().convertToDigit(ch);\n            if (digit < 0) {\n                if (pos < minEndPos) {\n                    return ~position;  // need at least min width digits\n                }\n                pos--;\n                break;\n            }\n            total = total * 10 + digit;\n        }\n        const moveLeft = pos - position;\n        const scale = Math.pow(10, moveLeft);\n        const value = this.convertFromFraction(total, scale);\n        return context.setParsedField(this.field, value, position, pos);\n    }\n\n    /**\n     *\n     * @param {Number} value  the value to convert, must be valid for this rule\n     * @return {String} the value as a fraction within the range, from 0 to 1, not null\n     */\n    convertToFraction(value, zeroDigit) {\n        const range = this.field.range();\n        range.checkValidValue(value, this.field);\n        const _min = range.minimum();\n        const _range = range.maximum() - _min + 1;\n        const _value = value - _min;\n        const _scaled = MathUtil.intDiv((_value * 1000000000),  _range);\n        let fraction = '' + _scaled;\n        while(fraction.length < 9){\n            fraction = zeroDigit + fraction;\n        }\n        return fraction;\n    }\n\n    /**\n     *\n     * @param {Number} fraction  the fraction to convert, not null\n     * @return {Number} the value of the field, valid for this rule\n     * @throws DateTimeException if the value cannot be converted\n     */\n    convertFromFraction(total, scale) {\n        const range = this.field.range();\n        const _min = range.minimum();\n        const _range = range.maximum() - _min + 1;\n        const _value = MathUtil.intDiv((total * _range), scale);\n        return _value;\n    }\n\n    toString() {\n        const decimal = (this.decimalPoint ? ',DecimalPoint' : '');\n        return 'Fraction(' + this.field + ',' + this.minWidth + ',' + this.maxWidth + decimal + ')';\n    }\n}\n\n//-----------------------------------------------------------------------\n\n// days in a 400 year cycle = 146097\n// days in a 10,000 year cycle = 146097 * 25\n// seconds per day = 86400\nconst SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;\nconst SECONDS_0000_TO_1970 = ((146097 * 5) - (30 * 365 + 7)) * 86400;\n\n/**\n * Prints or parses an ISO-8601 instant.\n */\nclass InstantPrinterParser  {\n\n    constructor(fractionalDigits) {\n        this.fractionalDigits = fractionalDigits;\n    }\n\n    print(context, buf) {\n        // use INSTANT_SECONDS, thus this code is not bound by Instant.MAX\n        const inSecs = context.getValue(ChronoField.INSTANT_SECONDS);\n        let inNanos = 0;\n        if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {\n            inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);\n        }\n        if (inSecs == null) {\n            return false;\n        }\n        const inSec = inSecs;\n        let inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);\n        if (inSec >= -SECONDS_0000_TO_1970) {\n            // current era\n            let zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n            let hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n            let lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n            let ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n            if (hi > 0) {\n                buf.append('+').append(hi);\n            }\n            buf.append(ldt);\n            if (ldt.second() === 0) {\n                buf.append(':00');\n            }\n        } else {\n            // before current era\n            let zeroSecs = inSec + SECONDS_0000_TO_1970;\n            let hi = MathUtil.intDiv(zeroSecs, SECONDS_PER_10000_YEARS);\n            let lo = MathUtil.intMod(zeroSecs, SECONDS_PER_10000_YEARS);\n            let ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n            let pos = buf.length();\n            buf.append(ldt);\n            if (ldt.second() === 0) {\n                buf.append(':00');\n            }\n            if (hi < 0) {\n                if (ldt.year() === -10000) {\n                    buf.replace(pos, pos + 2, '' + (hi - 1));\n                } else if (lo === 0) {\n                    buf.insert(pos, hi);\n                } else {\n                    buf.insert(pos + 1, Math.abs(hi));\n                }\n            }\n        }\n        //fraction\n        if (this.fractionalDigits === -2) {\n            if (inNano !== 0) {\n                buf.append('.');\n                if (MathUtil.intMod(inNano, 1000000) === 0) {\n                    buf.append(('' + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));\n                } else if (MathUtil.intMod(inNano, 1000) === 0) {\n                    buf.append(('' + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));\n                } else {\n                    buf.append(('' + ((inNano) + 1000000000)).substring(1));\n                }\n            }\n        } else if (this.fractionalDigits > 0 || (this.fractionalDigits === -1 && inNano > 0)) {\n            buf.append('.');\n            let div = 100000000;\n            for (let i = 0; ((this.fractionalDigits === -1 && inNano > 0) || i < this.fractionalDigits); i++) {\n                let digit = MathUtil.intDiv(inNano, div);\n                buf.append(digit);\n                inNano = inNano - (digit * div);\n                div = MathUtil.intDiv(div, 10);\n            }\n        }\n        buf.append('Z');\n        return true;\n    }\n\n    parse(context, text, position) {\n        // new context to avoid overwriting fields like year/month/day\n        const newContext = context.copy();\n        const minDigits = (this.fractionalDigits < 0 ? 0 : this.fractionalDigits);\n        const maxDigits = (this.fractionalDigits < 0 ? 9 : this.fractionalDigits);\n        const parser = new DateTimeFormatterBuilder()\n                .append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T')\n                .appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':')\n                .appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral('Z')\n                .toFormatter().toPrinterParser(false);\n        const pos = parser.parse(newContext, text, position);\n        if (pos < 0) {\n            return pos;\n        }\n        // parser restricts most fields to 2 digits, so definitely int\n        // correctly parsed nano is also guaranteed to be valid\n        const yearParsed = newContext.getParsed(ChronoField.YEAR);\n        const month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);\n        const day = newContext.getParsed(ChronoField.DAY_OF_MONTH);\n        let hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);\n        const min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);\n        const secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);\n        const nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);\n        let sec = (secVal != null ? secVal : 0);\n        const nano = (nanoVal != null ? nanoVal : 0);\n        const year = MathUtil.intMod(yearParsed, 10000);\n        let days = 0;\n        if (hour === 24 && min === 0 && sec === 0 && nano === 0) {\n            hour = 0;\n            days = 1;\n        } else if (hour === 23 && min === 59 && sec === 60) {\n            context.setParsedLeapSecond();\n            sec = 59;\n        }\n        let instantSecs;\n        try {\n            const ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);\n            instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);\n            instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);\n        } catch (ex) {\n            return ~position;\n        }\n        let successPos = pos;\n        successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);\n        return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);\n    }\n\n    toString() {\n        return 'Instant()';\n    }\n}\n\n//-----------------------------------------------------------------------\nconst PATTERNS = [\n    '+HH', '+HHmm', '+HH:mm', '+HHMM', '+HH:MM', '+HHMMss', '+HH:MM:ss', '+HHMMSS', '+HH:MM:SS'\n];\n/**\n * Prints or parses an offset ID.\n */\nclass OffsetIdPrinterParser  {\n\n    /**\n     * Constructor.\n     *\n     * @param {string} noOffsetText  the text to use for UTC, not null\n     * @param {string} pattern  the pattern\n     */\n    constructor(noOffsetText, pattern) {\n        requireNonNull(noOffsetText, 'noOffsetText');\n        requireNonNull(pattern, 'pattern');\n        this.noOffsetText = noOffsetText;\n        this.type = this._checkPattern(pattern);\n    }\n\n    /**\n     * @param {String} pattern\n     * @return {number}\n     */\n    _checkPattern(pattern) {\n        for (let i = 0; i < PATTERNS.length; i++) {\n            if (PATTERNS[i] === pattern) {\n                return i;\n            }\n        }\n        throw new IllegalArgumentException('Invalid zone offset pattern: ' + pattern);\n    }\n\n    /**\n     * @param {DateTimePrintContext} context\n     * @param {StringBuilder} buf\n     * @return {boolean}\n     */\n    print(context, buf) {\n        const offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);\n        if (offsetSecs == null) {\n            return false;\n        }\n        const totalSecs = MathUtil.safeToInt(offsetSecs);\n        if (totalSecs === 0) {\n            buf.append(this.noOffsetText);\n        } else {\n            const absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));  // anything larger than 99 silently dropped\n            const absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));\n            const absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));\n            const bufPos = buf.length();\n            let output = absHours;\n            buf.append(totalSecs < 0 ? '-' : '+')\n                .appendChar((MathUtil.intDiv(absHours, 10) + '0')).appendChar(MathUtil.intMod(absHours, 10) + '0');\n            if (this.type >= 3 || (this.type >= 1 && absMinutes > 0)) {\n                buf.append((this.type % 2) === 0 ? ':' : '')\n                    .appendChar((MathUtil.intDiv(absMinutes, 10) + '0')).appendChar((absMinutes % 10 + '0'));\n                output += absMinutes;\n                if (this.type >= 7 || (this.type >= 5 && absSeconds > 0)) {\n                    buf.append((this.type % 2) === 0 ? ':' : '')\n                        .appendChar((MathUtil.intDiv(absSeconds, 10) + '0')).appendChar((absSeconds % 10 + '0'));\n                    output += absSeconds;\n                }\n            }\n            if (output === 0) {\n                buf.setLength(bufPos);\n                buf.append(this.noOffsetText);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} position\n     * @return {number}\n     */\n    parse(context, text, position) {\n        const length = text.length;\n        const noOffsetLen = this.noOffsetText.length;\n        if (noOffsetLen === 0) {\n            if (position === length) {\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);\n            }\n        } else {\n            if (position === length) {\n                return ~position;\n            }\n            if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n            }\n        }\n\n        // parse normal plus/minus offset\n        const sign = text[position];  // IOOBE if invalid position\n        if (sign === '+' || sign === '-') {\n            // starts\n            const negative = (sign === '-' ? -1 : 1);\n            const array = [0,0,0,0];\n            array[0] = position + 1;\n            if ((this._parseNumber(array, 1, text, true) ||\n                    this._parseNumber(array, 2, text, this.type >=3) ||\n                    this._parseNumber(array, 3, text, false)) === false) {\n                // success\n                const offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);\n            }\n        }\n        // handle special case of empty no offset text\n        if (noOffsetLen === 0) {\n            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n        }\n        return ~position;\n    }\n\n    /**\n     * Parse a two digit zero-prefixed number.\n     *\n     * @param {number[]} array  the array of parsed data, 0=pos,1=hours,2=mins,3=secs, not null\n     * @param {number} arrayIndex  the index to parse the value into\n     * @param {string} parseText  the offset ID, not null\n     * @param {boolean} required  whether this number is required\n     * @return {boolean} true if an error occurred\n     */\n    _parseNumber(array, arrayIndex, parseText, required) {\n        if ((this.type + 3) / 2 < arrayIndex) {\n            return false;  // ignore seconds/minutes\n        }\n        let pos = array[0];\n        if ((this.type % 2) === 0 && arrayIndex > 1) {\n            if (pos + 1 > parseText.length || parseText[pos] !== ':') {\n                return required;\n            }\n            pos++;\n        }\n        if (pos + 2 > parseText.length) {\n            return required;\n        }\n        let ch1 = parseText[pos++];\n        let ch2 = parseText[pos++];\n        if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n            return required;\n        }\n        const value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n        if (value < 0 || value > 59) {\n            return required;\n        }\n        array[arrayIndex] = value;\n        array[0] = pos;\n        return false;\n    }\n\n\n    toString() {\n        const converted = this.noOffsetText.replace('\\'', '\\'\\'');\n        return 'Offset(' + PATTERNS[this.type] + ',\\'' + converted + '\\')';\n    }\n}\nOffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser('Z', '+HH:MM:ss');\nOffsetIdPrinterParser.PATTERNS = PATTERNS;\n\n/**\n * Prints or parses a zone ID.\n */\nclass ZoneIdPrinterParser {\n\n    /**\n     *\n     * @param {TemporalQuery} query\n     * @param {string} description\n     */\n    constructor(query, description) {\n        this.query = query;\n        this.description = description;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {DateTimePrintContext } context\n     * @param {StringBuilder} buf\n     * @returns {boolean}\n     */\n    print(context, buf) {\n        const zone = context.getValueQuery(this.query);\n        if (zone == null) {\n            return false;\n        }\n        buf.append(zone.id());\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * This implementation looks for the longest matching string.\n     * For example, parsing Etc/GMT-2 will return Etc/GMC-2 rather than just\n     * Etc/GMC although both are valid.\n     *\n     * This implementation uses a tree to search for valid time-zone names in\n     * the parseText. The top level node of the tree has a length equal to the\n     * length of the shortest time-zone as well as the beginning characters of\n     * all other time-zones.\n     *\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} position\n     * @return {number}\n     */\n    parse(context, text, position) {\n        const length = text.length;\n        if (position > length) {\n            return ~position;\n        }\n        if (position === length) {\n            return ~position;\n        }\n\n        // handle fixed time-zone IDs\n        const nextChar = text.charAt(position);\n        if (nextChar === '+' || nextChar === '-') {\n            const newContext = context.copy();\n            const endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n            if (endPos < 0) {\n                return endPos;\n            }\n            const offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n            const zone = ZoneOffset.ofTotalSeconds(offset);\n            context.setParsedZone(zone);\n            return endPos;\n        } else if (length >= position + 2) {\n            const nextNextChar = text.charAt(position + 1);\n            if (context.charEquals(nextChar, 'U') &&\n                            context.charEquals(nextNextChar, 'T')) {\n                if (length >= position + 3 &&\n                                context.charEquals(text.charAt(position + 2), 'C')) {\n                    return this._parsePrefixedOffset(context, text, position, position + 3);\n                }\n                return this._parsePrefixedOffset(context, text, position, position + 2);\n            } else if (context.charEquals(nextChar, 'G') &&\n                    length >= position + 3 &&\n                    context.charEquals(nextNextChar, 'M') &&\n                    context.charEquals(text.charAt(position + 2), 'T')) {\n                return this._parsePrefixedOffset(context, text, position, position + 3);\n            }\n        }\n        // javascript special case\n        if(text.substr(position, 6) === 'SYSTEM'){\n            context.setParsedZone(ZoneId.systemDefault());\n            return position + 6;\n        }\n\n        // ...\n        if (context.charEquals(nextChar, 'Z')) {\n            context.setParsedZone(ZoneOffset.UTC);\n            return position + 1;\n        }\n        // ...\n        return ~position;\n    }\n\n    /**\n     *\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} prefixPos\n     * @param {number} position\n     * @return {number}\n     */\n    _parsePrefixedOffset(context, text, prefixPos, position) {\n        const prefix = text.substring(prefixPos, position).toUpperCase();\n        const newContext = context.copy();\n        if (position < text.length && context.charEquals(text.charAt(position), 'Z')) {\n            context.setParsedZone(ZoneIdFactory.ofOffset(prefix, ZoneOffset.UTC));\n            return position;\n        }\n        const endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n        if (endPos < 0) {\n            context.setParsedZone(ZoneIdFactory.ofOffset(prefix, ZoneOffset.UTC));\n            return position;\n        }\n        const offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n        const offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n        context.setParsedZone(ZoneIdFactory.ofOffset(prefix, offset));\n        return endPos;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return this.description;\n    }\n}\n\nexport function _init() {\n    ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);\n\n    DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;\n    DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;\n    DateTimeFormatterBuilder.SettingsParser = SettingsParser;\n    DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;\n    DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;\n    DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;\n    DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;\n    DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;\n    DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;\n    DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;\n    DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/DateTimeFormatterBuilder.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from './assert';\nimport {DateTimeException, IllegalArgumentException} from './errors';\nimport {StringUtil} from './StringUtil';\n\nimport {ZoneOffset} from './ZoneOffset';\nimport {ZoneRegion} from './ZoneRegion';\nimport {ZoneId} from './ZoneId';\n\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {SystemDefaultZoneId} from './zone/SystemDefaultZoneId';\nimport {ZoneRulesProvider} from './zone/ZoneRulesProvider';\n\n/**\n * @see {@link ZoneId}\n *\n * Helper class to avoid dependency cycles.\n * Static methods of the class ZoneIdFactory are added automatically to class ZoneId.\n */\nexport class ZoneIdFactory {\n\n    /**\n     * Gets the system default time-zone.\n     *\n     *\n     * @return {ZoneId} the zone ID, not null\n     */\n    static systemDefault() {\n        return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n    }\n\n    /**\n     * Gets the set of available zone IDs.\n     *\n     * This set includes the string form of all available region-based IDs.\n     * Offset-based zone IDs are not included in the returned set.\n     * The ID can be passed to {@link of} to create a {@link ZoneId}.\n     *\n     * The set of zone IDs can increase over time, although in a typical application\n     * the set of IDs is fixed. Each call to this method is thread-safe.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds() {\n        return ZoneRulesProvider.getAvailableZoneIds();\n    }\n\n    /**\n     * Obtains an instance of {@link ZoneId} from an ID ensuring that the\n     * ID is valid and available for use.\n     *\n     * This method parses the ID producing a {@link ZoneId} or {@link ZoneOffset}.\n     * A {@link ZoneOffset} is returned if the ID is 'Z', or starts with '+' or '-'.\n     * The result will always be a valid ID for which {@link ZoneRules} can be obtained.\n     *\n     * Parsing matches the zone ID step by step as follows.\n     *\n     * * If the zone ID equals 'Z', the result is {@link ZoneOffset.UTC}.\n     * * If the zone ID consists of a single letter, the zone ID is invalid\n     *   and {@link DateTimeException} is thrown.\n     * * If the zone ID starts with '+' or '-', the ID is parsed as a\n     *   {@link ZoneOffset} using {@link ZoneOffset#of}.\n     * * If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a {@link ZoneId}\n     *   with the same ID and rules equivalent to {@link ZoneOffset.UTC}.\n     * * If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'\n     *   then the ID is a prefixed offset-based ID. The ID is split in two, with\n     *   a two or three letter prefix and a suffix starting with the sign.\n     *   The suffix is parsed as a {@link ZoneOffset}.\n     *   The result will be a {@link ZoneId} with the specified UTC/GMT/UT prefix\n     *   and the normalized offset ID as per {@link ZoneOffset#getId}.\n     *   The rules of the returned {@link ZoneId} will be equivalent to the\n     *   parsed {@link ZoneOffset}.\n     * * All other IDs are parsed as region-based zone IDs. Region IDs must\n     *   match the regular expression `[A-Za-z][A-Za-z0-9~/._+-]+`,\n     *   otherwise a {@link DateTimeException} is thrown. If the zone ID is not\n     *   in the configured set of IDs, {@link ZoneRulesException} is thrown.\n     *   The detailed format of the region ID depends on the group supplying the data.\n     *   The default set of data is supplied by the IANA Time Zone Database (TZDB).\n     *   This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.\n     *   This is compatible with most IDs from {@link java.util.TimeZone}.\n     *\n     * @param {string} zoneId  the time-zone ID, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if the zone ID has an invalid format\n     * @throws ZoneRulesException if the zone ID is a region ID that cannot be found\n     */\n    static of(zoneId) {\n        requireNonNull(zoneId, 'zoneId');\n        if (zoneId === 'Z') {\n            return ZoneOffset.UTC;\n        }\n        if (zoneId.length === 1) {\n            throw new DateTimeException('Invalid zone: ' + zoneId);\n        }\n        if (StringUtil.startsWith(zoneId, '+') || StringUtil.startsWith(zoneId, '-')) {\n            return ZoneOffset.of(zoneId);\n        }\n        if (zoneId === 'UTC' || zoneId === 'GMT' || zoneId === 'GMT0' || zoneId === 'UT') {\n            return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());\n        }\n        if (StringUtil.startsWith(zoneId, 'UTC+') || StringUtil.startsWith(zoneId, 'GMT+') ||\n                StringUtil.startsWith(zoneId, 'UTC-') || StringUtil.startsWith(zoneId, 'GMT-')) {\n            let offset = ZoneOffset.of(zoneId.substring(3));\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion(zoneId.substring(0, 3), offset.rules());\n            }\n            return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());\n        }\n        if (StringUtil.startsWith(zoneId, 'UT+') || StringUtil.startsWith(zoneId, 'UT-')) {\n            let offset = ZoneOffset.of(zoneId.substring(2));\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion('UT', offset.rules());\n            }\n            return new ZoneRegion('UT' + offset.id(), offset.rules());\n        }\n        // javascript special case\n        if(zoneId === 'SYSTEM'){\n            return ZoneId.systemDefault();\n        }\n        return ZoneRegion.ofId(zoneId);\n    }\n\n    /**\n     * Obtains an instance of {@link ZoneId} wrapping an offset.\n     *\n     * If the prefix is 'GMT', 'UTC', or 'UT' a {@link ZoneId}\n     * with the prefix and the non-zero offset is returned.\n     * If the prefix is empty `''` the {@link ZoneOffset} is returned.\n     *\n     * @param {string} prefix  the time-zone ID, not null\n     * @param {ZoneOffset} offset  the offset, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws IllegalArgumentException if the prefix is not one of\n     *     'GMT', 'UTC', or 'UT', or ''\n     */\n    static ofOffset(prefix, offset) {\n        requireNonNull(prefix, 'prefix');\n        requireNonNull(offset, 'offset');\n        if (prefix.length === 0) {\n            return offset;\n        }\n        if (prefix === 'GMT' || prefix === 'UTC' || prefix === 'UT') {\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion(prefix, offset.rules());\n            }\n            return new ZoneRegion(prefix + offset.id(), offset.rules());\n        }\n        throw new IllegalArgumentException('Invalid prefix, must be GMT, UTC or UT: ' + prefix);\n    }\n\n\n    /**\n     * Obtains an instance of {@link ZoneId} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link ZoneId}.\n     *\n     * The conversion will try to obtain the zone in a way that favours region-based\n     * zones over offset-based zones using {@link TemporalQueries#zone}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link ZoneId::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if unable to convert to a {@link ZoneId}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        const obj = temporal.query(TemporalQueries.zone());\n        if (obj == null) {\n            throw new DateTimeException('Unable to obtain ZoneId from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));\n        }\n        return obj;\n    }\n}\n\nlet SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;\n\nexport function _init(){\n    SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();\n\n    // a bit magic to stay a bit more to the threeten bp impl.\n    ZoneId.systemDefault = ZoneIdFactory.systemDefault;\n    ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;\n    ZoneId.of = ZoneIdFactory.of;\n    ZoneId.ofOffset = ZoneIdFactory.ofOffset;\n    ZoneId.from = ZoneIdFactory.from;\n    ZoneOffset.from = ZoneIdFactory.from;\n\n    // short cut\n    ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n    ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ZoneIdFactory.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport class StringUtil {\n\n    /**\n     *\n     * @param {string} text\n     * @param {string} pattern\n     * @return {boolean}\n     */\n    static startsWith(text, pattern){\n        return text.indexOf(pattern) === 0;\n    }\n\n    /**\n     *\n     * @param {string} text\n     * @returns {number}\n     */\n    static hashCode(text) {\n        let hash = 0, i, chr, len;\n        if (text.length === 0) return hash;\n        for (i = 0, len = text.length; i < len; i++) {\n            chr = text.charCodeAt(i);\n            hash = ((hash << 5) - hash) + chr;\n            hash |= 0; // Convert to 32bit integer\n        }\n        return hash;\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/StringUtil.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from './assert';\nimport {DateTimeException} from './errors';\nimport {MathUtil} from './MathUtil';\n\nimport {LocalTime} from './LocalTime';\nimport {ZoneId} from './ZoneId';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {TemporalQueries} from './temporal/TemporalQueries';\n\nimport {ZoneRules} from './zone/ZoneRules';\n\nconst SECONDS_CACHE = {};\nconst ID_CACHE = {};\n\n/**\n *\n * ### Static properties of Class {@link LocalDate}\n *\n * ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n *\n * ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n *\n * ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n *\n * ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n *\n */\nexport class ZoneOffset extends ZoneId {\n    /**\n     *\n     * @param {number} totalSeconds\n     */\n    constructor(totalSeconds){\n        super();\n        ZoneOffset._validateTotalSeconds(totalSeconds);\n        this._totalSeconds = totalSeconds;\n        this._rules = ZoneRules.of(this);\n        this._id = ZoneOffset._buildId(totalSeconds);\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    totalSeconds() {\n        return this._totalSeconds;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    id() {\n        return this._id;\n    }\n\n    /**\n     *\n     * @param {number} totalSeconds\n     * @returns {string}\n     */\n    static _buildId(totalSeconds) {\n        if (totalSeconds === 0) {\n            return 'Z';\n        } else {\n            const absTotalSeconds = Math.abs(totalSeconds);\n            const absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);\n            const absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n            let buf = '' + (totalSeconds < 0 ? '-' : '+')\n                + (absHours < 10 ? '0' : '') + (absHours)\n                + (absMinutes < 10 ? ':0' : ':') + (absMinutes);\n            const absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);\n            if (absSeconds !== 0) {\n                buf += (absSeconds < 10 ? ':0' : ':') + (absSeconds);\n            }\n            return buf;\n        }\n    }\n\n\n    /**\n     *\n     * @param {number} totalSeconds\n     * @private\n     */\n    static _validateTotalSeconds(totalSeconds){\n        if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {\n            throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n        }\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @param {number} minutes\n     * @param {number} seconds\n     * @private\n     */\n    static _validate(hours, minutes, seconds) {\n        if (hours < -18 || hours > 18) {\n            throw new DateTimeException('Zone offset hours not in valid range: value ' + hours +\n                    ' is not in the range -18 to 18');\n        }\n        if (hours > 0) {\n            if (minutes < 0 || seconds < 0) {\n                throw new DateTimeException('Zone offset minutes and seconds must be positive because hours is positive');\n            }\n        } else if (hours < 0) {\n            if (minutes > 0 || seconds > 0) {\n                throw new DateTimeException('Zone offset minutes and seconds must be negative because hours is negative');\n            }\n        } else if ((minutes > 0 && seconds < 0) || (minutes < 0 && seconds > 0)) {\n            throw new DateTimeException('Zone offset minutes and seconds must have the same sign');\n        }\n        if (Math.abs(minutes) > 59) {\n            throw new DateTimeException('Zone offset minutes not in valid range: abs(value) ' +\n                    Math.abs(minutes) + ' is not in the range 0 to 59');\n        }\n        if (Math.abs(seconds) > 59) {\n            throw new DateTimeException('Zone offset seconds not in valid range: abs(value) ' +\n                    Math.abs(seconds) + ' is not in the range 0 to 59');\n        }\n        if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {\n            throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZoneOffset} using the ID.\n     *\n     * This method parses the string ID of a {@link ZoneOffset} to\n     * return an instance. The parsing accepts all the formats generated by\n     * {@link getId}, plus some additional formats:\n     *\n     * * {@link Z} - for UTC\n     * * `+h`\n     * * `+hh`\n     * * `+hh:mm`\n     * * `-hh:mm`\n     * * `+hhmm`\n     * * `-hhmm`\n     * * `+hh:mm:ss`\n     * * `-hh:mm:ss`\n     * * `+hhmmss`\n     * * `-hhmmss`\n     *\n     * Note that &plusmn; means either the plus or minus symbol.\n     *\n     * The ID of the returned offset will be normalized to one of the formats\n     * described by {@link getId}.\n     *\n     * The maximum supported range is from +18:00 to -18:00 inclusive.\n     *\n     * @param {string} offsetId  the offset ID, not null\n     * @return {ZoneOffset} the zone-offset, not null\n     * @throws DateTimeException if the offset ID is invalid\n     */\n    static of(offsetId) {\n        requireNonNull(offsetId, 'offsetId');\n        // \"Z\" is always in the cache\n        const offset = ID_CACHE[offsetId];\n        if (offset != null) {\n            return offset;\n        }\n\n        // parse - +h, +hh, +hhmm, +hh:mm, +hhmmss, +hh:mm:ss\n        let hours, minutes, seconds;\n        switch (offsetId.length) {\n            case 2:\n                offsetId = offsetId[0] + '0' + offsetId[1];  // fallthru\n            // eslint-disable-next-line no-fallthrough\n            case 3:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = 0;\n                seconds = 0;\n                break;\n            case 5:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n                seconds = 0;\n                break;\n            case 6:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n                seconds = 0;\n                break;\n            case 7:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n                seconds = ZoneOffset._parseNumber(offsetId, 5, false);\n                break;\n            case 9:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n                seconds = ZoneOffset._parseNumber(offsetId, 7, true);\n                break;\n            default:\n                throw new DateTimeException('Invalid ID for ZoneOffset, invalid format: ' + offsetId);\n        }\n        const first = offsetId[0];\n        if (first !== '+' && first !== '-') {\n            throw new DateTimeException('Invalid ID for ZoneOffset, plus/minus not found when expected: ' + offsetId);\n        }\n        if (first === '-') {\n            return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);\n        } else {\n            return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);\n        }\n    }\n\n    /**\n     * Parse a two digit zero-prefixed number.\n     *\n     * @param {string} offsetId - the offset ID, not null\n     * @param {number} pos - the position to parse, valid\n     * @param {boolean} precededByColon - should this number be prefixed by a precededByColon\n     * @return {number} the parsed number, from 0 to 99\n     */\n    static _parseNumber(offsetId, pos, precededByColon) {\n        if (precededByColon && offsetId[pos - 1] !== ':') {\n            throw new DateTimeException('Invalid ID for ZoneOffset, colon not found when expected: ' + offsetId);\n        }\n        const ch1 = offsetId[pos];\n        const ch2 = offsetId[pos + 1];\n        if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n            throw new DateTimeException('Invalid ID for ZoneOffset, non numeric characters found: ' + offsetId);\n        }\n        return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @returns {ZoneOffset}\n     */\n    static ofHours(hours) {\n        return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @param {number} minutes\n     * @returns {ZoneOffset}\n     */\n    static ofHoursMinutes(hours, minutes) {\n        return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @param {number} minutes\n     * @param {number} seconds\n     * @returns {ZoneOffset}\n     */\n    static ofHoursMinutesSeconds(hours, minutes, seconds) {\n        ZoneOffset._validate(hours, minutes, seconds);\n        const totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;\n        return ZoneOffset.ofTotalSeconds(totalSeconds);\n    }\n\n    /**\n     *\n     * @param {number} totalMinutes\n     * @returns {ZoneOffset}\n     */\n    static ofTotalMinutes(totalMinutes) {\n        const totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;\n        return ZoneOffset.ofTotalSeconds(totalSeconds);\n    }\n\n    /**\n     *\n     * @param {number} totalSeconds\n     * @returns {ZoneOffset}\n     */\n    static ofTotalSeconds(totalSeconds) {\n        if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {\n            const totalSecs = totalSeconds;\n            let result = SECONDS_CACHE[totalSecs];\n            if (result == null) {\n                result = new ZoneOffset(totalSeconds);\n                SECONDS_CACHE[totalSecs] = result;\n                ID_CACHE[result.id()] = result;\n            }\n            return result;\n        } else {\n            return new ZoneOffset(totalSeconds);\n        }\n    }\n\n    /**\n     * Gets the associated time-zone rules.\n     *\n     * The rules will always return this offset when queried.\n     * The implementation class is immutable, thread-safe and serializable.\n     *\n     * @return {ZoneRules} the rules, not null\n     */\n    rules() {\n        return this._rules;\n    }\n\n    /**\n      * Gets the value of the specified field from this offset as an `int`.\n      *\n      * This queries this offset for the value for the specified field.\n      * The returned value will always be within the valid range of values for the field.\n      * If it is not possible to return the value, because the field is not supported\n      * or for some other reason, an exception is thrown.\n      *\n      * If the field is a {@link ChronoField} then the query is implemented here.\n      * The {@link OFFSET_SECONDS} field returns the value of the offset.\n      * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n      *\n      * If the field is not a {@link ChronoField}, then the result of this method\n      * is obtained by invoking {@link TemporalField.getFrom}\n      * passing `this` as the argument. Whether the value can be obtained,\n      * and what the value represents, is determined by the field.\n      *\n      * @param {TemporalField} field - the field to get, not null\n      * @return {number} the value for the field\n      * @throws DateTimeException if a value for the field cannot be obtained\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n    get(field) {\n        return this.getLong(field);\n    }\n\n     /**\n      * Gets the value of the specified field from this offset as a `long`.\n      *\n      * This queries this offset for the value for the specified field.\n      * If it is not possible to return the value, because the field is not supported\n      * or for some other reason, an exception is thrown.\n      *\n      * If the field is a {@link ChronoField} then the query is implemented here.\n      * The {@link OFFSET_SECONDS} field returns the value of the offset.\n      * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n      *\n      * If the field is not a {@link ChronoField}, then the result of this method\n      * is obtained by invoking {@link TemporalField.getFrom}\n      * passing `this` as the argument. Whether the value can be obtained,\n      * and what the value represents, is determined by the field.\n      *\n      * @param {TemporalField} field - the field to get, not null\n      * @return {number} the value for the field\n      * @throws DateTimeException if a value for the field cannot be obtained\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n    getLong(field) {\n        if (field === ChronoField.OFFSET_SECONDS) {\n            return this._totalSeconds;\n        } else if (field instanceof ChronoField) {\n            throw new DateTimeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n     //-----------------------------------------------------------------------\n     /**\n      * Queries this offset using the specified query.\n      *\n      * This queries this offset using the specified query strategy object.\n      * The {@link TemporalQuery} object defines the logic to be used to\n      * obtain the result. Read the documentation of the query to understand\n      * what the result of this method will be.\n      *\n      * The result of this method is obtained by invoking the\n      * {@link TemporalQuery#queryFrom} method on the\n      * specified query passing `this` as the argument.\n      *\n      * @param {TemporalQuery} query - the query to invoke, not null\n      * @return {*} the query result, null may be returned (defined by the query)\n      * @throws DateTimeException if unable to query (defined by the query)\n      * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n      */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.offset() || query === TemporalQueries.zone()) {\n            return this;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                 query === TemporalQueries.precision() || query === TemporalQueries.chronology() || query === TemporalQueries.zoneId()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n     /**\n      * Adjusts the specified temporal object to have the same offset as this object.\n      *\n      * This returns a temporal object of the same observable type as the input\n      * with the offset changed to be the same as this.\n      *\n      * The adjustment is equivalent to using {@link Temporal#with}\n      * passing {@link ChronoField#OFFSET_SECONDS} as the field.\n      *\n      * In most cases, it is clearer to reverse the calling pattern by using\n      * {@link Temporal#with}:\n      * <pre>\n      *   // these two lines are equivalent, but the second approach is recommended\n      *   temporal = thisOffset.adjustInto(temporal);\n      *   temporal = temporal.with(thisOffset);\n      * </pre>\n      *\n      * This instance is immutable and unaffected by this method call.\n      *\n      * @param {Temporal} temporal - the target object to be adjusted, not null\n      * @return {Temporal} the adjusted object, not null\n      * @throws DateTimeException if unable to make the adjustment\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n    adjustInto(temporal) {\n        return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);\n    }\n\n    /**\n     * Compares this offset to another offset in descending order.\n     *\n     * The offsets are compared in the order that they occur for the same time\n     * of day around the world. Thus, an offset of `+10:00` comes before an\n     * offset of `+09:00` and so on down to `-18:00`.\n     *\n     * The comparison is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {!ZoneOffset} other - the other date to compare to, not null\n     * @return {number} the comparator value, negative if less, postive if greater\n     * @throws NullPointerException if {@link other} is null\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        return other._totalSeconds - this._totalSeconds;\n    }\n\n\n    /**\n     * Checks if this offset is equal to another offset.\n     *\n     * The comparison is based on the amount of the offset in seconds.\n     * This is equivalent to a comparison by ID.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other offset\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof ZoneOffset) {\n            return this._totalSeconds === obj._totalSeconds;\n        }\n        return false;\n    }\n\n    /**\n     * @return {number}\n     */\n    hashCode(){\n        return this._totalSeconds;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return this._id;\n    }\n}\n\nexport function _init() {\n    ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n    ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n    ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n    ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ZoneOffset.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from './assert';\nimport {StringUtil} from './StringUtil';\n\nimport {Instant} from './Instant';\n\nexport class ZoneId {\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the unique time-zone ID.\n     *\n     * This ID uniquely defines this object.\n     * The format of an offset based ID is defined by {@link ZoneOffset#getId}.\n     *\n     * @return {String} the time-zone unique ID, not null\n     */\n    id(){\n        abstractMethodFail('ZoneId.id');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the time-zone rules for this ID allowing calculations to be performed.\n     *\n     * The rules provide the functionality associated with a time-zone,\n     * such as finding the offset for a given instant or local date-time.\n     *\n     * A time-zone can be invalid if it is deserialized in a Java Runtime which\n     * does not have the same rules loaded as the Java Runtime that stored it.\n     * In this case, calling this method will throw a {@link ZoneRulesException}.\n     *\n     * The rules are supplied by {@link ZoneRulesProvider}. An advanced provider may\n     * support dynamic updates to the rules without restarting the Java Runtime.\n     * If so, then the result of this method may change over time.\n     * Each individual call will be still remain thread-safe.\n     *\n     * {@link ZoneOffset} will always return a set of rules where the offset never changes.\n     *\n     * @return {!ZoneRules} the rules, not null\n     * @throws ZoneRulesException if no rules are available for this ID\n     */\n    rules(){\n        abstractMethodFail('ZoneId.rules');\n    }\n\n    /**\n      * Normalizes the time-zone ID, returning a {@link ZoneOffset} where possible.\n      *\n      * The returns a normalized {@link ZoneId} that can be used in place of this ID.\n      * The result will have {@link ZoneRules} equivalent to those returned by this object,\n      * however the ID returned by {@link getId} may be different.\n      *\n      * The normalization checks if the rules of this {@link ZoneId} have a fixed offset.\n      * If they do, then the {@link ZoneOffset} equal to that offset is returned.\n      * Otherwise `this` is returned.\n      *\n      * @return {ZoneId} the time-zone unique ID, not null\n      */\n    normalized() {\n        const rules = this.rules();\n        if (rules.isFixedOffset()) {\n            return rules.offset(Instant.EPOCH);\n        }\n        //try {\n        //} catch (ZoneRulesException ex) {\n        //    // ignore invalid objects\n        //}\n        return this;\n    }\n\n     //-----------------------------------------------------------------------\n     /**\n      * Checks if this time-zone ID is equal to another time-zone ID.\n      *\n      * The comparison is based on the ID.\n      *\n      * @param {*} other  the object to check, null returns false\n      * @return {boolean} true if this is equal to the other time-zone ID\n      */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ZoneId) {\n            return this.id() === other.id();\n        }\n        return false;\n    }\n\n     /**\n      * A hash code for this time-zone ID.\n      *\n      * @return {number} a suitable hash code\n      */\n    hashCode() {\n        return StringUtil.hashCode(this.id());\n    }\n\n     //-----------------------------------------------------------------------\n     /**\n      * Outputs this zone as a string, using the ID.\n      *\n      * @return {string} a string representation of this time-zone ID, not null\n      */\n    toString() {\n        return this.id();\n    }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ZoneId.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull, abstractMethodFail} from '../assert';\n\nimport {Duration} from '../Duration';\nimport {Instant} from '../Instant';\n\nexport class ZoneRules {\n\n    /**\n     * Obtains an instance of {@link ZoneRules} that always uses the same offset.\n     *\n     * The returned rules always have the same offset.\n     *\n     * @param {ZoneOffset} offset - the offset, not null\n     * @return {ZoneRules} the zone rules, not null\n     */\n    static of(offset) {\n        requireNonNull(offset, 'offset');\n        return new Fixed(offset);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks of the zone rules are fixed, such that the offset never varies.\n     *\n     * @return {boolean} true if the time-zone is fixed and the offset never changes\n     */\n    isFixedOffset(){\n        abstractMethodFail('ZoneRules.isFixedOffset');\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     *\n     * @param instantOrLocalDateTime\n     * @returns {ZoneOffset}\n     */\n    offset(instantOrLocalDateTime){\n        if(instantOrLocalDateTime instanceof Instant){\n            return this.offsetOfInstant(instantOrLocalDateTime);\n        } else {\n            return this.offsetOfLocalDateTime(instantOrLocalDateTime);\n        }\n    }\n\n    /**\n     * Gets the offset applicable at the specified instant in these rules.\n     *\n     * The mapping from an instant to an offset is simple, there is only\n     * one valid offset for each instant.\n     * This method returns that offset.\n     *\n     * @param {Instant} instant - the instant to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    offsetOfInstant(instant){\n        abstractMethodFail('ZoneRules.offsetInstant');\n    }\n\n    /**\n     * Gets the offset applicable at the specified epochMilli in these rules.\n     *\n     * The method is for javascript performance optimisation.\n     *\n     * @param {number} epochMilli - the epoch millisecond to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    offsetOfEpochMilli(epochMilli){\n        abstractMethodFail('ZoneRules.offsetOfEpochMilli');\n    }\n\n\n    /**\n     * Gets a suitable offset for the specified local date-time in these rules.\n     *\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     *\n     * * Normal, with one valid offset. For the vast majority of the year, the normal\n     *   case applies, where there is a single valid offset for the local date-time.\n     * * Gap, with zero valid offsets. This is when clocks jump forward typically\n     *   due to the spring daylight savings change from \"winter\" to \"summer\".\n     *   In a gap there are local date-time values with no valid offset.\n     * * Overlap, with two valid offsets. This is when clocks are set back typically\n     *   due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *   In an overlap there are local date-time values with two valid offsets.\n     *\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns the single offset in the Normal case, and in the Gap or Overlap\n     * case it returns the offset before the transition.\n     *\n     * Since, in the case of Gap and Overlap, the offset returned is a \"best\" value, rather\n     * than the \"correct\" value, it should be treated with care. Applications that care\n     * about the correct offset should use a combination of this method,\n     * {@link getValidOffsets} and {@link getTransition}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the best available offset for the local date-time, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    offsetOfLocalDateTime(localDateTime){\n        abstractMethodFail('ZoneRules.offsetLocalDateTime');\n    }\n\n    /**\n     * Gets the offset applicable at the specified local date-time in these rules.\n     *\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     *\n     * * Normal, with one valid offset. For the vast majority of the year, the normal\n     *   case applies, where there is a single valid offset for the local date-time.\n     * * Gap, with zero valid offsets. This is when clocks jump forward typically\n     *   due to the spring daylight savings change from \"winter\" to \"summer\".\n     *   In a gap there are local date-time values with no valid offset.\n     * * Overlap, with two valid offsets. This is when clocks are set back typically\n     *   due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *   In an overlap there are local date-time values with two valid offsets.\n     *\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns that list of valid offsets, which is a list of size 0, 1 or 2.\n     * In the case where there are two offsets, the earlier offset is returned at index 0\n     * and the later offset at index 1.\n     *\n     * There are various ways to handle the conversion from a {@link LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  List<ZoneOffset> validOffsets = rules.getOffset(localDT);\n     *  if (validOffsets.size() == 1) {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = validOffsets.get(0);\n     *  } else {\n     *    // Gap or Overlap: determine what to do from transition (which will be non-null)\n     *    ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  }\n     * </pre>\n     *\n     * In theory, it is possible for there to be more than two valid offsets.\n     * This would happen if clocks to be put back more than once in quick succession.\n     * This has never happened in the history of time-zones and thus has no special handling.\n     * However, if it were to happen, then the list would return more than 2 entries.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query for valid offsets, not null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset[]} the list of valid offsets, may be immutable, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    validOffsets(localDateTime){\n        abstractMethodFail('ZoneRules.validOffsets');\n    }\n\n    /**\n     * Gets the offset transition applicable at the specified local date-time in these rules.\n     *\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     *\n     * * Normal, with one valid offset. For the vast majority of the year, the normal\n     *   case applies, where there is a single valid offset for the local date-time.\n     * * Gap, with zero valid offsets. This is when clocks jump forward typically\n     *   due to the spring daylight savings change from \"winter\" to \"summer\".\n     *   In a gap there are local date-time values with no valid offset.\n     * * Overlap, with two valid offsets. This is when clocks are set back typically\n     *   due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *   In an overlap there are local date-time values with two valid offsets.\n     *\n     * A transition is used to model the cases of a Gap or Overlap.\n     * The Normal case will return null.\n     *\n     * There are various ways to handle the conversion from a {@link LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  if (trans != null) {\n     *    // Gap or Overlap: determine what to do from transition\n     *  } else {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = rule.getOffset(localDT);\n     *  }\n     * </pre>\n     *\n     * @param {LocalDateTime} localDateTime  the local date-time to query for offset transition, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the offset transition, null if the local date-time is not in transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    transition(localDateTime){\n        abstractMethodFail('ZoneRules.transition');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the standard offset for the specified instant in this zone.\n     *\n     * This provides access to historic information on how the standard offset\n     * has changed over time.\n     * The standard offset is the offset before any daylight saving time is applied.\n     * This is typically the offset applicable during winter.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    standardOffset(instant){\n        abstractMethodFail('ZoneRules.standardOffset');\n    }\n\n    /**\n     * Gets the amount of daylight savings in use for the specified instant in this zone.\n     *\n     * This provides access to historic information on how the amount of daylight\n     * savings has changed over time.\n     * This is the difference between the standard offset and the actual offset.\n     * Typically the amount is zero during winter and one hour during summer.\n     * Time-zones are second-based, so the nanosecond part of the duration will be zero.\n     *\n     * @param {Instant} instant - the instant to find the daylight savings for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {Duration} the difference between the standard and actual offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    daylightSavings(instant){\n        abstractMethodFail('ZoneRules.daylightSavings');\n        //    default {\n        //        ZoneOffset standardOffset = getStandardOffset(instant);\n        //        ZoneOffset actualOffset = getOffset(instant);\n        //        return actualOffset.toDuration().minus(standardOffset.toDuration()).normalized();\n        //    }\n    }\n\n    /**\n     * Checks if the specified instant is in daylight savings.\n     *\n     * This checks if the standard and actual offsets are the same at the specified instant.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {boolean} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    isDaylightSavings(instant) {\n        abstractMethodFail('ZoneRules.isDaylightSavings');\n        //    default {\n        //        return (getStandardOffset(instant).equals(getOffset(instant)) == false);\n        //    }\n    }\n\n    /**\n     * Checks if the offset date-time is valid for these rules.\n     *\n     * To be valid, the local date-time must not be in a gap and the offset\n     * must match the valid offsets.\n     *\n     * @param {LocalDateTime} localDateTime - the date-time to check, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @param {ZoneOffset} offset - the offset to check, null returns false\n     * @return {boolean} true if the offset date-time is valid for these rules\n     */\n    // eslint-disable-next-line no-unused-vars\n    isValidOffset(localDateTime, offset){\n        abstractMethodFail('ZoneRules.isValidOffset');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the next transition after the specified instant.\n     *\n     * This returns details of the next transition after the specified instant.\n     * For example, if the instant represents a point where \"Summer\" daylight savings time\n     * applies, then the method will return the transition to the next \"Winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the next transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the next transition after the specified instant, null if this is after the last transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    nextTransition(instant){\n        abstractMethodFail('ZoneRules.nextTransition');\n    }\n\n    /**\n     * Gets the previous transition before the specified instant.\n     *\n     * This returns details of the previous transition after the specified instant.\n     * For example, if the instant represents a point where \"summer\" daylight saving time\n     * applies, then the method will return the transition from the previous \"winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the previous transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the previous transition after the specified instant, null if this is before the first transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    previousTransition(instant){\n        abstractMethodFail('ZoneRules.previousTransition');\n    }\n\n    /**\n     * Gets the complete list of fully defined transitions.\n     *\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link getTransitionRules}. This method returns those transitions that have\n     * been fully defined. These are typically historical, but may be in the future.\n     *\n     * The list will be empty for fixed offset rules and for any time-zone where there has\n     * only ever been a single offset. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransition[]} an immutable list of fully defined transitions, not null\n     */\n    transitions(){\n        abstractMethodFail('ZoneRules.transitions');\n    }\n\n    /**\n     * Gets the list of transition rules for years beyond those defined in the transition list.\n     *\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link getTransitions}. This method returns instances of {@link ZoneOffsetTransitionRule}\n     * that define an algorithm for when transitions will occur.\n     *\n     * For any given {@link ZoneRules}, this list contains the transition rules for years\n     * beyond those years that have been fully defined. These rules typically refer to future\n     * daylight saving time rule changes.\n     *\n     * If the zone defines daylight savings into the future, then the list will normally\n     * be of size two and hold information about entering and exiting daylight savings.\n     * If the zone does not have daylight savings, or information about future changes\n     * is uncertain, then the list will be empty.\n     *\n     * The list will be empty for fixed offset rules and for any time-zone where there is no\n     * daylight saving time. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransitionRule[]} an immutable list of transition rules, not null\n     */\n    transitionRules(){\n        abstractMethodFail('ZoneRules.transitionRules');\n    }\n}\n\n\nclass Fixed extends ZoneRules{\n    /**\n     *\n     * @param {ZoneOffset} offset\n     */\n    constructor(offset){\n        super();\n        this._offset = offset;\n    }\n\n    isFixedOffset(){\n        return true;\n    }\n\n    offsetOfInstant(){\n        return this._offset;\n    }\n\n    offsetOfEpochMilli(){\n        return this._offset;\n    }\n\n    offsetOfLocalDateTime(){\n        return this._offset;\n    }\n\n    validOffsets(){\n        return [this._offset];\n    }\n\n    transition(){\n        return null;\n    }\n\n    standardOffset(){\n        return this._offset;\n    }\n\n    daylightSavings(){\n        return Duration.ZERO;\n    }\n\n    isDaylightSavings(){\n        return false;\n    }\n\n    /**\n     *\n     * @param {LocalDateTime} LocalDateTime\n     * @param {ZoneOffset} offset\n     * @return {boolean}\n     */\n    isValidOffset(dateTime, offset) {\n        return this._offset.equals(offset);\n    }\n\n    nextTransition(){\n        return null;\n    }\n\n    previousTransition(){\n        return null;\n    }\n\n    transitions(){\n        return [];\n    }\n\n    transitionRules(){\n        return [];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof Fixed) {\n            return this._offset.equals(other._offset);\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'FixedRules:' + this._offset.toString();\n    }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/zone/ZoneRules.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n\nimport {ZoneId} from './ZoneId';\nimport {ZoneRulesProvider} from './zone/ZoneRulesProvider';\n\n/**\n * A geographical region where the same time-zone rules apply.\n *\n * Time-zone information is categorized as a set of rules defining when and\n * how the offset from UTC/Greenwich changes. These rules are accessed using\n * identifiers based on geographical regions, such as countries or states.\n * The most common region classification is the Time Zone Database (TZDB),\n * which defines regions such as 'Europe/Paris' and 'Asia/Tokyo'.\n *\n * The region identifier, modeled by this class, is distinct from the\n * underlying rules, modeled by {@link ZoneRules}.\n * The rules are defined by governments and change frequently.\n * By contrast, the region identifier is well-defined and long-lived.\n * This separation also allows rules to be shared between regions if appropriate.\n *\n * ### Specification for implementors\n *\n * This class is immutable and thread-safe.\n */\nexport class ZoneRegion extends ZoneId {\n    /**\n     * not yet implemented\n     * @params {string} zoneId\n     * @return {ZoneId}\n     */\n    static ofId(zoneId){\n        let rules = ZoneRulesProvider.getRules(zoneId);\n        return new ZoneRegion(zoneId, rules);\n    }\n\n     //-------------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {string} id  the time-zone ID, not null\n     * @param {ZoneRules} rules  the rules, null for lazy lookup\n     */\n    constructor(id, rules) {\n        super();\n        this._id = id;\n        this._rules = rules;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @returns {string}\n     */\n    id() {\n        return this._id;\n    }\n\n    /**\n     *\n     * @returns {ZoneRules}\n     */\n    rules() {\n        return this._rules;\n    }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ZoneRegion.js","/*\n * @copyright (c) 2016, Philipp Thrwchter, Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {DateTimeException} from '../errors';\n\nexport class ZoneRulesProvider {\n    /**\n     * Gets the rules for the zone ID.\n     *\n     * This returns the latest available rules for the zone ID.\n     *\n     * This method relies on time-zone data provider files that are configured.\n     *\n     * @param {string} zoneId\n     * @return {ZoneRules}\n     */\n    static getRules(zoneId){\n        throw new DateTimeException('unsupported ZoneId:' + zoneId);\n    }\n\n\n    /**\n     * Gets the set of available zone IDs.\n     *\n     * These zone IDs are loaded and available for use by {@link ZoneId}.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds(){\n        return [];\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/zone/ZoneRulesProvider.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {SystemDefaultZoneRules} from './SystemDefaultZoneRules';\nimport {ZoneId} from '../ZoneId';\n\nexport class SystemDefaultZoneId extends ZoneId {\n\n    constructor(){\n        super();\n        this._rules = new SystemDefaultZoneRules();\n    }\n\n    rules(){\n        return this._rules;\n    }\n\n    equals(other){\n        if(this === other){\n            return true;\n        }\n        return false;\n    }\n\n    id(){\n        return 'SYSTEM';\n    }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/zone/SystemDefaultZoneId.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {ZoneRules} from './ZoneRules';\nimport {ZoneOffset} from '../ZoneOffset';\nimport {DateTimeException} from '../errors';\n\nexport class SystemDefaultZoneRules extends ZoneRules {\n\n    isFixedOffset(){\n        return false;\n    }\n\n    /**\n     *\n     * @param {Instant} instant\n     * @returns {ZoneOffset}\n     */\n    offsetOfInstant(instant){\n        const offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n    }\n\n    /**\n     *\n     * @param {number} epochMilli\n     * @returns {ZoneOffset}\n     */\n    offsetOfEpochMilli(epochMilli){\n        const offsetInMinutes = new Date(epochMilli).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n    }\n\n    /**\n     * This implementation is NOT returning the best value in a gap or overlap situation\n     * as specified at {@link ZoneRules.offsetOfLocalDateTime}.\n     *\n     * The calculated offset depends Date.prototype.getTimezoneOffset and its not specified\n     * at the ECMA-262 specification how to handle daylight savings gaps/ overlaps.\n     *\n     * The Chrome Browser version 49 is returning the next transition offset in a gap/overlap situation,\n     * other browsers/ engines might do it in the same way.\n     *\n     * @param {LocalDateTime} localDateTime\n     * @returns {ZoneOffset}\n     */\n    offsetOfLocalDateTime(localDateTime){\n        const epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;\n        const offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();\n        const epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;\n        const offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);\n    }\n\n    /**\n     *\n     * @param localDateTime\n     * @return {ZoneOffset[]}\n     */\n    validOffsets(localDateTime){\n        return [this.offsetOfLocalDateTime(localDateTime)];\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    transition(){\n        return null;\n    }\n\n    /**\n     *\n     * @param instant\n     * @return {ZoneOffset}\n     */\n    standardOffset(instant){\n        return this.offsetOfInstant(instant);\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    daylightSavings(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    isDaylightSavings(){\n        this._throwNotSupported();\n    }\n\n    /**\n     *\n     * @param {LocalDateTime} dateTime\n     * @param {ZoneOffset} offset\n     * @return {boolean}\n     */\n    isValidOffset(dateTime, offset) {\n        return this.offsetOfLocalDateTime(dateTime).equals(offset);\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    nextTransition(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    previousTransition(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    transitions(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    transitionRules(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    _throwNotSupported(){\n        throw new DateTimeException('not supported operation');\n    }\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other || other instanceof SystemDefaultZoneRules) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'SYSTEM';\n    }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/zone/SystemDefaultZoneRules.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull, requireInstance} from '../assert';\n\nimport {ChronoField} from '../temporal/ChronoField';\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {DateTimeFormatter} from '../format/DateTimeFormatter';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\nimport {Temporal} from '../temporal/Temporal';\n\nimport {LocalDate} from '../LocalDate';\n\n/**\n * A date without time-of-day or time-zone in an arbitrary chronology, intended\n * for advanced globalization use cases.\n *\n * **Most applications should declare method signatures, fields and variables\n * as {@link LocalDate}, not this interface.**\n *\n * A {@link ChronoLocalDate} is the abstract representation of a date where the\n * {@link Chronology}, or calendar system, is pluggable.\n * The date is defined in terms of fields expressed by {@link TemporalField},\n * where most common implementations are defined in {@link ChronoField}.\n * The chronology defines how the calendar system operates and the meaning of\n * the standard fields.\n *\n * #### When to use this interface\n *\n * The design of the API encourages the use of {@link LocalDate} rather than this\n * interface, even in the case where the application needs to deal with multiple\n * calendar systems. The rationale for this is explored in the following documentation.\n *\n * The primary use case where this interface should be used is where the generic\n * type parameter `C` is fully defined as a specific chronology.\n * In that case, the assumptions of that chronology are known at development\n * time and specified in the code.\n *\n * When the chronology is defined in the generic type parameter as ? or otherwise\n * unknown at development time, the rest of the discussion below applies.\n *\n * To emphasize the point, declaring a method signature, field or variable as this\n * interface type can initially seem like the sensible way to globalize an application,\n * however it is usually the wrong approach.\n * As such, it should be considered an application-wide architectural decision to choose\n * to use this interface as opposed to {@link LocalDate}.\n *\n * #### Architectural issues to consider\n *\n * These are some of the points that must be considered before using this interface\n * throughout an application.\n *\n * 1) Applications using this interface, as opposed to using just {@link LocalDate},\n * face a significantly higher probability of bugs. This is because the calendar system\n * in use is not known at development time. A key cause of bugs is where the developer\n * applies assumptions from their day-to-day knowledge of the ISO calendar system\n * to code that is intended to deal with any arbitrary calendar system.\n * The section below outlines how those assumptions can cause problems\n * The primary mechanism for reducing this increased risk of bugs is a strong code review process.\n * This should also be considered a extra cost in maintenance for the lifetime of the code.\n *\n * 2) This interface does not enforce immutability of implementations.\n * While the implementation notes indicate that all implementations must be immutable\n * there is nothing in the code or type system to enforce this. Any method declared\n * to accept a {@link ChronoLocalDate} could therefore be passed a poorly or\n * maliciously written mutable implementation.\n *\n * 3) Applications using this interface  must consider the impact of eras.\n * {@link LocalDate} shields users from the concept of eras, by ensuring that `getYear()`\n * returns the proleptic year. That decision ensures that developers can think of\n * {@link LocalDate} instances as consisting of three fields - year, month-of-year and day-of-month.\n * By contrast, users of this interface must think of dates as consisting of four fields -\n * era, year-of-era, month-of-year and day-of-month. The extra era field is frequently\n * forgotten, yet it is of vital importance to dates in an arbitrary calendar system.\n * For example, in the Japanese calendar system, the era represents the reign of an Emperor.\n * Whenever one reign ends and another starts, the year-of-era is reset to one.\n *\n * 4) The only agreed international standard for passing a date between two systems\n * is the ISO-8601 standard which requires the ISO calendar system. Using this interface\n * throughout the application will inevitably lead to the requirement to pass the date\n * across a network or component boundary, requiring an application specific protocol or format.\n *\n * 5) Long term persistence, such as a database, will almost always only accept dates in the\n * ISO-8601 calendar system (or the related Julian-Gregorian). Passing around dates in other\n * calendar systems increases the complications of interacting with persistence.\n *\n * 6) Most of the time, passing a {@link ChronoLocalDate} throughout an application\n * is unnecessary, as discussed in the last section below.\n *\n * #### False assumptions causing bugs in multi-calendar system code\n *\n * As indicated above, there are many issues to consider when try to use and manipulate a\n * date in an arbitrary calendar system. These are some of the key issues.\n *\n * Code that queries the day-of-month and assumes that the value will never be more than\n * 31 is invalid. Some calendar systems have more than 31 days in some months.\n *\n * Code that adds 12 months to a date and assumes that a year has been added is invalid.\n * Some calendar systems have a different number of months, such as 13 in the Coptic or Ethiopic.\n *\n * Code that adds one month to a date and assumes that the month-of-year value will increase\n * by one or wrap to the next year is invalid. Some calendar systems have a variable number\n * of months in a year, such as the Hebrew.\n *\n * Code that adds one month, then adds a second one month and assumes that the day-of-month\n * will remain close to its original value is invalid. Some calendar systems have a large difference\n * between the length of the longest month and the length of the shortest month.\n * For example, the Coptic or Ethiopic have 12 months of 30 days and 1 month of 5 days.\n *\n * Code that adds seven days and assumes that a week has been added is invalid.\n * Some calendar systems have weeks of other than seven days, such as the French Revolutionary.\n *\n * Code that assumes that because the year of `date1` is greater than the year of `date2`\n * then `date1` is after `date2` is invalid. This is invalid for all calendar systems\n * when referring to the year-of-era, and especially untrue of the Japanese calendar system\n * where the year-of-era restarts with the reign of every new Emperor.\n *\n * Code that treats month-of-year one and day-of-month one as the start of the year is invalid.\n * Not all calendar systems start the year when the month value is one.\n *\n * In general, manipulating a date, and even querying a date, is wide open to bugs when the\n * calendar system is unknown at development time. This is why it is essential that code using\n * this interface is subjected to additional code reviews. It is also why an architectural\n * decision to avoid this interface type is usually the correct one.\n *\n * #### Using LocalDate instead\n *\n * The primary alternative to using this interface throughout your application is as follows.\n *\n * * Declare all method signatures referring to dates in terms of {@link LocalDate}.\n * * Either store the chronology (calendar system) in the user profile or lookup the chronology\n *   from the user locale.\n * * Convert the ISO {@link LocalDate} to and from the user's preferred calendar system during\n *   printing and parsing.\n *\n * This approach treats the problem of globalized calendar systems as a localization issue\n * and confines it to the UI layer. This approach is in keeping with other localization\n * issues in the java platform.\n *\n * As discussed above, performing calculations on a date where the rules of the calendar system\n * are pluggable requires skill and is not recommended.\n * Fortunately, the need to perform calculations on a date in an arbitrary calendar system\n * is extremely rare. For example, it is highly unlikely that the business rules of a library\n * book rental scheme will allow rentals to be for one month, where meaning of the month\n * is dependent on the user's preferred calendar system.\n *\n * A key use case for calculations on a date in an arbitrary calendar system is producing\n * a month-by-month calendar for display and user interaction. Again, this is a UI issue,\n * and use of this interface solely within a few methods of the UI layer may be justified.\n *\n * In any other part of the system, where a date must be manipulated in a calendar system\n * other than ISO, the use case will generally specify the calendar system to use.\n * For example, an application may need to calculate the next Islamic or Hebrew holiday\n * which may require manipulating the date.\n * This kind of use case can be handled as follows:\n *\n * * start from the ISO {@link LocalDate} being passed to the method\n * * convert the date to the alternate calendar system, which for this use case is known\n *   rather than arbitrary\n * * perform the calculation\n * * convert back to {@link LocalDate}\n *\n * Developers writing low-level frameworks or libraries should also avoid this interface.\n * Instead, one of the two general purpose access interfaces should be used.\n * Use {@link TemporalAccessor} if read-only access is required, or use {@link Temporal}\n * if read-write access is required.\n *\n * ### Specification for implementors\n *\n * This interface must be implemented with care to ensure other classes operate correctly.\n * All implementations that can be instantiated must be final, immutable and thread-safe.\n * Subclasses should be Serializable wherever possible.\n *\n * Additional calendar systems may be added to the system.\n * See {@link Chronology} for more details.\n *\n * In JDK 8, this is an interface with default methods.\n * Since there are no default methods in JDK 7, an abstract class is used.\n */\nexport class ChronoLocalDate extends Temporal {\n\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.DAYS;\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toEpochDay());\n        } else if (query === TemporalQueries.localTime() || query === TemporalQueries.zone() ||\n                query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    adjustInto(temporal) {\n        return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());\n    }\n    /**\n     * Formats this date using the specified formatter.\n     *\n     * This date will be passed to the formatter to produce a string.\n     *\n     * The default implementation must behave as follows:\n     * <pre>\n     *  return formatter.format(this);\n     * </pre>\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.format(this);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/chrono/ChronoLocalDate.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull} from '../assert';\n\nimport {DateTimeParseException, NullPointerException} from '../errors';\n\nimport {Period} from '../Period';\n\nimport {ParsePosition} from './ParsePosition';\nimport {DateTimeBuilder} from './DateTimeBuilder';\nimport {DateTimeParseContext} from './DateTimeParseContext';\nimport {DateTimePrintContext} from './DateTimePrintContext';\nimport {DateTimeFormatterBuilder} from './DateTimeFormatterBuilder';\nimport {SignStyle} from './SignStyle';\nimport {StringBuilder} from './StringBuilder';\nimport {ResolverStyle} from './ResolverStyle';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {createTemporalQuery} from '../temporal/TemporalQuery';\n\n/**\n *\n * ### Static properties of Class {@link DateTimeFormatter}\n *\n * DateTimeFormatter.ISO_LOCAL_DATE\n *\n * DateTimeFormatter.ISO_LOCAL_TIME\n *\n * DateTimeFormatter.ISO_LOCAL_DATE_TIME\n *\n */\nexport class DateTimeFormatter {\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query that provides access to the excess days that were parsed.\n     *\n     * This returns a singleton {@link TemporalQuery} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null period, with a zero period returned instead of null.\n     *\n     * There are two situations where this query may return a non-zero period.\n     *\n     * * If the {@link ResolverStyle} is {@link LENIENT} and a time is parsed\n     *   without a date, then the complete result of the parse consists of a\n     *   {@link LocalTime} and an excess {@link Period} in days.\n     * * If the {@link ResolverStyle} is {@link SMART} and a time is parsed\n     *   without a date where the time is 24:00:00, then the complete result of\n     *   the parse consists of a {@link LocalTime} of 00:00:00 and an excess\n     *   {@link Period} of one day.\n     *\n     * In both cases, if a complete {@link ChronoLocalDateTime} or {@link Instant}\n     * is parsed, then the excess days are added to the date part.\n     * As a result, this query will return a zero period.\n     *\n     * The {@link SMART} behaviour handles the common \"end of day\" 24:00 value.\n     * Processing in {@link LENIENT} mode also produces the same result:\n     * <pre>\n     *  Text to parse        Parsed object                         Excess days\n     *  \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO\n     *  \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO\n     *  \"00:00\"              LocalTime.of(0, 0)                    ZERO\n     *  \"24:00\"              LocalTime.of(0, 0)                    Period.ofDays(1)\n     * </pre>\n     * The query can be used as follows:\n     * <pre>\n     *  TemporalAccessor parsed = formatter.parse(str);\n     *  LocalTime time = parsed.query(LocalTime.FROM);\n     *  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());\n     * </pre>\n     * @return {TemporalQuery} a query that provides access to the excess days that were parsed\n     */\n    static parsedExcessDays() {\n        return DateTimeFormatter.PARSED_EXCESS_DAYS;\n    }\n\n    /**\n     * A query that provides access to whether a leap-second was parsed.\n     *\n     * This returns a singleton {@link TemporalQuery} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null boolean, true if parsing saw a leap-second, false if not.\n     *\n     * Instant parsing handles the special \"leap second\" time of '23:59:60'.\n     * Leap seconds occur at '23:59:60' in the UTC time-zone, but at other\n     * local times in different time-zones. To avoid this potential ambiguity,\n     * the handling of leap-seconds is limited to\n     * {@link DateTimeFormatterBuilder#appendInstant}, as that method\n     * always parses the instant with the UTC zone offset.\n     *\n     * If the time '23:59:60' is received, then a simple conversion is applied,\n     * replacing the second-of-minute of 60 with 59. This query can be used\n     * on the parse result to determine if the leap-second adjustment was made.\n     * The query will return one second of excess if it did adjust to remove\n     * the leap-second, and zero if not. Note that applying a leap-second\n     * smoothing mechanism, such as UTC-SLS, is the responsibility of the\n     * application, as follows:\n     * <pre>\n     *  TemporalAccessor parsed = formatter.parse(str);\n     *  Instant instant = parsed.query(Instant::from);\n     *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n     *    // validate leap-second is correct and apply correct smoothing\n     *  }\n     * </pre>\n     * @return a query that provides access to whether a leap-second was parsed\n     */\n    static parsedLeapSecond() {\n        return DateTimeFormatter.PARSED_LEAP_SECOND;\n    }\n\n    /**\n     * Creates a formatter using the specified pattern.\n     *\n     * This method will create a formatter based on a simple pattern of letters and symbols.\n     *\n     * The returned formatter will use the default locale, but this can be changed\n     * using {@link DateTimeFormatter.withLocale}.\n     *\n     * All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.\n     * The following pattern letters are defined:\n     * <pre>\n     *  |Symbol  |Meaning                     |Presentation      |Examples\n     *  |--------|----------------------------|------------------|----------------------------------------------------\n     *  | G      | era                        | number/text      | 1; 01; AD; Anno Domini\n     *  | y      | year                       | year             | 2004; 04\n     *  | D      | day-of-year                | number           | 189\n     *  | M      | month-of-year              | number/text      | 7; 07; Jul; July; J\n     *  | d      | day-of-month               | number           | 10\n     *  |        |                            |                  |\n     *  | Q      | quarter-of-year            | number/text      | 3; 03; Q3\n     *  | Y      | week-based-year            | year             | 1996; 96\n     *  | w      | week-of-year               | number           | 27\n     *  | W      | week-of-month              | number           | 27\n     *  | e      | localized day-of-week      | number           | 2; Tue; Tuesday; T\n     *  | E      | day-of-week                | number/text      | 2; Tue; Tuesday; T\n     *  | F      | week-of-month              | number           | 3\n     *  |        |                            |                  |\n     *  | a      | am-pm-of-day               | text             | PM\n     *  | h      | clock-hour-of-am-pm (1-12) | number           | 12\n     *  | K      | hour-of-am-pm (0-11)       | number           | 0\n     *  | k      | clock-hour-of-am-pm (1-24) | number           | 0\n     *  |        |                            |                  |\n     *  | H      | hour-of-day (0-23)         | number           | 0\n     *  | m      | minute-of-hour             | number           | 30\n     *  | s      | second-of-minute           | number           | 55\n     *  | S      | fraction-of-second         | fraction         | 978\n     *  | A      | milli-of-day               | number           | 1234\n     *  | n      | nano-of-second             | number           | 987654321\n     *  | N      | nano-of-day                | number           | 1234000000\n     *  |        |                            |                  |\n     *  | V      | time-zone ID               | zone-id          | America/Los_Angeles; Z; -08:30\n     *  | z      | time-zone name             | zone-name        | Pacific Standard Time; PST\n     *  | X      | zone-offset 'Z' for zero   | offset-X         | Z; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | x      | zone-offset                | offset-x         | +0000; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | Z      | zone-offset                | offset-Z         | +0000; -0800; -08:00;\n     *  |        |                            |                  |\n     *  | p      | pad next                   | pad modifier     | 1\n     *  |        |                            |                  |\n     *  | '      | escape for text            | delimiter        |\n     *  | ''     | single quote               | literal          | '\n     *  | [      | optional section start     |                  |\n     *  | ]      | optional section end       |                  |\n     *  | {}     | reserved for future use    |                  |\n     * </pre>\n     *\n     * The count of pattern letters determine the format.\n     *\n     * **Text**: The text style is determined based on the number of pattern letters used.\n     * Less than 4 pattern letters will use the short form `TextStyle.SHORT`.\n     * Exactly 4 pattern letters will use the full form `TextStyle.FULL`.\n     * Exactly 5 pattern letters will use the narrow form `TextStyle.NARROW`.\n     *\n     * **NOTE**: since text styles require locale support, they are currently not supported in js-joda!\n     *\n     * **Number**: If the count of letters is one, then the value is printed using the minimum number\n     * of digits and without padding as per {@link DateTimeFormatterBuilder.appendValue}.\n     * Otherwise, the count of digits is used as the width of the output field as per\n     * {@link DateTimeFormatterBuilder.appendValue}.\n     *\n     * **Number/Text**: If the count of pattern letters is 3 or greater, use the Text rules above.\n     * Otherwise use the Number rules above.\n     *\n     * **Fraction**: Outputs the nano-of-second field as a fraction-of-second.\n     * The nano-of-second value has nine digits, thus the count of pattern letters is from 1 to 9.\n     * If it is less than 9, then the nano-of-second value is truncated, with only the most\n     * significant digits being output.\n     * When parsing in strict mode, the number of parsed digits must match the count of pattern letters.\n     * When parsing in lenient mode, the number of parsed digits must be at least the count of pattern\n     * letters, up to 9 digits.\n     *\n     * **Year**: The count of letters determines the minimum field width below which padding is used.\n     * If the count of letters is two, then a {@link DateTimeFormatterBuilder.appendValueReduced}\n     * two digit form is used.\n     * For printing, this outputs the rightmost two digits. For parsing, this will parse using the\n     * base value of 2000, resulting in a year within the range 2000 to 2099 inclusive.\n     * If the count of letters is less than four (but not two), then the sign is only output for negative\n     * years as per `SignStyle.NORMAL`.\n     * Otherwise, the sign is output if the pad width is exceeded, as per `SignStyle.EXCEEDS_PAD`\n     *\n     * **ZoneId**: This outputs the time-zone ID, such as 'Europe/Paris'.\n     * If the count of letters is two, then the time-zone ID is output.\n     * Any other count of letters throws `IllegalArgumentException`.\n     *\n     * **Zone names**: This outputs the display name of the time-zone ID.\n     * If the count of letters is one, two or three, then the short name is output.\n     * If the count of letters is four, then the full name is output.\n     * Five or more letters throws `IllegalArgumentException`.\n     *\n     * **NOTE**: since zone ids and name require the iana tzdb, they are currently not supported in js-joda!\n     *\n     * **Offset X and x**: This formats the offset based on the number of pattern letters.\n     * One letter outputs just the hour', such as '+01', unless the minute is non-zero\n     * in which case the minute is also output, such as '+0130'.\n     * Two letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Three letters outputs the hour and minute, with a colon, such as '+01:30'.\n     * Four letters outputs the hour and minute and optional second, without a colon, such as '+013015'.\n     * Five letters outputs the hour and minute and optional second, with a colon, such as '+01:30:15'.\n     * Six or more letters throws `IllegalArgumentException`.\n     * Pattern letter 'X' (upper case) will output 'Z' when the offset to be output would be zero,\n     * whereas pattern letter 'x' (lower case) will output '+00', '+0000', or '+00:00'.\n     *\n     * **Offset Z**: This formats the offset based on the number of pattern letters.\n     * One, two or three letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Four or more letters throws `IllegalArgumentException`.\n     * The output will be '+0000' when the offset is zero.\n     *\n     * **Optional section**: The optional section markers work exactly like calling\n     * {@link DateTimeFormatterBuilder.optionalStart} and {@link DateTimeFormatterBuilder.optionalEnd}.\n     *\n     * **Pad modifier**: Modifies the pattern that immediately follows to be padded with spaces.\n     * The pad width is determined by the number of pattern letters.\n     * This is the same as calling {@link DateTimeFormatterBuilder.padNext}.\n     *\n     * For example, 'ppH' outputs the hour-of-day padded on the left with spaces to a width of 2.\n     *\n     * Any unrecognized letter is an error.\n     * Any non-letter character, other than '[', ']', '{', '}' and the single quote will be output directly.\n     * Despite this, it is recommended to use single quotes around all characters that you want to\n     * output directly to ensure that future changes do not break your application.\n     *\n     * @param {String} pattern  the pattern to use, not null\n     * @return {DateTimeFormatter} the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     * @example\n     * var s = LocalDate.parse('2016-04-01').format(DateTimeFormatter.ofPattern('d MM yyyy'));\n     * console.log(s); // '1 04 2016'\n     *\n     */\n    static ofPattern(pattern) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer/parser to use, not null\n     * @param locale  the locale to use, not null\n     * @param decimalStyle  the decimal style to use, not null\n     * @param resolverStyle  the resolver style to use, not null\n     * @param resolverFields  the fields to use during resolving, null for all fields\n     * @param chrono  the chronology to use, null for no override\n     * @param zone  the zone to use, null for no override\n     */\n    constructor(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono=IsoChronology.INSTANCE, zone) {\n        assert(printerParser != null);\n        assert(decimalStyle != null);\n        assert(resolverStyle != null);\n        /**\n         * The printer and/or parser to use, not null.\n         */\n        this._printerParser = printerParser;\n        /**\n         * The locale to use for formatting. // nyi\n         */\n        this._locale = locale;\n        /**\n         * The symbols to use for formatting, not null.\n         */\n        this._decimalStyle = decimalStyle;\n        /**\n         * The resolver style to use, not null.\n         */\n        this._resolverStyle = resolverStyle;\n        /**\n         * The fields to use in resolving, null for all fields.\n         */\n        this._resolverFields = resolverFields;\n        /**\n         * The chronology to use for formatting, null for no override.\n         */\n        this._chrono = chrono;\n        /**\n         * The zone to use for formatting, null for no override. // nyi\n         */\n        this._zone = zone;\n    }\n\n    locale() {\n        return this._locale;\n    }\n\n    decimalStyle() {\n        return this._decimalStyle;\n    }\n\n    chronology() {\n        return this._chrono;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override chronology.\n     *\n     * This returns a formatter with similar state to this formatter but\n     * with the override chronology set.\n     * By default, a formatter has no override chronology, returning null.\n     *\n     * If an override is added, then any date that is printed or parsed will be affected.\n     *\n     * When printing, if the {@link Temporal} object contains a date then it will\n     * be converted to a date in the override chronology.\n     * Any time or zone will be retained unless overridden.\n     * The converted result will behave in a manner equivalent to an implementation\n     * of {@link ChronoLocalDate},{@link ChronoLocalDateTime} or {@link ChronoZonedDateTime}.\n     *\n     * When parsing, the override chronology will be used to interpret the\n     * {@link ChronoField} into a date unless the\n     * formatter directly parses a valid chronology.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param chrono  the new chronology, not null\n     * @return a formatter based on this formatter with the requested override chronology, not null\n     */\n    withChronology(chrono) {\n        if (this._chrono != null && this._chrono.equals(chrono)) {\n            return this;\n        }\n        return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle,\n            this._resolverStyle, this._resolverFields, chrono, this._zone);\n    }\n\n    /**\n     * not yet supported\n     * @returns {DateTimeFormatter}\n     */\n    withLocale(){\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object using this formatter.\n     *\n     * This formats the date-time to a String using the rules of the formatter.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to print, not null\n     * @return {String} the printed string, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    format(temporal) {\n        const buf = new StringBuilder(32);\n        this._formatTo(temporal, buf);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object to an {@link Appendable} using this formatter.\n     *\n     * This formats the date-time to the specified destination.\n     * {@link Appendable} is a general purpose interface that is implemented by all\n     * key character output classes including {@link StringBuffer}, {@link StringBuilder},\n     * {@link PrintStream} and {@link Writer}.\n     *\n     * Although {@link Appendable} methods throw an {@link IOException}, this method does not.\n     * Instead, any {@link IOException} is wrapped in a runtime exception.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to print, not null\n     * @param {StringBuilder} appendable - the appendable to print to, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    _formatTo(temporal, appendable) {\n        requireNonNull(temporal, 'temporal');\n        requireNonNull(appendable, 'appendable');\n        const context = new DateTimePrintContext(temporal, this);\n        this._printerParser.print(context, appendable);\n    }\n\n    /**\n     * function overloading for {@link DateTimeFormatter.parse}\n     *\n     * if called with one arg {@link DateTimeFormatter.parse1} is called\n     * otherwise {@link DateTimeFormatter.parse2}\n     *\n     * @param {string} text\n     * @param {TemporalQuery} type\n     * @return {TemporalAccessor}\n     */\n    parse(text, type){\n        if(arguments.length === 1){\n            return this.parse1(text);\n        } else {\n            return this.parse2(text, type);\n        }\n    }\n\n    /**\n     * Fully parses the text producing a temporal object.\n     *\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link parse}.\n     * The result of this method is {@link TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     *\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param {String} text  the text to parse, not null\n     * @return {TemporalAccessor} the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    parse1(text) {\n        requireNonNull(text, 'text');\n        try {\n            return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n        } catch (ex) {\n            if(ex instanceof DateTimeParseException){\n                throw ex;\n            } else {\n                throw this._createError(text, ex);\n            }\n        }\n    }\n\n    /**\n     * Fully parses the text producing a temporal object.\n     *\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link parse}.\n     * The result of this method is {@link TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     *\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @param type the type to extract, not null\n * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    parse2(text, type) {\n        requireNonNull(text, 'text');\n        requireNonNull(type, 'type');\n        try {\n            const builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n            return builder.build(type);\n        } catch (ex) {\n            if(ex instanceof DateTimeParseException){\n                throw ex;\n            } else {\n                throw this._createError(text, ex);\n            }\n        }\n    }\n\n    _createError(text, ex) {\n        let abbr = '';\n        if (text.length > 64) {\n            abbr = text.subString(0, 64) + '...';\n        } else {\n            abbr = text;\n        }\n        return new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed: ' + ex.message, text, 0, ex);\n    }\n\n\n    /**\n     * Parses the text to a builder.\n     *\n     * This parses to a {@link DateTimeBuilder} ensuring that the text is fully parsed.\n     * This method throws {@link DateTimeParseException} if unable to parse, or\n     * some other {@link DateTimeException} if another date/time problem occurs.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, null if parsing whole string\n     * @return the engine representing the result of the parse, not null\n     * @throws DateTimeParseException if the parse fails\n     */\n    _parseToBuilder(text, position) {\n        const pos = (position != null ? position : new ParsePosition(0));\n        const result = this._parseUnresolved0(text, pos);\n        if (result == null || pos.getErrorIndex() >= 0 || (position == null && pos.getIndex() < text.length)) {\n            let abbr = '';\n            if (text.length > 64) {\n                abbr = text.substr(0, 64).toString() + '...';\n            } else {\n                abbr = text;\n            }\n            if (pos.getErrorIndex() >= 0) {\n                throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed at index ' +\n                        pos.getErrorIndex(), text, pos.getErrorIndex());\n            } else {\n                throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed, unparsed text found at index ' +\n                        pos.getIndex(), text, pos.getIndex());\n            }\n        }\n        return result.toBuilder();\n    }\n\n    /**\n     * Parses the text using this formatter, without resolving the result, intended\n     * for advanced use cases.\n     *\n     * Parsing is implemented as a two-phase operation.\n     * First, the text is parsed using the layout defined by the formatter, producing\n     * a {@link Map} of field to value, a {@link ZoneId} and a {@link Chronology}.\n     * Second, the parsed data is *resolved*, by validating, combining and\n     * simplifying the various fields into more useful ones.\n     * This method performs the parsing stage but not the resolving stage.\n     *\n     * The result of this method is {@link TemporalAccessor} which represents the\n     * data as seen in the input. Values are not validated, thus parsing a date string\n     * of '2012-00-65' would result in a temporal with three fields - year of '2012',\n     * month of '0' and day-of-month of '65'.\n     *\n     * The text will be parsed from the specified start {@link ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@link ParsePosition}\n     * will be updated with the index at the end of parsing.\n     *\n     * Errors are returned using the error index field of the {@link ParsePosition}\n     * instead of {@link DateTimeParseException}.\n     * The returned error index will be set to an index indicative of the error.\n     * Callers must check for errors before using the context.\n     *\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     *\n     * This method is intended for advanced use cases that need access to the\n     * internal state during parsing. Typical application code should use\n     * {@link parse} or the parse method on the target type.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed text, null if the parse results in an error\n     * @throws DateTimeException if some problem occurs during parsing\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    parseUnresolved(text, position) {\n        return this._parseUnresolved0(text, position);\n    }\n\n    _parseUnresolved0(text, position) {\n        assert(text != null, 'text', NullPointerException);\n        assert(position != null, 'position', NullPointerException);\n        const context = new DateTimeParseContext(this);\n        let pos = position.getIndex();\n        pos = this._printerParser.parse(context, text, pos);\n        if (pos < 0) {\n            position.setErrorIndex(~pos);  // index not updated from input\n            return null;\n        }\n        position.setIndex(pos);  // errorIndex not updated from input\n        return context.toParsed();\n    }\n\n    /**\n     * Returns the formatter as a composite printer parser.\n     *\n     * @param {boolean} optional  whether the printer/parser should be optional\n     * @return {CompositePrinterParser} the printer/parser, not null\n     */\n    toPrinterParser(optional) {\n        return this._printerParser.withOptional(optional);\n    }\n\n    toString() {\n        const pattern = this._printerParser.toString();\n        return pattern.indexOf('[') === 0 ? pattern : pattern.substring(1, pattern.length - 1);\n    }\n\n}\n\nexport function _init() {\n\n    DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendLiteral('-')\n        .appendValue(ChronoField.MONTH_OF_YEAR, 2)\n        .appendLiteral('-')\n        .appendValue(ChronoField.DAY_OF_MONTH, 2)\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.HOUR_OF_DAY, 2)\n        .appendLiteral(':')\n        .appendValue(ChronoField.MINUTE_OF_HOUR, 2)\n        .optionalStart()\n        .appendLiteral(':')\n        .appendValue(ChronoField.SECOND_OF_MINUTE, 2)\n        .optionalStart()\n        .appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true)\n        .toFormatter(ResolverStyle.STRICT);\n\n    DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_DATE)\n        .appendLiteral('T')\n        .append(DateTimeFormatter.ISO_LOCAL_TIME)\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .appendInstant()\n        .toFormatter(ResolverStyle.STRICT);\n\n    DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_DATE_TIME)\n        .appendOffsetId()\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder()\n        .append(DateTimeFormatter.ISO_OFFSET_DATE_TIME)\n        .optionalStart()\n        .appendLiteral('[')\n        .parseCaseSensitive()\n        .appendZoneId()\n        // .appendZoneRegionId()\n        .appendLiteral(']')\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery('PARSED_EXCESS_DAYS', (temporal) => {\n        if (temporal instanceof DateTimeBuilder) {\n            return temporal.excessDays;\n        } else {\n            return Period.ZERO;\n        }\n    });\n\n    DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery('PARSED_LEAP_SECOND', (temporal) => {\n        if (temporal instanceof DateTimeBuilder) {\n            return temporal.leapSecond;\n        } else {\n            return false;\n        }\n    });\n\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/DateTimeFormatter.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {MathUtil} from './MathUtil';\nimport {requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException, ArithmeticException, DateTimeParseException} from './errors';\n\nimport {IsoChronology} from './chrono/IsoChronology';\n\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {TemporalAmount} from './temporal/TemporalAmount';\n\nimport {LocalDate} from './LocalDate';\n\n/**\n * The pattern for parsing.\n */\nconst PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;\n\n/**\n * A date-based amount of time, such as '2 years, 3 months and 4 days'.\n *\n * This class models a quantity or amount of time in terms of years, months and days.\n * See {@link Duration} for the time-based equivalent to this class.\n *\n * Durations and period differ in their treatment of daylight savings time\n * when added to {@link ZonedDateTime}. A {@link Duration} will add an exact\n * number of seconds, thus a duration of one day is always exactly 24 hours.\n * By contrast, a {@link Period} will add a conceptual day, trying to maintain\n * the local time.\n *\n * For example, consider adding a period of one day and a duration of one day to\n * 18:00 on the evening before a daylight savings gap. The {@link Period} will add\n * the conceptual day and result in a {@link ZonedDateTime} at 18:00 the following day.\n * By contrast, the {@link Duration} will add exactly 24 hours, resulting in a\n * {@link ZonedDateTime} at 19:00 the following day (assuming a one hour DST gap).\n *\n * The supported units of a period are {@link ChronoUnit#YEARS},\n * {@link ChronoUnit#MONTHS} and {@link ChronoUnit#DAYS}.\n * All three fields are always present, but may be set to zero.\n *\n * The period may be used with any calendar system.\n * The meaning of a 'year' or 'month' is only applied when the object is added to a date.\n *\n * The period is modeled as a directed amount of time, meaning that individual parts of the\n * period may be negative.\n *\n * The months and years fields may be normalized (see {@link normalized}).\n * The normalization assumes a 12 month year, so is not appropriate for all calendar systems.\n *\n * ### Static properties of Class {@link Period}\n *\n * Period.ZERO\n *\n * A constant for a period of zero.\n *\n */\nexport class Period extends TemporalAmount /* extends ChronoPeriod */ {\n\n    /**\n     * do not call the constructor directly\n     * use a factory method instead\n     *\n     * @param {number} years\n     * @param {number} months\n     * @param {number} days\n     * @private\n     */\n    constructor(years, months, days){\n        super();\n        if((years | months | days) === 0){\n            return Period.ZERO;\n        }\n        Period._validate(years, months, days);\n        /**\n         * The number of years.\n         */\n        this._years = MathUtil.safeToInt(years);\n        /**\n         * The number of months.\n         */\n        this._months =  MathUtil.safeToInt(months);\n        /**\n         * The number of days.\n         */\n        this._days = MathUtil.safeToInt(days);\n    }\n\n    static _validate(years, month, days){\n        requireNonNull(years, 'years');\n        requireNonNull(month, 'month');\n        requireNonNull(days, 'days');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} representing a number of years.\n     *\n     * The resulting period will have the specified years.\n     * The months and days units will be zero.\n     *\n     * @param {number} years - the number of years, positive or negative\n     * @return {Period} the period of years, not null\n     */\n    static ofYears(years) {\n        return Period.create(years, 0, 0);\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of months.\n     *\n     * The resulting period will have the specified months.\n     * The years and days units will be zero.\n     *\n     * @param {number} months - the number of months, positive or negative\n     * @return {Period} the period of months, not null\n     */\n    static ofMonths(months) {\n        return Period.create(0, months, 0);\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of weeks.\n     *\n     * The resulting period will have days equal to the weeks multiplied by seven.\n     * The years and months units will be zero.\n     *\n     * @param {number} weeks - the number of weeks, positive or negative\n     * @return {Period} the period of days, not null\n     */\n    static ofWeeks(weeks) {\n        return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of days.\n     *\n     * The resulting period will have the specified days.\n     * The years and months units will be zero.\n     *\n     * @param {number} days - the number of days, positive or negative\n     * @return {Period} the period of days, not null\n     */\n    static ofDays(days) {\n        return Period.create(0, 0, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} representing a number of years, months and days.\n     *\n     * This creates an instance based on years, months and days.\n     *\n     * @param {!number} years - the amount of years, may be negative\n     * @param {!number} months - the amount of months, may be negative\n     * @param {!number} days - the amount of days, may be negative\n     * @return {Period} the period of years, months and days, not null\n     */\n    static of(years, months, days) {\n        return Period.create(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Period} from a temporal amount.\n     *\n     * This obtains a period based on the specified amount.\n     * A {@link TemporalAmount} represents an - amount of time, which may be\n     * date-based or time-based, which this factory extracts to a {@link Period}.\n     *\n     * The conversion loops around the set of units from the amount and uses\n     * the {@link ChronoUnit#YEARS}, {@link ChronoUnit#MONTHS}\n     * and {@link ChronoUnit#DAYS} units to create a period.\n     * If any other units are found then an exception is thrown.\n     *\n     * If the amount is a {@link ChronoPeriod} then it must use the ISO chronology.\n     *\n     * @param {TemporalAmount} amount - the temporal amount to convert, not null\n     * @return {Period} the equivalent period, not null\n     * @throws DateTimeException if unable to convert to a {@link Period}\n     * @throws ArithmeticException if the amount of years, months or days exceeds an int\n     */\n    static from(amount) {\n        if (amount instanceof Period) {\n            return amount;\n        }\n/*\n        if (amount instanceof ChronoPeriod) {\n            if (IsoChronology.INSTANCE !== amount.chronology()) {\n                throw new DateTimeException('Period requires ISO chronology: ' + amount);\n            }\n        }\n*/\n        requireNonNull(amount, 'amount');\n        let years = 0;\n        let months = 0;\n        let days = 0;\n        const units = amount.units();\n        for (let i=0; i<units.length; i++) {\n            const unit = units[i];\n            const unitAmount = amount.get(unit);\n            if (unit === ChronoUnit.YEARS) {\n                years = MathUtil.safeToInt(unitAmount);\n            } else if (unit === ChronoUnit.MONTHS) {\n                months = MathUtil.safeToInt(unitAmount);\n            } else if (unit === ChronoUnit.DAYS) {\n                days = MathUtil.safeToInt(unitAmount);\n            } else {\n                throw new DateTimeException('Unit must be Years, Months or Days, but was ' + unit);\n            }\n        }\n        return Period.create(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} consisting of the number of years, months,\n     * and days between two dates.\n     *\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then split into years and months based on a 12 month year.\n     * A month is considered if the end day-of-month is greater than or equal to the start day-of-month.\n     * For example, from `2010-01-15` to `2011-03-18` is one year, two months and three days.\n     *\n     * The result of this method can be a negative period if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n\n     * see {@link ChronoLocalDate.until}\n     *\n     * @param {LocalDate} startDate - the start date, inclusive, not null\n     * @param {LocalDate} endDate - the end date, exclusive, not null\n     * @return {Period} the period between this date and the end date, not null\n     */\n    static between(startDate, endDate) {\n        requireNonNull(startDate, 'startDate');\n        requireNonNull(endDate, 'endDate');\n        requireInstance(startDate, LocalDate, 'startDate');\n        requireInstance(endDate, LocalDate, 'endDate');\n        return startDate.until(endDate);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} from a text string such as {@link PnYnMnD}.\n     *\n     * This will parse the string produced by {@link toString} which is\n     * based on the ISO-8601 period formats {@link PnYnMnD} and {@link PnW}.\n     *\n     * The string starts with an optional sign, denoted by the ASCII negative\n     * or positive symbol. If negative, the whole period is negated.\n     * The ASCII letter 'P' is next in upper or lower case.\n     * There are then four sections, each consisting of a number and a suffix.\n     * At least one of the four sections must be present.\n     * The sections have suffixes in ASCII of 'Y', 'M', 'W' and 'D' for\n     * years, months, weeks and days, accepted in upper or lower case.\n     * The suffixes must occur in order.\n     * The number part of each section must consist of ASCII digits.\n     * The number may be prefixed by the ASCII negative or positive symbol.\n     * The number must parse to an `int`.\n     *\n     * The leading plus/minus sign, and negative values for other units are\n     * not part of the ISO-8601 standard. In addition, ISO-8601 does not\n     * permit mixing between the {@link PnYnMnD} and {@link PnW} formats.\n     * Any week-based input is multiplied by 7 and treated as a number of days.\n     *\n     * For example, the following are valid inputs:\n     * <pre>\n     *   'P2Y'             -- Period.ofYears(2)\n     *   'P3M'             -- Period.ofMonths(3)\n     *   'P4W'             -- Period.ofWeeks(4)\n     *   'P5D'             -- Period.ofDays(5)\n     *   'P1Y2M3D'         -- Period.of(1, 2, 3)\n     *   'P1Y2M3W4D'       -- Period.of(1, 2, 25)\n     *   'P-1Y2M'          -- Period.of(-1, 2, 0)\n     *   '-P1Y2M'          -- Period.of(-1, -2, 0)\n     * </pre>\n     *\n     * @param {string} text - the text to parse, not null\n     * @return {Period} the parsed period, not null\n     * @throws DateTimeParseException if the text cannot be parsed to a period\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        try {\n            return Period._parse(text);\n        } catch (ex){\n            if(ex instanceof ArithmeticException){\n                throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0, ex);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    /**\n     * because functions that containing a try/ catch block cant be optimized,\n     * we put the code in a sub function.\n     */\n    static _parse(text){\n        const matches = PATTERN.exec(text);\n        if (matches != null) {\n            const negate = '-' === matches[1] ? -1 : 1;\n            const yearMatch = matches[2];\n            const monthMatch = matches[3];\n            const weekMatch = matches[4];\n            const dayMatch = matches[5];\n            if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {\n                const years = Period._parseNumber(text, yearMatch, negate);\n                const months = Period._parseNumber(text, monthMatch, negate);\n                const weeks = Period._parseNumber(text, weekMatch, negate);\n                let days = Period._parseNumber(text, dayMatch, negate);\n                days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));\n                return Period.create(years, months, days);\n            }\n        }\n        throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0);\n    }\n\n    static _parseNumber(text, str, negate) {\n        if (str == null) {\n            return 0;\n        }\n        const val = MathUtil.parseInt(str);\n        return MathUtil.safeMultiply(val, negate);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates an instance.\n     *\n     * @param {number} years - the amount\n     * @param {number} months - the amount\n     * @param {number} days - the amount\n     * @return {Duration}\n     */\n    static create(years, months, days) {\n        return new Period(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the list of units, from largest to smallest, that fully define this amount.\n     *\n     * @returns {ChronoUnit[]} list of units\n     */\n    units() {\n        return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];\n    }\n\n    /**\n     * Gets the chronology that defines the meaning of the supported units.\n     *\n     * The period is defined by the chronology.\n     * It controls the supported units and restricts addition/subtraction\n     * to {@link ChronoLocalDate} instances of the same chronology.\n     *\n     * @return {IsoChronology} the chronology defining the period, not null\n     */\n    chronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     * Gets the value of the requested unit.\n     *\n     * The supported units are chronology specific.\n     * They will typically be {@link ChronoUnit#YEARS},\n     * {@link ChronoUnit#MONTHS} and {@link ChronoUnit#DAYS}.\n     * Requesting an unsupported unit will throw an exception.\n     *\n     * @param {TemporalUnit} unit the {@link TemporalUnit} for which to return the value\n     * @return {number} the long value of the unit\n     * @throws DateTimeException if the unit is not supported\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    get(unit) {\n        if (unit === ChronoUnit.YEARS) {\n            return this._years;\n        }\n        if (unit === ChronoUnit.MONTHS) {\n            return this._months;\n        }\n        if (unit === ChronoUnit.DAYS) {\n            return this._days;\n        }\n        throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if all three units of this period are zero.\n     *\n     * A zero period has the value zero for the years, months and days units.\n     *\n     * @return {boolean} true if this period is zero-length\n     */\n    isZero() {\n        return (this === Period.ZERO);\n    }\n\n    /**\n     * Checks if any of the three units of this period are negative.\n     *\n     * This checks whether the years, months or days units are less than zero.\n     *\n     * @return {boolean} true if any unit of this period is negative\n     */\n    isNegative() {\n        return this._years < 0 || this._months < 0 || this._days < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the amount of years of this period.\n     *\n     * This returns the years unit.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * @return {number} the amount of years of this period, may be negative\n     */\n    years() {\n        return this._years;\n    }\n\n    /**\n     * Gets the amount of months of this period.\n     *\n     * This returns the months unit.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * @return {number} the amount of months of this period, may be negative\n     */\n    months() {\n        return this._months;\n    }\n\n    /**\n     * Gets the amount of days of this period.\n     *\n     * This returns the days unit.\n     *\n     * @return {number} the amount of days of this period, may be negative\n     */\n    days() {\n        return this._days;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount of years.\n     *\n     * This sets the amount of the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested years, not null\n     */\n    withYears(years) {\n        if (years === this._years) {\n            return this;\n        }\n        return Period.create(years, this._months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified amount of months.\n     *\n     * This sets the amount of the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested months, not null\n     */\n    withMonths(months) {\n        if (months === this._months) {\n            return this;\n        }\n        return Period.create(this._years, months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified amount of days.\n     *\n     * This sets the amount of the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested days, not null\n     */\n    withDays(days) {\n        if (days === this._days) {\n            return this;\n        }\n        return Period.create(this._years, this._months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount added.\n     *\n     * This input amount is converted to a {@link Period} using {@link from}.\n     * This operates separately on the years, months and days.\n     *\n     * For example, '1 year, 6 months and 3 days' plus '2 years, 2 months and 2 days'\n     * returns '3 years, 8 months and 5 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amountToAdd - the period to add, not null\n     * @return {Period} a {@link Period} based on this period with the requested period added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plus(amountToAdd) {\n        const amount = Period.from(amountToAdd);\n        return Period.create(\n            MathUtil.safeAdd(this._years, amount._years),\n            MathUtil.safeAdd(this._months, amount._months),\n            MathUtil.safeAdd(this._days, amount._days));\n    }\n\n    /**\n     * Returns a copy of this period with the specified years added.\n     *\n     * This adds the amount to the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 years returns '3 years, 6 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToAdd - the years to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified years added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified months added.\n     *\n     * This adds the amount to the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 months returns '1 year, 8 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToAdd - the months to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified months added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified days added.\n     *\n     * This adds the amount to the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 days returns '1 year, 6 months and 5 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} daysToAdd - the days to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified days added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDays(daysToAdd) {\n        if (daysToAdd === 0) {\n            return this;\n        }\n        return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount subtracted.\n     *\n     * This input amount is converted to a {@link Period} using {@link from}.\n     * This operates separately on the years, months and days.\n     *\n     * For example, '1 year, 6 months and 3 days' minus '2 years, 2 months and 2 days'\n     * returns '-1 years, 4 months and 1 day'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amountToSubtract - the period to subtract, not null\n     * @return {Period} a {@link Period} based on this period with the requested period subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minus(amountToSubtract) {\n        const amount = Period.from(amountToSubtract);\n        return Period.create(\n                MathUtil.safeSubtract(this._years, amount._years),\n                MathUtil.safeSubtract(this._months, amount._months),\n                MathUtil.safeSubtract(this._days, amount._days));\n    }\n\n    /**\n     * Returns a copy of this period with the specified years subtracted.\n     *\n     * This subtracts the amount from the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 years returns '-1 years, 6 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToSubtract - the years to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified years subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusYears(yearsToSubtract) {\n        return this.plusYears(-1 * yearsToSubtract);\n    }\n\n    /**\n     * Returns a copy of this period with the specified months subtracted.\n     *\n     * This subtracts the amount from the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 months returns '1 year, 4 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToSubtract - the years to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified months subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMonths(monthsToSubtract) {\n        return this.plusMonths(-1 * monthsToSubtract);\n    }\n\n    /**\n     * Returns a copy of this period with the specified days subtracted.\n     *\n     * This subtracts the amount from the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 days returns '1 year, 6 months and 1 day'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} daysToSubtract - the months to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified days subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDays(daysToSubtract) {\n        return this.plusDays(-1 * daysToSubtract);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new instance with each element in this period multiplied\n     * by the specified scalar.\n     *\n     * This simply multiplies each field, years, months, days and normalized time,\n     * by the scalar. No normalization is performed.\n     *\n     * @param {number} scalar - the scalar to multiply by, not null\n     * @return {Period} a {@link Period} based on this period with the amounts multiplied by the scalar, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    multipliedBy(scalar) {\n        if (this === Period.ZERO || scalar === 1) {\n            return this;\n        }\n        return Period.create(\n                MathUtil.safeMultiply(this._years, scalar),\n                MathUtil.safeMultiply(this._months, scalar),\n                MathUtil.safeMultiply(this._days, scalar));\n    }\n\n    /**\n     * Returns a new instance with each amount in this period negated.\n     *\n     * @return {Period} a {@link Period} based on this period with the amounts negated, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    negated() {\n        return this.multipliedBy(-1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the years and months normalized\n     * using a 12 month year.\n     *\n     * This normalizes the years and months units, leaving the days unit unchanged.\n     * The months unit is adjusted to have an absolute value less than 11,\n     * with the years unit being adjusted to compensate. For example, a period of\n     * '1 Year and 15 months' will be normalized to '2 years and 3 months'.\n     *\n     * The sign of the years and months units will be the same after normalization.\n     * For example, a period of '1 year and -25 months' will be normalized to\n     * '-1 year and -1 month'.\n     *\n     * This normalization uses a 12 month year which is not valid for all calendar systems.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Period} a {@link Period} based on this period with excess months normalized to years, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    normalized() {\n        const totalMonths = this.toTotalMonths();\n        const splitYears = MathUtil.intDiv(totalMonths, 12);\n        const splitMonths = MathUtil.intMod(totalMonths, 12);  // no overflow\n        if (splitYears === this._years && splitMonths === this._months) {\n            return this;\n        }\n        return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);\n    }\n\n    /**\n     * Gets the total number of months in this period using a 12 month year.\n     *\n     * This returns the total number of months in the period by multiplying the\n     * number of years by 12 and adding the number of months.\n     *\n     * This uses a 12 month year which is not valid for all calendar systems.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the total number of months in the period, may be negative\n     */\n    toTotalMonths() {\n        return this._years * 12 + this._months;  // no overflow\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Adds this period to the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this period added.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#plus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisPeriod.addTo(dateTime);\n     *   dateTime = dateTime.plus(thisPeriod);\n     * </pre>\n     *\n     * The calculation will add the years, then months, then days.\n     * Only non-zero amounts will be added.\n     * If the date-time has a calendar system with a fixed number of months in a\n     * year, then the years and months will be combined before being added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    addTo(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._years !== 0) {\n            if (this._months !== 0) {\n                temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);\n            } else {\n                temporal = temporal.plus(this._years, ChronoUnit.YEARS);\n            }\n        } else if (this._months !== 0) {\n            temporal = temporal.plus(this._months, ChronoUnit.MONTHS);\n        }\n        if (this._days !== 0) {\n            temporal = temporal.plus(this._days, ChronoUnit.DAYS);\n        }\n        return temporal;\n    }\n\n    /**\n     * Subtracts this period from the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this period subtracted.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#minus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisPeriod.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(thisPeriod);\n     * </pre>\n     *\n     * The calculation operates as follows.\n     * First, the chronology of the temporal is checked to ensure it is ISO chronology or null.\n     * Second, if the months are zero, the years are added if non-zero, otherwise\n     * the combination of years and months is added if non-zero.\n     * Finally, any days are added.\n     *\n     * The calculation will subtract the years, then months, then days.\n     * Only non-zero amounts will be subtracted.\n     * If the date-time has a calendar system with a fixed number of months in a\n     * year, then the years and months will be combined before being subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    subtractFrom(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._years !== 0) {\n            if (this._months !== 0) {\n                temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);\n            } else {\n                temporal = temporal.minus(this._years, ChronoUnit.YEARS);\n            }\n        } else if (this._months !== 0) {\n            temporal = temporal.minus(this._months, ChronoUnit.MONTHS);\n        }\n        if (this._days !== 0) {\n            temporal = temporal.minus(this._days, ChronoUnit.DAYS);\n        }\n        return temporal;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this period is equal to another period.\n     *\n     * The comparison is based on the amounts held in the period.\n     * To be equal, the years, months and days units must be individually equal.\n     * Note that this means that a period of '15 Months' is not equal to a period\n     * of '1 Year and 3 Months'.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other period\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof Period) {\n            const other = obj;\n            return this._years === other._years &&\n                this._months === other._months &&\n                this._days === other._days;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this period.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._years + (this._months << 8) + (this._days << 16);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this period as a string, such as {@link P6Y3M1D}.\n     *\n     * The output will be in the ISO-8601 period format.\n     * A zero period will be represented as zero days, 'P0D'.\n     *\n     * @return {string} a string representation of this period, not null\n     */\n    toString() {\n        if (this === Period.ZERO) {\n            return 'P0D';\n        } else {\n            let buf = 'P';\n            if (this._years !== 0) {\n                buf += '' + this._years + 'Y';\n            }\n            if (this._months !== 0) {\n                buf += '' + this._months + 'M';\n            }\n            if (this._days !== 0) {\n                buf += '' + this._days + 'D';\n            }\n            return buf;\n        }\n    }\n\n    /**\n     *\n     * @return {string} same as {@link Period.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n\nexport function _init() {\n    /**\n     * A constant for a period of zero.\n     */\n    Period.ZERO = makeZeroPeriod();\n\n    function makeZeroPeriod() {\n        const zero = Object.create(Period.prototype);\n        TemporalAmount.call(zero);\n        zero._years = 0;\n        zero._months = 0;\n        zero._days = 0;\n        return zero;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Period.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nexport class ParsePosition {\n    constructor(index) {\n        this._index = index;\n        this._errorIndex = -1;\n    }\n\n    getIndex(){\n        return this._index;\n    }\n\n    setIndex(index){\n        this._index = index;\n    }\n\n    getErrorIndex(){\n        return this._errorIndex;\n    }\n\n    setErrorIndex(errorIndex){\n        this._errorIndex = errorIndex;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/ParsePosition.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {DateTimeException} from '../errors';\nimport {MathUtil} from '../MathUtil';\n\nimport {EnumMap} from './EnumMap';\nimport {ResolverStyle} from './ResolverStyle';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\nimport {ChronoLocalDate} from '../chrono/ChronoLocalDate';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\nimport {LocalTime} from '../LocalTime';\nimport {LocalDate} from '../LocalDate';\nimport {Period} from '../Period';\n\n//import {ZoneOffset} from '../ZoneOffset';\n\n/**\n * Builder that can holds date and time fields and related date and time objects.\n *\n * The builder is used to hold onto different elements of date and time.\n * It is designed as two separate maps:\n *\n * * from {@link TemporalField} to `long` value, where the value may be\n *   outside the valid range for the field\n * * from {@link Class} to {@link TemporalAccessor}, holding larger scale objects\n *   like {@link LocalDateTime}.\n */\nexport class DateTimeBuilder extends Temporal {\n\n    /**\n     * Creates a new instance of the builder with a single field-value.\n     *\n     * This is equivalent to using {@link addFieldValue} on an empty builder.\n     *\n     * @param {TemporalField} field - the field to add, not null\n     * @param {number} value - the value to add, not null\n     * @return {DateTimeBuilder}\n     */\n    static create(field, value) {\n        const dtb = new DateTimeBuilder();\n        dtb._addFieldValue(field, value);\n        return dtb;\n    }\n\n\n    constructor(){\n        super();\n\n        /**\n         * The map of other fields.\n         */\n        this.fieldValues = new EnumMap();\n        /**\n         * The chronology.\n         */\n        this.chrono = null;\n        /**\n         * The zone.\n         */\n        this.zone = null;\n        /**\n         * The date.\n         */\n        this.date = null;\n        /**\n         * The time.\n         */\n        this.time = null;\n        /**\n         * The leap second flag.\n         */\n        this.leapSecond = false;\n        /**\n         * The excess days.\n         */\n        this.excessDays = null;\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @return {Number} field value\n     */\n    getFieldValue0(field) {\n        return this.fieldValues.get(field);\n    }\n\n    /**\n     * Adds a field-value pair to the builder.\n     *\n     * This adds a field to the builder.\n     * If the field is not already present, then the field-value pair is added to the map.\n     * If the field is already present and it has the same value as that specified, no action occurs.\n     * If the field is already present and it has a different value to that specified, then\n     * an exception is thrown.\n     *\n     * @param {TemporalField} field - the field to add, not null\n     * @param {Number} value - the value to add, not null\n     * @return {DateTimeBuilder}, this for method chaining\n     * @throws DateTimeException if the field is already present with a different value\n     */\n    _addFieldValue(field, value) {\n        requireNonNull(field, 'field');\n        const old = this.getFieldValue0(field);  // check first for better error message\n        if (old != null && old !== value) {\n            throw new DateTimeException('Conflict found: ' + field + ' ' + old + ' differs from ' + field + ' ' + value + ': ' + this);\n        }\n        return this._putFieldValue0(field, value);\n    }\n\n    /**\n     * @param {TemporalField} field\n     * @param {Number} value\n     * @return {DateTimeBuilder}, this for method chaining\n     */\n    _putFieldValue0(field, value) {\n        this.fieldValues.put(field, value);\n        return this;\n    }\n\n    /**\n     * Resolves the builder, evaluating the date and time.\n     *\n     * This examines the contents of the build.er and resolves it to produce the best\n     * available date and time, throwing an exception if a problem occurs.\n     * Calling this method changes the state of the builder.\n     *\n     * @param {ResolverStyle} resolverStyle - how to resolve\n     * @param {TemporalField[]} resolverFields\n     * @return {DateTimeBuilder} this, for method chaining\n     */\n    resolve(resolverStyle, resolverFields) {\n        if (resolverFields != null) {\n            this.fieldValues.retainAll(resolverFields);\n        }\n        // handle standard fields\n        // this._mergeInstantFields();\n        this._mergeDate(resolverStyle);\n        this._mergeTime(resolverStyle);\n        //if (resolveFields(resolverStyle)) {\n        //    mergeInstantFields();\n        //    mergeDate(resolverStyle);\n        //    mergeTime(resolverStyle);\n        //}\n        this._resolveTimeInferZeroes(resolverStyle);\n        //this._crossCheck();\n        if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {\n            this.date = this.date.plus(this.excessDays);\n            this.excessDays = Period.ZERO;\n        }\n        //resolveFractional();\n        //resolveInstant();\n        return this;\n    }\n\n    /**\n     *\n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _mergeDate(resolverStyle) {\n        //if (this.chrono instanceof IsoChronology) {\n        this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));\n        //} else {\n        //    if (this.fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n        //        this._checkDate(LocalDate.ofEpochDay(this.fieldValues.remove(ChronoField.EPOCH_DAY)));\n        //        return;\n        //    }\n        //}\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @private\n     */\n    _checkDate(date) {\n        if (date != null) {\n            this._addObject(date);\n            for (let fieldName in this.fieldValues.keySet()) {\n                let field = ChronoField.byName(fieldName);\n                if (field !== null) {\n                    if (this.fieldValues.get(field) !== undefined) { // undefined if \"removed\" in EnumMap\n                        if (field.isDateBased()) {\n                            let val1;\n                            try {\n                                val1 = date.getLong(field);\n                            } catch (ex) {\n                                if (ex instanceof DateTimeException) {\n                                    continue;\n                                } else {\n                                    throw ex;\n                                }\n                            }\n                            const val2 = this.fieldValues.get(field);\n                            if (val1 !== val2) {\n                                throw new DateTimeException('Conflict found: Field ' + field + ' ' + val1 + ' differs from ' + field + ' ' + val2 + ' derived from ' + date);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _mergeTime(resolverStyle) {\n        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {\n            const ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                if (resolverStyle === ResolverStyle.SMART && ch === 0) {\n                    // ok\n                } else {\n                    ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);\n                }\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);\n        }\n        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {\n            const ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                if (resolverStyle === ResolverStyle.SMART && ch === 0) {\n                    // ok\n                } else {\n                    ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(ch);\n                }\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_AMPM, ch === 12 ? 0 : ch);\n        }\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {\n                ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));\n            }\n            if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n                ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));\n            }\n        }\n        if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n            const ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);\n            const hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);\n        }\n//        if (timeFields.containsKey(HOUR_OF_DAY) && timeFields.containsKey(MINUTE_OF_HOUR)) {\n//            const hod = timeFields.remove(HOUR_OF_DAY);\n//            const moh = timeFields.remove(MINUTE_OF_HOUR);\n//            this._addFieldValue(MINUTE_OF_DAY, hod * 60 + moh);\n//        }\n//        if (timeFields.containsKey(MINUTE_OF_DAY) && timeFields.containsKey(SECOND_OF_MINUTE)) {\n//            const mod = timeFields.remove(MINUTE_OF_DAY);\n//            const som = timeFields.remove(SECOND_OF_MINUTE);\n//            this._addFieldValue(SECOND_OF_DAY, mod * 60 + som);\n//        }\n        if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {\n            const nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.NANO_OF_DAY.checkValidValue(nod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));\n            this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {\n            const cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MICRO_OF_DAY.checkValidValue(cod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));\n            this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {\n            const lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MILLI_OF_DAY.checkValidValue(lod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));\n            this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {\n            const sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.SECOND_OF_DAY.checkValidValue(sod);\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n            this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {\n            const mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MINUTE_OF_DAY.checkValidValue(mod);\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));\n            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));\n        }\n\n//            const sod = MathUtil.intDiv(nod, 1000000000L);\n//            this._addFieldValue(HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n//            this._addFieldValue(MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n//            this._addFieldValue(SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n//            this._addFieldValue(NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000L));\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n                ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));\n            }\n            if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n                ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));\n            }\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n            const los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n            const cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1000 + (MathUtil.intMod(cos, 1000)));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n            const nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));\n            this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n            const nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(nos, 1000000));\n            this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n            const cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n            this._putFieldValue0(ChronoField.NANO_OF_SECOND, cos * 1000);\n        } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n            const los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n            this._putFieldValue0(ChronoField.NANO_OF_SECOND, los * 1000000);\n        }\n    }\n\n    /**\n     *\n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _resolveTimeInferZeroes(resolverStyle) {\n        let hod =  this.fieldValues.get(ChronoField.HOUR_OF_DAY);\n        const moh =  this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);\n        const som =  this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);\n        let nos =  this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n        if (hod == null) {\n            return;\n        }\n        if (moh == null && (som != null || nos != null)) {\n            return;\n        }\n        if (moh != null && som == null && nos != null) {\n            return;\n        }\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (hod != null) {\n                if (resolverStyle === ResolverStyle.SMART &&\n                                hod === 24 &&\n                                (moh == null || moh === 0) &&\n                                (som == null || som === 0) &&\n                                (nos == null || nos === 0)) {\n                    hod = 0;\n                    this.excessDays = Period.ofDays(1);\n                }\n                let hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);\n                if (moh != null) {\n                    let mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);\n                    if (som != null) {\n                        let somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);\n                        if (nos != null) {\n                            let nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);\n                            this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));\n                        } else {\n                            this._addObject(LocalTime.of(hodVal, mohVal, somVal));\n                        }\n                    } else {\n                        if (nos == null) {\n                            this._addObject(LocalTime.of(hodVal, mohVal));\n                        }\n                    }\n                } else {\n                    if (som == null && nos == null) {\n                        this._addObject(LocalTime.of(hodVal, 0));\n                    }\n                }\n            }\n        } else {\n            if (hod != null) {\n                let hodVal = hod;\n                if (moh != null) {\n                    if (som != null) {\n                        if (nos == null) {\n                            nos = 0;\n                        }\n                        let totalNanos = MathUtil.safeMultiply(hodVal, 3600000000000);\n                        totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));\n                        totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));\n                        totalNanos = MathUtil.safeAdd(totalNanos, nos);\n                        let excessDays =  MathUtil.floorDiv(totalNanos, 86400000000000);  // safe int cast\n                        let nod = MathUtil.floorMod(totalNanos, 86400000000000);\n                        this._addObject(LocalTime.ofNanoOfDay(nod));\n                        this.excessDays = Period.ofDays(excessDays);\n                    } else {\n                        let totalSecs = MathUtil.safeMultiply(hodVal, 3600);\n                        totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));\n                        let excessDays =  MathUtil.floorDiv(totalSecs, 86400);  // safe int cast\n                        let sod = MathUtil.floorMod(totalSecs, 86400);\n                        this._addObject(LocalTime.ofSecondOfDay(sod));\n                        this.excessDays = Period.ofDays(excessDays);\n                    }\n                } else {\n                    let excessDays = MathUtil.safeToInt(MathUtil.floorDiv(hodVal, 24));\n                    hodVal = MathUtil.floorMod(hodVal, 24);\n                    this._addObject(LocalTime.of(hodVal, 0));\n                    this.excessDays = Period.ofDays(excessDays);\n                }\n            }\n        }\n        this.fieldValues.remove(ChronoField.HOUR_OF_DAY);\n        this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);\n        this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);\n        this.fieldValues.remove(ChronoField.NANO_OF_SECOND);\n    }\n\n    /**\n     *\n     * @param {ChronoLocalDate|LocalTime} dateOrTime\n     * @private\n     */\n    _addObject(dateOrTime) {\n        if (dateOrTime instanceof ChronoLocalDate){\n            this.date = dateOrTime;\n        } else if (dateOrTime instanceof LocalTime){\n            this.time = dateOrTime;\n        }\n    }\n\n    /**\n     * Builds the specified type from the values in this builder.\n     *\n     * This attempts to build the specified type from this builder.\n     * If the builder cannot return the type, an exception is thrown.\n     *\n     * @param {!TemporalQuery} type - the type to invoke `from` on, not null\n     * @return {*} the extracted value, not null\n     * @throws DateTimeException if an error occurs\n     */\n    build(type) {\n        return type.queryFrom(this);\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {number}\n     */\n    isSupported(field) {\n        if (field == null) {\n            return false;\n        }\n        return (this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== undefined) ||\n                (this.date != null && this.date.isSupported(field)) ||\n                (this.time != null && this.time.isSupported(field));\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {number}\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        const value = this.getFieldValue0(field);\n        if (value == null) {\n            if (this.date != null && this.date.isSupported(field)) {\n                return this.date.getLong(field);\n            }\n            if (this.time != null && this.time.isSupported(field)) {\n                return this.time.getLong(field);\n            }\n            throw new DateTimeException('Field not found: ' + field);\n        }\n        return value;\n    }\n\n    /**\n     *\n     * @param {!TemporalQuery} query\n     * @returns {*}\n     */\n    query(query) {\n        if (query === TemporalQueries.zoneId()) {\n            return this.zone;\n        } else if (query === TemporalQueries.chronology()) {\n            return this.chrono;\n        } else if (query === TemporalQueries.localDate()) {\n            return this.date != null ? LocalDate.from(this.date) : null;\n        } else if (query === TemporalQueries.localTime()) {\n            return this.time;\n        } else if (query === TemporalQueries.zone() || query === TemporalQueries.offset()) {\n            return query.queryFrom(this);\n        } else if (query === TemporalQueries.precision()) {\n            return null;  // not a complete date/time\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/DateTimeBuilder.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport class EnumMap {\n    constructor(){\n        this._map = {};\n    }\n\n    putAll(otherMap){\n        for(let key in otherMap._map){\n            this._map[key] = otherMap._map[key];\n        }\n        return this;\n    }\n\n    containsKey(key){\n        return (this._map.hasOwnProperty(key.name())) && (this.get(key) !== undefined);\n    }\n\n    get(key) {\n        return this._map[key.name()];\n    }\n\n    put(key, val) {\n        return this.set(key, val);\n    }\n\n    set(key, val) {\n        this._map[key.name()] = val;\n        return this;\n    }\n\n    retainAll(keyList){\n        const map = {};\n        for(let i=0; i<keyList.length; i++){\n            let key = keyList[i].name();\n            map[key] = this._map[key];\n        }\n        this._map = map;\n        return this;\n    }\n\n    /**\n     * due to the bad performance of delete we just set the key entry to undefined.\n     *\n     * this might lead to issues with \"null\" entries. Calling clear in the end might solve the issue\n     * @param key\n     * @returns {*}\n     */\n    remove(key){\n        const keyName = key.name();\n        const val = this._map[keyName];\n        this._map[keyName] = undefined;\n        return val;\n    }\n\n    keySet(){\n        return this._map;\n    }\n\n    clear(){\n        this._map = {};\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/EnumMap.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {Enum} from '../Enum';\n\n/**\n * Enumeration of different ways to resolve dates and times.\n * \n * Parsing a text string occurs in two phases.\n * Phase 1 is a basic text parse according to the fields added to the builder.\n * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n * This style is used to control how phase 2, resolving, happens.\n *\n * ### Static properties of Class {@link DateTimeFormatter}\n *\n * ResolverStyle.STRICT = new ResolverStyle('STRICT');\n *\n * Style to resolve dates and times strictly.\n *\n * Using strict resolution will ensure that all parsed values are within\n * the outer range of valid values for the field. Individual fields may\n * be further processed for strictness.\n *\n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using strict mode will ensure that the day-of-month is valid\n * for the year-month, rejecting invalid values.\n *\n * ResolverStyle.SMART = new ResolverStyle('SMART');\n *\n * Style to resolve dates and times in a smart, or intelligent, manner.\n *\n * Using smart resolution will perform the sensible default for each\n * field, which may be the same as strict, the same as lenient, or a third\n * behavior. Individual fields will interpret this differently.\n *\n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using smart mode will ensure that the day-of-month is from\n * 1 to 31, converting any value beyond the last valid day-of-month to be\n * the last valid day-of-month.\n *\n * ResolverStyle.LENIENT = new ResolverStyle('LENIENT');\n *\n * Style to resolve dates and times leniently.\n *\n * Using lenient resolution will resolve the values in an appropriate\n * lenient manner. Individual fields will interpret this differently.\n *\n * For example, lenient mode allows the month in the ISO calendar system\n * to be outside the range 1 to 12.\n * For example, month 15 is treated as being 3 months after month 12.\n *\n */\nexport class ResolverStyle extends Enum {}\n\n/**\n * Style to resolve dates and times strictly.\n * \n * Using strict resolution will ensure that all parsed values are within\n * the outer range of valid values for the field. Individual fields may\n * be further processed for strictness.\n * \n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using strict mode will ensure that the day-of-month is valid\n * for the year-month, rejecting invalid values.\n */\nResolverStyle.STRICT = new ResolverStyle('STRICT');\n/**\n * Style to resolve dates and times in a smart, or intelligent, manner.\n * \n * Using smart resolution will perform the sensible default for each\n * field, which may be the same as strict, the same as lenient, or a third\n * behavior. Individual fields will interpret this differently.\n * \n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using smart mode will ensure that the day-of-month is from\n * 1 to 31, converting any value beyond the last valid day-of-month to be\n * the last valid day-of-month.\n */\nResolverStyle.SMART = new ResolverStyle('SMART');\n/**\n * Style to resolve dates and times leniently.\n * \n * Using lenient resolution will resolve the values in an appropriate\n * lenient manner. Individual fields will interpret this differently.\n * \n * For example, lenient mode allows the month in the ISO calendar system\n * to be outside the range 1 to 12.\n * For example, month 15 is treated as being 3 months after month 12.\n */\nResolverStyle.LENIENT = new ResolverStyle('LENIENT');\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/ResolverStyle.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull} from '../assert';\n\nimport {DateTimeBuilder} from './DateTimeBuilder';\nimport {EnumMap} from './EnumMap';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\nexport class DateTimeParseContext{\n\n    constructor(){\n        if(arguments.length === 1){\n            if(arguments[0] instanceof DateTimeParseContext){\n                this._constructorSelf.apply(this, arguments);\n                return;\n            } else {\n                this._constructorFormatter.apply(this, arguments);\n            }\n        } else {\n            this._constructorParam.apply(this, arguments);\n        }\n\n        this._caseSensitive = true;\n        this._strict = true;\n        this._parsed = [new Parsed(this)];\n    }\n\n    _constructorParam(locale, symbols, chronology){\n        this._locale = locale;\n        this._symbols = symbols;\n        this._overrideChronology = chronology;\n    }\n\n    _constructorFormatter(formatter){\n        this._locale = formatter.locale();\n        this._symbols = formatter.decimalStyle();\n        this._overrideChronology = formatter.chronology();\n    }\n\n\n    _constructorSelf(other) {\n        this._locale = other._locale;\n        this._symbols = other._symbols;\n        this._overrideChronology = other._overrideChronology;\n        this._overrideZone = other._overrideZone;\n        this._caseSensitive = other._caseSensitive;\n        this._strict = other._strict;\n        this._parsed = [new Parsed(this)];\n    }\n\n    /**\n     * Creates a copy of this context.\n     */\n    copy() {\n        return new DateTimeParseContext(this);\n    }\n\n    symbols(){\n        return this._symbols;\n    }\n\n    isStrict(){\n        return this._strict;\n    }\n\n    setStrict(strict){\n        this._strict = strict;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Starts the parsing of an optional segment of the input.\n     */\n    startOptional() {\n        this._parsed.push(this.currentParsed().copy());\n    }\n\n    /**\n     * Ends the parsing of an optional segment of the input.\n     *\n     * @param {boolean} successful  whether the optional segment was successfully parsed\n     */\n    endOptional(successful) {\n        if (successful) {\n            this._parsed.splice(this._parsed.length - 2, 1);\n        } else {\n            this._parsed.splice(this._parsed.length - 1, 1);\n        }\n    }\n\n    /**\n     * Checks if parsing is case sensitive.\n     *\n     * @return true if parsing is case sensitive, false if case insensitive\n     */\n    isCaseSensitive() {\n        return this._caseSensitive;\n    }\n\n    /**\n     * Sets whether the parsing is case sensitive or not.\n     *\n     * @param caseSensitive  changes the parsing to be case sensitive or not from now on\n     */\n    setCaseSensitive(caseSensitive) {\n        this._caseSensitive = caseSensitive;\n    }\n\n    /**\n     * Helper to compare two {@link CharSequence} instances.\n     * This uses {@link isCaseSensitive}.\n     *\n     * @param cs1  the first character sequence, not null\n     * @param offset1  the offset into the first sequence, valid\n     * @param cs2  the second character sequence, not null\n     * @param offset2  the offset into the second sequence, valid\n     * @param length  the length to check, valid\n     * @return true if equal\n     */\n    subSequenceEquals(cs1, offset1, cs2, offset2, length) {\n        if (offset1 + length > cs1.length || offset2 + length > cs2.length) {\n            return false;\n        }\n        if (! this.isCaseSensitive()) {\n            cs1 = cs1.toLowerCase();\n            cs2 = cs2.toLowerCase();\n        }\n        for (let i = 0; i < length; i++) {\n            let ch1 = cs1[offset1 + i];\n            let ch2 = cs2[offset2 + i];\n            if (ch1 !== ch2) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Helper to compare two `char`.\n     * This uses {@link isCaseSensitive}.\n     *\n     * @param ch1  the first character\n     * @param ch2  the second character\n     * @return true if equal\n     */\n    charEquals(ch1, ch2) {\n        if (this.isCaseSensitive()) {\n            return ch1 === ch2;\n        }\n        return this.charEqualsIgnoreCase(ch1, ch2);\n    }\n\n    /**\n     * Compares two characters ignoring case.\n     *\n     * @param c1  the first\n     * @param c2  the second\n     * @return true if equal\n     */\n    charEqualsIgnoreCase(c1, c2) {\n        return c1 === c2 ||\n                c1.toLowerCase() === c2.toLowerCase();\n    }\n\n    setParsedField(field, value, errorPos, successPos){\n        const currentParsedFieldValues = this.currentParsed().fieldValues;\n        const old = currentParsedFieldValues.get(field);\n        currentParsedFieldValues.set(field, value);\n        return (old != null && old !== value) ? ~errorPos : successPos;\n    }\n\n    /**\n     * Stores the parsed zone.\n     *\n     * This stores the zone that has been parsed.\n     * No validation is performed other than ensuring it is not null.\n     *\n     * @param {ZoneId} zone  the parsed zone, not null\n     */\n    setParsedZone(zone) {\n        requireNonNull(zone, 'zone');\n        this.currentParsed().zone = zone;\n    }\n\n    getParsed(field) {\n        return this.currentParsed().fieldValues.get(field);\n    }\n\n    toParsed() {\n        return this.currentParsed();\n    }\n\n    currentParsed() {\n        return this._parsed[this._parsed.length - 1];\n    }\n\n    /**\n     * Stores the leap second.\n     */\n    setParsedLeapSecond() {\n        this.currentParsed().leapSecond = true;\n    }\n\n    /**\n     * Gets the effective chronology during parsing.\n     *\n     * @return the effective parsing chronology, not null\n     */\n    getEffectiveChronology() {\n        let chrono = this.currentParsed().chrono;\n        if (chrono == null) {\n            chrono = this._overrideChronology;\n            if (chrono == null) {\n                chrono = IsoChronology.INSTANCE;\n            }\n        }\n        return chrono;\n    }\n\n\n}\n\nclass Parsed extends Temporal {\n    constructor(dateTimeParseContext){\n        super();\n        this.chrono = null;\n        this.zone = null;\n        this.fieldValues = new EnumMap();\n        this.leapSecond = false;\n        this.dateTimeParseContext = dateTimeParseContext;\n    }\n\n    copy() {\n        const cloned = new Parsed();\n        cloned.chrono = this.chrono;\n        cloned.zone = this.zone;\n        cloned.fieldValues.putAll(this.fieldValues);\n        cloned.leapSecond = this.leapSecond;\n        cloned.dateTimeParseContext = this.dateTimeParseContext;\n        return cloned;\n    }\n\n    toString() {\n        return `${this.fieldValues}, ${this.chrono}, ${this.zone}`;\n    }\n\n    isSupported(field) {\n        return this.fieldValues.containsKey(field);\n    }\n\n    get(field) {\n        const val = this.fieldValues.get(field);\n        assert(val != null);\n        return val;\n    }\n\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chrono;\n        }\n        if (query === TemporalQueries.zoneId() || query === TemporalQueries.zone()) {\n            return this.zone;\n        }\n        return super.query(query);\n    }\n\n    toBuilder() {\n        const builder = new DateTimeBuilder();\n        builder.fieldValues.putAll(this.fieldValues);\n        builder.chrono = this.dateTimeParseContext.getEffectiveChronology();\n        if (this.zone != null) {\n            builder.zone = this.zone;\n        } else {\n            builder.zone = this.overrideZone;\n        }\n        builder.leapSecond = this.leapSecond;\n        builder.excessDays = this.excessDays;\n        return builder;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/DateTimeParseContext.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {DateTimeException} from '../errors';\n\nimport {DateTimeFormatter} from './DateTimeFormatter';\n\nexport class DateTimePrintContext{\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @param {DateTimeFormatter|Locale} localeOrFormatter\n     * @param {DecimalStyle} symbols\n     */\n    constructor(temporal, localeOrFormatter, symbols) {\n        if(arguments.length === 2 && arguments[1] instanceof DateTimeFormatter){\n            this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);\n            this._locale = localeOrFormatter.locale();\n            this._symbols = localeOrFormatter.decimalStyle();\n        } else {\n            this._temporal = temporal;\n            this._locale = localeOrFormatter;\n            this._symbols = symbols;\n        }\n        this._optional = 0;\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @param {DateTimeFormatter} formatter\n     * @returns {TemporalAccessor}\n     */\n    // eslint-disable-next-line no-unused-vars\n    static adjust(temporal, formatter) {\n        // TODO implement\n        return temporal;\n    }\n\n\n    symbols(){\n        return this._symbols;\n    }\n\n    /**\n     * Starts the printing of an optional segment of the input.\n     */\n    startOptional() {\n        this._optional++;\n    }\n\n    /**\n     * Ends the printing of an optional segment of the input.\n     */\n    endOptional() {\n        this._optional--;\n    }\n\n    /**\n     * Gets a value using a query.\n     *\n     * @param {TemporalQuery} query  the query to use, not null\n     * @return {*} the result, null if not found and optional is true\n     * @throws DateTimeException if the type is not available and the section is not optional\n     */\n    getValueQuery(query) {\n        const result = this._temporal.query(query);\n        if (result == null && this._optional === 0) {\n            throw new DateTimeException('Unable to extract value: ' + this._temporal);\n        }\n        return result;\n    }\n\n    /**\n     * Gets the value of the specified field.\n     *\n     * This will return the value for the specified field.\n     *\n     * @param field  the field to find, not null\n     * @return the value, null if not found and optional is true\n     * @throws DateTimeException if the field is not available and the section is not optional\n     */\n    getValue(field) {\n        try {\n            return this._temporal.getLong(field);\n        } catch (ex) {\n            if ((ex instanceof DateTimeException) && this._optional > 0) {\n                return null;\n            }\n            throw ex;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the temporal object being output.\n     *\n     * @return {TemporalAccessor} the temporal object, not null\n     */\n    temporal() {\n        return this._temporal;\n    }\n\n    //-------------------------------------------------------------------------\n    // for testing\n    /**\n     * Sets the date-time being output.\n     *\n     * @param temporal  the date-time object, not null\n     */\n    setDateTime(temporal) {\n        this._temporal = temporal;\n    }\n\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/DateTimePrintContext.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {Enum} from '../Enum';\n\nexport class SignStyle extends Enum{\n    /**\n     * Parse helper.\n     *\n     * @param positive  true if positive sign parsed, false for negative sign\n     * @param strict  true if strict, false if lenient\n     * @param fixedWidth  true if fixed width, false if not\n     * @return true if valid\n     */\n    parse(positive, strict, fixedWidth){\n        switch (this) {\n            case SignStyle.NORMAL: // NORMAL\n                // valid if negative or (positive and lenient)\n                return !positive || !strict;\n            case SignStyle.ALWAYS: // ALWAYS\n            case SignStyle.EXCEEDS_PAD: // EXCEEDS_PAD\n                return true;\n            default:\n                // valid if lenient and not fixed width\n                return !strict && !fixedWidth;\n        }\n\n    }\n}\n\nSignStyle.NORMAL = new SignStyle('NORMAL');\nSignStyle.NEVER = new SignStyle('NEVER');\nSignStyle.ALWAYS = new SignStyle('ALWAYS');\nSignStyle.EXCEEDS_PAD = new SignStyle('EXCEEDS_PAD');\nSignStyle.NOT_NEGATIVE = new SignStyle('NOT_NEGATIVE');\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/SignStyle.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport class StringBuilder {\n    constructor(){\n        this._str = '';\n    }\n\n    append(str){\n        this._str += str;\n        return this;\n    }\n\n    appendChar(str){\n        this._str += str[0];\n        return this;\n    }\n\n    insert(offset, str){\n        this._str = this._str.slice(0, offset) + str + this._str.slice(offset);\n        return this;\n    }\n\n    replace(start, end, str){\n        this._str = this._str.slice(0, start) + str + this._str.slice(end);\n        return this;\n    }\n\n    length(){\n        return this._str.length;\n    }\n\n    setLength(length){\n        this._str = this._str.slice(0, length);\n        return this;\n    }\n\n\n    toString() {\n        return this._str;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/StringBuilder.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {UnsupportedTemporalTypeException, IllegalStateException} from '../errors';\n\nimport {DayOfWeek} from '../DayOfWeek';\nimport {Duration} from '../Duration';\nimport {MathUtil} from '../MathUtil';\nimport {LocalDate} from '../LocalDate';\n\nimport {ChronoField} from './ChronoField';\nimport {ChronoUnit} from './ChronoUnit';\nimport {TemporalField} from './TemporalField';\nimport {TemporalUnit} from './TemporalUnit';\nimport {ValueRange} from './ValueRange';\n\nimport {IsoChronology} from '../chrono/IsoChronology';\n\nimport {ResolverStyle} from '../format/ResolverStyle';\n\n/**\n * Fields and units specific to the ISO-8601 calendar system,\n * including quarter-of-year and week-based-year.\n *\n * This class defines fields and units that are specific to the ISO calendar system.\n *\n * ### Quarter of year\n *\n * The ISO-8601 standard is based on the standard civic 12 month year.\n * This is commonly divided into four quarters, often abbreviated as Q1, Q2, Q3 and Q4.\n *\n * January, February and March are in Q1.\n * April, May and June are in Q2.\n * July, August and September are in Q3.\n * October, November and December are in Q4.\n *\n * The complete date is expressed using three fields:\n *\n * * {@link DAY_OF_QUARTER} - the day within the quarter, from 1 to 90, 91 or 92\n * * {@link QUARTER_OF_YEAR} - the week within the week-based-year\n * * {@link ChronoField#YEAR} - the standard ISO year\n *\n * ### Week based years\n *\n * The ISO-8601 standard was originally intended as a data interchange format,\n * defining a string format for dates and times. However, it also defines an\n * alternate way of expressing the date, based on the concept of week-based-year.\n *\n * The date is expressed using three fields:\n *\n * * {@link ChronoField#DAY_OF_WEEK} - the standard field defining the\n *   day-of-week from Monday (1) to Sunday (7)\n * * {@link WEEK_OF_WEEK_BASED_YEAR} - the week within the week-based-year\n * * {@link WEEK_BASED_YEAR} - the week-based-year\n *\n * The week-based-year itself is defined relative to the standard ISO proleptic year.\n * It differs from the standard year in that it always starts on a Monday.\n *\n * The first week of a week-based-year is the first Monday-based week of the standard\n * ISO year that has at least 4 days in the new year.\n *\n * * If January 1st is Monday then week 1 starts on January 1st\n * * If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year\n * * If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year\n * * If January 1st is Thursday then week 1 starts on December 29th of the previous standard year\n * * If January 1st is Friday then week 1 starts on January 4th\n * * If January 1st is Saturday then week 1 starts on January 3rd\n * * If January 1st is Sunday then week 1 starts on January 2nd\n *\n * There are 52 weeks in most week-based years, however on occasion there are 53 weeks.\n *\n * For example:\n *\n * * Sunday, 2008-12-28: Week 52 of week-based-year 2008\n * * Monday, 2008-12-29: Week 1 of week-based-year 2009\n * * Wednesday, 2008-12-31: Week 1 of week-based-year 2009\n * * Thursday, 2009-01-01: Week 1 of week-based-year 2009\n * * Sunday, 2009-01-04: Week 1 of week-based-year 2009\n * * Monday, 2009-01-05: Week 2 of week-based-year 2009\n *\n * ### Static properties of Class {@link IsoFields}\n *\n * IsoFields.DAY_OF_QUARTER\n *\n * The field that represents the day-of-quarter.\n *\n * This field allows the day-of-quarter value to be queried and set.\n * The day-of-quarter has values from 1 to 90 in Q1 of a standard year, from 1 to 91\n * in Q1 of a leap year, from 1 to 91 in Q2 and from 1 to 92 in Q3 and Q4.\n *\n * The day-of-quarter can only be calculated if the day-of-year, month-of-year and year\n * are available.\n *\n * When setting this field, the value is allowed to be partially lenient, taking any\n * value from 1 to 92. If the quarter has less than 92 days, then day 92, and\n * potentially day 91, is in the following quarter.\n *\n * IsoFields.QUARTER_OF_YEAR\n *\n * The field that represents the quarter-of-year.\n *\n * This field allows the quarter-of-year value to be queried and set.\n * The quarter-of-year has values from 1 to 4.\n *\n * The day-of-quarter can only be calculated if the month-of-year is available.\n *\n * IsoFields.WEEK_OF_WEEK_BASED_YEAR\n *\n * The field that represents the week-of-week-based-year.\n *\n * This field allows the week of the week-based-year value to be queried and set.\n *\n * IsoFields.WEEK_BASED_YEAR\n *\n * The field that represents the week-based-year.\n *\n * This field allows the week-based-year value to be queried and set.\n *\n * IsoFields.WEEK_BASED_YEARS\n *\n * The unit that represents week-based-years for the purpose of addition and subtraction.\n *\n * This allows a number of week-based-years to be added to, or subtracted from, a date.\n * The unit is equal to either 52 or 53 weeks.\n * The estimated duration of a week-based-year is the same as that of a standard ISO\n * year at 365.2425 days.\n *\n * The rules for addition add the number of week-based-years to the existing value\n * for the week-based-year field. If the resulting week-based-year only has 52 weeks,\n * then the date will be in week 1 of the following week-based-year.\n *\n * IsoFields.QUARTER_YEARS\n *\n * Unit that represents the concept of a quarter-year.\n * For the ISO calendar system, it is equal to 3 months.\n * The estimated duration of a quarter-year is one quarter of 365.2425 days.\n */\nexport class IsoFields {\n}\n\n//-----------------------------------------------------------------------\n\nconst QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];\n\n/**\n * Implementation of the field.\n */\nclass Field extends TemporalField{\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDateBased() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isTimeBased() {\n        return false;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    _isIso() {\n        return true;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {ValueRange}\n     */\n    static _getWeekRangeByLocalDate(date) {\n        const wby = Field._getWeekBasedYear(date);\n        return ValueRange.of(1, Field._getWeekRangeByYear(wby));\n    }\n\n    /**\n     *\n     * @param {number} wby\n     * @returns {number}\n     */\n    static _getWeekRangeByYear(wby) {\n        const date = LocalDate.of(wby, 1, 1);\n        // 53 weeks if standard year starts on Thursday, or Wed in a leap year\n        if (date.dayOfWeek() === DayOfWeek.THURSDAY || (date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear())) {\n            return 53;\n        }\n        return 52;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {number}\n     */\n    static _getWeek(date) {\n        const dow0 = date.dayOfWeek().ordinal();\n        const doy0 = date.dayOfYear() - 1;\n        const doyThu0 = doy0 + (3 - dow0);  // adjust to mid-week Thursday (which is 3 indexed from zero)\n        const alignedWeek = MathUtil.intDiv(doyThu0, 7);\n        const firstThuDoy0 = doyThu0 - (alignedWeek * 7);\n        let firstMonDoy0 = firstThuDoy0 - 3;\n        if (firstMonDoy0 < -3) {\n            firstMonDoy0 += 7;\n        }\n        if (doy0 < firstMonDoy0) {\n            return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();\n        }\n        let week = MathUtil.intDiv((doy0 - firstMonDoy0), 7) + 1;\n        if (week === 53) {\n            if ((firstMonDoy0 === -3 || (firstMonDoy0 === -2 && date.isLeapYear())) === false) {\n                week = 1;\n            }\n        }\n        return week;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {number}\n     */\n    static _getWeekBasedYear(date) {\n        let year = date.year();\n        let doy = date.dayOfYear();\n        if (doy <= 3) {\n            let dow = date.dayOfWeek().ordinal();\n            if (doy - dow < -2) {\n                year--;\n            }\n        } else if (doy >= 363) {\n            let dow = date.dayOfWeek().ordinal();\n            doy = doy - 363 - (date.isLeapYear() ? 1 : 0);\n            if (doy - dow >= 0) {\n                year++;\n            }\n        }\n        return year;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    getDisplayName(/*locale*/) {\n        return this.toString();\n    }\n\n    /**\n     *\n     * @returns {null}\n     */\n    resolve() {\n        return null;\n    }\n\n    name(){\n        return this.toString();\n    }\n\n}\n\n\nclass DAY_OF_QUARTER_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'DayOfQuarter';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return ChronoUnit.DAYS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return QUARTER_YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 90, 92);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) &&\n            temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    rangeRefinedBy(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n        }\n        const qoy = temporal.getLong(QUARTER_OF_YEAR);\n        if (qoy === 1) {\n            const year = temporal.getLong(ChronoField.YEAR);\n            return (IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90));\n        } else if (qoy === 2) {\n            return ValueRange.of(1, 91);\n        } else if (qoy === 3 || qoy === 4) {\n            return ValueRange.of(1, 92);\n        } // else value not from 1 to 4, so drop through\n        return this.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n        }\n        const doy = temporal.get(ChronoField.DAY_OF_YEAR);\n        const moy = temporal.get(ChronoField.MONTH_OF_YEAR);\n        const year = temporal.getLong(ChronoField.YEAR);\n        return doy - QUARTER_DAYS[MathUtil.intDiv((moy - 1), 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        const curValue = this.getFrom(temporal);\n        this.range().checkValidValue(newValue, this);\n        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));\n    }\n\n    /**\n     *\n     * @param {Map<TemporalField, number>} fieldValues\n     * @param {TemporalAccessor} partialTemporal\n     * @param {ResolverStyle} resolverStyle\n     * @returns {ValueRange}\n     */\n    resolve(fieldValues, partialTemporal, resolverStyle) {\n        const yearLong = fieldValues.get(ChronoField.YEAR);\n        const qoyLong = fieldValues.get(QUARTER_OF_YEAR);\n        if (yearLong == null || qoyLong == null) {\n            return null;\n        }\n        const y = ChronoField.YEAR.checkValidIntValue(yearLong);\n        const doq = fieldValues.get(DAY_OF_QUARTER);\n        let date;\n        if (resolverStyle === ResolverStyle.LENIENT) {\n            let qoy = qoyLong;\n            date = LocalDate.of(y, 1, 1);\n            date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));\n            date = date.plusDays(MathUtil.safeSubtract(doq, 1));\n        } else {\n            let qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                let max = 92;\n                if (qoy === 1) {\n                    max = (IsoChronology.isLeapYear(y) ? 91 : 90);\n                } else if (qoy === 2) {\n                    max = 91;\n                }\n                ValueRange.of(1, max).checkValidValue(doq, this);\n            } else {\n                this.range().checkValidValue(doq, this);  // leniently check from 1 to 92\n            }\n            date = LocalDate.of(y, ((qoy - 1) * 3) + 1, 1).plusDays(doq - 1);\n        }\n        fieldValues.remove(this);\n        fieldValues.remove(ChronoField.YEAR);\n        fieldValues.remove(QUARTER_OF_YEAR);\n        return date;\n    }\n}\n\nclass QUARTER_OF_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'QuarterOfYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return QUARTER_YEARS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return ChronoUnit.YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 4);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    //eslint-disable-next-line no-unused-vars\n    rangeRefinedBy(temporal) {\n        return this.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: QuarterOfYear');\n        }\n        const moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);\n        return MathUtil.intDiv((moy + 2), 3);\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        const curValue = this.getFrom(temporal);\n        this.range().checkValidValue(newValue, this);\n        return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);\n    }\n\n}\n\nclass WEEK_OF_WEEK_BASED_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'WeekOfWeekBasedYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return ChronoUnit.WEEKS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return WEEK_BASED_YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 52, 53);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    rangeRefinedBy(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n        }\n        return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n        }\n        return Field._getWeek(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        this.range().checkValidValue(newValue, this);\n        return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);\n    }\n\n    /**\n     *\n     * @param {Map<TemporalField, number>} fieldValues\n     * @param {TemporalAccessor} partialTemporal\n     * @param {ResolverStyle} resolverStyle\n     * @returns {ValueRange}\n     */\n    resolve(fieldValues, partialTemporal, resolverStyle) {\n        const wbyLong = fieldValues.get(WEEK_BASED_YEAR);\n        const dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);\n        if (wbyLong == null || dowLong == null) {\n            return null;\n        }\n        const wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);\n        const wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);\n        let date;\n        if (resolverStyle === ResolverStyle.LENIENT) {\n            let dow = dowLong;\n            let weeks = 0;\n            if (dow > 7) {\n                weeks = MathUtil.intDiv((dow - 1), 7);\n                dow = (MathUtil.intMod((dow - 1), 7) + 1);\n            } else if (dow < 1) {\n                weeks = MathUtil.intDiv(dow, 7) - 1;\n                dow = MathUtil.intMod(dow, 7) + 7;\n            }\n            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);\n        } else {\n            let dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                let temp = LocalDate.of(wby, 1, 4);\n                let range = Field._getWeekRangeByLocalDate(temp);\n                range.checkValidValue(wowby, this);\n            } else {\n                this.range().checkValidValue(wowby, this);  // leniently check from 1 to 53\n            }\n            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, dow);\n        }\n        fieldValues.remove(this);\n        fieldValues.remove(WEEK_BASED_YEAR);\n        fieldValues.remove(ChronoField.DAY_OF_WEEK);\n        return date;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    getDisplayName() {\n        return 'Week';\n    }\n\n}\n\nclass WEEK_BASED_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'WeekBasedYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return WEEK_BASED_YEARS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return ChronoUnit.FOREVER;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ChronoField.YEAR.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    //eslint-disable-next-line no-unused-vars\n    rangeRefinedBy(temporal) {\n        return ChronoField.YEAR.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n        }\n        return Field._getWeekBasedYear(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        if (this.isSupportedBy(temporal) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n        }\n        const newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);  // strict check\n        const date = LocalDate.from(temporal);\n        const dow = date.get(ChronoField.DAY_OF_WEEK);\n        let week = Field._getWeek(date);\n        if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {\n            week = 52;\n        }\n        let resolved = LocalDate.of(newWby, 1, 4);  // 4th is guaranteed to be in week one\n        const days = (dow - resolved.get(ChronoField.DAY_OF_WEEK)) + ((week - 1) * 7);\n        resolved = resolved.plusDays(days);\n        return temporal.with(resolved);\n    }\n\n}\n\n//-----------------------------------------------------------------------\n/**\n * Implementation of the period unit.\n */\nclass Unit extends TemporalUnit {\n\n    /**\n     *\n     * @param {string} name\n     * @param {Duration} estimatedDuration\n     */\n    constructor(name, estimatedDuration) {\n        super();\n        this._name = name;\n        this._duration = estimatedDuration;\n    }\n\n    /**\n     *\n     * @returns {Duration}\n     */\n    duration() {\n        return this._duration;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDurationEstimated() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDateBased() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isTimeBased() {\n        return false;\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY);\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} periodToAdd\n     * @returns {number}\n     */\n    addTo(temporal, periodToAdd) {\n        switch(this) {\n            case WEEK_BASED_YEARS: {\n                const added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);\n                return temporal.with(WEEK_BASED_YEAR, added);\n            }\n            case QUARTER_YEARS:\n                // no overflow (256 is multiple of 4)\n                return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);\n            default:\n                throw new IllegalStateException('Unreachable');\n        }\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal1\n     * @param {Temporal} temporal2\n     * @returns {number}\n     */\n    between(temporal1, temporal2) {\n        switch(this) {\n            case WEEK_BASED_YEARS:\n                return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));\n            case QUARTER_YEARS:\n                return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);\n            default:\n                throw new IllegalStateException('Unreachable');\n        }\n    }\n\n    toString() {\n        return name;\n    }\n}\n\nlet DAY_OF_QUARTER = null;\nlet QUARTER_OF_YEAR = null;\nlet WEEK_OF_WEEK_BASED_YEAR = null;\nlet WEEK_BASED_YEAR = null;\nlet WEEK_BASED_YEARS = null;\nlet QUARTER_YEARS = null;\n\nexport function _init() {\n    DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();\n    QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();\n    WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();\n    WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();\n\n    WEEK_BASED_YEARS = new Unit('WeekBasedYears', Duration.ofSeconds(31556952));\n    QUARTER_YEARS = new Unit('QuarterYears', Duration.ofSeconds(31556952 / 4));\n\n    IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;\n    IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;\n    IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;\n    IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;\n    IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;\n    IsoFields.QUARTER_YEARS = QUARTER_YEARS;\n\n    // this differs from threeten, but for ease of use we bring back good old joda time functionality\n    /**\n     * the week of the week based year as defined by the ISO8601 Standard with a Monday-based week\n     *\n     * @returns {number} the week a the week based year\n     */\n    LocalDate.prototype.isoWeekOfWeekyear = function () {\n        return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);\n    };\n    /**\n     * the year of the week based year as defined by the ISO8601 Standard with a Monday-based week\n     *\n     * @returns {number} the year a the week based year\n     */\n    LocalDate.prototype.isoWeekyear = function () {\n        return this.get(IsoFields.WEEK_BASED_YEAR);\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/IsoFields.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport class DecimalStyle {\n    constructor(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {\n        this._zeroDigit = zeroChar;\n        this._zeroDigitCharCode = zeroChar.charCodeAt(0);\n        this._positiveSign = positiveSignChar;\n        this._negativeSign = negativeSignChar;\n        this._decimalSeparator = decimalPointChar;\n    }\n\n    positiveSign(){\n        return this._positiveSign;\n    }\n\n    withPositiveSign(positiveSign) {\n        if (positiveSign === this._positiveSign) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);\n    }\n\n    negativeSign(){\n        return this._negativeSign;\n    }\n\n    withNegativeSign(negativeSign) {\n        if (negativeSign === this._negativeSign) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);\n    }\n\n    zeroDigit(){\n        return this._zeroDigit;\n    }\n\n    withZeroDigit(zeroDigit) {\n        if (zeroDigit === this._zeroDigit) {\n            return this;\n        }\n        return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);\n    }\n\n    decimalSeparator(){\n        return this._decimalSeparator;\n    }\n\n    withDecimalSeparator(decimalSeparator) {\n        if (decimalSeparator === this._decimalSeparator) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);\n    }\n\n    convertToDigit(char){\n        const val = char.charCodeAt(0) - this._zeroDigitCharCode;\n        return (val >= 0 && val <= 9) ? val : -1;\n    }\n\n    convertNumberToI18N(numericText) {\n        if (this._zeroDigit === '0') {\n            return numericText;\n        }\n        const diff = this._zeroDigitCharCode - '0'.charCodeAt(0);\n        let convertedText = '';\n        for (let i = 0; i < numericText.length; i++) {\n            convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);\n        }\n        return convertedText;\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof DecimalStyle) {\n            return (this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign &&\n                this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator);\n        }\n        return false;\n    }\n\n    hashCode() {\n        return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;\n    }\n\n    toString() {\n        return 'DecimalStyle[' + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + ']';\n    }\n\n    static of(){\n        throw new Error('not yet supported');\n    }\n    static availableLocales(){\n        throw new Error('not yet supported');\n    }\n\n}\n\nDecimalStyle.STANDARD = new DecimalStyle('0', '+', '-', '.');\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/DecimalStyle.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport {Enum} from '../Enum';\n\n/**\n * Enumeration of the style of text formatting and parsing.\n *\n * Text styles define three sizes for the formatted text - 'full', 'short' and 'narrow'.\n * Each of these three sizes is available in both 'standard' and 'stand-alone' variations.\n *\n * The difference between the three sizes is obvious in most languages.\n * For example, in English the 'full' month is 'January', the 'short' month is 'Jan'\n * and the 'narrow' month is 'J'. Note that the narrow size is often not unique.\n * For example, 'January', 'June' and 'July' all have the 'narrow' text 'J'.\n *\n * The difference between the 'standard' and 'stand-alone' forms is trickier to describe\n * as there is no difference in English. However, in other languages there is a difference\n * in the word used when the text is used alone, as opposed to in a complete date.\n * For example, the word used for a month when used alone in a date picker is different\n * to the word used for month in association with a day and year in a date.\n *\n * ### Specification for implementors\n *\n * This is immutable and thread-safe enum.\n */\nexport class TextStyle extends Enum {\n    /**\n     * Checks if the style is stand-alone.\n     *\n     * @return {boolean} true if the style is stand-alone\n     */\n    isStandalone() {\n        switch (this) {\n            case TextStyle.FULL_STANDALONE:\n            case TextStyle.SHORT_STANDALONE:\n            case TextStyle.NARROW_STANDALONE:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * Converts the style to the equivalent stand-alone style.\n     *\n     * @return {TextStyle} the matching stand-alone style\n     */\n    asStandalone() {\n        switch (this) {\n            case TextStyle.FULL:\n                return TextStyle.FULL_STANDALONE;\n            case TextStyle.SHORT:\n                return TextStyle.SHORT_STANDALONE;\n            case TextStyle.NARROW:\n                return TextStyle.NARROW_STANDALONE;\n            default:\n                // all others are already standalone\n                return this;\n        }\n    }\n\n    /**\n     * Converts the style to the equivalent normal style.\n     *\n     * @return {TextStyle} the matching normal style\n     */\n    asNormal() {\n        switch (this) {\n            case TextStyle.FULL_STANDALONE:\n                return TextStyle.FULL;\n            case TextStyle.SHORT_STANDALONE:\n                return TextStyle.SHORT;\n            case TextStyle.NARROW_STANDALONE:\n                return TextStyle.NARROW;\n            default:\n                // all others are already normal\n                return this;\n        }\n    }\n}\n\n/**\n * Full text, typically the full description.\n * For example, day-of-week Monday might output \"Monday\".\n */\nTextStyle.FULL = new TextStyle('FULL');\n/**\n * Full text for stand-alone use, typically the full description.\n * For example, day-of-week Monday might output \"Monday\".\n */\nTextStyle.FULL_STANDALONE = new TextStyle('FULL_STANDALONE');\n/**\n * Short text, typically an abbreviation.\n * For example, day-of-week Monday might output \"Mon\".\n */\nTextStyle.SHORT = new TextStyle('SHORT');\n/**\n * Short text for stand-alone use, typically an abbreviation.\n * For example, day-of-week Monday might output \"Mon\".\n */\nTextStyle.SHORT_STANDALONE = new TextStyle('SHORT_STANDALONE');\n/**\n * Narrow text, typically a single letter.\n * For example, day-of-week Monday might output \"M\".\n */\nTextStyle.NARROW = new TextStyle('NARROW');\n/**\n * Narrow text for stand-alone use, typically a single letter.\n * For example, day-of-week Monday might output \"M\".\n */\nTextStyle.NARROW_STANDALONE = new TextStyle('NARROW_STANDALONE');\n\n\n\n// WEBPACK FOOTER //\n// ./src/format/TextStyle.js","/**\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {DateTimeException, UnsupportedTemporalTypeException} from './errors';\nimport {requireNonNull, requireInstance} from './assert';\nimport {MathUtil} from './MathUtil';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {Clock} from './Clock';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\nimport {DateTimeFormatterBuilder} from './format/DateTimeFormatterBuilder';\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {LocalDate} from './LocalDate';\nimport {Month} from './Month';\nimport {MonthDay} from './MonthDay';\nimport {SignStyle} from './format/SignStyle';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalAccessor} from './temporal/TemporalAccessor';\nimport {TemporalAmount} from './temporal/TemporalAmount';\nimport {TemporalField} from './temporal/TemporalField';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {TemporalQuery, createTemporalQuery} from './temporal/TemporalQuery';\nimport {TemporalUnit} from './temporal/TemporalUnit';\nimport {YearConstants} from './YearConstants';\nimport {YearMonth} from './YearMonth';\nimport {ZoneId} from './ZoneId';\n\n\n/**\n * A year in the ISO-8601 calendar system, such as `2007`.\n *\n * {@link Year} is an immutable date-time object that represents a year.\n * Any field that can be derived from a year can be obtained.\n *\n * **Note that years in the ISO chronology only align with years in the\n * Gregorian-Julian system for modern years. Parts of Russia did not switch to the\n * modern Gregorian/ISO rules until 1920.\n * As such, historical years must be treated with caution.**\n *\n * This class does not store or represent a month, day, time or time-zone.\n * For example, the value \"2007\" can be stored in a {@link Year}.\n *\n * Years represented by this class follow the ISO-8601 standard and use\n * the proleptic numbering system. Year 1 is preceded by year 0, then by year -1.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Static properties of Class {@link LocalDate}\n *\n * Year.MIN_VALUE = -999.999;\n *\n * The minimum supported year. Theoretically the minimum could be -28.542.4812 years in javascript.\n * approx LocalDateTime.ofEpochSecond(Number.MIN_SAFE_INTEGER, 0, ZoneOffset.UTC).year()\n *\n * Year.MAX_VALUE = 999.999;\n *\n * The maximum supported year. Theoretically the maximum could be 285.428.751 years in javascript.\n * approx LocalDateTime.ofEpochSecond(Number.MAX_SAFE_INTEGER, 0, ZoneOffset.UTC).year()\n *\n */\nexport class Year extends Temporal {\n\n    /**\n     *\n     * @param {number} value\n     */\n    constructor(value) {\n        super();\n        this._year = value;\n    }\n\n    /**\n     *\n     * @return {number} gets the value\n     */\n    value() {\n        return this._year;\n    }\n\n    /**\n     * function overloading for {@link Year.now}\n     *\n     * if called without arguments, then {@link Year.now0} is executed.\n\n     * if called with 1 arguments and first argument is an instance of ZoneId, then {@link Year.nowZoneId} is executed.\n     *\n     * Otherwise {@link Year.nowClock} is executed.\n     *\n     * @param {!(ZoneId|Clock)} zoneIdOrClock\n     * @returns {Year}\n     */\n    static now(zoneIdOrClock = undefined) {\n        if (zoneIdOrClock === undefined) {\n            return Year.now0();\n        } else if (zoneIdOrClock instanceof ZoneId) {\n            return Year.nowZoneId(zoneIdOrClock);\n        } else {\n            return Year.nowClock(zoneIdOrClock);\n        }\n    }\n\n    /**\n     * Obtains the current year from the system clock in the default time-zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current year.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {Year} the current year using the system clock and default time-zone, not null\n     */\n    static now0() {\n        return Year.nowClock(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current year from the system clock in the specified time-zone.\n     *\n     * This will query the system clock (see {@link Clock#system}) to obtain the current year.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone  the zone ID to use, not null\n     * @return {Year} the current year using the system clock, not null\n     */\n    static nowZoneId(zone) {\n        requireNonNull(zone, 'zone');\n        requireInstance(zone, ZoneId, 'zone');\n        return Year.nowClock(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current year from the specified clock.\n     *\n     * This will query the specified clock to obtain the current year.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock} clock  the clock to use, not null\n     * @return {Year} the current year, not null\n     */\n    static nowClock(clock) {\n        requireNonNull(clock, 'clock');\n        requireInstance(clock, Clock, 'clock');\n        let now = LocalDate.now(clock);  // called once\n        return Year.of(now.year());\n    }\n    /**\n     * Obtains an instance of {@link Year}.\n     *\n     * This method accepts a year value from the proleptic ISO calendar system.\n     *\n     * * The year 2AD/CE is represented by 2.\n     * * The year 1AD/CE is represented by 1.\n     * * The year 1BC/BCE is represented by 0.\n     * * The year 2BC/BCE is represented by -1.\n     *\n     * @param {Number} isoYear  the ISO proleptic year to represent, from {@link MIN_VALUE} to {@link MAX_VALUE}\n     * @return {Year} the year, not null\n     * @throws DateTimeException if the field is invalid\n     */\n    static of(isoYear) {\n        requireNonNull(isoYear, 'isoYear');\n        ChronoField.YEAR.checkValidValue(isoYear);\n        return new Year(isoYear);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Year} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link Year}.\n     *\n     * The conversion extracts the {@link ChronoField#YEAR} field.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link Year::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {Year} the year, not null\n     * @throws DateTimeException if unable to convert to a {@link Year}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        requireInstance(temporal, TemporalAccessor, 'temporal');\n        if (temporal instanceof Year) {\n            return temporal;\n        }\n        try {\n            /* TODO: we support only ISO for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return Year.of(temporal.get(ChronoField.YEAR));\n        } catch (ex) {\n            throw new DateTimeException('Unable to obtain Year from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n        }\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Year.parse}\n     *\n     * if called with 1 argument, then {@link Year.parseText} is executed.\n     *\n     * Otherwise {@link Year.parseTextFormatter} is executed.\n     *\n     * @param {!(String)} text\n     * @param {?DateTimeFormatter} formatter\n     * @returns {Year}\n     */\n    static parse(text, formatter) {\n        if (arguments.length <= 1) {\n            return Year.parseText(text);\n        } else {\n            return Year.parseTextFormatter(text, formatter);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link Year} from a text string such as `2007`.\n     *\n     * The string must represent a valid year.\n     * Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.\n     *\n     * @param {String} text  the text to parse such as \"2007\", not null\n     * @return {Year} the parsed year, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseText(text) {\n        requireNonNull(text, 'text');\n        return Year.parse(text, PARSER);\n    }\n\n    /**\n     * Obtains an instance of {@link Year} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a year.\n     *\n     * @param {String} text  the text to parse, not null\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {Year} the parsed year, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseTextFormatter(text, formatter = PARSER) {\n        requireNonNull(text, 'text');\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.parse(text, Year.FROM);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @param {number} year  the year to check\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    static isLeap(year) {\n        return ((MathUtil.intMod(year, 4) === 0) && ((MathUtil.intMod(year, 100) !== 0) || (MathUtil.intMod(year, 400) === 0)));\n    }\n\n    /**\n     * function overloading for {@link YearMonth.isSupported}\n     *\n     * if called with 1 argument and first argument is an instance of TemporalField, then {@link YearMonth.isSupportedField} is executed,\n     *\n     * otherwise {@link YearMonth.isSupportedUnit} is executed\n     *\n     * @param {!(TemporalField|ChronoUnit)} fieldOrUnit\n     * @returns {boolean}\n     */\n    isSupported(fieldOrUnit) {\n        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n            return this.isSupportedField(fieldOrUnit);\n        } else {\n            return this.isSupportedUnit(fieldOrUnit);\n        }\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this year can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link YEAR_OF_ERA}\n     * * {@link YEAR}\n     * * {@link ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this year, false if not\n     */\n    isSupportedField(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    isSupportedUnit(unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n        }\n        return unit != null && unit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This year is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (this.isSupported(field)) {\n            return field.range();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year as an `int`.\n     *\n     * This queries this year for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year as a `long`.\n     *\n     * This queries this year for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.YEAR_OF_ERA: return (this._year < 1 ? 1 - this._year : this._year);\n                case ChronoField.YEAR: return this._year;\n                case ChronoField.ERA: return (this._year < 1 ? 0 : 1);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    isLeap() {\n        return Year.isLeap(this._year);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.with}\n     *\n     * if called with 2 arguments and first argument is an instance of TemporalField, then {@link Year.withFieldValue} is executed,\n\n     * otherwise {@link Year.withAdjuster} is executed,\n     *\n     * @param {!(TemporalAdjuster|TemporalField|Number)} adjusterOrFieldOrNumber\n     * @param {?number} value nullable only of first argument is an instance of TemporalAdjuster\n     * @returns {Year}\n     */\n    with(adjusterOrFieldOrNumber, value) {\n        if (arguments.length === 2 && adjusterOrFieldOrNumber instanceof TemporalField) {\n            return this.withFieldValue(adjusterOrFieldOrNumber, value);\n        } else {\n            return this.withAdjuster(adjusterOrFieldOrNumber);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this year.\n     *\n     * This returns a new {@link Year}, based on this one, with the year adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster the adjuster to use, not null\n     * @returns {Year} based on `this` with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this year with the specified field set to a new value.\n     *\n     * This returns a new {@link Year}, based on this one, with the value\n     * for the specified field changed.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link YEAR_OF_ERA} -\n     *   Returns a {@link Year} with the specified year-of-era\n     *   The era will be unchanged.\n     * * {@link YEAR} -\n     *   Returns a {@link Year} with the specified year.\n     *   This completely replaces the date and is equivalent to {@link of}.\n     * * {@link ERA} -\n     *   Returns a {@link Year} with the specified era.\n     *   The year-of-era will be unchanged.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field  the field to set in the result, not null\n     * @param {number} newValue  the new value of the field in the result\n     * @returns {Year} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withFieldValue(field, newValue) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.YEAR_OF_ERA:\n                    return Year.of((this._year < 1 ? 1 - newValue : newValue));\n                case ChronoField.YEAR:\n                    return Year.of(newValue);\n                case ChronoField.ERA:\n                    return (this.getLong(ChronoField.ERA) === newValue ? this : Year.of(1 - this._year));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    /**\n     * function overloading for {@link Year.plus}\n     *\n     * if called with 1 arguments, then {@link Year.plusAmount} is executed.\n     *\n     * Otherwise {@link Year.plusAmountToAddUnit} is executed.\n     *\n     * @param {!(TemporalAmount|number)} amountOrNumber\n     * @param {?TemporalUnit} unit nullable only if first argument is an instance of TemporalAmount\n     * @returns {Year}\n     */\n    plus(amountOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.plusAmount(amountOrNumber);\n        } else {\n            return this.plusAmountToAddUnit(amountOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this year with the specified period added.\n     *\n     * This method returns a new year based on this year with the specified period added.\n     * The adder is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link plus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount  the amount to add, not null\n     * @return {Year} based on this year with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmount(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * @param {number} amountToAdd\n     * @param {TemporalUnit} unit\n     * @return {Year} based on this year with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmountToAddUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.YEARS: return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS: return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this year with the specified number of years added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToAdd  the years to add, may be negative\n     * @return {Year} based on this year with the period added, not null\n     * @throws DateTimeException if the result exceeds the supported year range\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        return Year.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Year.minus}\n     *\n     * if called with 1 argument, then {@link Year.minusAmount} is executed.\n     *\n     * Otherwise {@link Year.minusAmountToSubtractUnit} is executed.\n     *\n     * @param {!(TemporalAmount|number)} amountOrNumber\n     * @param {?TemporalUnit} unit\n     * @returns {Year}\n     */\n    minus(amountOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.minusAmount(amountOrNumber);\n        } else {\n            return this.minusAmountToSubtractUnit(amountOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this year with the specified period subtracted.\n     *\n     * This method returns a new year based on this year with the specified period subtracted.\n     * The subtractor is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount  the amount to subtract, not null\n     * @return {Year} based on this year with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmount(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * @param {number} amountToSubtract  the amount to subtract, not null\n     * @param {TemporalUnit} unit\n     * @return {Year} based on this year with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmountToSubtractUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit, 'unit');\n        return (amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plus(MathUtil.MAX_SAFE_INTEGER, unit).plus(1, unit) : this.plus(-amountToSubtract, unit));\n    }\n\n    /**\n     * Returns a copy of this year with the specified number of years subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToSubtract  the years to subtract, may be negative\n     * @return {Year} based on this year with the period subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported year range\n     */\n    minusYears(yearsToSubtract) {\n        return (yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this year.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the year changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#YEAR} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisYear.adjustInto(temporal);\n     *   temporal = temporal.with(thisYear);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n         if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) == false) {\n         throw new DateTimeException(\"Adjustment only supported on ISO date-time\");\n         }*/\n        return temporal.with(ChronoField.YEAR, this._year);\n    }\n\n    /**\n     * Checks if the month-day is valid for this year.\n     *\n     * This method checks whether this year and the input month and day form\n     * a valid date.\n     *\n     * @param {MonthDay} monthDay  the month-day to validate, null returns false\n     * @return {boolean} true if the month and day are valid for this year\n     */\n    isValidMonthDay(monthDay) {\n        return monthDay != null && monthDay.isValidYear(this._year);\n    }\n\n    /**\n     * Gets the length of this year in days.\n     *\n     * @return {number} the length of this year in days, 365 or 366\n     */\n    length() {\n        return this.isLeap() ? 366 : 365;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this year with a day-of-year to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this year and the specified day-of-year.\n     *\n     * The day-of-year value 366 is only valid in a leap year.\n     *\n     * @param {number} dayOfYear  the day-of-year to use, not null\n     * @return {LocalDate} the local date formed from this year and the specified date of year, not null\n     * @throws DateTimeException if the day of year is zero or less, 366 or greater or equal\n     *  to 366 and this is not a leap year\n     */\n    atDay(dayOfYear) {\n        return LocalDate.ofYearDay(this._year, dayOfYear);\n    }\n\n    /**\n     * function overloading for {@link Year.atMonth}\n     *\n     * if called with 1 arguments and first argument is instance of Month, then {@link Year.atMonthMonth} is executed.\n     *\n     * Otherwise {@link Year.atMonthNumber} is executed.\n     *\n     * @param {Month|number} monthOrNumber\n     * @returns {YearMonth}\n     */\n    atMonth(monthOrNumber) {\n        if (arguments.length === 1 && monthOrNumber instanceof Month) {\n            return this.atMonthMonth(monthOrNumber);\n        } else {\n            return this.atMonthNumber(monthOrNumber);\n        }\n    }\n\n    /**\n     * Combines this year with a month to create a {@link YearMonth}.\n     *\n     * This returns a {@link YearMonth} formed from this year and the specified month.\n     * All possible combinations of year and month are valid.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atDay(day);\n     * </pre>\n     *\n     * @param {Month} month  the month-of-year to use, not null\n     * @return {YearMonth} the year-month formed from this year and the specified month, not null\n     */\n    atMonthMonth(month) {\n        requireNonNull(month, 'month');\n        requireInstance(month, Month, 'month');\n        return YearMonth.of(this._year, month);\n    }\n\n    /**\n     * Combines this year with a month to create a {@link YearMonth}.\n     *\n     * This returns a {@link YearMonth} formed from this year and the specified month.\n     * All possible combinations of year and month are valid.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atDay(day);\n     * </pre>\n     *\n     * @param {number} month  the month-of-year to use, from 1 (January) to 12 (December)\n     * @return {YearMonth} the year-month formed from this year and the specified month, not null\n     * @throws DateTimeException if the month is invalid\n     */\n    atMonthNumber(month) {\n        requireNonNull(month, 'month');\n        return YearMonth.of(this._year, month);\n    }\n\n    /**\n     * Combines this year with a month-day to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this year and the specified month-day.\n     *\n     * A month-day of February 29th will be adjusted to February 28th in the resulting\n     * date if the year is not a leap year.\n     *\n     * @param {MonthDay} monthDay  the month-day to use, not null\n     * @return {LocalDate} the local date formed from this year and the specified month-day, not null\n     */\n    atMonthDay(monthDay) {\n        requireNonNull(monthDay, 'monthDay');\n        requireInstance(monthDay, MonthDay, 'monthDay');\n        return monthDay.atYear(this._year);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this year using the specified query.\n     *\n     * This queries this year using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query()');\n        requireInstance(query, TemporalQuery, 'query()');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.YEARS;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this year to another year.\n     *\n     * The comparison is based on the value of the year.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {Year} other  the other year to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Year, 'other');\n        return this._year - other._year;\n    }\n\n    /**\n     * Is this year after the specified year.\n     *\n     * @param {Year} other  the other year to compare to, not null\n     * @return {boolean} true if this is after the specified year\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Year, 'other');\n        return this._year > other._year;\n    }\n\n    /**\n     * Is this year before the specified year.\n     *\n     * @param {Year} other  the other year to compare to, not null\n     * @return {boolean} true if this point is before the specified year\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Year, 'other');\n        return this._year < other._year;\n    }\n    /**\n     * Outputs this year as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted year string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.format(this);\n    }\n\n    /**\n     * Checks if this year is equal to the specified {@link Year}.\n     *\n     * The comparison is based on the value\n     *\n     * @param {*} otherYear - the other year, null returns false\n     * @return {boolean} true if the other duration is equal to this one\n     */\n    equals(otherYear) {\n        if (this === otherYear) {\n            return true;\n        }\n        if (otherYear instanceof Year) {\n            return this.value() === otherYear.value();\n        }\n        return false;\n    }\n    /**\n     * Outputs this year as a string.\n     *\n     * @return {String} a string representation of this year, not null\n     */\n    toString() {\n        return '' + this._year;\n    }\n}\n\nlet PARSER;\n\nexport function _init() {\n\n    Year.MIN_VALUE = YearConstants.MIN_VALUE;\n    Year.MAX_VALUE = YearConstants.MAX_VALUE;\n\n    PARSER = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .toFormatter();\n\n    Year.FROM = createTemporalQuery('Year.FROM', (temporal) => {\n        return Year.from(temporal);\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Year.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport {requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException} from './errors';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {Clock} from './Clock';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\nimport {DateTimeFormatterBuilder} from './format/DateTimeFormatterBuilder';\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {LocalDate} from './LocalDate';\nimport {Month} from './Month';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalAccessor} from './temporal/TemporalAccessor';\nimport {TemporalQuery, createTemporalQuery} from './temporal/TemporalQuery';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {ValueRange} from './temporal/ValueRange';\nimport {Year} from './Year';\nimport {ZoneId} from './ZoneId';\n\n/**\n * A month-day in the ISO-8601 calendar system, such as `--12-03`.\n *\n * {@link MonthDay} is an immutable date-time object that represents the combination\n * of a year and month. Any field that can be derived from a month and day, such as\n * quarter-of-year, can be obtained.\n *\n * This class does not store or represent a year, time or time-zone.\n * For example, the value \"December 3rd\" can be stored in a {@link MonthDay}.\n *\n * Since a {@link MonthDay} does not possess a year, the leap day of\n * February 29th is considered valid.\n *\n * This class implements {@link TemporalAccessor} rather than {@link Temporal}.\n * This is because it is not possible to define whether February 29th is valid or not\n * without external information, preventing the implementation of plus/minus.\n * Related to this, {@link MonthDay} only provides access to query and set the fields\n * {@link MONTH_OF_YEAR} and {@link DAY_OF_MONTH}.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Specification for implementors\n *\n * This class is immutable and thread-safe.\n */\nexport class MonthDay extends Temporal {\n    /**\n     * function overloading for {@link MonthDay.now}\n     *\n     * if called with 0 argument {@link MonthDay.now0} is executed,\n     *\n     * if called with 1 argument and first argument is an instance of ZoneId, then {@link MonthDay.nowZoneId} is executed,\n     *\n     * otherwise {@link MonthDay.nowClock} is executed\n     *\n     * @param {?(ZoneId|Clock)} zoneIdOrClock\n     * @returns {MonthDay}\n     */\n    static now(zoneIdOrClock) {\n        if (arguments.length === 0) {\n            return MonthDay.now0();\n        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n            return MonthDay.nowZoneId(zoneIdOrClock);\n        } else {\n            return MonthDay.nowClock(zoneIdOrClock);\n        }\n    }\n    /**\n     * Obtains the current month-day from the system clock in the default time-zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current month-day.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {MonthDay} the current month-day using the system clock and default time-zone, not null\n     */\n    static now0() {\n        return this.nowClock(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current month-day from the system clock in the specified time-zone.\n     *\n     * This will query the system clock (see {@link Clock#system}) to obtain the current month-day.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone  the zone ID to use, not null\n     * @return {MonthDay} the current month-day using the system clock, not null\n     */\n    static nowZoneId(zone) {\n        requireNonNull(zone, 'zone');\n        return this.nowClock(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current month-day from the specified clock.\n     *\n     * This will query the specified clock to obtain the current month-day.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection (see {@link Clock}).\n     *\n     * @param {Clock} clock  the clock to use, not null\n     * @return {MonthDay} the current month-day, not null\n     */\n    static nowClock(clock) {\n        requireNonNull(clock, 'clock');\n        let now = LocalDate.now(clock);  // called once\n        return MonthDay.of(now.month(), now.dayOfMonth());\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link MonthDay.of}\n     *\n     * if called with 2 argument and first argument is an instance of Month, then {@link MonthDay.ofMonthNumber} is executed,\n     *\n     * otherwise {@link MonthDay.ofNumberNumber} is executed\n     *\n     * @param {!(Month|number)} monthOrNumber\n     * @param {?number} number\n     * @returns {MonthDay}\n     */\n    static of(monthOrNumber, number) {\n        if (arguments.length === 2 && monthOrNumber instanceof Month) {\n            return MonthDay.ofMonthNumber(monthOrNumber, number);\n        } else {\n            return MonthDay.ofNumberNumber(monthOrNumber, number);\n        }\n    }\n    /**\n     * Obtains an instance of {@link MonthDay}.\n     *\n     * The day-of-month must be valid for the month within a leap year.\n     * Hence, for February, day 29 is valid.\n     *\n     * For example, passing in April and day 31 will throw an exception, as\n     * there can never be April 31st in any year. By contrast, passing in\n     * February 29th is permitted, as that month-day can sometimes be valid.\n     *\n     * @param {Month} month  the month-of-year to represent, not null\n     * @param {number} dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return {MonthDay} the month-day, not null\n     * @throws DateTimeException if the value of any field is out of range\n     * @throws DateTimeException if the day-of-month is invalid for the month\n     */\n    static ofMonthNumber(month, dayOfMonth) {\n        requireNonNull(month, 'month');\n        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        if (dayOfMonth > month.maxLength()) {\n            throw new DateTimeException('Illegal value for DayOfMonth field, value ' + dayOfMonth +\n                    ' is not valid for month ' + month.toString());\n        }\n        return new MonthDay(month.value(), dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@link MonthDay}.\n     *\n     * The day-of-month must be valid for the month within a leap year.\n     * Hence, for month 2 (February), day 29 is valid.\n     *\n     * For example, passing in month 4 (April) and day 31 will throw an exception, as\n     * there can never be April 31st in any year. By contrast, passing in\n     * February 29th is permitted, as that month-day can sometimes be valid.\n     *\n     * @param {number} month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {number} dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return {MonthDay} the month-day, not null\n     * @throws DateTimeException if the value of any field is out of range\n     * @throws DateTimeException if the day-of-month is invalid for the month\n     */\n    static ofNumberNumber(month, dayOfMonth) {\n        requireNonNull(month, 'month');\n        requireNonNull(dayOfMonth, 'dayOfMonth');\n        return MonthDay.of(Month.of(month), dayOfMonth);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link MonthDay} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link MonthDay}.\n     *\n     * The conversion extracts the MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) and\n     * DAY_OF_MONTH (see {@link ChronoField#DAY_OF_MONTH}) fields.\n     * The extraction is only permitted if the date-time has an ISO chronology.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link MonthDay::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {MonthDay} the month-day, not null\n     * @throws DateTimeException if unable to convert to a {@link MonthDay}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        requireInstance(temporal, TemporalAccessor, 'temporal');\n        if (temporal instanceof MonthDay) {\n            return temporal;\n        }\n        try {\n            /* TODO: only IsoChronology for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return MonthDay.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));\n        } catch (ex) {\n            throw new DateTimeException('Unable to obtain MonthDay from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n        }\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link MonthDay.parse}\n     *\n     * if called with 1 argument, then {@link MonthDay.parseString} is executed,\n     *\n     * otherwise {@link MonthDay.parseStringFormatter} is executed\n     *\n     * @param {!(String)} text\n     * @param {?DateTimeFormatter} formatter\n     * @returns {MonthDay}\n     */\n    static parse(text, formatter) {\n        if (arguments.length === 1) {\n            return MonthDay.parseString(text);\n        } else {\n            return MonthDay.parseStringFormatter(text, formatter);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link MonthDay} from a text string such as `--12-03`.\n     *\n     * The string must represent a valid month-day.\n     * The format is `--MM-dd`.\n     *\n     * @param {String} text  the text to parse such as \"--12-03\", not null\n     * @return {MonthDay} the parsed month-day, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseString(text) {\n        return MonthDay.parseStringFormatter(text, PARSER);\n    }\n\n    /**\n     * Obtains an instance of {@link MonthDay} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a month-day.\n     *\n     * @param {String} text  the text to parse, not null\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {MonthDay} the parsed month-day, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseStringFormatter(text, formatter) {\n        requireNonNull(text, 'text');\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.parse(text, MonthDay.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor, previously validated.\n     *\n     * @param {number} month  the month-of-year to represent, validated from 1 to 12\n     * @param {number} dayOfMonth  the day-of-month to represent, validated from 1 to 29-31\n     */\n    constructor(month, dayOfMonth) {\n        super();\n        this._month = month;\n        this._day = dayOfMonth;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #month()\n     */\n    monthValue() {\n        return this._month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value then the enum\n     * provides the int value (see {@link Month#getValue}).\n     *\n     * @return {Month} the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    month() {\n        return Month.of(this._month);\n    }\n\n    /**\n     * Gets the day-of-month field.\n     *\n     * This method returns the primitive `int` value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._day;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this month-day can be queried for the specified field.\n     * If false, then calling the range (see {@link range}) and\n     * get (see {@link get}) methods will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link MONTH_OF_YEAR}\n     * * {@link YEAR}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this month-day, false if not\n     */\n    isSupported(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This month-day is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return field.range();\n        } else if (field === ChronoField.DAY_OF_MONTH) {\n            return ValueRange.of(1, this.month().minLength(), this.month().maxLength());\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-day as an `int`.\n     *\n     * This queries this month-day for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this month-day.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-day as a `long`.\n     *\n     * This queries this month-day for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this month-day.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                // alignedDOW and alignedWOM not supported because they cannot be set in with()\n                case ChronoField.DAY_OF_MONTH: return this._day;\n                case ChronoField.MONTH_OF_YEAR: return this._month;\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is valid for this month-day.\n     *\n     * This method checks whether this month and day and the input year form\n     * a valid date. This can only return false for February 29th.\n     *\n     * @param {number} year  the year to validate, an out of range value returns false\n     * @return {boolean} true if the year is valid for this month-day\n     * @see Year#isValidMonthDay(MonthDay)\n     */\n    isValidYear(year) {\n        return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link MonthDay} with the month-of-year altered.\n     *\n     * This returns a month-day with the specified month.\n     * If the day-of-month is invalid for the specified month, the day will\n     * be adjusted to the last valid day-of-month.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} month  the month-of-year to set in the returned month-day, from 1 (January) to 12 (December)\n     * @return {MonthDay} based on this month-day with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this.with(Month.of(month));\n    }\n\n    /**\n    * Returns a copy of this {@link MonthDay} with the month-of-year altered.\n    *\n    * This returns a month-day with the specified month.\n    * If the day-of-month is invalid for the specified month, the day will\n    * be adjusted to the last valid day-of-month.\n    *\n    * This instance is immutable and unaffected by this method call.\n    *\n    * @param {Month} month  the month-of-year to set in the returned month-day, not null\n    * @return {MonthDay} based on this month-day with the requested month, not null\n    */\n    with(month) {\n        requireNonNull(month, 'month');\n        if (month.value() === this._month) {\n            return this;\n        }\n        let day = Math.min(this._day, month.maxLength());\n        return new MonthDay(month.value(), day);\n    }\n\n    /**\n     * Returns a copy of this {@link MonthDay} with the day-of-month altered.\n     *\n     * This returns a month-day with the specified day-of-month.\n     * If the day-of-month is invalid for the month, an exception is thrown.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth  the day-of-month to set in the return month-day, from 1 to 31\n     * @return {MonthDay} based on this month-day with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid\n     * @throws DateTimeException if the day-of-month is invalid for the month\n     */\n    withDayOfMonth(dayOfMonth) {\n        if (dayOfMonth === this._day) {\n            return this;\n        }\n        return MonthDay.of(this._month, dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this month-day using the specified query.\n     *\n     * This queries this month-day using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        requireInstance(query, TemporalQuery, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this month-day.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the month and day-of-month changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * twice, passing {@link ChronoField#MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH} as the fields.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisMonthDay.adjustInto(temporal);\n     *   temporal = temporal.with(thisMonthDay);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n        if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) == false) {\n            throw new DateTimeException(\"Adjustment only supported on ISO date-time\");\n        }*/\n        temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);\n        return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this month-day with a year to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this month-day and the specified year.\n     *\n     * A month-day of February 29th will be adjusted to February 28th in the resulting\n     * date if the year is not a leap year.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year  the year to use, from MIN_YEAR to MAX_YEAR\n     * @return {LocalDate} the local date formed from this month-day and the specified year, not null\n     * @throws DateTimeException if the year is outside the valid range of years\n     */\n    atYear(year) {\n        return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this month-day to another month-day.\n     *\n     * The comparison is based first on value of the month, then on the value of the day.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {MonthDay} other  the other month-day to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, MonthDay, 'other');\n        let cmp = (this._month - other.monthValue());\n        if (cmp === 0) {\n            cmp = (this._day - other.dayOfMonth());\n        }\n        return cmp;\n    }\n\n    /**\n     * Is this month-day after the specified month-day.\n     *\n     * @param {MonthDay} other  the other month-day to compare to, not null\n     * @return {boolean} true if this is after the specified month-day\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, MonthDay, 'other');\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Is this month-day before the specified month-day.\n     *\n     * @param {MonthDay} other  the other month-day to compare to, not null\n     * @return {boolean} true if this point is before the specified month-day\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, MonthDay, 'other');\n        return this.compareTo(other) < 0;\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this month-day is equal to another month-day.\n     *\n     * The comparison is based on the time-line position of the month-day within a year.\n     *\n     * @param {*} obj  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other month-day\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof MonthDay) {\n            let other = obj;\n            return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();\n        }\n        return false;\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this month-day as a string, such as `--12-03`.\n     *\n     * The output will be in the format `--MM-dd`:\n     *\n     * @return {String} a string representation of this month-day, not null\n     */\n    toString() {\n        return '--'\n            + (this._month < 10 ? '0' : '') + this._month\n            + (this._day < 10 ? '-0' : '-') + this._day;\n    }\n\n    /**\n     * Outputs this month-day as a string using the formatter.\n     *\n     * This month-day will be passed to the formatter\n     * print method (see {@link DateTimeFormatter#format}).\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted month-day string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.format(this);\n    }\n\n}\n\nlet PARSER;\n\nexport function _init() {\n    PARSER = new DateTimeFormatterBuilder()\n        .appendLiteral('--')\n        .appendValue(ChronoField.MONTH_OF_YEAR, 2)\n        .appendLiteral('-')\n        .appendValue(ChronoField.DAY_OF_MONTH, 2)\n        .toFormatter();\n\n    MonthDay.FROM = createTemporalQuery('MonthDay.FROM', (temporal) => {\n        return MonthDay.from(temporal);\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/MonthDay.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport {requireNonNull, requireInstance} from './assert';\nimport {DateTimeException, UnsupportedTemporalTypeException} from './errors';\nimport {MathUtil} from './MathUtil';\n\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {Clock} from './Clock';\nimport {DateTimeFormatterBuilder} from './format/DateTimeFormatterBuilder';\nimport {IsoChronology} from './chrono/IsoChronology';\nimport {LocalDate} from './LocalDate';\nimport {Month} from './Month';\nimport {SignStyle} from './format/SignStyle';\nimport {Temporal} from './temporal/Temporal';\nimport {TemporalAmount} from './temporal/TemporalAmount';\nimport {TemporalField} from './temporal/TemporalField';\nimport {TemporalQueries} from './temporal/TemporalQueries';\nimport {TemporalQuery} from './temporal/TemporalQuery';\nimport {TemporalUnit} from './temporal/TemporalUnit';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\nimport {ValueRange} from './temporal/ValueRange';\nimport {Year} from './Year';\nimport {ZoneId} from './ZoneId';\n\n/**\n * A year-month in the ISO-8601 calendar system, such as `2007-12`.\n *\n * {@link YearMonth} is an immutable date-time object that represents the combination\n * of a year and month. Any field that can be derived from a year and month, such as\n * quarter-of-year, can be obtained.\n *\n * This class does not store or represent a day, time or time-zone.\n * For example, the value \"October 2007\" can be stored in a {@link YearMonth}.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Specification for implementors\n *\n * This class is immutable and thread-safe.\n */\nexport class YearMonth extends Temporal {\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.now}\n     *\n     * if called with 0 argument {@link YearMonth.now0} is executed,\n     *\n     * if called with 1 argument and first argument is an instance of ZoneId, then {@link YearMonth.nowZoneId} is executed,\n     *\n     * otherwise {@link YearMonth.nowClock} is executed\n     *\n     * @param {?(ZoneId|Clock)} zoneIdOrClock\n     * @returns {YearMonth}\n     */\n    static now(zoneIdOrClock) {\n        if (arguments.length === 0) {\n            return YearMonth.now0();\n        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n            return YearMonth.nowZoneId(zoneIdOrClock);\n        } else {\n            return YearMonth.nowClock(zoneIdOrClock);\n        }\n    }\n\n    /**\n     * Obtains the current year-month from the system clock in the default time-zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current year-month.\n     * The zone and offset will be set based on the time-zone in the clock.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {YearMonth} the current year-month using the system clock and default time-zone, not null\n     */\n    static now0() {\n        return YearMonth.nowClock(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current year-month from the system clock in the specified time-zone.\n     *\n     * This will query the system clock (see {@link Clock#system}) to obtain the current year-month.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone  the zone ID to use, not null\n     * @return {YearMonth} the current year-month using the system clock, not null\n     */\n    static nowZoneId(zone) {\n        return YearMonth.nowClock(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current year-month from the specified clock.\n     *\n     * This will query the specified clock to obtain the current year-month.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock} clock  the clock to use, not null\n     * @return {YearMonth} the current year-month, not null\n     */\n    static nowClock(clock) {\n        let now = LocalDate.now(clock);\n        return YearMonth.of(now.year(), now.month());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.of}\n     *\n     * if called with 2 argument and first argument is an instance of Month, then {@link YearMonth.ofNumberMonth} is executed,\n     *\n     * otherwise {@link YearMonth.ofNumberNumber} is executed\n     *\n     * @param {!number} year\n     * @param {!(Month|number)} monthOrNumber\n     * @returns {YearMonth}\n     */\n    static of(year, monthOrNumber) {\n        if (arguments.length === 2 && monthOrNumber instanceof Month) {\n            return YearMonth.ofNumberMonth(year, monthOrNumber);\n        } else {\n            return YearMonth.ofNumberNumber(year, monthOrNumber);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a year and month.\n     *\n     * @param {number} year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {Month} month  the month-of-year to represent, not null\n     * @return {YearMonth} the year-month, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    static ofNumberMonth(year, month) {\n        requireNonNull(month, 'month');\n        requireInstance(month, Month, 'month');\n        return YearMonth.ofNumberNumber(year, month.value());\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a year and month.\n     *\n     * @param {number} year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @return {YearMonth} the year-month, not null\n     * @throws DateTimeException if either field value is invalid\n     */\n    static ofNumberNumber(year, month) {\n        requireNonNull(year, 'year');\n        requireNonNull(month, 'month');\n        ChronoField.YEAR.checkValidValue(year);\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        return new YearMonth(year, month);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link YearMonth} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link YearMonth}.\n     *\n     * The conversion extracts the {@link ChronoField#YEAR} and\n     * {@link ChronoField#MONTH_OF_YEAR} fields.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link YearMonth::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {YearMonth} the year-month, not null\n     * @throws DateTimeException if unable to convert to a {@link YearMonth}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof YearMonth) {\n            return temporal;\n        }\n        try {\n            /* TODO: only IsoChronology for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return YearMonth.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));\n        } catch (ex) {\n            throw new DateTimeException('Unable to obtain YearMonth from TemporalAccessor: ' +\n                    temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n        }\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.parse}\n     *\n     * if called with 2 argument and first argument is an instance of Month, then {@link YearMonth.parseString} is executed,\n     *\n     * otherwise {@link YearMonth.parseStringFormatter} is executed\n     *\n     * @param {!(String)} text\n     * @param {?DateTimeFormatter} formatter\n     * @returns {YearMonth}\n     */\n    static parse(text, formatter) {\n        if (arguments.length === 1) {\n            return YearMonth.parseString(text);\n        } else {\n            return YearMonth.parseStringFormatter(text, formatter);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a text string such as `2007-12`.\n     *\n     * The string must represent a valid year-month.\n     * The format must be {@link yyyy-MM}.\n     * Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.\n     *\n     * @param {String} text  the text to parse such as \"2007-12\", not null\n     * @return {YearMonth} the parsed year-month, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseString(text) {\n        return YearMonth.parseStringFormatter(text, PARSER);\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a year-month.\n     *\n     * @param {String} text  the text to parse, not null\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return the parsed year-month, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseStringFormatter(text, formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, YearMonth.FROM);\n    }\n\n\n    /**\n     * Constructor.\n     *\n     * @param {number} year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param {number} month  the month-of-year to represent, validated from 1 (January) to 12 (December)\n     */\n    constructor(year, month) {\n        super();\n        this._year = year;\n        this._month = month;\n    }\n\n    /**\n     * function overloading for {@link YearMonth.isSupported}\n     *\n     * if called with 1 argument and first argument is an instance of TemporalField, then {@link YearMonth.isSupportedField} is executed,\n     *\n     * otherwise {@link YearMonth.isSupportedUnit} is executed\n     *\n     * @param {!(TemporalField|ChronoUnit)} fieldOrUnit\n     * @returns {boolean}\n     */\n    isSupported(fieldOrUnit) {\n        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n            return this.isSupportedField(fieldOrUnit);\n        } else {\n            return this.isSupportedUnit(fieldOrUnit);\n        }\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this year-month can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link MONTH_OF_YEAR}\n     * * {@link EPOCH_MONTH}\n     * * {@link YEAR_OF_ERA}\n     * * {@link YEAR}\n     * * {@link ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this year-month, false if not\n     */\n    isSupportedField(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR ||\n                    field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    isSupportedUnit(unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n        }\n        return unit != null && unit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This year-month is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field === ChronoField.YEAR_OF_ERA) {\n            return (this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year-month as an `int`.\n     *\n     * This queries this year-month for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year-month, except {@link EPOCH_MONTH} which is too\n     * large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year-month as a `long`.\n     *\n     * This queries this year-month for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year-month.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong( field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.MONTH_OF_YEAR: return this._month;\n                case ChronoField.PROLEPTIC_MONTH: return this._getProlepticMonth();\n                case ChronoField.YEAR_OF_ERA: return (this._year < 1 ? 1 - this._year : this._year);\n                case ChronoField.YEAR: return this._year;\n                case ChronoField.ERA: return (this._year < 1 ? 0 : 1);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    _getProlepticMonth() {\n        return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), (this._month - 1));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     *\n     * This method returns the primitive `int` value for the year.\n     *\n     * The year returned by this method is proleptic as per {@link get}.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._year;\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    monthValue() {\n        return this._month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use {@link Month#getValue}.\n     *\n     * @return {Month} the month-of-year, not null\n     */\n    month() {\n        return Month.of(this._month);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    isLeapYear() {\n        return IsoChronology.isLeapYear(this._year);\n    }\n\n    /**\n     * Checks if the day-of-month is valid for this year-month.\n     *\n     * This method checks whether this year and month and the input day form\n     * a valid date.\n     *\n     * @param {number} dayOfMonth  the day-of-month to validate, from 1 to 31, invalid value returns false\n     * @return {boolean} true if the day is valid for this year-month\n     */\n    isValidDay(dayOfMonth) {\n        return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();\n    }\n\n    /**\n     * Returns the length of the month, taking account of the year.\n     *\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return {number} the length of the month in days, from 28 to 31\n     */\n    lengthOfMonth() {\n        return this.month().length(this.isLeapYear());\n    }\n\n    /**\n     * Returns the length of the year.\n     *\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return {number} 366 if the year is leap, 365 otherwise\n     */\n    lengthOfYear() {\n        return (this.isLeapYear() ? 366 : 365);\n    }\n\n    /**\n     * function overloading for {@link YearMonth.with}\n     *\n     * if called with 1 argument, then {@link YearMonth.withAdjuster} is executed,\n     *\n     * if called with 2 arguments and first argument is an instance of TemporalField, then {@link YearMonth.withFieldValue} is executed,\n     *\n     * otherwise {@link YearMonth.withYearMonth} is executed\n     *\n     * @param {!(TemporalAdjuster|TemporalField|Number)} adjusterOrFieldOrNumber\n     * @param {?number} value nullable only of first argument is an instance of TemporalAdjuster\n     * @returns {YearMonth}\n     */\n    with(adjusterOrFieldOrNumber, value) {\n        if (arguments.length === 1) {\n            return this.withAdjuster(adjusterOrFieldOrNumber);\n        } else if (arguments.length === 2 && adjusterOrFieldOrNumber instanceof TemporalField){\n            return this.withFieldValue(adjusterOrFieldOrNumber, value);\n        } else {\n            return this.withYearMonth(adjusterOrFieldOrNumber, value);\n        }\n    }\n\n    /**\n     * Returns a copy of this year-month with the new year and month, checking\n     * to see if a new object is in fact required.\n     *\n     * @param {number} newYear  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param {number} newMonth  the month-of-year to represent, validated not null\n     * @return the year-month, not null\n     */\n    withYearMonth(newYear, newMonth) {\n        requireNonNull(newYear);\n        requireNonNull(newMonth);\n        if (this._year === newYear && this._month === newMonth) {\n            return this;\n        }\n        return new YearMonth(newYear, newMonth);\n    }\n\n    /**\n     * Returns an adjusted copy of this year-month.\n     *\n     * This returns a new {@link YearMonth}, based on this one, with the year-month adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the year-month to the next month that\n     * Halley's comet will pass the Earth.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster the adjuster to use, not null\n     * @return {YearMonth} based on `this` with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified field set to a new value.\n     *\n     * This returns a new {@link YearMonth}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year or month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link MONTH_OF_YEAR} -\n     *   Returns a {@link YearMonth} with the specified month-of-year.\n     *   The year will be unchanged.\n     * * {@link PROLEPTIC_MONTH} -\n     *   Returns a {@link YearMonth} with the specified proleptic-month.\n     *   This completely replaces the year and month of this object.\n     * * {@link YEAR_OF_ERA} -\n     *   Returns a {@link YearMonth} with the specified year-of-era\n     *   The month and era will be unchanged.\n     * * {@link YEAR} -\n     *   Returns a {@link YearMonth} with the specified year.\n     *   The month will be unchanged.\n     * * {@link ERA} -\n     *   Returns a {@link YearMonth} with the specified era.\n     *   The month and year-of-era will be unchanged.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field  the field to set in the result, not null\n     * @param {number} newValue  the new value of the field in the result\n     * @return a {@link YearMonth} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withFieldValue(field, newValue) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            let f = field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case ChronoField.MONTH_OF_YEAR: return this.withMonth(newValue);\n                case ChronoField.PROLEPTIC_MONTH: return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n                case ChronoField.YEAR_OF_ERA: return this.withYear((this._year < 1 ? 1 - newValue : newValue));\n                case ChronoField.YEAR: return this.withYear(newValue);\n                case ChronoField.ERA: return (this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link YearMonth} with the year altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year  the year to set in the returned year-month, from MIN_YEAR to MAX_YEAR\n     * @return {YearMonth} based on this year-month with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    withYear(year) {\n        ChronoField.YEAR.checkValidValue(year);\n        return this.withYearMonth(year, this._month);\n    }\n\n    /**\n     * Returns a copy of this {@link YearMonth} with the month-of-year altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} month  the month-of-year to set in the returned year-month, from 1 (January) to 12 (December)\n     * @return {YearMonth} based on this year-month with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        return this.withYearMonth(this._year, month);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.plus}\n     *\n     * if called with 1 arguments, then {@link YearMonth.plusAmount} is executed.\n     *\n     * Otherwise {@link YearMonth.plusAmountUnit} is executed.\n     *\n     * @param {!(TemporalAmount|number)} amountOrNumber\n     * @param {?TemporalUnit} unit nullable only if first argument is an instance of TemporalAmount\n     * @returns {YearMonth}\n     */\n    plus(amountOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.plusAmount(amountOrNumber);\n        } else {\n            return this.plusAmountUnit(amountOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period added.\n     *\n     * This method returns a new year-month based on this year-month with the specified period added.\n     * The adder is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link plus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount  the amount to add, not null\n     * @return {YearMonth} based on this year-month with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmount(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * @param {number} amountToAdd\n     * @param {TemporalUnit} unit\n     * @return {YearMonth} based on this year-month with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmountUnit(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.MONTHS: return this.plusMonths(amountToAdd);\n                case ChronoUnit.YEARS: return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS: return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period in years added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToAdd  the years to add, may be negative\n     * @return {YearMonth} based on this year-month with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        let newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);  // safe overflow\n        return this.withYearMonth(newYear, this._month);\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period in months added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToAdd  the months to add, may be negative\n     * @return {YearMonth} based on this year-month with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        let monthCount = (this._year * 12) + (this._month - 1);\n        let calcMonths = monthCount + monthsToAdd;\n        let newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n        let newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n        return this.withYearMonth(newYear, newMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.minus}\n     *\n     * if called with 1 arguments, then {@link YearMonth.minusAmount} is executed.\n     *\n     * Otherwise {@link YearMonth.minusAmountUnit} is executed.\n     *\n     * @param {!(TemporalAmount|number)} amountOrNumber\n     * @param {?TemporalUnit} unit\n     * @returns {YearMonth}\n     */\n    minus(amountOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.minusAmount(amountOrNumber);\n        } else {\n            return this.minusAmountUnit(amountOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period subtracted.\n     *\n     * This method returns a new year-month based on this year-month with the specified period subtracted.\n     * The subtractor is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount  the amount to subtract, not null\n     * @return {YearMonth} based on this year-month with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * @param {number} amountToSubtract  the amount to subtract, not null\n     * @param {TemporalUnit} unit\n     * @return {YearMonth} based on this year-month with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmountUnit(amountToSubtract, unit) {\n        return (amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusAmountUnit(MathUtil.MAX_SAFE_INTEGER, unit).plusAmountUnit(1, unit) : this.plusAmountUnit(-amountToSubtract, unit));\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period in years subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToSubtract  the years to subtract, may be negative\n     * @return {YearMonth} based on this year-month with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    minusYears(yearsToSubtract) {\n        return (yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period in months subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToSubtract  the months to subtract, may be negative\n     * @return {YearMonth} based on this year-month with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    minusMonths(monthsToSubtract) {\n        return (monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this year-month using the specified query.\n     *\n     * This queries this year-month using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        requireInstance(query, TemporalQuery, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.MONTHS;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this year-month.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the year and month changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#PROLEPTIC_MONTH} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisYearMonth.adjustInto(temporal);\n     *   temporal = temporal.with(thisYearMonth);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        requireInstance(temporal, Temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n        if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) == false) {\n            throw new DateTimeException(\"Adjustment only supported on ISO date-time\");\n        }*/\n        return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());\n    }\n\n    /**\n     * Calculates the period between this year-month and another year-month in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two year-months in terms of a single unit.\n     * The start and end points are `this` and the specified year-month.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link YearMonth}.\n     * For example, the period in years between two year-months can be calculated\n     * using {@link startYearMonth.until}.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two year-months.\n     * For example, the period in decades between 2012-06 and 2032-05\n     * will only be one decade as it is one month short of two decades.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, YEARS);   // this method\n     *   dateTime.plus(YEARS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link MONTHS}, {@link YEARS}, {@link DECADES},\n     * {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive  the end year-month, which is converted to a {@link YearMonth}, not null\n     * @param {TemporalUnit} unit  the unit to measure the period in, not null\n     * @return {number} the amount of the period between this year-month and the end year-month\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        requireInstance(endExclusive, Temporal, 'endExclusive');\n        requireInstance(unit, TemporalUnit, 'unit');\n\n        let end = YearMonth.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            let monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();  // no overflow\n            switch (unit) {\n                case ChronoUnit.MONTHS: return monthsUntil;\n                case ChronoUnit.YEARS: return monthsUntil / 12;\n                case ChronoUnit.DECADES: return monthsUntil / 120;\n                case ChronoUnit.CENTURIES: return monthsUntil / 1200;\n                case ChronoUnit.MILLENNIA: return monthsUntil / 12000;\n                case ChronoUnit.ERAS: return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this year-month with a day-of-month to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this year-month and the specified day-of-month.\n     *\n     * The day-of-month value must be valid for the year-month.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atDay(day);\n     * </pre>\n     *\n     * @param {number} dayOfMonth  the day-of-month to use, from 1 to 31\n     * @return {LocalDate} the date formed from this year-month and the specified day, not null\n     * @throws DateTimeException if the day is invalid for the year-month\n     * @see #isValidDay(int)\n     */\n    atDay(dayOfMonth) {\n        return LocalDate.of(this._year, this._month, dayOfMonth);\n    }\n\n    /**\n     * Returns a {@link LocalDate} at the end of the month.\n     *\n     * This returns a {@link LocalDate} based on this year-month.\n     * The day-of-month is set to the last valid day of the month, taking\n     * into account leap years.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atEndOfMonth();\n     * </pre>\n     *\n     * @return {LocalDate} the last valid date of this year-month, not null\n     */\n    atEndOfMonth() {\n        return LocalDate.of(this._year, this._month, this.lengthOfMonth());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this year-month to another year-month.\n     *\n     * The comparison is based first on the value of the year, then on the value of the month.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {YearMonth} other  the other year-month to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, YearMonth, 'other');\n        let cmp = (this._year - other.year());\n        if (cmp === 0) {\n            cmp = (this._month - other.monthValue());\n        }\n        return cmp;\n    }\n\n    /**\n     * Is this year-month after the specified year-month.\n     *\n     * @param {YearMonth} other  the other year-month to compare to, not null\n     * @return {boolean} true if this is after the specified year-month\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Is this year-month before the specified year-month.\n     *\n     * @param {YearMonth} other  the other year-month to compare to, not null\n     * @return {boolean} true if this point is before the specified year-month\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this year-month is equal to another year-month.\n     *\n     * The comparison is based on the time-line position of the year-months.\n     *\n     * @param {*} obj  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other year-month\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof YearMonth) {\n            let other = obj;\n            return this.year() === other.year() && this.monthValue() === other.monthValue();\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this year-month as a string, such as `2007-12`.\n     *\n     * The output will be in the format {@link yyyy-MM}:\n     *\n     * @return {String} a string representation of this year-month, not null\n     */\n    toString() {\n        return PARSER.format(this);\n    }\n\n    /**\n     * Outputs this year-month as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted year-month string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n}\n\nlet PARSER;\n\nexport function _init() {\n\n    PARSER = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendLiteral('-')\n        .appendValue(ChronoField.MONTH_OF_YEAR, 2)\n        .toFormatter();\n\n    YearMonth.FROM = createTemporalQuery('YearMonth.FROM', (temporal) => {\n        return YearMonth.from(temporal);\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/YearMonth.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {IllegalStateException} from '../errors';\n\nimport {TemporalAdjuster} from './TemporalAdjuster';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {MathUtil} from '../MathUtil';\n\n/**\n * Common implementations of {@link TemporalAdjuster}.\n *\n * This class provides common implementations of {@link TemporalAdjuster}.\n * They are especially useful to document the intent of business logic and\n * often link well to requirements.\n * For example, these two pieces of code do the same thing, but the second\n * one is clearer (assuming that there is a static import of this class):\n * <pre>\n *  // direct manipulation\n *  date.withDayOfMonth(1).plusMonths(1).minusDays(1);\n *  // use of an adjuster from this class\n *  date.with(lastDayOfMonth());\n * </pre>\n * There are two equivalent ways of using a {@link TemporalAdjuster}.\n * The first is to invoke the method on the interface directly.\n * The second is to use {@link Temporal#with}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   dateTime = adjuster.adjustInto(dateTime);\n *   dateTime = dateTime.with(adjuster);\n * </pre>\n * It is recommended to use the second approach, {@link with},\n * as it is a lot clearer to read in code.\n *\n * ### Specification for implementors\n *\n * This is a thread-safe utility class.\n * All returned adjusters are immutable and thread-safe.\n *\n * The JDK 8 ofDateAdjuster(UnaryOperator) method is not backported.\n */\nexport class TemporalAdjusters {\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the 'first day of month' adjuster, which returns a new date set to\n     * the first day of the current month.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-01-01.\n     * * The input 2011-02-15 will return 2011-02-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_MONTH, 1);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day-of-month adjuster, not null\n     */\n    static firstDayOfMonth() {\n        return Impl.FIRST_DAY_OF_MONTH;\n    }\n\n    /**\n     * Returns the 'last day of month' adjuster, which returns a new date set to\n     * the last day of the current month.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-01-31.\n     * * The input 2011-02-15 will return 2011-02-28.\n     * * The input 2012-02-15 will return 2012-02-29 (leap year).\n     * * The input 2011-04-15 will return 2011-04-30.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  long lastDay = temporal.range(DAY_OF_MONTH).getMaximum();\n     *  temporal.with(DAY_OF_MONTH, lastDay);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the last day-of-month adjuster, not null\n     */\n    static lastDayOfMonth() {\n        return Impl.LAST_DAY_OF_MONTH;\n    }\n\n    /**\n     * Returns the 'first day of next month' adjuster, which returns a new date set to\n     * the first day of the next month.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-02-01.\n     * * The input 2011-02-15 will return 2011-03-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_MONTH, 1).plus(1, MONTHS);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day of next month adjuster, not null\n     */\n    static firstDayOfNextMonth() {\n        return Impl.FIRST_DAY_OF_NEXT_MONTH;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the 'first day of year' adjuster, which returns a new date set to\n     * the first day of the current year.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-01-01.\n     * * The input 2011-02-15 will return 2011-01-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_YEAR, 1);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day-of-year adjuster, not null\n     */\n    static firstDayOfYear() {\n        return Impl.FIRST_DAY_OF_YEAR;\n    }\n\n    /**\n     * Returns the 'last day of year' adjuster, which returns a new date set to\n     * the last day of the current year.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-12-31.\n     * * The input 2011-02-15 will return 2011-12-31.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  long lastDay = temporal.range(DAY_OF_YEAR).getMaximum();\n     *  temporal.with(DAY_OF_YEAR, lastDay);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the last day-of-year adjuster, not null\n     */\n    static lastDayOfYear() {\n        return Impl.LAST_DAY_OF_YEAR;\n    }\n\n    /**\n     * Returns the 'first day of next year' adjuster, which returns a new date set to\n     * the first day of the next year.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2012-01-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_YEAR, 1).plus(1, YEARS);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day of next month adjuster, not null\n     */\n    static firstDayOfNextYear() {\n        return Impl.FIRST_DAY_OF_NEXT_YEAR;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the first in month adjuster, which returns a new date\n     * in the same month with the first matching day-of-week.\n     * This is used for expressions like 'first Tuesday in March'.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-12-15 for (MONDAY) will return 2011-12-05.\n     * * The input 2011-12-15 for (FRIDAY) will return 2011-12-02.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\n     * and the {@link DAYS} unit, and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the first in month adjuster, not null\n     */\n    static firstInMonth(dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(1, dayOfWeek);\n    }\n\n    /**\n     * Returns the last in month adjuster, which returns a new date\n     * in the same month with the last matching day-of-week.\n     * This is used for expressions like 'last Tuesday in March'.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-12-15 for (MONDAY) will return 2011-12-26.\n     * * The input 2011-12-15 for (FRIDAY) will return 2011-12-30.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\n     * and the {@link DAYS} unit, and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the first in month adjuster, not null\n     */\n    static lastInMonth(dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(-1, dayOfWeek);\n    }\n\n    /**\n     * Returns the day-of-week in month adjuster, which returns a new date\n     * in the same month with the ordinal day-of-week.\n     * This is used for expressions like the 'second Tuesday in March'.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-12-15 for (1,TUESDAY) will return 2011-12-06.\n     * * The input 2011-12-15 for (2,TUESDAY) will return 2011-12-13.\n     * * The input 2011-12-15 for (3,TUESDAY) will return 2011-12-20.\n     * * The input 2011-12-15 for (4,TUESDAY) will return 2011-12-27.\n     * * The input 2011-12-15 for (5,TUESDAY) will return 2012-01-03.\n     * * The input 2011-12-15 for (-1,TUESDAY) will return 2011-12-27 (last in month).\n     * * The input 2011-12-15 for (-4,TUESDAY) will return 2011-12-06 (3 weeks before last in month).\n     * * The input 2011-12-15 for (-5,TUESDAY) will return 2011-11-29 (4 weeks before last in month).\n     * * The input 2011-12-15 for (0,TUESDAY) will return 2011-11-29 (last in previous month).\n     *\n     * For a positive or zero ordinal, the algorithm is equivalent to finding the first\n     * day-of-week that matches within the month and then adding a number of weeks to it.\n     * For a negative ordinal, the algorithm is equivalent to finding the last\n     * day-of-week that matches within the month and then subtracting a number of weeks to it.\n     * The ordinal number of weeks is not validated and is interpreted leniently\n     * according to this algorithm. This definition means that an ordinal of zero finds\n     * the last matching day-of-week in the previous month.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\n     * and the {@link DAYS} unit, and assumes a seven day week.\n     *\n     * @param {Number} ordinal  the week within the month, unbounded but typically from -5 to 5\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the day-of-week in month adjuster, not null\n     */\n    static dayOfWeekInMonth(ordinal, dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(ordinal, dayOfWeek);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the next day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week after the date being adjusted.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (seven days later).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to move the date to, not null\n     * @return {TemporalAdjuster} the next day-of-week adjuster, not null\n     */\n    static next(dayOfWeek) {\n        return new RelativeDayOfWeek(2, dayOfWeek);\n    }\n\n    /**\n     * Returns the next-or-same day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week after the date being adjusted\n     * unless it is already on that day in which case the same object is returned.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to check for or move the date to, not null\n     * @return {TemporalAdjuster} the next-or-same day-of-week adjuster, not null\n     */\n    static nextOrSame(dayOfWeek) {\n        return new RelativeDayOfWeek(0, dayOfWeek);\n    }\n\n    /**\n     * Returns the previous day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week before the date being adjusted.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (seven days earlier).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to move the date to, not null\n     * @return {TemporalAdjuster} the previous day-of-week adjuster, not null\n     */\n    static previous(dayOfWeek) {\n        return new RelativeDayOfWeek(3, dayOfWeek);\n    }\n\n    /**\n     * Returns the previous-or-same day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week before the date being adjusted\n     * unless it is already on that day in which case the same object is returned.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek the day-of-week to check for or move the date to, not null\n     * @return {TemporalAdjuster} the previous-or-same day-of-week adjuster, not null\n     */\n    static previousOrSame(dayOfWeek) {\n        return new RelativeDayOfWeek(1, dayOfWeek);\n    }\n\n}\n\n//-----------------------------------------------------------------------\n/**\n * Enum implementing the adjusters.\n */\nclass Impl extends TemporalAdjuster {\n\n    constructor(ordinal) {\n        super();\n        this._ordinal = ordinal;\n    }\n\n    adjustInto(temporal) {\n        switch (this._ordinal) {\n            case 0: return temporal.with(ChronoField.DAY_OF_MONTH, 1);\n            case 1: return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n            case 2: return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);\n            case 3: return temporal.with(ChronoField.DAY_OF_YEAR, 1);\n            case 4: return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());\n            case 5: return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);\n        }\n        throw new IllegalStateException('Unreachable');\n    }\n\n}\n\n/** First day of month adjuster. */\nImpl.FIRST_DAY_OF_MONTH = new Impl(0);\n/** Last day of month adjuster. */\nImpl.LAST_DAY_OF_MONTH = new Impl(1);\n/** First day of next month adjuster. */\nImpl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);\n/** First day of year adjuster. */\nImpl.FIRST_DAY_OF_YEAR = new Impl(3);\n/** Last day of year adjuster. */\nImpl.LAST_DAY_OF_YEAR = new Impl(4);\n/** First day of next month adjuster. */\nImpl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);\n\n\n/**\n * Class implementing day-of-week in month adjuster.\n */\nclass DayOfWeekInMonth extends TemporalAdjuster {\n\n    constructor(ordinal, dow) {\n        super();\n        this._ordinal = ordinal;\n        this._dowValue = dow.value();\n    }\n\n    adjustInto(temporal) {\n        if (this._ordinal >= 0) {\n            let temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);\n            let curDow = temp.get(ChronoField.DAY_OF_WEEK);\n            let dowDiff = MathUtil.intMod((this._dowValue - curDow + 7), 7);\n            dowDiff += (this._ordinal - 1) * 7;  // safe from overflow\n            return temp.plus(dowDiff, ChronoUnit.DAYS);\n        } else {\n            let temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n            let curDow = temp.get(ChronoField.DAY_OF_WEEK);\n            let daysDiff = this._dowValue - curDow;\n            daysDiff = (daysDiff === 0 ? 0 : (daysDiff > 0 ? daysDiff - 7 : daysDiff));\n            daysDiff -= (-this._ordinal - 1) * 7;  // safe from overflow\n            return temp.plus(daysDiff, ChronoUnit.DAYS);\n        }\n    }\n}\n\n/**\n * Implementation of next, previous or current day-of-week.\n */\nclass RelativeDayOfWeek extends TemporalAdjuster {\n\n    constructor(relative, dayOfWeek) {\n        super();\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        /** Whether the current date is a valid answer. */\n        this._relative = relative;\n        /** The day-of-week value, from 1 to 7. */\n        this._dowValue = dayOfWeek.value();\n    }\n\n    adjustInto(temporal) {\n        const calDow = temporal.get(ChronoField.DAY_OF_WEEK);\n        if (this._relative < 2 && calDow === this._dowValue) {\n            return temporal;\n        }\n        if ((this._relative & 1) === 0) {\n            let daysDiff = calDow - this._dowValue;\n            return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n        } else {\n            let daysDiff = this._dowValue - calDow;\n            return temporal.minus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/TemporalAdjusters.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {abstractMethodFail} from '../assert';\n\n/**\n * Strategy for adjusting a temporal object.\n *\n * Adjusters are a key tool for modifying temporal objects.\n * They exist to externalize the process of adjustment, permitting different\n * approaches, as per the strategy design pattern.\n * Examples might be an adjuster that sets the date avoiding weekends, or one that\n * sets the date to the last day of the month.\n *\n * There are two equivalent ways of using a {@link TemporalAdjuster}.\n * The first is to invoke the method on this interface directly.\n * The second is to use {@link Temporal#with}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   temporal = thisAdjuster.adjustInto(temporal);\n *   temporal = temporal.with(thisAdjuster);\n * </pre>\n * It is recommended to use the second approach, {@link with},\n * as it is a lot clearer to read in code.\n *\n * See {@link TemporalAdjusters} for a standard set of adjusters, including finding the\n * last day of the month.\n * Adjusters may also be defined by applications.\n *\n * ### Specification for implementors\n *\n * This interface places no restrictions on the mutability of implementations,\n * however immutability is strongly recommended.\n *\n * @interface\n */\nexport class TemporalAdjuster {\n\n    /**\n     * Adjusts the specified temporal object.\n     *\n     * This adjusts the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     * Examples might be an adjuster that sets the date avoiding weekends, or one that\n     * sets the date to the last day of the month.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisAdjuster.adjustInto(temporal);\n     *   temporal = temporal.with(thisAdjuster);\n     * </pre>\n     * It is recommended to use the second approach, {@link with},\n     * as it is a lot clearer to read in code.\n     *\n     * ### Specification for implementors\n     *\n     * The implementation must take the input object and adjust it.\n     * The implementation defines the logic of the adjustment and is responsible for\n     * documenting that logic. It may use any method on {@link Temporal} to\n     * query the temporal object and perform the adjustment.\n     * The returned object must have the same observable type as the input object\n     *\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal  the temporal object to adjust, not null\n     * @return {Temporal} an object of the same observable type with the adjustment made, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     *\n     * @abstract\n     */\n    // eslint-disable-next-line no-unused-vars\n    adjustInto(temporal){\n        abstractMethodFail('adjustInto');\n    }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/TemporalAdjuster.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from './assert';\nimport {DateTimeException, IllegalArgumentException} from './errors';\n\nimport {Clock} from './Clock';\nimport {Instant} from './Instant';\nimport {LocalDate} from './LocalDate';\nimport {LocalDateTime} from './LocalDateTime';\nimport {LocalTime} from './LocalTime';\nimport {ZoneId} from './ZoneId';\nimport {ZoneOffset} from './ZoneOffset';\n\nimport {ChronoZonedDateTime} from './chrono/ChronoZonedDateTime';\nimport {DateTimeFormatter} from './format/DateTimeFormatter';\nimport {ChronoField} from './temporal/ChronoField';\nimport {ChronoUnit} from './temporal/ChronoUnit';\nimport {createTemporalQuery} from './temporal/TemporalQuery';\nimport {TemporalQueries} from './temporal/TemporalQueries';\n\n/**\n * A date-time with a time-zone in the ISO-8601 calendar system,\n * such as `2007-12-03T10:15:30+01:00 Europe/Paris`.\n *\n * `ZonedDateTime` is an immutable representation of a date-time with a time-zone.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * and a time-zone, with a zone offset used to handle ambiguous local date-times.\n * For example, the value\n * '2nd October 2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone'\n * can be stored in a {@link ZonedDateTime}.\n *\n * This class handles conversion from the local time-line of {@link LocalDateTime}\n * to the instant time-line of {@link Instant}.\n * The difference between the two time-lines is the offset from UTC/Greenwich,\n * represented by a {@link ZoneOffset}.\n *\n * Converting between the two time-lines involves calculating the offset using the\n * {@link ZoneRules} rules accessed from the {@link ZoneId}.\n * Obtaining the offset for an instant is simple, as there is exactly one valid\n * offset for each instant. By contrast, obtaining the offset for a local date-time\n * is not straightforward. There are three cases:\n *\n * * Normal, with one valid offset. For the vast majority of the year, the normal\n *   case applies, where there is a single valid offset for the local date-time.\n * * Gap, with zero valid offsets. This is when clocks jump forward typically\n *   due to the spring daylight savings change from 'winter' to 'summer'.\n *   In a gap there are local date-time values with no valid offset.\n * * Overlap, with two valid offsets. This is when clocks are set back typically\n *   due to the autumn daylight savings change from 'summer' to 'winter'.\n *   In an overlap there are local date-time values with two valid offsets.\n *\n * Any method that converts directly or implicitly from a local date-time to an\n * instant by obtaining the offset has the potential to be complicated.\n *\n * For Gaps, the general strategy is that if the local date-time falls in the\n * middle of a Gap, then the resulting zoned date-time will have a local date-time\n * shifted forwards by the length of the Gap, resulting in a date-time in the later\n * offset, typically 'summer' time.\n *\n * For Overlaps, the general strategy is that if the local date-time falls in the\n * middle of an Overlap, then the previous offset will be retained. If there is no\n * previous offset, or the previous offset is invalid, then the earlier offset is\n * used, typically 'summer' time. Two additional methods,\n * {@link withEarlierOffsetAtOverlap} and {@link withLaterOffsetAtOverlap},\n * help manage the case of an overlap.\n *\n * ### Specification for implementors\n *\n * A {@link ZonedDateTime} holds state equivalent to three separate objects,\n * a {@link LocalDateTime}, a {@link ZoneId} and the resolved {@link ZoneOffset}.\n * The offset and local date-time are used to define an instant when necessary.\n * The zone ID is used to obtain the rules for how and when the offset changes.\n * The offset cannot be freely set, as the zone controls which offsets are valid.\n */\nexport class ZonedDateTime extends ChronoZonedDateTime {\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone or clock\n     * or default time zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current date-time.\n     * The zone and offset will be set based on the time-zone in the clock.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {Clock|ZoneId} [clockOrZone=Clock.systemDefaultZone()]\n     * @return {ZonedDateTime} the current date-time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        let clock;\n        if(clockOrZone instanceof ZoneId){\n            clock = Clock.system(clockOrZone);\n        } else {\n            clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;\n        }\n        return ZonedDateTime.ofInstant(clock.instant(), clock.zone());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for static {@link ZonedDateTime.of}\n     *\n     * if called with 2 (or less) args {@link ZonedDateTime.of2} is called,\n     * if called with 3 args and the first arg is an instance of LocalDate {@link ZonedDateTime.of3} is called,\n     * otherwise {@link ZonedDateTime.of8} is called.\n     */\n    static of(){\n        if(arguments.length <= 2){\n            return ZonedDateTime.of2.apply(this, arguments);\n        } else if (arguments.length === 3 && arguments[0] instanceof LocalDate){\n            return ZonedDateTime.of3.apply(this, arguments);\n        } else {\n            return ZonedDateTime.of8.apply(this, arguments);\n        }\n    }\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a local date and time.\n     *\n     * This creates a zoned date-time matching the input local date and time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date time and first combined to form a local date-time.\n     * The local date-time is then resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {LocalDate} date - the local date, not null\n     * @param {LocalTime} time - the local time, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the offset date-time, not null\n     */\n    static of3(date, time, zone) {\n        return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a local date-time.\n     *\n     * This creates a zoned date-time matching the input local date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {!LocalDateTime} localDateTime - the local date-time, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static of2(localDateTime, zone) {\n        return ZonedDateTime.ofLocal(localDateTime, zone, null);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and time-zone.\n     *\n     * This creates a zoned date-time matching the local date-time of the seven\n     * specified fields as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@link LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param {number} year - the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} month - the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {number} dayOfMonth - the day-of-month to represent, from 1 to 31\n     * @param {number} hour - the hour-of-day to represent, from 0 to 23\n     * @param {number} minute - the minute-of-hour to represent, from 0 to 59\n     * @param {number} second - the second-of-minute to represent, from 0 to 59\n     * @param {number} nanoOfSecond - the nano-of-second to represent, from 0 to 999,999,999\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime } the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    static of8(\n            year, month, dayOfMonth,\n            hour, minute, second, nanoOfSecond, zone) {\n        const dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return ZonedDateTime.ofLocal(dt, zone, null);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a local date-time\n     * using the preferred offset if possible.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * If the preferred offset is one of the valid offsets then it is used.\n     * Otherwise the earlier valid offset is used, typically corresponding to 'summer'.\n     *\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {!LocalDateTime} localDateTime - the local date-time, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @param {ZoneOffset} preferredOffset - the zone offset, null if no preference\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofLocal(localDateTime, zone, preferredOffset) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(zone, 'zone');\n        if (zone instanceof ZoneOffset) {\n            return new ZonedDateTime(localDateTime, zone, zone);\n        }\n        let offset = null;\n        let rules = zone.rules();\n        let validOffsets = rules.validOffsets(localDateTime);\n        if (validOffsets.length === 1) {\n            offset = validOffsets[0];\n        } else if (validOffsets.length === 0) {\n            let trans = rules.transition(localDateTime);\n            localDateTime = localDateTime.plusSeconds(trans.duration().seconds());\n            offset = trans.offsetAfter();\n        } else {\n            if (preferredOffset != null &&\n                    validOffsets.some((validOffset) => {return validOffset.equals(preferredOffset);})) {\n                offset = preferredOffset;\n            } else {\n                offset = requireNonNull(validOffsets[0], 'offset');  // protect against bad ZoneRules\n            }\n        }\n\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.ofInstant}.\n     * if called with 2 args {@link ZonedDateTime.ofInstant2} is called\n     * otherwise {@link ZonedDateTime.ofInstant3}.\n     */\n    static ofInstant(){\n        if (arguments.length === 2){\n            return ZonedDateTime.ofInstant2.apply(this, arguments);\n        } else {\n            return ZonedDateTime.ofInstant3.apply(this, arguments);\n        }\n    }\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from an {@link Instant}.\n     *\n     * This creates a zoned date-time with the same instant as that specified.\n     * Calling {@link toInstant} will return an instant equal to the one used here.\n     *\n     * Converting an instant to a zoned date-time is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param {!Instant} instant - the instant to create the date-time from, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    static ofInstant2(instant, zone) {\n        requireNonNull(instant, 'instant');\n        requireNonNull(zone, 'zone');\n        return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from the instant formed by combining\n     * the local date-time and offset.\n     *\n     * This creates a zoned date-time by combining the {@link LocalDateTime} and {@link ZoneOffset}.\n     * This combination uniquely specifies an instant without ambiguity.\n     *\n     * Converting an instant to a zoned date-time is simple as there is only one valid\n     * offset for each instant. If the valid offset is different to the offset specified,\n     * the the date-time and offset of the zoned date-time will differ from those specified.\n     *\n     * If the {@link ZoneId} to be used is a {@link ZoneOffset}, this method is equivalent\n     * to {@link of}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofInstant3(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * @param {number} epochSecond - the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param {number} nanoOfSecond - the nanosecond within the second, from 0 to 999,999,999\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    static _create(epochSecond, nanoOfSecond, zone) {\n        const rules = zone.rules();\n        const instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);  // TODO: rules should be queryable by epochSeconds\n        const offset = rules.offset(instant);\n        const ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);\n        return new ZonedDateTime(ldt, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZonedDateTime} strictly validating the\n     * combination of local date-time, offset and zone ID.\n     *\n     * This creates a zoned date-time ensuring that the offset is valid for the\n     * local date-time according to the rules of the specified zone.\n     * If the offset is invalid, an exception is thrown.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofStrict(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        const rules = zone.rules();\n        if (rules.isValidOffset(localDateTime, offset) === false) {\n            const trans = rules.transition(localDateTime);\n            if (trans != null && trans.isGap()) {\n                // error message says daylight savings for simplicity\n                // even though there are other kinds of gaps\n                throw new DateTimeException('LocalDateTime ' + localDateTime +\n                        ' does not exist in zone ' + zone +\n                        ' due to a gap in the local time-line, typically caused by daylight savings');\n            }\n            throw new DateTimeException('ZoneOffset \"' + offset + '\" is not valid for LocalDateTime \"' +\n                localDateTime + '\" in zone \"' + zone + '\"');\n        }\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} leniently, for advanced use cases,\n     * allowing any combination of local date-time, offset and zone ID.\n     *\n     * This creates a zoned date-time with no checks other than no nulls.\n     * This means that the resulting zoned date-time may have an offset that is in conflict\n     * with the zone ID.\n     *\n     * This method is intended for advanced use cases.\n     * For example, consider the case where a zoned date-time with valid fields is created\n     * and then stored in a database or serialization-based store. At some later point,\n     * the object is then re-loaded. However, between those points in time, the government\n     * that defined the time-zone has changed the rules, such that the originally stored\n     * local date-time now does not occur. This method can be used to create the object\n     * in an 'invalid' state, despite the change in rules.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofLenient(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        if (zone instanceof ZoneOffset && offset.equals(zone) === false) {\n            throw new IllegalArgumentException('ZoneId must match ZoneOffset');\n        }\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link ZonedDateTime}.\n     *\n     * The conversion will first obtain a {@link ZoneId}. It will then try to obtain an instant.\n     * If that fails it will try to obtain a local date-time.\n     * The zoned date time will either be a combination of {@link ZoneId} and instant,\n     * or {@link ZoneId} and local date-time.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link ZonedDateTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if unable to convert to an {@link ZonedDateTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof ZonedDateTime) {\n            return temporal;\n        }\n        const zone = ZoneId.from(temporal);\n        if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {\n            const zdt = ZonedDateTime._from(temporal, zone);\n            if(zdt != null) return zdt;\n        }\n        const ldt = LocalDateTime.from(temporal);\n        return ZonedDateTime.of2(ldt, zone);\n    }\n\n    static _from(temporal, zone){\n        try {\n            return ZonedDateTime.__from(temporal, zone);\n        } catch (ex) {\n            if(!(ex instanceof DateTimeException)) throw ex;\n            // ignore\n        }\n    }\n\n    static __from(temporal, zone){\n        const epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);\n        const nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n        return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a text string such as\n     * `2007-12-03T10:15:30+01:00[Europe/Paris]`.\n     *\n     * The string must represent a valid date-time and is parsed using\n     * {@link org.threeten.bp.format.DateTimeFormatter#ISO_ZONED_DATE_TIME}.\n     *\n     * @param {!string} text - the text to parse such as '2007-12-03T10:15:30+01:00[Europe/Paris]', not null\n     * @param {!DateTimeFormatter} [formatter=DateTimeFormatter.ISO_ZONED_DATE_TIME] - the formatter to use\n     * @return {ZonedDateTime} the parsed zoned date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME) {\n        requireNonNull(formatter, 'fromatter');\n        return formatter.parse(text, ZonedDateTime.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {LocalDateTime} dateTime - the date-time, validated as not null\n     * @param {ZoneOffset} offset - the zone offset, validated as not null\n     * @param {ZoneUd} zone - the time-zone, validated as not null\n     */\n    constructor(dateTime, offset, zone) {\n        requireNonNull(dateTime, 'dateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n\n        super();\n\n        /**\n         * The local date-time.\n         */\n        this._dateTime = dateTime;\n        /**\n         * The offset from UTC/Greenwich.\n         */\n        this._offset = offset;\n        /**\n         * The time-zone.\n         */\n        this._zone = zone;\n    }\n\n    /**\n     * Resolves the new local date-time using this zone ID, retaining the offset if possible.\n     *\n     * @param {LocalDateTime} newDateTime - the new local date-time, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveLocal(newDateTime) {\n        requireNonNull(newDateTime, 'newDateTime');\n        return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);\n    }\n\n    /**\n     * Resolves the new local date-time using the offset to identify the instant.\n     *\n     * @param {LocalDateTime} newDateTime - the new local date-time, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveInstant(newDateTime) {\n        return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);\n    }\n\n    /**\n     * Resolves the offset into this zoned date-time.\n     *\n     * This ignores the offset, unless it can be used in an overlap.\n     *\n     * @param {ZoneOffset} offset - the offset, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveOffset(offset) {\n        if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {\n            return new ZonedDateTime(this._dateTime, offset, this._zone);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link NANO_OF_SECOND}\n     * * {@link NANO_OF_DAY}\n     * * {@link MICRO_OF_SECOND}\n     * * {@link MICRO_OF_DAY}\n     * * {@link MILLI_OF_SECOND}\n     * * {@link MILLI_OF_DAY}\n     * * {@link SECOND_OF_MINUTE}\n     * * {@link SECOND_OF_DAY}\n     * * {@link MINUTE_OF_HOUR}\n     * * {@link MINUTE_OF_DAY}\n     * * {@link HOUR_OF_AMPM}\n     * * {@link CLOCK_HOUR_OF_AMPM}\n     * * {@link HOUR_OF_DAY}\n     * * {@link CLOCK_HOUR_OF_DAY}\n     * * {@link AMPM_OF_DAY}\n     * * {@link DAY_OF_WEEK}\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * * {@link DAY_OF_MONTH}\n     * * {@link DAY_OF_YEAR}\n     * * {@link EPOCH_DAY}\n     * * {@link ALIGNED_WEEK_OF_MONTH}\n     * * {@link ALIGNED_WEEK_OF_YEAR}\n     * * {@link MONTH_OF_YEAR}\n     * * {@link EPOCH_MONTH}\n     * * {@link YEAR_OF_ERA}\n     * * {@link YEAR}\n     * * {@link ERA}\n     * * {@link INSTANT_SECONDS}\n     * * {@link OFFSET_SECONDS}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date-time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if(fieldOrUnit instanceof ChronoField){\n            return true;\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return (fieldOrUnit != null && fieldOrUnit.isSupportedBy(this));\n    }\n\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n                return field.range();\n            }\n            return this._dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an `int`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time, except {@link NANO_OF_DAY}, {@link MICRO_OF_DAY},\n     * {@link EPOCH_DAY}, {@link EPOCH_MONTH} and {@link INSTANT_SECONDS} which are too\n     * large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a `long`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.INSTANT_SECONDS: return this.toEpochSecond();\n                case ChronoField.OFFSET_SECONDS: return this._offset.totalSeconds();\n            }\n            return this._dateTime.getLong(field);\n        }\n        requireNonNull(field, 'field');\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as '+01:00'.\n     *\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return {ZoneOffset}the zone offset, not null\n     */\n    offset() {\n        return this._offset;\n    }\n\n    /**\n     * Returns a copy of this date-time changing the zone offset to the\n     * earlier of the two valid offsets at a local time-line overlap.\n     *\n     * This method only has any effect when the local time-line overlaps, such as\n     * at an autumn daylight savings cutover. In this scenario, there are two\n     * valid offsets for the local date-time. Calling this method will return\n     * a zoned date-time with the earlier of the two selected.\n     *\n     * If this method is called when it is not an overlap, `this`\n     * is returned.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the earlier offset, not null\n     */\n    withEarlierOffsetAtOverlap() {\n        const trans = this._zone.rules().transition(this._dateTime);\n        if (trans != null && trans.isOverlap()) {\n            const earlierOffset = trans.offsetBefore();\n            if (earlierOffset.equals(this._offset) === false) {\n                return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Returns a copy of this date-time changing the zone offset to the\n     * later of the two valid offsets at a local time-line overlap.\n     *\n     * This method only has any effect when the local time-line overlaps, such as\n     * at an autumn daylight savings cutover. In this scenario, there are two\n     * valid offsets for the local date-time. Calling this method will return\n     * a zoned date-time with the later of the two selected.\n     *\n     * If this method is called when it is not an overlap, `this`\n     * is returned.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the later offset, not null\n     */\n    withLaterOffsetAtOverlap() {\n        const trans = this._zone.rules().transition(this.toLocalDateTime());\n        if (trans != null) {\n            const laterOffset = trans.offsetAfter();\n            if (laterOffset.equals(this._offset) === false) {\n                return new ZonedDateTime(this._dateTime, laterOffset, this._zone);\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the time-zone, such as 'Europe/Paris'.\n     *\n     * This returns the zone ID. This identifies the time-zone {@link ZoneRules}\n     * that determine when and how the offset from UTC/Greenwich changes.\n     *\n     * The zone ID may be same as the offset (see {@link getOffset}).\n     * If this is true, then any future calculations, such as addition or subtraction,\n     * have no complex edge cases due to time-zone rules.\n     * See also {@link withFixedOffsetZone}.\n     *\n     * @return {ZoneId} the time-zone, not null\n     */\n    zone() {\n        return this._zone;\n    }\n\n    /**\n     * Returns a copy of this date-time with a different time-zone,\n     * retaining the local date-time if possible.\n     *\n     * This method changes the time-zone and retains the local date-time.\n     * The local date-time is only changed if it is invalid for the new zone,\n     * determined using the same approach as\n     * {@link ofLocal}.\n     *\n     * To change the zone and adjust the local date-time,\n     * use {@link withZoneSameInstant}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {ZoneId} zone - the time-zone to change to, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested zone, not null\n     */\n    withZoneSameLocal(zone) {\n        requireNonNull(zone, 'zone');\n        return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n    }\n\n    /**\n     * Returns a copy of this date-time with a different time-zone,\n     * retaining the instant.\n     *\n     * This method changes the time-zone and retains the instant.\n     * This normally results in a change to the local date-time.\n     *\n     * This method is based on retaining the same instant, thus gaps and overlaps\n     * in the local time-line have no effect on the result.\n     *\n     * To change the offset while keeping the local time,\n     * use {@link withZoneSameLocal}.\n     *\n     * @param {ZoneId} zone - the time-zone to change to, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested zone, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    withZoneSameInstant(zone) {\n        requireNonNull(zone, 'zone');\n        return this._zone.equals(zone) ? this :\n            ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);\n    }\n\n    /**\n     * Returns a copy of this date-time with the zone ID set to the offset.\n     *\n     * This returns a zoned date-time where the zone ID is the same as {@link getOffset}.\n     * The local date-time, offset and instant of the result will be the same as in this date-time.\n     *\n     * Setting the date-time to a fixed single offset means that any future\n     * calculations, such as addition or subtraction, have no complex edge cases\n     * due to time-zone rules.\n     * This might also be useful when sending a zoned date-time across a network,\n     * as most protocols, such as ISO-8601, only handle offsets,\n     * and not region-based zone IDs.\n     *\n     * This is equivalent to {@link ZonedDateTime.of}.\n     *\n     * @return {ZonedDateTime} a {@link ZonedDateTime} with the zone ID set to the offset, not null\n     */\n    withFixedOffsetZone() {\n        return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     *\n     * This method returns the primitive `int` value for the year.\n     *\n     * The year returned by this method is proleptic as per {@link get}.\n     * To obtain the year-of-era, use `get(YEAR_OF_ERA)`.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._dateTime.year();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #month()\n     */\n    monthValue() {\n        return this._dateTime.monthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use {@link Month#getValue}.\n     *\n     * @return {Month} the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    month() {\n        return this._dateTime.month();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     *\n     * This method returns the primitive `int` value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._dateTime.dayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     *\n     * This method returns the primitive `int` value for the day-of-year.\n     *\n     * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    dayOfYear() {\n        return this._dateTime.dayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n     *\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use {@link DayOfWeek#getValue}.\n     *\n     * Additional information can be obtained from the {@link DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        return this._dateTime.dayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._dateTime.hour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._dateTime.minute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._dateTime.second();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._dateTime.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.with}\n     *\n     * if called with 1 argument {@link ZonedDateTime.withTemporalAdjuster} is applied\n     * otherwise {@link ZonedDateTime.with2}\n     */\n    with(){\n        if(arguments.length === 1){\n            return this.withTemporalAdjuster.apply(this, arguments);\n        } else {\n            return this.with2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Returns an adjusted copy of this date-time.\n     *\n     * This returns a new {@link ZonedDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the 'last day of the month' and 'next Wednesday'.\n     * Key date-time classes also implement the {@link TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     *\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = zonedDateTime.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     *\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@link TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * <pre>\n     *  result = zonedDateTime.with(date);\n     *  result = zonedDateTime.with(time);\n     * </pre>\n     *\n     * {@link ZoneOffset} also implements {@link TemporalAdjuster} however it is less likely\n     * that setting the offset will have the effect you expect. When an offset is passed in,\n     * the local date-time is combined with the new offset to form an {@link Instant}.\n     * The instant and original zone are then used to create the result.\n     * This algorithm means that it is quite likely that the output has a different offset\n     * to the specified offset. It will however work correctly when passing in the offset\n     * applicable for the instant of the zoned date-time, and will work correctly if passing\n     * one of the two valid offsets during a daylight savings overlap when the same local time\n     * occurs twice.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on `this` with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    withTemporalAdjuster(adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));\n        } else if (adjuster instanceof LocalTime) {\n            return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));\n        } else if (adjuster instanceof LocalDateTime) {\n            return this._resolveLocal(adjuster);\n        } else if (adjuster instanceof Instant) {\n            const instant = adjuster;\n            return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);\n        } else if (adjuster instanceof ZoneOffset) {\n            return this._resolveOffset(adjuster);\n        }\n        requireNonNull(adjuster, 'adjuster');\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     *\n     * This returns a {@link ZonedDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     *\n     * The {@link INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The zone and nano-of-second are unchanged.\n     * The result will have an offset derived from the new instant and original zone.\n     * If the new instant value is outside the valid range then a {@link DateTimeException} will be thrown.\n     *\n     * The {@link OFFSET_SECONDS} field will typically be ignored.\n     * The offset of a {@link ZonedDateTime} is controlled primarily by the time-zone.\n     * As such, changing the offset does not generally make sense, because there is only\n     * one valid offset for the local date-time and zone.\n     * If the zoned date-time is in a daylight savings overlap, then the offset is used\n     * to switch between the two valid offsets. In all other cases, the offset is ignored.\n     * If the new offset value is outside the valid range then a {@link DateTimeException} will be thrown.\n     *\n     * The other supported fields (see {@link isSupported}) will behave as in {@link LocalDateTime#with}.\n     * The zone is not part of the calculation and will be unchanged.\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    with2(field, newValue) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.INSTANT_SECONDS: return ZonedDateTime._create(newValue, this.nano(), this._zone);\n                case ChronoField.OFFSET_SECONDS: {\n                    const offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));\n                    return this._resolveOffset(offset);\n                }\n            }\n            return this._resolveLocal(this._dateTime.with(field, newValue));\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the year value altered.\n     *\n     * This operates on the local time-line,\n     * changing the year (see {@link LocalDateTime#withYear}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year - the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    withYear(year) {\n        return this._resolveLocal(this._dateTime.withYear(year));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the month-of-year value altered.\n     *\n     * This operates on the local time-line,\n     * changing the month (see {@link LocalDateTime#withMonth}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this._resolveLocal(this._dateTime.withMonth(month));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the day-of-month value altered.\n     *\n     * This operates on the local time-line,\n     * changing the day-of-month (see {@link LocalDateTime#withDayOfMonth}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid\n     * @throws DateTimeException if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the day-of-year altered.\n     *\n     * This operates on the local time-line,\n     * changing the day-of-year (see {@link LocalDateTime#withDayOfYear}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfYear - the day-of-year to set in the result, from 1 to 365-366\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid\n     * @throws DateTimeException if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the hour-of-day value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withHour}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hour - the hour-of-day to set in the result, from 0 to 23\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    withHour(hour) {\n        return this._resolveLocal(this._dateTime.withHour(hour));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the minute-of-hour value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withMinute}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minute - the minute-of-hour to set in the result, from 0 to 59\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    withMinute(minute) {\n        return this._resolveLocal(this._dateTime.withMinute(minute));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the second-of-minute value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withSecond}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} second - the second-of-minute to set in the result, from 0 to 59\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    withSecond(second) {\n        return this._resolveLocal(this._dateTime.withSecond(second));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the nano-of-second value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withNano}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanoOfSecond - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    withNano(nanoOfSecond) {\n        return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the time truncated.\n     *\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with {@link ChronoUnit#MINUTES}\n     * will set the second-of-minute and nano-of-second field to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS}. Other units throw an exception.\n     *\n     * This operates on the local time-line, truncating the underlying local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalUnit} unit - the unit to truncate to, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     */\n    truncatedTo(unit) {\n        return this._resolveLocal(this._dateTime.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.plus}\n     *\n     * if called with 1 argument {@link ZonedDateTime.plusTemporalAmount} is applied,\n     * otherwise {@link ZonedDateTime.plus2}\n     */\n    plus(){\n        if(arguments.length === 1){\n            return this.plusTemporalAmount.apply(this, arguments);\n        } else {\n            return this.plus2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     *\n     * This method returns a new date-time based on this time with the specified period added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link plus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalAmount} amount - the amount to add, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusTemporalAmount(amount) {\n        requireNonNull(amount);\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     *\n     * This method returns a new date-time based on this date-time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * The calculation for date and time units differ.\n     *\n     * Date units operate on the local time-line.\n     * The period is first added to the local date-time, then converted back\n     * to a zoned date-time using the zone ID.\n     * The conversion uses {@link ofLocal}\n     * with the offset before the addition.\n     *\n     * Time units operate on the instant time-line.\n     * The period is first added to the local date-time, then converted back to\n     * a zoned date-time using the zone ID.\n     * The conversion uses {@link ofInstant}\n     * with the offset before the addition.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to add, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the specified period added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    plus2(amountToAdd, unit) {\n        if (unit instanceof ChronoUnit) {\n            if (unit.isDateBased()) {\n                return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));\n            } else {\n                return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));\n            }\n        }\n        requireNonNull(unit, 'unit');\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in years added.\n     *\n     * This operates on the local time-line, adding years to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusYears(years) {\n        return this._resolveLocal(this._dateTime.plusYears(years));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in months added.\n     *\n     * This operates on the local time-line, adding months to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusMonths(months) {\n        return this._resolveLocal(this._dateTime.plusMonths(months));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in weeks added.\n     *\n     * This operates on the local time-line, adding weeks to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to add, may be negative\n     * @return {ZonedDateTime}a {@link ZonedDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusWeeks(weeks) {\n        return this._resolveLocal(this._dateTime.plusWeeks(weeks));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in days added.\n     *\n     * This operates on the local time-line, adding days to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, may be negative\n     * @return {ZonedDateTime}a {@link ZonedDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusDays(days) {\n        return this._resolveLocal(this._dateTime.plusDays(days));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in hours added.\n     *\n     * This operates on the instant time-line, such that adding one hour will\n     * always be a duration of one hour later.\n     * This may cause the local date-time to change by an amount other than one hour.\n     * Note that this is a different approach to that used by days, months and years,\n     * thus adding one day is not the same as adding 24 hours.\n     *\n     * For example, consider a time-zone where the spring DST cutover means that the\n     * local times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00.\n     *\n     * * Adding one hour to 00:30+02:00 will result in 01:30+02:00\n     * * Adding one hour to 01:30+02:00 will result in 01:30+01:00\n     * * Adding one hour to 01:30+01:00 will result in 02:30+01:00\n     * * Adding three hours to 00:30+02:00 will result in 02:30+01:00\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusHours(hours) {\n        return this._resolveInstant(this._dateTime.plusHours(hours));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in minutes added.\n     *\n     * This operates on the instant time-line, such that adding one minute will\n     * always be a duration of one minute later.\n     * This may cause the local date-time to change by an amount other than one minute.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusMinutes(minutes) {\n        return this._resolveInstant(this._dateTime.plusMinutes(minutes));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in seconds added.\n     *\n     * This operates on the instant time-line, such that adding one second will\n     * always be a duration of one second later.\n     * This may cause the local date-time to change by an amount other than one second.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusSeconds(seconds) {\n        return this._resolveInstant(this._dateTime.plusSeconds(seconds));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in nanoseconds added.\n     *\n     * This operates on the instant time-line, such that adding one nano will\n     * always be a duration of one nano later.\n     * This may cause the local date-time to change by an amount other than one nano.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusNanos(nanos) {\n        return this._resolveInstant(this._dateTime.plusNanos(nanos));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.minus}\n     *\n     * if called with 1 argument {@link ZonedDateTime.minusTemporalAmount} is applied,\n     * otherwise {@link ZonedDateTime.minus2}\n     */\n    minus(){\n        if(arguments.length === 1){\n            return this.minusTemporalAmount.apply(this, arguments);\n        } else {\n            return this.minus2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     *\n     * This method returns a new date-time based on this time with the specified period subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * The calculation is delegated to the specified adjuster, which typically calls\n     * back to {@link minus}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amount - the amount to subtract, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusTemporalAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     *\n     * This method returns a new date-time based on this date-time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * The calculation for date and time units differ.\n     *\n     * Date units operate on the local time-line.\n     * The period is first subtracted from the local date-time, then converted back\n     * to a zoned date-time using the zone ID.\n     * The conversion uses {@link ofLocal}\n     * with the offset before the subtraction.\n     *\n     * Time units operate on the instant time-line.\n     * The period is first subtracted from the local date-time, then converted back to\n     * a zoned date-time using the zone ID.\n     * The conversion uses {@link ofInstant}\n     * with the offset before the subtraction.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to subtract, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the specified period subtracted, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    minus2(amountToSubtract, unit) {\n        return this.plus2(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in years subtracted.\n     *\n     * This operates on the local time-line, subtracting years from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusYears(years) {\n        return this.plusYears(-1 * years);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in months subtracted.\n     *\n     * This operates on the local time-line, subtracting months from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusMonths(months) {\n        return this.plusMonths(-1 * months);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in weeks subtracted.\n     *\n     * This operates on the local time-line, subtracting weeks from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusWeeks(weeks) {\n        return this.plusWeeks(-1 * weeks);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in days subtracted.\n     *\n     * This operates on the local time-line, subtracting days from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusDays(days) {\n        return this.plusDays(-1 * days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in hours subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one hour will\n     * always be a duration of one hour earlier.\n     * This may cause the local date-time to change by an amount other than one hour.\n     * Note that this is a different approach to that used by days, months and years,\n     * thus subtracting one day is not the same as adding 24 hours.\n     *\n     * For example, consider a time-zone where the spring DST cutover means that the\n     * local times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00.\n     *\n     * * Subtracting one hour from 02:30+01:00 will result in 01:30+02:00\n     * * Subtracting one hour from 01:30+01:00 will result in 01:30+02:00\n     * * Subtracting one hour from 01:30+02:00 will result in 00:30+01:00\n     * * Subtracting three hours from 02:30+01:00 will result in 00:30+02:00\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusHours(hours) {\n        return this.plusHours(-1 * hours);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in minutes subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one minute will\n     * always be a duration of one minute earlier.\n     * This may cause the local date-time to change by an amount other than one minute.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusMinutes(minutes) {\n        return this.plusMinutes(-1 * minutes);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in seconds subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one second will\n     * always be a duration of one second earlier.\n     * This may cause the local date-time to change by an amount other than one second.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusSeconds(seconds) {\n        return this.plusSeconds(-1 * seconds);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in nanoseconds subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one nano will\n     * always be a duration of one nano earlier.\n     * This may cause the local date-time to change by an amount other than one nano.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusNanos(nanos) {\n        return this.plusNanos(-1 * nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     *\n     * This queries this date-time using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        if (query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        }\n        requireNonNull(query, 'query');\n        return super.query(query);\n    }\n\n    /**\n     * Calculates the period between this date-time and another date-time in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two date-times in terms of a single unit.\n     * The start and end points are `this` and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the period in days between two date-times can be calculated\n     * using {@link startDateTime.until}.\n     *\n     * The {@link Temporal} passed to this method must be a {@link ZonedDateTime}.\n     * If the time-zone differs between the two zoned date-times, the specified\n     * end date-time is normalized to have the same zone as this date-time.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the period in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n     * {@link MINUTES}, {@link HOURS} and {@link HALF_DAYS}, {@link DAYS},\n     * {@link WEEKS}, {@link MONTHS}, {@link YEARS}, {@link DECADES},\n     * {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * The calculation for date and time units differ.\n     *\n     * Date units operate on the local time-line, using the local date-time.\n     * For example, the period from noon on day 1 to noon the following day\n     * in days will always be counted as exactly one day, irrespective of whether\n     * there was a daylight savings change or not.\n     *\n     * Time units operate on the instant time-line.\n     * The calculation effectively converts both zoned date-times to instants\n     * and then calculates the period between the instants.\n     * For example, the period from noon on day 1 to noon the following day\n     * in hours may be 23, 24 or 25 hours (or some other amount) depending on\n     * whether there was a daylight savings change or not.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive  the end date-time, which is converted to a {@link ZonedDateTime}, not null\n     * @param {TemporalUnit} unit  the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date-time and the end date-time\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        let end = ZonedDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end = end.withZoneSameInstant(this._zone);\n            if (unit.isDateBased()) {\n                return this._dateTime.until(end._dateTime, unit);\n            } else {\n                let difference = this._offset.totalSeconds() - end._offset.totalSeconds();\n                let adjustedEnd = end._dateTime.plusSeconds(difference);\n                return this._dateTime.until(adjustedEnd, unit);\n            }\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@link LocalDateTime} part of this date-time.\n     *\n     * This returns a {@link LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return {LocalDateTime} the local date-time part of this date-time, not null\n     */\n    toLocalDateTime() {\n        return this._dateTime;\n    }\n\n    /**\n     * Gets the {@link LocalDate} part of this date-time.\n     *\n     * This returns a {@link LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return {LocalDate} the date part of this date-time, not null\n     */\n    toLocalDate() {\n        return this._dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the {@link LocalTime} part of this date-time.\n     *\n     * This returns a {@link LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return {LocalTime} the time part of this date-time, not null\n     */\n    toLocalTime() {\n        return this._dateTime.toLocalTime();\n    }\n\n    /**\n     * Converts this date-time to an {@link OffsetDateTime}.\n     *\n     * This creates an offset date-time using the local date-time and offset.\n     * The zone ID is ignored.\n     *\n     * @return {OffsetDateTime} an offset date-time representing the same local date-time and offset, not null\n     */\n    /**\n     * we will not support OffsetDateTime in the near future\n        toOffsetDateTime() {\n            return OffsetDateTime.of(this._dateTime, this._offset);\n        }\n    */\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     *\n     * The comparison is based on the offset date-time and the zone.\n     * Only objects of type {@link ZonedDateTime} are compared, other types return false.\n     *\n     * @param {*} other  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ZonedDateTime) {\n            return this._dateTime.equals(other._dateTime) &&\n                this._offset.equals(other._offset) &&\n                this._zone.equals(other._zone);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        let r = 17;\n        r = 31 * r + this._dateTime.hashCode();\n        r = 31 * r + this._offset.hashCode();\n        r = 31 * r + this._zone.hashCode();\n        return r;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a string, such as\n     * `2007-12-03T10:15:30+01:00[Europe/Paris]`.\n     *\n     * The format consists of the {@link LocalDateTime} followed by the {@link ZoneOffset}.\n     * If the {@link ZoneId} is not the same as the offset, then the ID is output.\n     * The output is compatible with ISO-8601 if the offset and ID are the same.\n     *\n     * @return {string} a string representation of this date-time, not null\n     */\n    toString() {\n        let str = this._dateTime.toString() + this._offset.toString();\n        if (this._offset !== this._zone) {\n            str += '[' + this._zone.toString() + ']';\n        }\n        return str;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link ZonedDateTime.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this date-time as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {string} the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        return super.format(formatter);\n    }\n\n}\n\nexport function _init(){\n    ZonedDateTime.FROM = createTemporalQuery('ZonedDateTime.FROM', (temporal) => {\n        return ZonedDateTime.from(temporal);\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ZonedDateTime.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {Instant} from '../Instant';\nimport {LocalDate} from '../LocalDate';\nimport {MathUtil} from '../MathUtil';\n\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\nexport class ChronoZonedDateTime  extends Temporal {\n    query(query) {\n        if (query === TemporalQueries.zoneId() || query === TemporalQueries.zone()) {\n            return this.zone();\n        } else if (query === TemporalQueries.chronology()) {\n            return this.toLocalDate().chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.offset()) {\n            return this.offset();\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n        } else if (query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Outputs this date-time as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n    /**\n     * Converts this date-time to an {@link Instant}.\n     *\n     * This returns an {@link Instant} representing the same point on the\n     * time-line as this date-time. The calculation combines the\n     * local date-time (see {@link toLocalDateTime}) and\n     * offset (see {@link getOffset}).\n     *\n     * @return {Instant} an {@link Instant} representing the same instant, not null\n     */\n    toInstant() {\n        return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch\n     * of 1970-01-01T00:00:00Z.\n     *\n     * This uses the local date-time (see {@link toLocalDateTime}) and\n     * offset (see {@link getOffset}) to calculate the epoch-second value,\n     * which is the number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier are negative.\n     *\n     * @return {number} the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    toEpochSecond() {\n        const epochDay = this.toLocalDate().toEpochDay();\n        let secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n        secs -= this.offset().totalSeconds();\n        return secs;\n    }\n\n    /**\n      * Compares this date-time to another date-time, including the chronology.\n      *\n      * The comparison is based first on the instant, then on the local date-time,\n      * then on the zone ID, then on the chronology.\n      * It is \"consistent with equals\", as defined by {@link Comparable}.\n      *\n      * If all the date-time objects being compared are in the same chronology, then the\n      * additional chronology stage is not required.\n      *\n      * @param {ChronoZonedDateTime} other - the other date-time to compare to, not null\n      * @return {number} the comparator value, negative if less, positive if greater\n      */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        let cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n        if (cmp === 0) {\n            cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n            if (cmp === 0) {\n                cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n                if (cmp === 0) {\n                    cmp = strcmp(this.zone().id(), other.zone().id());\n                    // we only support iso for now\n                    //if (cmp === 0) {\n                    //    cmp = toLocalDate().getChronology().compareTo(other.toLocalDate().getChronology());\n                    //}\n                }\n            }\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     *\n     * This method differs from the comparison in {@link compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * `dateTime1.toInstant().isAfter(dateTime2.toInstant())`.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this is after the specified date-time\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        const thisEpochSec = this.toEpochSecond();\n        const otherEpochSec = other.toEpochSecond();\n        return thisEpochSec > otherEpochSec ||\n            (thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     *\n     * This method differs from the comparison in {@link compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * `dateTime1.toInstant().isBefore(dateTime2.toInstant())`.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this point is before the specified date-time\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        const thisEpochSec = this.toEpochSecond();\n        const otherEpochSec = other.toEpochSecond();\n        return thisEpochSec < otherEpochSec ||\n            (thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     *\n     * This method differs from the comparison in {@link compareTo} and {@link equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * `dateTime1.toInstant().equals(dateTime2.toInstant())`.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if the instant equals the instant of the specified date-time\n     */\n    isEqual(other) {\n        requireNonNull(other, 'other');\n        return this.toEpochSecond() === other.toEpochSecond() &&\n                this.toLocalTime().nano() === other.toLocalTime().nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     *\n     * The comparison is based on the offset date-time and the zone.\n     * To compare for the same instant on the time-line, use {@link compareTo}.\n     * Only objects of type {@link ChronoZoneDateTime} are compared, other types return false.\n     *\n     * @param {*} other  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ChronoZonedDateTime) {\n            return this.compareTo(other) === 0;\n        }\n        return false;\n    }\n\n}\n\nfunction strcmp(a, b){\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/chrono/ChronoZonedDateTime.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {requireNonNull} from '../assert';\nimport {MathUtil} from '../MathUtil';\n\nimport {LocalDate} from '../LocalDate';\nimport {Instant} from '../Instant';\nimport {ChronoUnit} from '../temporal/ChronoUnit';\nimport {ChronoField} from '../temporal/ChronoField';\nimport {Temporal} from '../temporal/Temporal';\nimport {TemporalQueries} from '../temporal/TemporalQueries';\n\n/**\n * A date-time without a time-zone in an arbitrary chronology, intended\n * for advanced globalization use cases.\n *\n * **Most applications should declare method signatures, fields and variables\n * as {@link LocalDateTime}, not this interface.**\n *\n * A {@link ChronoLocalDateTime} is the abstract representation of a local date-time\n * where the {@link Chronology}, or calendar system, is pluggable.\n * The date-time is defined in terms of fields expressed by {@link TemporalField},\n * where most common implementations are defined in {@link ChronoField}.\n * The chronology defines how the calendar system operates and the meaning of\n * the standard fields.\n *\n * #### When to use this interface\n *\n * The design of the API encourages the use of {@link LocalDateTime} rather than this\n * interface, even in the case where the application needs to deal with multiple\n * calendar systems. The rationale for this is explored in detail in {@link ChronoLocalDate}.\n *\n * Ensure that the discussion in {@link ChronoLocalDate} has been read and understood\n * before using this interface.\n *\n * ### Specification for implementors\n *\n * This interface must be implemented with care to ensure other classes operate correctly.\n * All implementations that can be instantiated must be final, immutable and thread-safe.\n * Subclasses should be Serializable wherever possible.\n *\n * In JDK 8, this is an interface with default methods.\n * Since there are no default methods in JDK 7, an abstract class is used.\n *\n * @param D the date type\n */\nexport class ChronoLocalDateTime extends Temporal {\n        /* <D extends ChronoLocalDate>\n        extends DefaultInterfaceTemporal\n        implements Temporal, TemporalAdjuster, Comparable<ChronoLocalDateTime<?>> */\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of this date-time.\n     *\n     * The {@link Chronology} represents the calendar system in use.\n     * The era and other fields in {@link ChronoField} are defined by the chronology.\n     *\n     * @return the chronology, not null\n     */\n    chronology() {\n        return this.toLocalDate().chronology();\n    }\n\n    /**\n     *\n     * @param {TemporalQuery} query\n     * @returns {*}\n     */\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n        } else if (query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        } else if (query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    adjustInto(temporal) {\n        return temporal\n                .with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay())\n                .with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@link Instant}.\n     *\n     * This combines this local date-time and the specified offset to form\n     * an {@link Instant}.\n     *\n     * @param {ZoneOffset} offset  the offset to use for the conversion, not null\n     * @return {Instant} an {@link Instant} representing the same instant, not null\n     */\n    toInstant(offset) {\n        return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch\n     * of 1970-01-01T00:00:00Z.\n     *\n     * This combines this local date-time and the specified offset to calculate the\n     * epoch-second value, which is the number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier are negative.\n     *\n     * @param {ZoneOffset} offset  the offset to use for the conversion, not null\n     * @return {number} the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    toEpochSecond(offset) {\n        requireNonNull(offset, 'offset');\n        const epochDay = this.toLocalDate().toEpochDay();\n        let secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n        secs -= offset.totalSeconds();\n        return MathUtil.safeToInt(secs);\n    }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/chrono/ChronoLocalDateTime.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {IllegalArgumentException} from './errors';\n\nimport {LocalDate} from './LocalDate';\nimport {LocalDateTime} from './LocalDateTime';\nimport {ZonedDateTime} from './ZonedDateTime';\nimport {ZoneId} from './ZoneId';\n\nclass ToNativeJsConverter {\n    /**\n     * @param {!(LocalDate|LocalDateTime|ZonedDateTime)} temporal - a joda temporal instance\n     * @param {ZoneId} [zone] - the zone of the temporal,\n     *  the default value for LocalDate and LocalDateTime is ZoneId.systemDefault().\n     */\n    constructor(temporal, zone){\n        let zonedDateTime;\n\n        if(temporal instanceof LocalDate) {\n            zone = zone == null ?  ZoneId.systemDefault() : zone;\n            zonedDateTime = temporal.atStartOfDay(zone);\n        } else if (temporal instanceof LocalDateTime) {\n            zone = zone == null ? ZoneId.systemDefault() : zone;\n            zonedDateTime = temporal.atZone(zone);\n        } else if (temporal instanceof ZonedDateTime) {\n            if (zone == null) {\n                zonedDateTime = temporal;\n            } else {\n                zonedDateTime = temporal.withZoneSameInstant(zone);\n            }\n        } else {\n            throw new IllegalArgumentException('unsupported instance for convert operation:' + temporal);\n        }\n\n        this.instant = zonedDateTime.toInstant();\n    }\n\n    /**\n     *\n     * @returns {Date}\n     */\n    toDate() {\n        return new Date(this.instant.toEpochMilli());\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    toEpochMilli() {\n        return this.instant.toEpochMilli();\n    }\n}\n\n/**\n * converts a LocalDate, LocalDateTime or ZonedDateTime to a native Javascript Date.\n *\n * In a first step the temporal is converted to an Instant by adding implicit values.\n * \n * A LocalDate is implicit set to a LocalDateTime at start of day. \n * A LocalDateTime is implicit set to a ZonedDateTime with \n * the passed zone or if null, with the system default time zone. \n * A ZonedDateTime is converted to an Instant, if a zone is specified the zonedDateTime is adjusted to this \n * zone, keeping the same Instant.\n *\n * In a second step the instant is converted to a native Javascript Date\n *\n * default zone for LocalDate and LocalDateTime is ZoneId.systemDefault().\n *\n * @example\n * convert(localDate).toDate() // returns a javascript Date\n * convert(localDate).toEpochMilli()   // returns the epochMillis\n *\n * @param {!(LocalDate|LocalDateTime|ZonedDateTime)} temporal - a joda temporal instance\n * @param {ZoneId} [zone] - the zone of the temporal\n * @returns {ToNativeJsConverter}\n */\nexport function convert(temporal, zone){\n    return new ToNativeJsConverter(temporal, zone);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/convert.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {assert, requireNonNull} from '../assert';\nimport {UnsupportedTemporalTypeException} from '../errors';\n\nimport {Instant} from '../Instant';\nimport {LocalDate} from '../LocalDate';\nimport {LocalTime} from '../LocalTime';\nimport {MathUtil} from '../MathUtil';\nimport {ZoneId} from '../ZoneId';\n\nimport {ChronoField} from './ChronoField';\nimport {TemporalQueries} from './TemporalQueries';\nimport {TemporalAccessor} from './TemporalAccessor';\n\n/**\n * A wrapper around a native javascript Date instance that\n * implements TemporalAccessor functionality\n */\nclass NativeJsTemporal extends TemporalAccessor {\n\n    /**\n     *\n     * @param {!(Date|moment)} date - a javascript Date or a moment instance\n     * @param {ZoneId} [zone=ZoneId.systemDefault()] - the zone of the temporal, defaults to ZoneId.systemDefault()\n     */\n    constructor(date, zone=ZoneId.systemDefault()){\n        super();\n        this._zone = zone;\n        if(date instanceof Date) {\n            this._epochMilli = date.getTime();\n            return;\n        } else if(typeof date.toDate === 'function' &&  date.toDate() instanceof Date) {\n            // it's a moment\n            this._epochMilli = date.toDate().getTime();\n            return;\n        }\n        assert(false, 'date must be either a javascript date or a moment');\n    }\n\n    /**\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n        } else if(query === TemporalQueries.localTime()){\n            return LocalTime.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n        } else if(query === TemporalQueries.zone()){\n            return this._zone;\n        }\n        return super.query(query);\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {number}\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     *\n     * @param {!TemporalField} field\n     * @returns {number}\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.NANO_OF_SECOND: return MathUtil.floorMod(this._epochMilli, 1000) * 1000000;\n                case ChronoField.INSTANT_SECONDS: return MathUtil.floorDiv(this._epochMilli, 1000);\n            }\n            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {boolean}\n     */\n    isSupported(field){\n        return field === ChronoField.INSTANT_SECONDS || field === ChronoField.NANO_OF_SECOND;\n    }\n}\n\n/**\n *\n * @param {!(Date|moment)} date - a javascript Date or a moment instance\n * @param {ZoneId} [zone=ZoneId.systemDefault()] - the zone of the temporal, defaults to ZoneId.systemDefault()\n * @returns {NativeJsTemporal}\n */\nexport function nativeJs(date, zone){\n    return new NativeJsTemporal(date, zone);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/NativeJsTemporal.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {_init as ZoneOffsetInit} from './ZoneOffset';\nimport {_init as DayOfWeekInit} from './DayOfWeek';\nimport {_init as DurationInit} from './Duration';\nimport {_init as InstantInit} from './Instant';\nimport {_init as LocalDateInit} from './LocalDate';\nimport {_init as LocalTimeInit} from './LocalTime';\nimport {_init as LocalDateTimeInit} from './LocalDateTime';\nimport {_init as MonthInit} from './Month';\nimport {_init as MonthDayInit} from './MonthDay';\nimport {_init as PeriodInit} from './Period';\nimport {_init as YearInit} from './Year';\nimport {_init as YearConstantsInit} from './YearConstants';\nimport {_init as YearMonthInit} from './YearMonth';\nimport {_init as ZonedDateTimeInit} from './ZonedDateTime';\nimport {_init as IsoChronologyInit} from './chrono/IsoChronology';\nimport {_init as DateTimeFormatterInit} from './format/DateTimeFormatter';\nimport {_init as ChronoFieldInit} from './temporal/ChronoField';\nimport {_init as ChronoUnitInit} from './temporal/ChronoUnit';\nimport {_init as IsoFieldsInit} from './temporal/IsoFields';\nimport {_init as DateTimeFormatterBuilderInit} from './format/DateTimeFormatterBuilder';\n\nimport {_init as TemporalQueriesInit} from './temporal/TemporalQueriesFactory';\nimport {_init as ZoneIdInit} from './ZoneIdFactory';\n\nlet isInit = false;\n\nfunction init() {\n\n    if (isInit) {\n        return;\n    }\n\n    isInit = true;\n\n    YearConstantsInit();\n    DurationInit();\n    LocalTimeInit();\n    ChronoUnitInit();\n    ChronoFieldInit();\n    IsoFieldsInit();\n    TemporalQueriesInit();\n    DayOfWeekInit();\n    InstantInit();\n    LocalDateInit();\n    LocalDateTimeInit();\n    YearInit();\n    MonthInit();\n    YearMonthInit();\n    MonthDayInit();\n    PeriodInit();\n    ZoneOffsetInit();\n    ZonedDateTimeInit();\n    ZoneIdInit();\n    IsoChronologyInit();\n    DateTimeFormatterInit();\n    DateTimeFormatterBuilderInit();\n}\n\ninit();\n\n\n\n// WEBPACK FOOTER //\n// ./src/_init.js","/*\n * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {ChronoField} from './ChronoField';\nimport {createTemporalQuery} from './TemporalQuery';\nimport {TemporalQueries} from './TemporalQueries';\n\nimport {LocalDate} from '../LocalDate';\nimport {LocalTime} from '../LocalTime';\nimport {ZoneOffset} from '../ZoneOffset';\n\n\nexport function _init() {\n    //-----------------------------------------------------------------------\n    /**\n     * A strict query for the {@link ZoneId}.\n     */\n    TemporalQueries.ZONE_ID = createTemporalQuery('ZONE_ID', (temporal) => {\n        return temporal.query(TemporalQueries.ZONE_ID);\n    });\n\n    /**\n     * A query for the {@link Chronology}.\n     */\n    TemporalQueries.CHRONO = createTemporalQuery('CHRONO', (temporal) => {\n        return temporal.query(TemporalQueries.CHRONO);\n    });\n\n    /**\n     * A query for the smallest supported unit.\n     */\n    TemporalQueries.PRECISION = createTemporalQuery('PRECISION', (temporal) => {\n        return temporal.query(TemporalQueries.PRECISION);\n    });\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query for {@link ZoneOffset} returning null if not found.\n     */\n    TemporalQueries.OFFSET = createTemporalQuery('OFFSET', (temporal) => {\n        if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {\n            return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));\n        }\n        return null;\n    });\n\n    /**\n     * A lenient query for the {@link ZoneId}, falling back to the {@link ZoneOffset}.\n     */\n    TemporalQueries.ZONE = createTemporalQuery('ZONE', (temporal) => {\n        const zone = temporal.query(TemporalQueries.ZONE_ID);\n        return (zone != null ? zone : temporal.query(TemporalQueries.OFFSET));\n    });\n\n    /**\n     * A query for {@link LocalDate} returning null if not found.\n     */\n    TemporalQueries.LOCAL_DATE = createTemporalQuery('LOCAL_DATE', (temporal) => {\n        if (temporal.isSupported(ChronoField.EPOCH_DAY)) {\n            return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));\n        }\n        return null;\n    });\n\n    /**\n     * A query for {@link LocalTime} returning null if not found.\n     */\n    TemporalQueries.LOCAL_TIME = createTemporalQuery('LOCAL_TIME', (temporal) => {\n        if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {\n            return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));\n        }\n        return null;\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/temporal/TemporalQueriesFactory.js"],"sourceRoot":""}