{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/stream.js"],"names":["Lazy","func","this","has_evaluated","value","Eager","Stream","head","tailPromise","wrapper","headValue","create","_continually","callback","iterate","_iterate","x","f","EagerStream","call","prototype","eval","empty","Error","tail","item","n","s","e","length","len","add","zip","y","append","stream","self","args","Array","slice","arguments","shift","streams","concat","filter","apply","map","concatmap","reduce","a","initial","aggregator","TypeError","sum","b","walk","force","scale","factor","h","t","take","howmany","takeWhile","condition","result","push","fromArray","drop","dropWhile","member","print","target","console","log","toString","continually","continuallyEager","repeat","element","makeOnes","makeNaturalNumbers","nats","make","restArguments","array","range","low","high","equals","stream1","stream2","iterateEager","cycle","promise_generator","index","module","exports"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\"use strict\";\n\nfunction Lazy(func) {\n    this.has_evaluated = false;\n    this.func = func;\n    this.value = null;\n}\n\nLazy.prototype = {\n    eval: function() {\n        if ( this.has_evaluated ) {\n            return this.value;\n        }\n\n        this.value = this.func();\n        this.has_evaluated = true;\n        return this.value;\n    }\n};\n\nfunction Eager(func) {\n    this.func = func;\n}\n\nEager.prototype = {\n    eval: function() {\n        return this.func();\n    }\n}\n\nfunction Stream( head, tailPromise, wrapper ) {\n    if ( typeof wrapper == 'undefined' ) {\n        wrapper = Lazy;\n    }\n\n    this.wrapper = wrapper;\n\n    if ( typeof head != 'undefined' ) {\n        this.headValue = head;\n    }\n    if ( typeof tailPromise == 'undefined' ) {\n        tailPromise = function () {\n            return this.create();\n        };\n    }\n\n    if ( typeof tailPromise == 'function' ) {\n        tailPromise = new wrapper(tailPromise);\n    }\n\n    this.tailPromise = tailPromise;\n}\n\n// TODO: write some unit tests\nStream.prototype = {\n    // This makes it easier to avoid passing around the explicit wrapper\n    // when making new streams below\n    create: function(head, tailPromise) {\n        return new Stream( head, tailPromise, this.wrapper );\n    },\n    empty: function() {\n        return typeof this.headValue == 'undefined';\n    },\n    head: function() {\n        if ( this.empty() ) {\n            throw new Error('Cannot get the head of the empty stream.');\n        }\n        return this.headValue;\n    },\n    tail: function() {\n        if ( this.empty() ) {\n            throw new Error('Cannot get the tail of the empty stream.');\n        }\n\n        return this.tailPromise.eval();\n    },\n    item: function( n ) {\n        if ( this.empty() ) {\n            throw new Error('Cannot use item() on an empty stream.');\n        }\n        var s = this;\n        while ( n != 0 ) {\n            --n;\n            try {\n                s = s.tail();\n            }\n            catch ( e ) {\n                throw new Error('Item index does not exist in stream.');\n            }\n        }\n        try {\n            return s.head();\n        }\n        catch ( e ) {\n            throw new Error('Item index does not exist in stream.');\n        }\n    },\n    length: function() {\n        // requires finite stream\n        var s = this;\n        var len = 0;\n\n        while ( !s.empty() ) {\n            ++len;\n            s = s.tail();\n        }\n        return len;\n    },\n    add: function( s ) {\n        return this.zip( function ( x, y ) {\n            return x + y;\n        }, s );\n    },\n    append: function ( stream ) {\n        if ( this.empty() ) {\n            return stream;\n        }\n        var self = this;\n        return this.create(\n            self.head(),\n            function () {\n                return self.tail().append( stream );\n            }\n        );\n    },\n    zip: function( /* arguments */ ) {\n        var args = Array.prototype.slice.call( arguments, 0 )\n        var f = args[0];\n        args.shift();\n        var streams = [this].concat( args );\n        var self = this;\n\n        // If any streams are empty, return an empty stream\n        if( streams.filter( function(x) { return x.empty(); } ).length > 0 ) {\n          return new Stream();\n        }\n\n        return new Stream(\n          f.apply( null, streams.map( function(x) { return x.head(); }) ),\n          function () {\n            var tail = self.tail();\n            return tail.zip.apply( tail, [f].concat(\n              args.map( function (x) { return x.tail(); } )\n            ) );\n          }\n        );\n    },\n    map: function( f ) {\n        if ( this.empty() ) {\n            return this;\n        }\n        var self = this;\n        return this.create( f( this.head() ), function () {\n            return self.tail().map( f );\n        } );\n    },\n    concatmap: function ( f ) {\n        return this.reduce( function ( a, x ) {\n            return a.append( f(x) );\n        }, this.create() );\n    },\n    reduce: function () {\n        var aggregator = arguments[0];\n        var initial, self;\n        if(arguments.length < 2) {\n            if(this.empty()) throw new TypeError(\"Array length is 0 and no second argument\");\n            initial = this.head();\n            self = this.tail();\n        }\n        else {\n            initial = arguments[1];\n            self = this;\n        }\n        // requires finite stream\n        if ( self.empty() ) {\n            return initial;\n        }\n        // TODO: iterate\n        return self.tail().reduce( aggregator, aggregator( initial, self.head() ) );\n    },\n    sum: function () {\n        // requires finite stream\n        return this.reduce( function ( a, b ) {\n            return a + b;\n        }, 0 );\n    },\n    walk: function( f ) {\n        // requires finite stream\n        this.map( function ( x ) {\n            f( x );\n            return x;\n        } ).force();\n    },\n    force: function() {\n        // requires finite stream\n        var stream = this;\n        while ( !stream.empty() ) {\n            stream = stream.tail();\n        }\n    },\n    scale: function( factor ) {\n        return this.map( function ( x ) {\n            return factor * x;\n        } );\n    },\n    filter: function( f ) {\n        if ( this.empty() ) {\n            return this;\n        }\n        var h = this.head();\n        var t = this.tail();\n        if ( f( h ) ) {\n            return this.create( h, function () {\n                return t.filter( f );\n            } );\n        }\n        return t.filter( f );\n    },\n    take: function ( howmany ) {\n        if ( this.empty() ) {\n            return this;\n        }\n        if ( howmany == 0 ) {\n            return this.create();\n        }\n        var self = this;\n        return this.create(\n            this.head(),\n            function () {\n                return self.tail().take( howmany - 1 );\n            }\n        );\n    },\n    takeWhile: function( condition ) {\n      if(this.empty()) return new Stream();\n      var self = this, result = [];\n\n      while( condition( self.head() ) ) {\n        result.push( self.head() );\n        self = self.tail();\n      }\n\n      return Stream.fromArray(result);\n    },\n    drop: function( n ){\n        var self = this;\n\n        while ( n-- > 0 ) {\n\n            if ( self.empty() ) {\n                return this.create();\n            }\n\n            self = self.tail();\n        }\n\n        // create clone/a contructor which accepts a stream?\n        return this.create( self.headValue, self.tailPromise );\n    },\n    dropWhile: function( condition ) {\n        if(this.empty()) return new Stream();\n        var self = this;\n\n        while( condition( self.head() ) ) {\n          self = self.tail();\n\n          if ( self.empty() ) {\n              return self;\n          }\n        }\n        return new Stream( self.headValue, self.tailPromise );\n    },\n    member: function( x ){\n        var self = this;\n\n        while( !self.empty() ) {\n            if ( self.head() == x ) {\n                return true;\n            }\n\n            self = self.tail();\n        }\n\n        return false;\n    },\n    print: function( n ) {\n        var target;\n        if ( typeof n != 'undefined' ) {\n            target = this.take( n );\n        }\n        else {\n            // requires finite stream\n            target = this;\n        }\n        target.walk( function ( x ) {\n            console.log( x );\n        } );\n    },\n    toString: function() {\n        // requires finite stream\n        return '[stream head: ' + this.head() + '; tail: ' + this.tail() + ']';\n    }\n};\n\nfunction _continually( callback, wrapper ) {\n    return Stream.iterate( callback(), callback, wrapper );\n}\n\nStream.continually = function( callback ) {\n    return _continually( callback, Lazy );\n}\n\nStream.continuallyEager = function( callback ) {\n    return _continually( callback, Eager );\n}\n\nStream.repeat = function( element ) {\n    return Stream.continually( function() { return element; } );\n};\n\nStream.makeOnes = function() {\n    return new Stream( 1, Stream.makeOnes );\n};\n\nStream.makeNaturalNumbers = function() {\n    return new Stream( 1, function () {\n        var nats = Stream.makeNaturalNumbers();\n        return nats.add( Stream.makeOnes() );\n    } );\n};\n\nStream.make = function( /* arguments */ ) {\n    if ( arguments.length == 0 ) {\n        return new Stream();\n    }\n    var restArguments = Array.prototype.slice.call( arguments, 1 );\n    return new Stream( arguments[ 0 ], function () {\n        return Stream.make.apply( null, restArguments );\n    } );\n};\n\n// This is Eager-only, since keeping around a Lazy for each element would\n// just copy array needlessly\nStream.fromArray = function ( array ) {\n    if ( array.length == 0 ) {\n        return new Stream();\n    }\n    return new Stream( array[0], function() { return Stream.fromArray(array.slice(1), Eager ); }, Eager );\n};\n\nStream.range = function ( low, high ) {\n    if ( typeof low == 'undefined' ) {\n        low = 1;\n    }\n    if ( low == high ) {\n        return Stream.make( low );\n    }\n    // if high is undefined, there won't be an upper bound\n    return new Stream( low, function () {\n        return Stream.range( low + 1, high );\n    });\n};\n\nStream.equals = function ( stream1, stream2 ) {\n    if ( ! (stream1 instanceof Stream) ) return false;\n    if ( ! (stream2 instanceof Stream) ) return false;\n    if ( stream1.empty() && stream2.empty() ) {\n        return true;\n    }\n    if ( stream1.empty() || stream2.empty() ) {\n        return false;\n    }\n    if ( stream1.head() === stream2.head() ) {\n        return Stream.equals( stream1.tail(), stream2.tail() );\n    }\n};\n\nfunction _iterate( x, f, wrapper ) {\n  return new Stream( x, function () {\n    return _iterate( f( x ), f, wrapper );\n  }, wrapper );\n};\n\nStream.iterate = function( x, f ) {\n    return _iterate( x, f, Lazy );\n}\n\nStream.iterateEager = function( x, f ) {\n    return _iterate( x, f, Eager );\n}\n\n// Like fromArray, this is Eager-only since it would needlessly copy\n// parts of the array if Lazy was used\nStream.cycle = function( array ) {\n  var promise_generator = function( array, index) {\n    if( index >= array.length ) index = 0;\n    return function() {\n      return new Stream( array[index], promise_generator(array, index + 1 ), Eager );\n    };\n  };\n  return new Stream( array[0], promise_generator( array, 1 ), Eager );\n};\n\n/*\n * Since Lazy and Eager aren't exported to the outside, this is used to make\n * eager streams.\n */\nfunction EagerStream( head, tailPromise ) {\n    return Stream.call( this, head, tailPromise, Eager );\n}\n\nEagerStream.prototype = Stream.prototype;\n\nStream.Eager = EagerStream;\nmodule.exports = Stream;\n"]}