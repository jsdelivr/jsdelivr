{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///autoNumeric.min.js","webpack:///webpack/bootstrap fdeb28f1ad001b5b70a4","webpack:///./src/autoNumeric.js","webpack:///external {\"root\":\"jQuery\",\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","err","Array","isArray","_typeof","obj","constructor","autoFormat","autoUnFormat","getDefaultConfig","validate","areSettingsValid","allowedTagList","defaultSettings","digitGroupSeparator","noSeparatorOnFocus","digitalGroupSpacing","decimalCharacter","decimalCharacterAlternative","currencySymbol","currencySymbolPlacement","negativePositiveSignPlacement","suffixText","overrideMinMaxLimits","maximumValue","minimumValue","decimalPlacesOverride","decimalPlacesShownOnFocus","scaleDivisor","scaleDecimalPlaces","scaleSymbol","saveValueToSessionStorage","onInvalidPaste","roundingMethod","allowDecimalPadding","negativeBracketsTypeOnBlur","emptyInputBehavior","leadingZero","formatOnPageLoad","selectNumberOnly","defaultValueOverride","unformatOnSubmit","outputFormat","showWarnings","failOnUnknownOption","keyCode","Backspace","Tab","Enter","Shift","Ctrl","Alt","PauseBreak","CapsLock","Esc","Space","PageUp","PageDown","End","Home","LeftArrow","UpArrow","RightArrow","DownArrow","Insert","Delete","num0","num1","num2","num3","num4","num5","num6","num7","num8","num9","a","b","d","e","f","g","h","j","k","l","n","o","q","r","s","t","u","v","w","x","y","z","Windows","RightClick","numpad0","numpad1","numpad2","numpad3","numpad4","numpad5","numpad6","numpad7","numpad8","numpad9","MultiplyNumpad","PlusNumpad","MinusNumpad","DotNumpad","SlashNumpad","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","NumLock","ScrollLock","MyComputer","MyCalculator","Semicolon","Equal","Comma","Hyphen","Dot","Slash","Backquote","LeftBracket","Backslash","RightBracket","Quote","Command","keyName","Unidentified","AltGr","Fn","FnLock","Hyper","Meta","Super","SymbolLock","Clear","Copy","CrSel","Cut","EraseEof","ExSel","Paste","Redo","Undo","Accept","Again","Attn","Cancel","ContextMenu","Execute","Find","Finish","Help","Pause","Play","Props","Select","ZoomIn","ZoomOut","BrightnessDown","BrightnessUp","Eject","LogOff","Power","PowerOff","PrintScreen","Hibernate","Standby","WakeUp","Compose","Dead","Print","Minus","Plus","apply","$","isNull","isUndefined","isUndefinedOrNullOrEmpty","isString","str","String","isBoolean","isTrueOrFalseString","lowercaseValue","toLowerCase","isObject","reference","isEmptyObj","prop","hasOwnProperty","isNumber","isNaN","parseFloat","isFinite","isInt","parseInt","preparePastedText","text","holder","stripAllNonNumberCharacters","settingsClone","replace","contains","needle","indexOf","isInArray","array","toString","Error","decimalPlaces","_str$split","split","_str$split2","decimalPart","keyCodeNumber","event","which","checkIfInRange","parsedMinValue","parsedMaxValue","parsedValue","parseStr","testMinMax","isNegative","string","charAt","setRawNegativeSign","insertCharAtPosition","char","caretPosition","slice","replaceCharAt","index","newCharacter","substr","clampToRangeLimits","settings","Math","max","min","countNumberCharactersOnTheCaretLeftSide","formattedNumberString","numberDotOrNegativeSign","RegExp","numberDotAndNegativeSignCount","test","findCaretPositionInFormattedNumber","rawNumberString","caretPositionInRawValue","formattedNumberStringSize","rawNumberStringSize","formattedNumberStringIndex","rawNumberStringIndex","countDotsInText","countCharInText","character","charCounter","convertCharacterCountToIndexPosition","characterCount","getElementSelection","that","position","selectionStart","focus","select","document","selection","createRange","moveStart","end","start","selectionEnd","setElementSelection","arguments","range","createTextRange","collapse","moveEnd","throwError","message","warning","showWarning","console","warn","runCallbacksFoundInTheSettingsObject","$this","each","val","autoNumeric","maximumVMinAndVMaxDecimalLength","leftOrAll","skipFirstAutoStrip","trailingNegative","skipLastAutoStrip","allowedAutoStrip","match","numRegAutoStrip","join","nSign","_s$split","_s$split2","integerPart","modifiedIntegerPart","negativeSignCharacter","mIntPos","mIntNeg","onOff","stripReg","toggleNegativeBracket","_settings$negativeBra","_settings$negativeBra2","firstBracket","lastBracket","fromLocale","lastIndexOf","toLocale","locale","result","Number","modifyNegativeSignAndDecimalCharacterForRawValue","modifyNegativeSignAndDecimalCharacterForFormattedValue","checkEmpty","inputValue","signOnEmpty","addGroupSeparators","strip","empty","digitalGroup","_inputValue$split","_inputValue$split2","_inputValue$split3","_inputValue$split4","substring","rawValue","truncateZeros","roundedInputValue","temporaryDecimalPlacesOverride","regex","roundValue","round","ceil","floor","ivRounded","dPos","inputValueHasADot","vdPos","cDec","zeros","rLength","tRound","odd","ivArray","truncateDecimal","isPaste","_s$split3","_s$split4","modifiedDecimalPart","nL","search","xc","yc","xNeg","checkIfInRangeWithOverrideOption","minParse","maxParse","valParse","getCurrentElement","element","getAutoNumericHolder","update","data","AutoNumericHolder","get","keepAnOriginalSettingsCopy","oDec","oPad","oBracket","oSep","oSign","oSuffix","readCookie","name","nameEQ","ca","cookie","storageTest","mod","sessionStorage","setItem","removeItem","saveValueToPersistentStorage","action","storedName","decodeURIComponent","date","expires","Date","setTime","getTime","toUTCString","getItem","_getStringOrArray","getArrayBehavior","formIndex","allFormElements","aiIndex","scIndex","rSubmitterTypes","rSubmittable","rCheckableType","rNonAutoNumericTypes","count","field","localName","type","disabled","checked","formFields","serializeArray","scElement","testInput","_ret2","serialize","formParts","_formParts$i$split","_formParts$i$split2","inputName","modifiedInputValue","onFocusInAndMouseEnter","is","valueOnFocus","lastVal","onEmpty","onKeydown","_updateAutoNumericHolderEventKeycode","initialValueOnKeydown","readOnly","processed","eventKeyCode","triggerEvent","_updateAutoNumericHolderProperties","_skipAlways","_processCharacterDeletion","_formatValue","throwInput","preventDefault","formatted","onKeypress","isCharacterInsertionAllowed","_processCharacterInsertion","onKeyup","skip","valuePartsBeforePaste","onFocusOutAndMouseLeave","origValue","_checkIfInRangeWithOv3","_checkIfInRangeWithOv4","minTest","maxTest","trigger","groupedValue","change","onPaste","rawPastedText","clipboardData","getData","initialFormattedValue","selectionSize","isAllInputTextSelected","isPasteNegative","rawPastedTextSize","pastedText","caretPositionOnInitialTextAfterPasting","initialUnformattedNumber","isInitialValueNegative","isPasteNegativeAndInitialValueIsPositive","leftFormattedPart","rightFormattedPart","leftPart","rightPart","lastGoodKnownResult","pastedTextIndex","modifiedLeftPart","lastGoodKnownResultIndex","lastGoodKnownResultSize","indexWhereToInsertThePastedText","firstPart","lastPart","indexSelectionEndInRawValue","selectedText","valueHasBeenSet","valueHasBeenClamped","error","clampedValue","caretPositionInFormattedNumber","onBlur","onSubmit","closest","on","$settings","getInputIfSupportedTagAndType","$input","currentElementTag","formatDefaultValueOnPageLoad","setValue","currentValue","attr","testedCurrentValue","Infinity","toStrip","tagList","correctPNegOption","options","calculateVMinAndVMaxIntegerSizes","_settings$maximumValu","_settings$maximumValu2","maximumValueIntegerPart","_ref3","_ref4","minimumValueIntegerPart","correctMDecOption","setsAlternativeDecimalSeparatorCharacter","cachesUsualRegularExpressions","aNegReg","aNegRegAutoStrip","allowed","transformOptionsValuesToDefaultTypes","convertOldOptionsToNewOnes","oldOptionsConverter","aSep","nSep","dGroup","aDec","altDec","aSign","pSign","pNeg","aSuffix","oLimits","vMax","vMin","mDec","eDec","scaleDecimal","aStor","mRound","aPad","nBracket","wEmpty","lZero","aForm","sNumber","anDefault","unSetOnSubmit","outputType","debug","runOnce","caretFix","option","getInitialSettings","extend","tagData","eventName","detail","window","CustomEvent","bubbles","cancelable","createEvent","initCustomEvent","dispatchEvent","$that","setReal","pos","_setSelection","left","right","_getLeftAndRightPartA","_getLeftAndRightPartAroundTheSelection","_getLeftAndRightPartA2","stripZeros","newValue","parts","_normalizeParts","_checkIfInRangeWithOv","_checkIfInRangeWithOv2","testValue","_setCaretPosition","currencySymbolLen","hasNeg","valueLen","signPosition","_getSignPosition","oldParts","_getLeftAndRightPartA3","_getLeftAndRightPartA4","_setValueParts","ctrlKey","metaKey","shiftKey","_checkPaste","negLen","suffixTextLen","_expandSelectionOnSign","_ref","_ref2","_getUnformattedLeftAn3","_getUnformattedLeftAndRightPartAroundTheSelection","_getUnformattedLeftAn4","_getUnformattedLeftAn","_getUnformattedLeftAn2","_processCharacterDele","_processCharacterDeletionIfTrailingNegativeSign","_processCharacterDele2","_getUnformattedLeftAn5","_getUnformattedLeftAn6","eventNumber","_this","leftLength","_getUnformattedLeftAn7","_getUnformattedLeftAn8","_leftLength$split","_leftLength$split2","subParts","leftAr","shift","signParts","escapeChr","escapedParts","miniParts","leftReg","newLeft","methods","init","addEventListener","destroy","removeData","off","wipe","set","_checkIfInRangeWithOv5","_checkIfInRangeWithOv6","attemptedValue","unSet","reSet","eq","getLocalized","getNumber","getFormatted","getString","getArray","getSettings","fn","method","_len","args","_key","defaults","valueString","_checkIfInRangeWithOv7","_checkIfInRangeWithOv8","autoStrip","autoUnformat","userOptions","shouldExtendDefaultOptions","testPositiveInteger","testNumericalCharacters","testFloatOrIntegerAndPossibleNegativeSign","testPositiveFloatOrInteger","vMinAndVMaxMaximumDecimalPlaces","autoValidate","isValid","params","evt","Event","default","format","unFormat"],"mappings":"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","file":"autoNumeric.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"autonumeric\"] = factory(require(\"jquery\"));\n\telse\n\t\troot[\"autonumeric\"] = factory(root[\"jQuery\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"autonumeric\"] = factory(require(\"jquery\"));\n\telse\n\t\troot[\"autonumeric\"] = factory(root[\"jQuery\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\n\tvar jQuery = __webpack_require__(1);\n\tvar $ = __webpack_require__(1);\n\t(function() {\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t *               autoNumeric.js\n\t *\n\t * @version      2.0-beta.15\n\t * @date         2016-12-27 UTC 14:00\n\t *\n\t * @author       Bob Knothe\n\t * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\n\t *               cf. AUTHORS.md.\n\t * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n\t * @since        2009-08-09\n\t *\n\t * @summary      autoNumeric is a jQuery plugin that automatically formats currency\n\t * (money) and numbers as-you-type in a form inputs. It supports most\n\t * international numeric formats and currency signs including those used in\n\t * Europe, North and South America, Asia, as well as India's' lakhs.\n\t *\n\t *               Note : Some functions are borrowed from big.js\n\t * @link         https://github.com/MikeMcl/big.js/\n\t *\n\t * Please report any bugs to https://github.com/BobKnothe/autoNumeric\n\t *\n\t * @license      Released under the MIT License\n\t * @link         http://www.opensource.org/licenses/mit-license.php\n\t *\n\t * Permission is hereby granted, free of charge, to any person\n\t * obtaining a copy of this software and associated documentation\n\t * files (the \"Software\"), to deal in the Software without\n\t * restriction, including without limitation the rights to use,\n\t * copy, modify, merge, publish, distribute, sub license, and/or sell\n\t * copies of the Software, and to permit persons to whom the\n\t * Software is furnished to do so, subject to the following\n\t * conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be\n\t * included in all copies or substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n\t * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n\t * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n\t * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n\t * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n\t * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\t * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n\t * OTHER DEALINGS IN THE SOFTWARE.\n\t */\n\t\n\t/* global module, require, define */\n\t\n\t// Functions names for ES6 exports\n\tvar autoFormat = void 0;\n\tvar autoUnFormat = void 0;\n\tvar getDefaultConfig = void 0;\n\tvar validate = void 0;\n\tvar areSettingsValid = void 0;\n\t\n\t// AutoNumeric default settings\n\t/**\n\t * List of allowed tag on which autoNumeric can be used.\n\t */\n\tvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\t\n\t/**\n\t * Defaults options are public - these can be overridden by the following:\n\t * - HTML5 data attributes\n\t * - Options passed by the 'init' or 'update' methods\n\t * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n\t */\n\tvar defaultSettings = {\n\t    /* Allowed thousand separator characters\n\t     * comma = \",\"\n\t     * period \"full stop\" = \".\"\n\t     * quote = \"'\"\n\t     * space = \" \"\n\t     * none = \"\"\n\t     * NOTE: do not use numeric characters\n\t     * Deprecated older option name : aSep\n\t     */\n\t    digitGroupSeparator: ',',\n\t\n\t    /* When true => removes the thousand separator, currency symbol & suffix \"focusin\"\n\t     * example if the input value \"$ 1,999.88 suffix\"\n\t     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n\t     * Deprecated older option name : nSep\n\t     */\n\t    noSeparatorOnFocus: false,\n\t\n\t    /* Digital grouping for the thousand separator used in Format\n\t     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\n\t     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n\t     * digitalGroupSpacing: \"3\", results in 999,999,999 default\n\t     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\n\t     * Deprecated older option name : dGroup\n\t     */\n\t    digitalGroupSpacing: '3',\n\t\n\t    /* Allowed decimal separator characters\n\t     * period \"full stop\" = \".\"\n\t     * comma = \",\"\n\t     * Deprecated older option name : aDec\n\t     */\n\t    decimalCharacter: '.',\n\t\n\t    /* Allow to declare alternative decimal separator which is automatically replaced by decimalCharacter\n\t     * developed for countries the use a comma \",\" as the decimal character\n\t     * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n\t     * Deprecated older option name : altDec\n\t     */\n\t    decimalCharacterAlternative: null,\n\t\n\t    /* currencySymbol = allowed currency symbol\n\t     * Must be in quotes currencySymbol: \"$\"\n\t     * space to the right of the currency symbol currencySymbol: '$ '\n\t     * space to the left of the currency symbol currencySymbol: ' $'\n\t     * Deprecated older option name : aSign\n\t     */\n\t    currencySymbol: '',\n\t\n\t    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\n\t     * for prefix currencySymbolPlacement: \"p\" (default)\n\t     * for suffix currencySymbolPlacement: \"s\"\n\t     * Deprecated older option name : pSign\n\t     */\n\t    currencySymbolPlacement: 'p',\n\t\n\t    /* Placement of negative sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\n\t     * -1,234.56  => default no options required\n\t     * -$1,234.56 => {currencySymbol: \"$\"}\n\t     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"}\n\t     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"}\n\t     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\n\t     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\n\t     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\n\t     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\n\t     * Deprecated older option name : pNeg\n\t     */\n\t    negativePositiveSignPlacement: 'l',\n\t\n\t    /* Additional suffix\n\t     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\n\t     * Numeric characters and negative sign not allowed'\n\t     * Deprecated older option name : aSuffix\n\t     */\n\t    suffixText: '',\n\t\n\t    /* Override min max limits\n\t     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\n\t     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\n\t     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\n\t     * Deprecated older option name : oLimits\n\t     */\n\t    overrideMinMaxLimits: null,\n\t\n\t    /* Maximum possible value\n\t     * value must be enclosed in quotes and use the period for the decimal point\n\t     * value must be larger than minimumValue\n\t     * Deprecated older option name : vMax\n\t     */\n\t    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\t\n\t    /* Minimum possible value\n\t     * value must be enclosed in quotes and use the period for the decimal point\n\t     * value must be smaller than maximumValue\n\t     * Deprecated older option name : vMin\n\t     */\n\t    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\t\n\t    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\n\t     * Deprecated older option name : mDec\n\t     */\n\t    decimalPlacesOverride: null,\n\t\n\t    /* Expanded decimal places visible when input has focus - example:\n\t     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n\t     * the \"get\" method returns the extended decimal places\n\t     * Deprecated older option name : eDec\n\t     */\n\t    decimalPlacesShownOnFocus: null,\n\t\n\t    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\n\t     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\n\t     * [\"divisor\", \"decimal places\", \"symbol\"]\n\t     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\n\t     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n\t     */\n\t\n\t    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n\t     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n\t     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n\t     * The \"get\" method returns the full value, including the 'hidden' decimals.\n\t     */\n\t    scaleDivisor: null,\n\t\n\t    /*\n\t     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n\t     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n\t     * Deprecated older option name : scaleDecimal\n\t     */\n\t    scaleDecimalPlaces: null,\n\t\n\t    /*\n\t     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n\t     * This is optional too.\n\t     */\n\t    scaleSymbol: null,\n\t\n\t    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\n\t     * if ie 6 or 7 the value will be saved as a session cookie\n\t     * Deprecated older option name : aStor\n\t     */\n\t    saveValueToSessionStorage: false,\n\t\n\t    /*\n\t     * Manage how autoNumeric react when the user tries to paste an invalid number.\n\t     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\n\t     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\n\t     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\n\t     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\n\t     *                The non-pasted numbers are dropped and therefore not used at all.\n\t     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\n\t     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\n\t     *\n\t     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\n\t     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\n\t     *          Only the first number will be used (here '123').\n\t     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\n\t     */\n\t    //TODO Shouldn't we use `truncate` as the default value?\n\t    onInvalidPaste: 'error',\n\t\n\t    /* method used for rounding\n\t     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\n\t     * roundingMethod: \"A\", Round-Half-Up Asymmetric\n\t     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\n\t     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\n\t     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\n\t     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\n\t     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n\t     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n\t     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\n\t     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n\t     * roundingMethod: \"U05\" Rounds up to next .05\n\t     * roundingMethod: \"D05\" Rounds down to next .05\n\t     * Deprecated older option name : mRound\n\t     */\n\t    roundingMethod: 'S',\n\t\n\t    /* Controls decimal padding\n\t     * allowDecimalPadding: true - always Pad decimals with zeros\n\t     * allowDecimalPadding: false - does not pad with zeros.\n\t     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\n\t     *\n\t     * thanks to Jonas Johansson for the suggestion\n\t     * Deprecated older option name : aPad\n\t     */\n\t    allowDecimalPadding: true,\n\t\n\t    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n\t     * Those brackets are visible only when the field does NOT have the focus.\n\t     * The left and right symbols should be enclosed in quotes and separated by a comma\n\t     * negativeBracketsTypeOnBlur: null - (default)\n\t     * negativeBracketsTypeOnBlur: '(,)', negativeBracketsTypeOnBlur: '[,]', negativeBracketsTypeOnBlur: '<,>' or negativeBracketsTypeOnBlur: '{,}'\n\t     * Deprecated older option name : nBracket\n\t     */\n\t    negativeBracketsTypeOnBlur: null,\n\t\n\t    /* Displayed on empty string \"\"\n\t     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\n\t     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\n\t     * emptyInputBehavior: \"always\" - always displays the currency sign only\n\t     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\n\t     * Deprecated older option name : wEmpty\n\t     */\n\t    emptyInputBehavior: 'focus',\n\t\n\t    /* Controls leading zero behavior\n\t     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n\t     * leadingZero: \"deny\", - allows only one leading zero on values less than one\n\t     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n\t     * Deprecated older option name : lZero\n\t     */\n\t    leadingZero: 'deny',\n\t\n\t    /* Determine if the default value will be formatted on initialization.\n\t     * true = automatically formats the default value on initialization\n\t     * false = will not format the default value on initialization\n\t     * Deprecated older option name : aForm\n\t     */\n\t    formatOnPageLoad: true,\n\t\n\t    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\n\t     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\n\t     * Deprecated older option name : sNumber\n\t     */\n\t    selectNumberOnly: false,\n\t\n\t    /* Helper option for ASP.NET postback\n\t     * should be the value of the unformatted default value\n\t     * examples:\n\t     * no default value=\"\" {defaultValueOverride: \"\"}\n\t     * value=1234.56 {defaultValueOverride: '1234.56'}\n\t     * Deprecated older option name : anDefault\n\t     */\n\t    defaultValueOverride: null,\n\t\n\t    /* Removes formatting on submit event\n\t     * this output format: positive nnnn.nn, negative -nnnn.nn\n\t     * review the 'unSet' method for other formats\n\t     * Deprecated older option name : unSetOnSubmit\n\t     */\n\t    unformatOnSubmit: false,\n\t\n\t    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n\t     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n\t     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n\t     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n\t     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n\t     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n\t     * Deprecated older option name : outputType\n\t     */\n\t    outputFormat: null,\n\t\n\t    /* Error handling function\n\t     * true => all warning are shown\n\t     * false => no warnings are shown, only the thrown errors\n\t     * Deprecated older option name : debug\n\t     */\n\t    showWarnings: true,\n\t\n\t    /*\n\t     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\n\t     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\n\t     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\n\t     */\n\t    failOnUnknownOption: false\n\t};\n\t\n\t/**\n\t * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n\t * //TODO Replace every call to this object with a call to `keyName`\n\t * @deprecated\n\t */\n\tvar keyCode = {\n\t    Backspace: 8,\n\t    Tab: 9,\n\t    Enter: 13,\n\t    Shift: 16,\n\t    Ctrl: 17,\n\t    Alt: 18,\n\t    PauseBreak: 19,\n\t    CapsLock: 20,\n\t    Esc: 27,\n\t    Space: 32,\n\t    PageUp: 33,\n\t    PageDown: 34,\n\t    End: 35,\n\t    Home: 36,\n\t    LeftArrow: 37,\n\t    UpArrow: 38,\n\t    RightArrow: 39,\n\t    DownArrow: 40,\n\t    Insert: 45,\n\t    Delete: 46,\n\t    num0: 48,\n\t    num1: 49,\n\t    num2: 50,\n\t    num3: 51,\n\t    num4: 52,\n\t    num5: 53,\n\t    num6: 54,\n\t    num7: 55,\n\t    num8: 56,\n\t    num9: 57,\n\t    a: 65,\n\t    b: 66,\n\t    c: 67,\n\t    d: 68,\n\t    e: 69,\n\t    f: 70,\n\t    g: 71,\n\t    h: 72,\n\t    i: 73,\n\t    j: 74,\n\t    k: 75,\n\t    l: 76,\n\t    m: 77,\n\t    n: 78,\n\t    o: 79,\n\t    p: 80,\n\t    q: 81,\n\t    r: 82,\n\t    s: 83,\n\t    t: 84,\n\t    u: 85,\n\t    v: 86,\n\t    w: 87,\n\t    x: 88,\n\t    y: 89,\n\t    z: 90,\n\t    Windows: 91,\n\t    RightClick: 93,\n\t    numpad0: 96,\n\t    numpad1: 97,\n\t    numpad2: 98,\n\t    numpad3: 99,\n\t    numpad4: 100,\n\t    numpad5: 101,\n\t    numpad6: 102,\n\t    numpad7: 103,\n\t    numpad8: 104,\n\t    numpad9: 105,\n\t    MultiplyNumpad: 106,\n\t    PlusNumpad: 107,\n\t    MinusNumpad: 109,\n\t    DotNumpad: 110,\n\t    SlashNumpad: 111,\n\t    F1: 112,\n\t    F2: 113,\n\t    F3: 114,\n\t    F4: 115,\n\t    F5: 116,\n\t    F6: 117,\n\t    F7: 118,\n\t    F8: 119,\n\t    F9: 120,\n\t    F10: 121,\n\t    F11: 122,\n\t    F12: 123,\n\t    NumLock: 144,\n\t    ScrollLock: 145,\n\t    MyComputer: 182,\n\t    MyCalculator: 183,\n\t    Semicolon: 186,\n\t    Equal: 187,\n\t    Comma: 188,\n\t    Hyphen: 189,\n\t    Dot: 190,\n\t    Slash: 191,\n\t    Backquote: 192,\n\t    LeftBracket: 219,\n\t    Backslash: 220,\n\t    RightBracket: 221,\n\t    Quote: 222,\n\t    Command: 224\n\t};\n\t\n\t/**\n\t * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\n\t * Those names are listed here :\n\t * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n\t */\n\tvar keyName = {\n\t    // Special values\n\t    Unidentified: 'Unidentified',\n\t\n\t    // Modifier keys\n\t    Alt: 'Alt',\n\t    AltGr: 'AltGraph',\n\t    CapsLock: 'CapsLock', // Under Chrome, e.key is empty for CapsLock\n\t    Ctrl: 'Control',\n\t    Fn: 'Fn',\n\t    FnLock: 'FnLock',\n\t    Hyper: 'Hyper', // 'OS' under Firefox\n\t    Meta: 'Meta', // The Windows, Command or  key // 'OS' under Firefox and IE9\n\t    Windows: 'Meta', // This is a non-official key name\n\t    Command: 'Meta', // This is a non-official key name\n\t    NumLock: 'NumLock',\n\t    ScrollLock: 'ScrollLock',\n\t    Shift: 'Shift',\n\t    Super: 'Super', // 'OS' under Firefox\n\t    Symbol: 'Symbol',\n\t    SymbolLock: 'SymbolLock',\n\t\n\t    // Whitespace keys\n\t    Enter: 'Enter',\n\t    Tab: 'Tab',\n\t    Space: ' ', // 'Spacebar' for Firefox <37, and IE9\n\t\n\t    // Navigation keys\n\t    DownArrow: 'ArrowDown', // 'Down' for Firefox <=36, and IE9\n\t    LeftArrow: 'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n\t    RightArrow: 'ArrowRight', // 'Right' for Firefox <=36, and IE9\n\t    UpArrow: 'ArrowUp', // 'Up' for Firefox <=36, and IE9\n\t    End: 'End',\n\t    Home: 'Home',\n\t    PageDown: 'PageDown',\n\t    PageUp: 'PageUp',\n\t\n\t    // Editing keys\n\t    Backspace: 'Backspace',\n\t    Clear: 'Clear',\n\t    Copy: 'Copy',\n\t    CrSel: 'CrSel', // 'Crsel' for Firefox <=36, and IE9\n\t    Cut: 'Cut',\n\t    Delete: 'Delete', // 'Del' for Firefox <=36, and IE9\n\t    EraseEof: 'EraseEof',\n\t    ExSel: 'ExSel', // 'Exsel' for Firefox <=36, and IE9\n\t    Insert: 'Insert',\n\t    Paste: 'Paste',\n\t    Redo: 'Redo',\n\t    Undo: 'Undo',\n\t\n\t    // UI keys\n\t    Accept: 'Accept',\n\t    Again: 'Again',\n\t    Attn: 'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n\t    Cancel: 'Cancel',\n\t    ContextMenu: 'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n\t    Esc: 'Escape', // 'Esc' for Firefox <=36, and IE9\n\t    Execute: 'Execute',\n\t    Find: 'Find',\n\t    Finish: 'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n\t    Help: 'Help',\n\t    Pause: 'Pause',\n\t    Play: 'Play',\n\t    Props: 'Props',\n\t    Select: 'Select',\n\t    ZoomIn: 'ZoomIn',\n\t    ZoomOut: 'ZoomOut',\n\t\n\t    // Device keys\n\t    BrightnessDown: 'BrightnessDown',\n\t    BrightnessUp: 'BrightnessUp',\n\t    Eject: 'Eject',\n\t    LogOff: 'LogOff',\n\t    Power: 'Power',\n\t    PowerOff: 'PowerOff',\n\t    PrintScreen: 'PrintScreen',\n\t    Hibernate: 'Hibernate', // 'Unidentified' for Firefox <=37\n\t    Standby: 'Standby', // 'Unidentified' for Firefox <=36, and IE9\n\t    WakeUp: 'WakeUp',\n\t\n\t    // IME and composition keys\n\t    Compose: 'Compose',\n\t    Dead: 'Dead',\n\t\n\t    // Function keys\n\t    F1: 'F1',\n\t    F2: 'F2',\n\t    F3: 'F3',\n\t    F4: 'F4',\n\t    F5: 'F5',\n\t    F6: 'F6',\n\t    F7: 'F7',\n\t    F8: 'F8',\n\t    F9: 'F9',\n\t    F10: 'F10',\n\t    F11: 'F11',\n\t    F12: 'F12',\n\t\n\t    // Document keys\n\t    Print: 'Print',\n\t\n\t    // 'Normal' keys\n\t    num0: '0',\n\t    num1: '1',\n\t    num2: '2',\n\t    num3: '3',\n\t    num4: '4',\n\t    num5: '5',\n\t    num6: '6',\n\t    num7: '7',\n\t    num8: '8',\n\t    num9: '9',\n\t    numpad0: '0',\n\t    numpad1: '1',\n\t    numpad2: '2',\n\t    numpad3: '3',\n\t    numpad4: '4',\n\t    numpad5: '5',\n\t    numpad6: '6',\n\t    numpad7: '7',\n\t    numpad8: '8',\n\t    numpad9: '9',\n\t    a: 'a',\n\t    b: 'b',\n\t    c: 'c',\n\t    d: 'd',\n\t    e: 'e',\n\t    f: 'f',\n\t    g: 'g',\n\t    h: 'h',\n\t    i: 'i',\n\t    j: 'j',\n\t    k: 'k',\n\t    l: 'l',\n\t    m: 'm',\n\t    n: 'n',\n\t    o: 'o',\n\t    p: 'p',\n\t    q: 'q',\n\t    r: 'r',\n\t    s: 's',\n\t    t: 't',\n\t    u: 'u',\n\t    v: 'v',\n\t    w: 'w',\n\t    x: 'x',\n\t    y: 'y',\n\t    z: 'z',\n\t    MultiplyNumpad: '*',\n\t    PlusNumpad: '+',\n\t    MinusNumpad: '-',\n\t    DotNumpad: '.',\n\t    SlashNumpad: '/',\n\t    Semicolon: ';',\n\t    Equal: '=',\n\t    Comma: ',',\n\t    Hyphen: '-',\n\t    Minus: '-',\n\t    Plus: '+',\n\t    Dot: '.',\n\t    Slash: '/',\n\t    Backquote: '`',\n\t    LeftBracket: '[',\n\t    RightBracket: ']',\n\t    Backslash: '\\\\',\n\t    Quote: \"'\"\n\t};\n\t\n\t(function (factory) {\n\t    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n\t        // Node/CommonJS\n\t        module.exports = factory(require('jquery'));\n\t    } else {\n\t        // Browser globals\n\t        factory(window.jQuery);\n\t    }\n\t})(function ($) {\n\t    // Helper functions\n\t\n\t    /**\n\t     * Return TRUE if the `value` is null\n\t     *\n\t     * @static\n\t     * @param {*} value The value to test\n\t     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\n\t     */\n\t    function isNull(value) {\n\t        return value === null;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the `value` is undefined\n\t     *\n\t     * @static\n\t     * @param {*} value The value to test\n\t     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\n\t     */\n\t    function isUndefined(value) {\n\t        return value === void 0;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the `value` is undefined, null or empty\n\t     *\n\t     * @param {*} value\n\t     * @returns {boolean}\n\t     */\n\t    function isUndefinedOrNullOrEmpty(value) {\n\t        return value === null || value === void 0 || '' === value;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the given parameter is a String\n\t     *\n\t     * @param {*} str\n\t     * @returns {boolean}\n\t     */\n\t    function isString(str) {\n\t        return typeof str === 'string' || str instanceof String;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is a boolean\n\t     *\n\t     * @static\n\t     * @param {*} value\n\t     * @returns {boolean}\n\t     */\n\t    function isBoolean(value) {\n\t        return typeof value === 'boolean';\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is a string 'true' or 'false'\n\t     *\n\t     * This function accepts any cases for those strings.\n\t     * @param {string} value\n\t     * @returns {boolean}\n\t     */\n\t    function isTrueOrFalseString(value) {\n\t        var lowercaseValue = String(value).toLowerCase();\n\t        return lowercaseValue === 'true' || lowercaseValue === 'false';\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is an object\n\t     *\n\t     * @param {*} reference\n\t     * @returns {boolean}\n\t     */\n\t    function isObject(reference) {\n\t        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the given object is empty\n\t     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n\t     *\n\t     * @param {object} obj\n\t     * @returns {boolean}\n\t     */\n\t    function isEmptyObj(obj) {\n\t        for (var prop in obj) {\n\t            if (obj.hasOwnProperty(prop)) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is a number (or a number written as a string).\n\t     *\n\t     * @param {*} n\n\t     * @returns {boolean}\n\t     */\n\t    function isNumber(n) {\n\t        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is an integer (and not a float).\n\t     *\n\t     * @param {*} n\n\t     * @returns {boolean}\n\t     */\n\t    function isInt(n) {\n\t        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n\t    }\n\t\n\t    /**\n\t     * Return the pasted text that will be used.\n\t     *\n\t     * @param {string} text\n\t     * @param {AutoNumericHolder} holder\n\t     * @returns {string|void|XML|*}\n\t     */\n\t    function preparePastedText(text, holder) {\n\t        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n\t    }\n\t\n\t    /**\n\t     * Return TRUE is the string `str` contains the string `needle`\n\t     * Note: this function does not coerce the parameters types\n\t     *\n\t     * @param {string} str\n\t     * @param {string} needle\n\t     * @returns {boolean}\n\t     */\n\t    function contains(str, needle) {\n\t        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n\t            return false;\n\t        }\n\t\n\t        return str.indexOf(needle) !== -1;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the `needle` is in the array\n\t     *\n\t     * @param {*} needle\n\t     * @param {Array} array\n\t     * @returns {boolean}\n\t     */\n\t    function isInArray(needle, array) {\n\t        if (!isArray(array) || array === [] || isUndefined(needle)) {\n\t            return false;\n\t        }\n\t\n\t        return array.indexOf(needle) !== -1;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is an Array\n\t     *\n\t     * @param {*} arr\n\t     * @throws Error\n\t     * @returns {*|boolean}\n\t     */\n\t    function isArray(arr) {\n\t        if (Object.prototype.toString.call([]) === '[object Array]') {\n\t            // Make sure an array has a class attribute of [object Array]\n\t            // Test passed, now check if is an Array\n\t            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n\t        } else {\n\t            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n\t     *\n\t     * @param {string} str\n\t     * @returns {boolean}\n\t     */\n\t    // function hasDecimals(str) {\n\t    //     const [, decimalPart] = str.split('.');\n\t    //     return !isUndefined(decimalPart);\n\t    // }\n\t\n\t    /**\n\t     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n\t     *\n\t     * @param {string} str\n\t     * @returns {int}\n\t     */\n\t    function decimalPlaces(str) {\n\t        var _str$split = str.split('.'),\n\t            _str$split2 = _slicedToArray(_str$split, 2),\n\t            decimalPart = _str$split2[1];\n\t\n\t        if (!isUndefined(decimalPart)) {\n\t            return decimalPart.length;\n\t        }\n\t\n\t        return 0;\n\t    }\n\t\n\t    /**\n\t     * Return the code for the key used to generate the given event.\n\t     *\n\t     * @param {Event} event\n\t     * @returns {string|Number}\n\t     */\n\t    function keyCodeNumber(event) {\n\t        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n\t        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\n\t     *\n\t     * @param {string} value\n\t     * @param {object} parsedMinValue Parsed via the `parseStr()` function\n\t     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\n\t     * @returns {boolean}\n\t     */\n\t    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n\t        var parsedValue = parseStr(value);\n\t        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\n\t    }\n\t\n\t    /**\n\t     * Return TRUE if the given string contains a negative sign on the first character.\n\t     *\n\t     * @param {string} string A number represented by a string\n\t     * @returns {boolean}\n\t     */\n\t    function isNegative(string) {\n\t        return string.charAt(0) === '-';\n\t    }\n\t\n\t    /**\n\t     * Return the negative version of the value (represented as a string) given as a parameter.\n\t     *\n\t     * @param {string} value\n\t     * @returns {*}\n\t     */\n\t    function setRawNegativeSign(value) {\n\t        if (!isNegative(value)) {\n\t            return '-' + value;\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    /**\n\t     * Insert a character or a string at the index given (0 being the far left side).\n\t     *\n\t     * @param {string} str\n\t     * @param {string} char\n\t     * @param {int} caretPosition\n\t     * @returns {string}\n\t     */\n\t    function insertCharAtPosition(str, char, caretPosition) {\n\t        return '' + str.slice(0, caretPosition) + char + str.slice(caretPosition);\n\t    }\n\t\n\t    /**\n\t     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\n\t     *\n\t     * @param {string} string\n\t     * @param {int} index\n\t     * @param {string} newCharacter\n\t     * @returns {string}\n\t     */\n\t    function replaceCharAt(string, index, newCharacter) {\n\t        return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n\t    }\n\t\n\t    /**\n\t     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\n\t     *\n\t     * @param {string|number} value\n\t     * @param {object} settings\n\t     * @returns {number}\n\t     */\n\t    function clampToRangeLimits(value, settings) {\n\t        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n\t        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n\t    }\n\t\n\t    /**\n\t     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\n\t     *\n\t     * @param {string} formattedNumberString\n\t     * @param {int} caretPosition This must be a positive integer\n\t     * @param {string} decimalCharacter\n\t     * @returns {number}\n\t     */\n\t    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n\t        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n\t        var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\t\n\t        var numberDotAndNegativeSignCount = 0;\n\t        for (var i = 0; i < caretPosition; i++) {\n\t            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n\t            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n\t                numberDotAndNegativeSignCount++;\n\t            }\n\t        }\n\t\n\t        return numberDotAndNegativeSignCount;\n\t    }\n\t\n\t    /**\n\t     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\n\t     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\n\t     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\n\t     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\n\t     *\n\t     * @example\n\t     * 1234567|89.01   : position 7 (rawNumberString)\n\t     * 123.456.7|89,01 : position 9 (formattedNumberString)\n\t     *\n\t     * @param {string} rawNumberString\n\t     * @param {int} caretPositionInRawValue\n\t     * @param {string} formattedNumberString\n\t     * @param {string} decimalCharacter\n\t     * @returns {*}\n\t     */\n\t    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n\t        var formattedNumberStringSize = formattedNumberString.length;\n\t        var rawNumberStringSize = rawNumberString.length;\n\t\n\t        var formattedNumberStringIndex = void 0;\n\t        var rawNumberStringIndex = 0;\n\t        for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n\t            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n\t                rawNumberStringIndex++;\n\t            }\n\t        }\n\t\n\t        return formattedNumberStringIndex;\n\t    }\n\t\n\t    /**\n\t     * Return the number of dot '.' in the given text.\n\t     *\n\t     * @param {string} text\n\t     * @returns {number}\n\t     */\n\t    function countDotsInText(text) {\n\t        return countCharInText('.', text);\n\t    }\n\t\n\t    /**\n\t     * Count the number of occurrence of the given character, in the given text.\n\t     *\n\t     * @param {string} character\n\t     * @param {string} text\n\t     * @returns {number}\n\t     */\n\t    function countCharInText(character, text) {\n\t        var charCounter = 0;\n\t        for (var i = 0; i < text.length; i++) {\n\t            if (text[i] === character) {\n\t                charCounter++;\n\t            }\n\t        }\n\t\n\t        return charCounter;\n\t    }\n\t\n\t    /**\n\t     * Return the index that can be used to set the caret position.\n\t     * This takes into account that the position is starting at '0', not 1.\n\t     *\n\t     * @param {int} characterCount\n\t     * @returns {number}\n\t     */\n\t    function convertCharacterCountToIndexPosition(characterCount) {\n\t        return Math.max(characterCount, characterCount - 1);\n\t    }\n\t\n\t    /**\n\t     * Cross browser routine for getting selected range/cursor position\n\t     *\n\t     * @param {HTMLElement|EventTarget} that\n\t     * @returns {{}}\n\t     */\n\t    function getElementSelection(that) {\n\t        var position = {};\n\t        if (isUndefined(that.selectionStart)) {\n\t            that.focus();\n\t            var select = document.selection.createRange();\n\t            position.length = select.text.length;\n\t            select.moveStart('character', -that.value.length);\n\t            position.end = select.text.length;\n\t            position.start = position.end - position.length;\n\t        } else {\n\t            position.start = that.selectionStart;\n\t            position.end = that.selectionEnd;\n\t            position.length = position.end - position.start;\n\t        }\n\t\n\t        return position;\n\t    }\n\t\n\t    /**\n\t     * Cross browser routine for setting selected range/cursor position\n\t     *\n\t     * @param {HTMLElement|EventTarget} that\n\t     * @param {int} start\n\t     * @param {int|null} end\n\t     */\n\t    function setElementSelection(that, start) {\n\t        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t        if (isUndefinedOrNullOrEmpty(end)) {\n\t            end = start;\n\t        }\n\t\n\t        if (isUndefined(that.selectionStart)) {\n\t            that.focus();\n\t            var range = that.createTextRange();\n\t            range.collapse(true);\n\t            range.moveEnd('character', end);\n\t            range.moveStart('character', start);\n\t            range.select();\n\t        } else {\n\t            that.selectionStart = start;\n\t            that.selectionEnd = end;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Function that throw error messages\n\t     *\n\t     * @param {string} message\n\t     */\n\t    function throwError(message) {\n\t        throw new Error(message);\n\t    }\n\t\n\t    /**\n\t     * Function that display a warning messages, according to the debug level.\n\t     *\n\t     * @param {string} message\n\t     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\n\t     */\n\t    function warning(message) {\n\t        var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t        if (showWarning) {\n\t            /* eslint no-console: 0 */\n\t            console.warn('Warning: ' + message);\n\t        }\n\t    }\n\t\n\t    // autoNumeric-specific functions\n\t\n\t    /**\n\t     * Run any callbacks found in the settings object.\n\t     * Any parameter could be a callback:\n\t     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n\t     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n\t     * @param {object} $this jQuery-selected DOM element\n\t     * @param {object} settings\n\t     */\n\t    function runCallbacksFoundInTheSettingsObject($this, settings) {\n\t        // Loops through the settings object (option array) to find the following\n\t        $.each(settings, function (k, val) {\n\t            if (typeof val === 'function') {\n\t                settings[k] = val($this, settings, k);\n\t            } else if (typeof $this.autoNumeric[val] === 'function') {\n\t                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n\t                settings[k] = $this.autoNumeric[val]($this, settings, k);\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Determine the maximum decimal length from the minimumValue and maximumValue settings\n\t     *\n\t     * @param {string} minimumValue\n\t     * @param {string} maximumValue\n\t     * @returns {number}\n\t     */\n\t    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n\t        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n\t    }\n\t\n\t    /**\n\t     * Strip all unwanted non-number characters and leave only a number alert\n\t     *\n\t     * @param {string} s\n\t     * @param {object} settings\n\t     * @param {boolean} leftOrAll\n\t     * @returns {string|*}\n\t     */\n\t\n\t    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\n\t        if (settings.currencySymbol !== '') {\n\t            // Remove currency sign\n\t            s = s.replace(settings.currencySymbol, '');\n\t        }\n\t        if (settings.suffixText) {\n\t            // Remove suffix\n\t            while (contains(s, settings.suffixText)) {\n\t                s = s.replace(settings.suffixText, '');\n\t            }\n\t        }\n\t\n\t        // First replace anything before digits\n\t        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\t\n\t        if ((settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && contains(s, '-') && s !== '') {\n\t            settings.trailingNegative = true;\n\t        }\n\t\n\t        // Then replace anything after digits\n\t        s = s.replace(settings.skipLastAutoStrip, '$1');\n\t\n\t        // Then remove any uninteresting characters\n\t        s = s.replace(settings.allowedAutoStrip, '');\n\t        if (settings.decimalCharacterAlternative) {\n\t            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n\t        }\n\t\n\t        // Get only number string\n\t        var m = s.match(settings.numRegAutoStrip);\n\t        s = m ? [m[1], m[2], m[3]].join('') : '';\n\t\n\t        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n\t            var nSign = '';\n\t\n\t            var _s$split = s.split(settings.decimalCharacter),\n\t                _s$split2 = _slicedToArray(_s$split, 2),\n\t                integerPart = _s$split2[0],\n\t                decimalPart = _s$split2[1];\n\t\n\t            var modifiedIntegerPart = integerPart;\n\t            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n\t                nSign = settings.negativeSignCharacter;\n\t                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n\t            }\n\t\n\t            // Strip leading zero on positive value if need\n\t            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n\t                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n\t            }\n\t\n\t            // Strip leading zero on negative value if need\n\t            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n\t                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n\t            }\n\t\n\t            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n\t        }\n\t\n\t        if (leftOrAll && settings.leadingZero === 'deny' || !settings.onOff && settings.leadingZero === 'allow') {\n\t            s = s.replace(settings.stripReg, '$1$2');\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * Sets or removes brackets on negative values, depending on the focus state.\n\t     * The focus state is 'stored' in the settings object under the `settings.onOff` attribute. //TODO Use another object to keep track of internal data that are not settings\n\t     *\n\t     * @param {string} s\n\t     * @param {object} settings\n\t     * @returns {*}\n\t     */\n\t    function toggleNegativeBracket(s, settings) {\n\t        if (settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p') {\n\t            var _settings$negativeBra = settings.negativeBracketsTypeOnBlur.split(','),\n\t                _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2),\n\t                firstBracket = _settings$negativeBra2[0],\n\t                lastBracket = _settings$negativeBra2[1];\n\t\n\t            if (!settings.onOff) {\n\t                s = s.replace(settings.negativeSignCharacter, '');\n\t                s = firstBracket + s + lastBracket;\n\t            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n\t                s = s.replace(firstBracket, settings.negativeSignCharacter);\n\t                s = s.replace(lastBracket, '');\n\t            }\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * Convert locale format to Javascript numeric string\n\t     * Allows locale decimal separator to be a period or a comma - no thousand separator allowed of currency signs allowed\n\t     * '1234.56'    OK\n\t     * '-1234.56'   OK\n\t     * '1234.56-'   OK\n\t     * '1234,56'    OK\n\t     * '-1234,56'   OK\n\t     * '1234,56-'   OK\n\t     *\n\t     * @param {string} s\n\t     * @returns {string|void|XML|*}\n\t     */\n\t    function fromLocale(s) {\n\t        s = s.replace(',', '.');\n\t        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n\t            s = s.replace('-', '');\n\t            s = '-' + s;\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n\t     * See the \"outputFormat\" option definition for more details.\n\t     *\n\t     * @param {string|null} value\n\t     * @param {string} locale\n\t     * @returns {*}\n\t     */\n\t    function toLocale(value, locale) {\n\t        if (isNull(locale) || locale === 'string') {\n\t            return value;\n\t        }\n\t\n\t        var result = void 0;\n\t        switch (locale) {\n\t            case 'number':\n\t                result = Number(value);\n\t                break;\n\t            case '.-':\n\t                result = contains(value, '-') ? value.replace('-', '') + '-' : value;\n\t                break;\n\t            case ',':\n\t            case '-,':\n\t                result = value.replace('.', ',');\n\t                break;\n\t            case ',-':\n\t                result = value.replace('.', ',');\n\t                result = contains(result, '-') ? result.replace('-', '') + '-' : result;\n\t                break;\n\t            // The default case\n\t            case '.':\n\t            case '-.':\n\t                result = value;\n\t                break;\n\t            default:\n\t                throwError('The given outputFormat [' + locale + '] option is not recognized.');\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\n\t     *\n\t     * @param {string} s\n\t     * @param {object} settings\n\t     * @returns {string}\n\t     */\n\t    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\n\t        if (settings.decimalCharacter !== '.') {\n\t            s = s.replace(settings.decimalCharacter, '.');\n\t        }\n\t        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n\t            s = s.replace(settings.negativeSignCharacter, '-');\n\t        }\n\t        if (!s.match(/\\d/)) {\n\t            // The default value returned by `get` is formatted with decimals\n\t            s += '0.00';\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * Modify the negative sign and the decimal character to use those defined in the settings.\n\t     *\n\t     * @param {string} s\n\t     * @param {object} settings\n\t     * @returns {string}\n\t     */\n\t    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n\t        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n\t            s = s.replace('-', settings.negativeSignCharacter);\n\t        }\n\t        if (settings.decimalCharacter !== '.') {\n\t            s = s.replace('.', settings.decimalCharacter);\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * Private function to check for empty value\n\t     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\n\t     *\n\t     * @param {string} inputValue\n\t     * @param {object} settings\n\t     * @param {boolean} signOnEmpty\n\t     * @returns {*}\n\t     */\n\t    function checkEmpty(inputValue, settings, signOnEmpty) {\n\t        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n\t            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n\t                return settings.negativePositiveSignPlacement === 'l' ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n\t            }\n\t\n\t            return inputValue;\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    /**\n\t     * Modify the input value by adding the group separators, as defined in the settings.\n\t     *\n\t     * @param {string} inputValue\n\t     * @param {object} settings\n\t     * @returns {*}\n\t     */\n\t    function addGroupSeparators(inputValue, settings) {\n\t        if (settings.strip) {\n\t            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\n\t        }\n\t\n\t        if (settings.trailingNegative && !contains(inputValue, '-')) {\n\t            inputValue = '-' + inputValue;\n\t        }\n\t\n\t        var empty = checkEmpty(inputValue, settings, true);\n\t        var isNegative = contains(inputValue, '-');\n\t        if (isNegative) {\n\t            inputValue = inputValue.replace('-', '');\n\t        }\n\t\n\t        if (!isNull(empty)) {\n\t            return empty;\n\t        }\n\t\n\t        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n\t        var digitalGroup = void 0;\n\t        switch (settings.digitalGroupSpacing) {\n\t            case '2':\n\t                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n\t                break;\n\t            case '2s':\n\t                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n\t                break;\n\t            case '4':\n\t                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n\t                break;\n\t            default:\n\t                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n\t        }\n\t\n\t        // Splits the string at the decimal string\n\t\n\t        var _inputValue$split = inputValue.split(settings.decimalCharacter),\n\t            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n\t            integerPart = _inputValue$split2[0],\n\t            decimalPart = _inputValue$split2[1];\n\t\n\t        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n\t            var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\t\n\t            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\t\n\t            integerPart = _inputValue$split4[0];\n\t            decimalPart = _inputValue$split4[1];\n\t        }\n\t\n\t        if (settings.digitGroupSeparator !== '') {\n\t            // Re-inserts the thousand separator via a regular expression\n\t            while (digitalGroup.test(integerPart)) {\n\t                integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n\t            }\n\t        }\n\t\n\t        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n\t            if (decimalPart.length > settings.decimalPlacesOverride) {\n\t                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n\t            }\n\t\n\t            // Joins the whole number with the decimal value\n\t            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n\t        } else {\n\t            // Otherwise if it's an integer\n\t            inputValue = integerPart;\n\t        }\n\t\n\t        if (settings.currencySymbolPlacement === 'p') {\n\t            if (isNegative) {\n\t                switch (settings.negativePositiveSignPlacement) {\n\t                    case 'l':\n\t                        inputValue = settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n\t                        break;\n\t                    case 'r':\n\t                        inputValue = settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n\t                        break;\n\t                    case 's':\n\t                        inputValue = settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else {\n\t                inputValue = settings.currencySymbol + inputValue;\n\t            }\n\t        }\n\t\n\t        if (settings.currencySymbolPlacement === 's') {\n\t            if (isNegative) {\n\t                switch (settings.negativePositiveSignPlacement) {\n\t                    case 'r':\n\t                        inputValue = inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n\t                        break;\n\t                    case 'l':\n\t                        inputValue = inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n\t                        break;\n\t                    case 'p':\n\t                        inputValue = settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else {\n\t                inputValue = inputValue + settings.currencySymbol;\n\t            }\n\t        }\n\t\n\t        // Removes the negative sign and places brackets\n\t        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || inputValue.charAt(0) === '-')) {\n\t            inputValue = toggleNegativeBracket(inputValue, settings);\n\t        }\n\t        settings.trailingNegative = false;\n\t\n\t        return inputValue + settings.suffixText;\n\t    }\n\t\n\t    /**\n\t     * Truncate not needed zeros\n\t     *\n\t     * @param {string} roundedInputValue\n\t     * @param {int} temporaryDecimalPlacesOverride\n\t     * @returns {void|XML|string|*}\n\t     */\n\t    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\n\t        var regex = void 0;\n\t        switch (temporaryDecimalPlacesOverride) {\n\t            case 0:\n\t                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n\t                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n\t                break;\n\t            case 1:\n\t                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n\t                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n\t                break;\n\t            default:\n\t                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n\t                regex = new RegExp('(\\\\.\\\\d{' + temporaryDecimalPlacesOverride + '}(?:\\\\d*[1-9])?)0*');\n\t        }\n\t\n\t        // If there are no decimal places, we don't need a decimal point at the end\n\t        roundedInputValue = roundedInputValue.replace(regex, '$1');\n\t        if (temporaryDecimalPlacesOverride === 0) {\n\t            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n\t        }\n\t\n\t        return roundedInputValue;\n\t    }\n\t\n\t    /**\n\t     * Round the input value using the rounding method defined in the settings.\n\t     * This function accepts multiple rounding methods. See the documentation for more details about those.\n\t     *\n\t     * Note : This is handled as text since JavaScript math function can return inaccurate values.\n\t     *\n\t     * @param {string} inputValue\n\t     * @param {object} settings\n\t     * @returns {*}\n\t     */\n\t    function roundValue(inputValue, settings) {\n\t        inputValue = inputValue === '' ? '0' : inputValue.toString();\n\t        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n\t            switch (settings.roundingMethod) {\n\t                case 'N05':\n\t                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n\t                    break;\n\t                case 'U05':\n\t                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n\t                    break;\n\t                default:\n\t                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n\t            }\n\t\n\t            var result = void 0;\n\t            if (!contains(inputValue, '.')) {\n\t                result = inputValue + '.00';\n\t            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n\t                result = inputValue + '0';\n\t            } else {\n\t                result = inputValue;\n\t            }\n\t            return result;\n\t        }\n\t\n\t        var ivRounded = '';\n\t        var i = 0;\n\t        var nSign = '';\n\t        var temporaryDecimalPlacesOverride = void 0;\n\t\n\t        // sets the truncate zero method\n\t        if (settings.allowDecimalPadding) {\n\t            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n\t        } else {\n\t            temporaryDecimalPlacesOverride = 0;\n\t        }\n\t\n\t        // Checks if the inputValue (input Value) is a negative value\n\t        if (inputValue.charAt(0) === '-') {\n\t            nSign = '-';\n\t\n\t            // Removes the negative sign that will be added back later if required\n\t            inputValue = inputValue.replace('-', '');\n\t        }\n\t\n\t        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n\t        if (!inputValue.match(/^\\d/)) {\n\t            inputValue = '0' + inputValue;\n\t        }\n\t\n\t        // Determines if the value is equal to zero. If it is, remove the negative sign\n\t        if (nSign === '-' && Number(inputValue) === 0) {\n\t            nSign = '';\n\t        }\n\t\n\t        // Trims leading zero's as needed\n\t        if (Number(inputValue) > 0 && settings.leadingZero !== 'keep' || inputValue.length > 0 && settings.leadingZero === 'allow') {\n\t            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n\t        }\n\t\n\t        var dPos = inputValue.lastIndexOf('.');\n\t        var inputValueHasADot = dPos === -1;\n\t\n\t        // Virtual decimal position\n\t        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\t\n\t        // Checks decimal places to determine if rounding is required :\n\t        // Check if no rounding is required\n\t        var cDec = inputValue.length - 1 - vdPos;\n\t\n\t        if (cDec <= settings.decimalPlacesOverride) {\n\t            // Check if we need to pad with zeros\n\t            ivRounded = inputValue;\n\t            if (cDec < temporaryDecimalPlacesOverride) {\n\t                if (inputValueHasADot) {\n\t                    ivRounded += settings.decimalCharacter;\n\t                }\n\t\n\t                var zeros = '000000';\n\t                while (cDec < temporaryDecimalPlacesOverride) {\n\t                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\n\t                    ivRounded += zeros;\n\t                    cDec += zeros.length;\n\t                }\n\t            } else if (cDec > temporaryDecimalPlacesOverride) {\n\t                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\n\t            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\n\t                ivRounded = ivRounded.replace(/\\.$/, '');\n\t            }\n\t\n\t            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n\t        }\n\t\n\t        // Rounded length of the string after rounding\n\t        var rLength = void 0;\n\t        if (inputValueHasADot) {\n\t            rLength = settings.decimalPlacesOverride - 1;\n\t        } else {\n\t            rLength = settings.decimalPlacesOverride + dPos;\n\t        }\n\t\n\t        var tRound = Number(inputValue.charAt(rLength + 1));\n\t        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n\t        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\t\n\t        if (tRound > 4 && settings.roundingMethod === 'S' || // Round half up symmetric\n\t        tRound > 4 && settings.roundingMethod === 'A' && nSign === '' || // Round half up asymmetric positive values\n\t        tRound > 5 && settings.roundingMethod === 'A' && nSign === '-' || // Round half up asymmetric negative values\n\t        tRound > 5 && settings.roundingMethod === 's' || // Round half down symmetric\n\t        tRound > 5 && settings.roundingMethod === 'a' && nSign === '' || // Round half down asymmetric positive values\n\t        tRound > 4 && settings.roundingMethod === 'a' && nSign === '-' || // Round half down asymmetric negative values\n\t        tRound > 5 && settings.roundingMethod === 'B' || // Round half even \"Banker's Rounding\"\n\t        tRound === 5 && settings.roundingMethod === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n\t        tRound > 0 && settings.roundingMethod === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n\t        tRound > 0 && settings.roundingMethod === 'F' && nSign === '-' || // Round to floor toward negative infinite\n\t        tRound > 0 && settings.roundingMethod === 'U') {\n\t            // Round up away from zero\n\t            // Round up the last digit if required, and continue until no more 9's are found\n\t            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n\t                if (ivArray[i] !== '.') {\n\t                    ivArray[i] = +ivArray[i] + 1;\n\t                    if (ivArray[i] < 10) {\n\t                        break;\n\t                    }\n\t\n\t                    if (i > 0) {\n\t                        ivArray[i] = '0';\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // Reconstruct the string, converting any 10's to 0's\n\t        ivArray = ivArray.slice(0, rLength + 1);\n\t\n\t        // Return the rounded value\n\t        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\n\t\n\t        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n\t    }\n\t\n\t    /**\n\t     * Truncates the decimal part of a number.\n\t     *\n\t     * @param {string} s\n\t     * @param {object} settings\n\t     * @param {boolean} isPaste\n\t     * @returns {*}\n\t     */\n\t    function truncateDecimal(s, settings, isPaste) {\n\t        s = isPaste ? roundValue(s, settings) : s;\n\t\n\t        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n\t            var _s$split3 = s.split(settings.decimalCharacter),\n\t                _s$split4 = _slicedToArray(_s$split3, 2),\n\t                integerPart = _s$split4[0],\n\t                decimalPart = _s$split4[1];\n\t\n\t            // truncate decimal part to satisfying length since we would round it anyway\n\t\n\t\n\t            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n\t                if (settings.decimalPlacesOverride > 0) {\n\t                    var modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n\t                    s = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n\t                } else {\n\t                    s = integerPart;\n\t                }\n\t            }\n\t        }\n\t\n\t        return s;\n\t    }\n\t\n\t    /**\n\t     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\n\t     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\n\t     *\n\t     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n\t     *\n\t     * @param {number|string} n A numeric value.\n\t     * @returns {{}}\n\t     */\n\t    function parseStr(n) {\n\t        var x = {}; // A Big number instance.\n\t        var e = void 0;\n\t        var i = void 0;\n\t        var nL = void 0;\n\t        var j = void 0;\n\t\n\t        // Minus zero?\n\t        if (n === 0 && 1 / n < 0) {\n\t            n = '-0';\n\t        }\n\t\n\t        // Determine sign. 1 positive, -1 negative\n\t        n = n.toString();\n\t        if (n.charAt(0) === '-') {\n\t            n = n.slice(1);\n\t            x.s = -1;\n\t        } else {\n\t            x.s = 1;\n\t        }\n\t\n\t        // Decimal point?\n\t        e = n.indexOf('.');\n\t        if (e > -1) {\n\t            n = n.replace('.', '');\n\t        }\n\t\n\t        // length of string if no decimal character\n\t        if (e < 0) {\n\t            // Integer\n\t            e = n.length;\n\t        }\n\t\n\t        // Determine leading zeros\n\t        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n\t        nL = n.length;\n\t        if (i === nL) {\n\t            // Zero\n\t            x.e = 0;\n\t            x.c = [0];\n\t        } else {\n\t            // Determine trailing zeros\n\t            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n\t                nL -= 1;\n\t            }\n\t            nL -= 1;\n\t\n\t            // Decimal location\n\t            x.e = e - i - 1;\n\t            x.c = [];\n\t\n\t            // Convert string to array of digits without leading/trailing zeros\n\t            for (e = 0; i <= nL; i += 1) {\n\t                x.c[e] = +n.charAt(i);\n\t                e += 1;\n\t            }\n\t        }\n\t\n\t        return x;\n\t    }\n\t\n\t    /**\n\t     * Function to test if the input value falls with the Min / Max settings.\n\t     * This uses the parsed strings for the above parseStr function.\n\t     *\n\t     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n\t     *\n\t     * @param {object} y Big number instance\n\t     * @param {object} x Big number instance\n\t     * @returns {*}\n\t     */\n\t    function testMinMax(y, x) {\n\t        var xc = x.c;\n\t        var yc = y.c;\n\t        var i = x.s;\n\t        var j = y.s;\n\t        var k = x.e;\n\t        var l = y.e;\n\t\n\t        // Either zero?\n\t        if (!xc[0] || !yc[0]) {\n\t            var _result = void 0;\n\t            if (!xc[0]) {\n\t                _result = !yc[0] ? 0 : -j;\n\t            } else {\n\t                _result = i;\n\t            }\n\t            return _result;\n\t        }\n\t\n\t        // Signs differ?\n\t        if (i !== j) {\n\t            return i;\n\t        }\n\t        var xNeg = i < 0;\n\t\n\t        // Compare exponents\n\t        if (k !== l) {\n\t            return k > l ^ xNeg ? 1 : -1;\n\t        }\n\t        i = -1;\n\t        k = xc.length;\n\t        l = yc.length;\n\t        j = k < l ? k : l;\n\t\n\t        // Compare digit by digit\n\t        for (i += 1; i < j; i += 1) {\n\t            if (xc[i] !== yc[i]) {\n\t                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n\t            }\n\t        }\n\t\n\t        // Compare lengths\n\t        var result = void 0;\n\t        if (k === l) {\n\t            result = 0;\n\t        } else {\n\t            result = k > l ^ xNeg ? 1 : -1;\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * Check that the number satisfy the format conditions\n\t     * and lays between settings.minimumValue and settings.maximumValue\n\t     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\n\t     *\n\t     * @param {string} s\n\t     * @param {object} settings\n\t     * @returns {*}\n\t     */\n\t    function checkIfInRangeWithOverrideOption(s, settings) {\n\t        s = s.toString();\n\t        s = s.replace(',', '.');\n\t        var minParse = parseStr(settings.minimumValue);\n\t        var maxParse = parseStr(settings.maximumValue);\n\t        var valParse = parseStr(s);\n\t\n\t        var result = void 0;\n\t        switch (settings.overrideMinMaxLimits) {\n\t            case 'floor':\n\t                result = [testMinMax(minParse, valParse) > -1, true];\n\t                break;\n\t            case 'ceiling':\n\t                result = [true, testMinMax(maxParse, valParse) < 1];\n\t                break;\n\t            case 'ignore':\n\t                result = [true, true];\n\t                break;\n\t            default:\n\t                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * Thanks to Anthony & Evan C\n\t     *\n\t     * @param {Element|string} element\n\t     * @returns {*|jQuery|HTMLElement}\n\t     */\n\t    function getCurrentElement(element) {\n\t        /*\n\t         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\n\t         * for jQuery to be able to parse the selector correctly.\n\t         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\n\t         */\n\t        if (isString(element)) {\n\t            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n\t            element = '#' + element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n\t        }\n\t\n\t        return $(element);\n\t    }\n\t\n\t    /**\n\t     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\n\t     *\n\t     * @param {object} $this jQuery-selected DOM element\n\t     * @param {object} settings\n\t     * @param {boolean} update\n\t     * @returns {*}\n\t     */\n\t    function getAutoNumericHolder($this, settings) {\n\t        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t        var data = $this.data('autoNumeric');\n\t        if (!data) {\n\t            data = {};\n\t            $this.data('autoNumeric', data);\n\t        }\n\t\n\t        var holder = data.holder;\n\t        if (update || isUndefined(holder) && settings) {\n\t            holder = new AutoNumericHolder($this.get(0), settings);\n\t            data.holder = holder;\n\t        }\n\t\n\t        return holder;\n\t    }\n\t\n\t    /**\n\t     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\n\t     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n\t     *\n\t     * @param {object} settings\n\t     */\n\t    function keepAnOriginalSettingsCopy(settings) {\n\t        //TODO Rename the old option names to the new ones\n\t        settings.oDec = settings.decimalPlacesOverride;\n\t        settings.oPad = settings.allowDecimalPadding;\n\t        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n\t        settings.oSep = settings.digitGroupSeparator;\n\t        settings.oSign = settings.currencySymbol;\n\t        settings.oSuffix = settings.suffixText;\n\t    }\n\t\n\t    /**\n\t     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\n\t     * This is taken from Quirksmode.\n\t     *\n\t     * @param {string} name\n\t     * @returns {*}\n\t     */\n\t    function readCookie(name) {\n\t        var nameEQ = name + '=';\n\t        var ca = document.cookie.split(';');\n\t        var c = '';\n\t        for (var i = 0; i < ca.length; i += 1) {\n\t            c = ca[i];\n\t            while (c.charAt(0) === ' ') {\n\t                c = c.substring(1, c.length);\n\t            }\n\t            if (c.indexOf(nameEQ) === 0) {\n\t                return c.substring(nameEQ.length, c.length);\n\t            }\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    /**\n\t     * Test if sessionStorage is supported.\n\t     * This is taken from Modernizr.\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    function storageTest() {\n\t        var mod = 'modernizr';\n\t        try {\n\t            sessionStorage.setItem(mod, mod);\n\t            sessionStorage.removeItem(mod);\n\t            return true;\n\t        } catch (e) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\n\t     *\n\t     * @param {Element|EventTarget} element\n\t     * @param {object} settings\n\t     * @param {string} action\n\t     * @returns {*}\n\t     */\n\t    function saveValueToPersistentStorage(element, settings, action) {\n\t        if (settings.saveValueToSessionStorage) {\n\t            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n\t            var date = void 0;\n\t            var expires = void 0;\n\t\n\t            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n\t            if (storageTest() === false) {\n\t                switch (action) {\n\t                    case 'set':\n\t                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n\t                        break;\n\t                    case 'wipe':\n\t                        date = new Date();\n\t                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n\t                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n\t                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n\t                        break;\n\t                    case 'get':\n\t                        return readCookie(storedName);\n\t                }\n\t            } else {\n\t                switch (action) {\n\t                    case 'set':\n\t                        sessionStorage.setItem(storedName, settings.rawValue);\n\t                        break;\n\t                    case 'wipe':\n\t                        sessionStorage.removeItem(storedName);\n\t                        break;\n\t                    case 'get':\n\t                        return sessionStorage.getItem(storedName);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Holder object for field properties\n\t     */\n\t\n\t    var AutoNumericHolder = function () {\n\t        /**\n\t         * Class constructor\n\t         *\n\t         * @param {HTMLElement} that - A reference to the current DOM element\n\t         * @param {object} settings\n\t         */\n\t        function AutoNumericHolder(that, settings) {\n\t            _classCallCheck(this, AutoNumericHolder);\n\t\n\t            this.settings = settings;\n\t            this.that = that;\n\t            this.$that = $(that);\n\t            this.formatted = false;\n\t            this.settingsClone = settings;\n\t            this.value = that.value;\n\t        }\n\t\n\t        /**\n\t         * Update the value and the selection values inside the AutoNumericHolder object.\n\t         * This keeps tracks of the input value, as well as the current selection.\n\t         * This also resets the 'processed' and 'formatted' state.\n\t         *\n\t         * Note : Those two can change between the keydown, keypress and keyup events, that's why\n\t         *        this function is called on each event handler.\n\t         *\n\t         * @private\n\t         */\n\t\n\t\n\t        _createClass(AutoNumericHolder, [{\n\t            key: '_updateAutoNumericHolderProperties',\n\t            value: function _updateAutoNumericHolderProperties() {\n\t                this.value = this.that.value;\n\t                this.selection = getElementSelection(this.that);\n\t                this.processed = false;\n\t                this.formatted = false;\n\t            }\n\t\n\t            /**\n\t             * Update the keycode of the key that triggered the given event.\n\t             * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\n\t             *\n\t             * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\n\t             * e.key describe the key name used to trigger the event.\n\t             * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\n\t                 * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\t             * The key list is described here\n\t             * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n\t             *\n\t             * @param {Event} e\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_updateAutoNumericHolderEventKeycode',\n\t            value: function _updateAutoNumericHolderEventKeycode(e) {\n\t                // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\n\t                this.eventKeyCode = keyCodeNumber(e);\n\t            }\n\t\n\t            /**\n\t             * Set the text selection inside the input with the given start and end position.\n\t             *\n\t             * @param {int} start\n\t             * @param {int} end\n\t             * @param {undefined|boolean} setReal\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_setSelection',\n\t            value: function _setSelection(start, end, setReal) {\n\t                //TODO Modify setReal to be more explicit (and a boolean)\n\t                start = Math.max(start, 0);\n\t                end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\n\t                this.selection = {\n\t                    start: start,\n\t                    end: end,\n\t                    length: end - start\n\t                };\n\t\n\t                if (isUndefined(setReal) || setReal) {\n\t                    setElementSelection(this.that, start, end);\n\t                }\n\t            }\n\t\n\t            /**\n\t             * Set the caret position inside the input at the given position.\n\t             *\n\t             * @param {int} pos\n\t             * @param {undefined|boolean} setReal\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_setCaretPosition',\n\t            value: function _setCaretPosition(pos, setReal) {\n\t                //TODO Modify setReal to be more explicit (and a boolean)\n\t                this._setSelection(pos, pos, setReal);\n\t            }\n\t\n\t            /**\n\t             * Return an array containing the string parts located on the left and right side of the caret or selection.\n\t             * Those parts are left 'untouched', ie. formatted by autoNumeric.\n\t             *\n\t             * @returns {[string, string]} The parts on the left and right of the caret or selection\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_getLeftAndRightPartAroundTheSelection',\n\t            value: function _getLeftAndRightPartAroundTheSelection() {\n\t                var value = this.value;\n\t                var left = value.substring(0, this.selection.start);\n\t                var right = value.substring(this.selection.end, value.length);\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\n\t             * Return an array containing the string parts located on the left and right side of the caret or selection.\n\t             * Those parts are unformatted (stripped) of any non-numbers characters.\n\t             *\n\t             * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n\t            value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n\t                    _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n\t                    left = _getLeftAndRightPartA2[0],\n\t                    right = _getLeftAndRightPartA2[1];\n\t\n\t                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n\t\n\t\n\t                var stripZeros = true;\n\t                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n\t                    stripZeros = false;\n\t                }\n\t                left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\n\t\n\t                right = stripAllNonNumberCharacters(right, this.settingsClone, false);\n\t\n\t                if (settingsClone.trailingNegative && !contains(left, '-')) {\n\t                    left = '-' + left;\n\t                    right = right === '-' ? '' : right;\n\t                }\n\t\n\t                settingsClone.trailingNegative = false;\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\n\t             * Strip parts from excess characters and leading zeros.\n\t             *\n\t             * @param {string} left\n\t             * @param {string} right\n\t             * @returns {[*,*]}\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_normalizeParts',\n\t            value: function _normalizeParts(left, right) {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n\t                var stripZeros = true;\n\t                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n\t                    stripZeros = false;\n\t                }\n\t                left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\n\t\n\t                // If right is not empty and first character is not decimalCharacter\n\t                right = stripAllNonNumberCharacters(right, settingsClone, false);\n\t\n\t                // Prevents multiple leading zeros from being entered\n\t                if (settingsClone.leadingZero === 'deny' && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) && Number(left) === 0 && !contains(left, settingsClone.decimalCharacter) && right !== '') {\n\t                    left = left.substring(0, left.length - 1);\n\t                }\n\t\n\t                if (settingsClone.trailingNegative && !contains(left, '-')) {\n\t                    left = '-' + left;\n\t                    settingsClone.trailingNegative = false;\n\t                }\n\t\n\t                // Insert zero if has leading dot\n\t                this.newValue = left + right;\n\t                if (settingsClone.decimalCharacter) {\n\t                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.decimalCharacter));\n\t                    if (m) {\n\t                        left = left.replace(m[1], m[1] + '0');\n\t                        this.newValue = left + right;\n\t                    }\n\t                }\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\n\t             * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\n\t             *\n\t             * @param {string} left\n\t             * @param {string} right\n\t             * @param {boolean} isPaste\n\t             * @returns {boolean}\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_setValueParts',\n\t            value: function _setValueParts(left, right) {\n\t                var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t                var settingsClone = this.settingsClone;\n\t                var parts = this._normalizeParts(left, right);\n\t\n\t                var _checkIfInRangeWithOv = checkIfInRangeWithOverrideOption(this.newValue, settingsClone),\n\t                    _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n\t                    minTest = _checkIfInRangeWithOv2[0],\n\t                    maxTest = _checkIfInRangeWithOv2[1];\n\t\n\t                var position = parts[0].length;\n\t                this.newValue = parts.join('');\n\t\n\t                if (minTest && maxTest) {\n\t                    this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\n\t                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n\t                    if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n\t                        settingsClone.rawValue = '';\n\t                    } else {\n\t                        settingsClone.rawValue = testValue;\n\t                    }\n\t\n\t                    if (position > this.newValue.length) {\n\t                        position = this.newValue.length;\n\t                    }\n\t\n\t                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n\t                    if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n\t                        // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n\t                        if (parts[1] === '') {\n\t                            position = 1;\n\t                        } else {\n\t                            position = 0;\n\t                        }\n\t                    }\n\t\n\t                    this.value = this.newValue;\n\t                    this._setCaretPosition(position, false);\n\t\n\t                    return true;\n\t                }\n\t\n\t                if (!minTest) {\n\t                    this.$that.trigger('autoNumeric:minExceeded');\n\t                } else if (!maxTest) {\n\t                    this.$that.trigger('autoNumeric:maxExceeded');\n\t                }\n\t\n\t                return false;\n\t            }\n\t\n\t            /**\n\t             * Helper function for `_expandSelectionOnSign()`.\n\t             *\n\t             * @returns {*} Sign position of a formatted value\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_getSignPosition',\n\t            value: function _getSignPosition() {\n\t                var settingsClone = this.settingsClone;\n\t                var currencySymbol = settingsClone.currencySymbol;\n\t                var that = this.that;\n\t\n\t                if (currencySymbol) {\n\t                    var currencySymbolLen = currencySymbol.length;\n\t                    if (settingsClone.currencySymbolPlacement === 'p') {\n\t                        var hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n\t                        return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n\t                    }\n\t                    var valueLen = that.value.length;\n\t                    return [valueLen - currencySymbolLen, valueLen];\n\t                }\n\t\n\t                return [1000, -1];\n\t            }\n\t\n\t            /**\n\t             * Expands selection to cover whole sign\n\t             * Prevents partial deletion/copying/overwriting of a sign\n\t             *\n\t             * @param {undefined|boolean} setReal\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_expandSelectionOnSign',\n\t            value: function _expandSelectionOnSign(setReal) {\n\t                //TODO Modify setReal to be more explicit (and a boolean only)\n\t                //TODO Use array destructuring here to set signPosition to more explicit variables\n\t                var signPosition = this._getSignPosition();\n\t                var selection = this.selection;\n\t\n\t                // If selection catches something except sign and catches only space from sign\n\t                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n\t                    // Then select without empty space\n\t                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n\t                        if (selection.start < signPosition[0]) {\n\t                            this._setSelection(selection.start, signPosition[0], setReal);\n\t                        } else {\n\t                            this._setSelection(signPosition[1], selection.end, setReal);\n\t                        }\n\t                    } else {\n\t                        // Else select with whole sign\n\t                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n\t                    }\n\t                }\n\t            }\n\t\n\t            /**\n\t             * Try to strip pasted value to digits\n\t             */\n\t\n\t        }, {\n\t            key: '_checkPaste',\n\t            value: function _checkPaste() {\n\t                if (!isUndefined(this.valuePartsBeforePaste)) {\n\t                    var oldParts = this.valuePartsBeforePaste;\n\t\n\t                    var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n\t                        _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n\t                        left = _getLeftAndRightPartA4[0],\n\t                        right = _getLeftAndRightPartA4[1];\n\t\n\t                    // Try to strip the pasted value first\n\t\n\t\n\t                    delete this.valuePartsBeforePaste;\n\t\n\t                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\n\t                    if (!this._setValueParts(modifiedLeftPart, right, true)) {\n\t                        this.value = oldParts.join('');\n\t                        this._setCaretPosition(oldParts[0].length, false);\n\t                    }\n\t                }\n\t            }\n\t\n\t            /**\n\t             * Process pasting, cursor moving and skipping of not interesting keys.\n\t             * If this function returns TRUE, then further processing is not performed.\n\t             *\n\t             * @param {Event} e\n\t             * @returns {boolean}\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_skipAlways',\n\t            value: function _skipAlways(e) {\n\t                // Catch the ctrl up on ctrl-v\n\t                if ((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || e.shiftKey && this.eventKeyCode === keyCode.Insert) {\n\t                    //TODO Move this test inside the `onKeyup` handler\n\t                    this._checkPaste();\n\t                    return false;\n\t                }\n\t\n\t                // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n\t                if (this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12 || this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick || this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space ||\n\t                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\n\t                this.eventKeyCode < keyCode.Backspace && (e.which === 0 || e.which === this.eventKeyCode) || this.eventKeyCode === keyCode.NumLock || this.eventKeyCode === keyCode.ScrollLock || this.eventKeyCode === keyCode.Insert || this.eventKeyCode === keyCode.Command) {\n\t                    return true;\n\t                }\n\t\n\t                // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n\t                if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\n\t                    if (this.settings.selectNumberOnly) {\n\t                        // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n\t                        e.preventDefault();\n\t                        var valueLen = this.that.value.length;\n\t                        var currencySymbolLen = this.settings.currencySymbol.length;\n\t                        var negLen = !contains(this.that.value, '-') ? 0 : 1;\n\t                        var suffixTextLen = this.settings.suffixText.length;\n\t                        var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n\t                        var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\t\n\t                        var start = void 0;\n\t                        if (currencySymbolPlacement === 's') {\n\t                            start = 0;\n\t                        } else {\n\t                            start = negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0 ? currencySymbolLen + 1 : currencySymbolLen;\n\t                        }\n\t\n\t                        var end = void 0;\n\t                        if (currencySymbolPlacement === 'p') {\n\t                            end = valueLen - suffixTextLen;\n\t                        } else {\n\t                            switch (negativePositiveSignPlacement) {\n\t                                case 'l':\n\t                                    end = valueLen - (suffixTextLen + currencySymbolLen);\n\t                                    break;\n\t                                case 'r':\n\t                                    end = currencySymbolLen > 0 ? valueLen - (currencySymbolLen + negLen + suffixTextLen) : valueLen - (currencySymbolLen + suffixTextLen);\n\t                                    break;\n\t                                default:\n\t                                    end = valueLen - (currencySymbolLen + suffixTextLen);\n\t                            }\n\t                        }\n\t\n\t                        setElementSelection(this.that, start, end);\n\t                    }\n\t\n\t                    return true;\n\t                }\n\t\n\t                // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n\t                if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\n\t                    if (e.type === 'keydown') {\n\t                        this._expandSelectionOnSign();\n\t                    }\n\t\n\t                    // Try to prevent wrong paste\n\t                    if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\n\t                        if (e.type === 'keydown' || e.type === 'keypress') {\n\t                            if (isUndefined(this.valuePartsBeforePaste)) {\n\t                                this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n\t                            }\n\t                        } else {\n\t                            this._checkPaste();\n\t                        }\n\t                    }\n\t\n\t                    return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\n\t                }\n\t\n\t                if (e.ctrlKey || e.metaKey) {\n\t                    return true;\n\t                }\n\t\n\t                // Jump over thousand separator\n\t                //TODO Move this test inside the `onKeydown` handler\n\t                if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\n\t                    if (e.type === 'keydown' && !e.shiftKey) {\n\t                        if (this.eventKeyCode === keyCode.LeftArrow && (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\n\t                            this._setCaretPosition(this.selection.start - 1);\n\t                        } else if (this.eventKeyCode === keyCode.RightArrow && (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\n\t                            this._setCaretPosition(this.selection.start + 1);\n\t                        }\n\t                    }\n\t                    return true;\n\t                }\n\t\n\t                return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\n\t            }\n\t\n\t            /**\n\t             * Process deletion of characters when the minus sign is to the right of the numeric characters.\n\t             *\n\t             * @param {string} left The part on the left of the caret or selection\n\t             * @param {string} right The part on the right of the caret or selection\n\t             * @returns {[string, string]}\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_processCharacterDeletionIfTrailingNegativeSign',\n\t            value: function _processCharacterDeletionIfTrailingNegativeSign(_ref) {\n\t                var _ref2 = _slicedToArray(_ref, 2),\n\t                    left = _ref2[0],\n\t                    right = _ref2[1];\n\t\n\t                var settingsClone = this.settingsClone;\n\t                if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n\t                    if (this.eventKeyCode === keyCode.Backspace) {\n\t                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n\t                        if (this.value.charAt(this.selection.start - 1) === '-') {\n\t                            left = left.substring(1);\n\t                        } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        }\n\t                    } else {\n\t                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n\t                        if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t                        if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n\t                            left = left.substring(1);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\n\t                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n\t                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n\t                    if (this.eventKeyCode === keyCode.Backspace) {\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length && contains(this.value, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1);\n\t                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        }\n\t                    } else {\n\t                        if (left[0] === '-') {\n\t                            right = right.substring(1);\n\t                        }\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n\t                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n\t                    if (this.eventKeyCode === keyCode.Backspace) {\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) {\n\t                            left = left.substring(1);\n\t                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        }\n\t                    } else {\n\t                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '';\n\t                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1);\n\t                        }\n\t                        right = right.substring(1);\n\t                    }\n\t                }\n\t\n\t                return [left, right];\n\t            }\n\t\n\t            /**\n\t             * Process the deletion of characters.\n\t             */\n\t\n\t        }, {\n\t            key: '_processCharacterDeletion',\n\t            value: function _processCharacterDeletion() {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                var left = void 0;\n\t                var right = void 0;\n\t\n\t                if (!this.selection.length) {\n\t                    var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\t\n\t                    var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\t\n\t                    left = _getUnformattedLeftAn2[0];\n\t                    right = _getUnformattedLeftAn2[1];\n\t\n\t                    if (left === '' && right === '') {\n\t                        settingsClone.throwInput = false;\n\t                    }\n\t\n\t                    if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r')) && contains(this.value, '-')) {\n\t                        var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]); //TODO Change `this.value` to `this.that.value`?\n\t\n\t\n\t                        var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\t\n\t                        left = _processCharacterDele2[0];\n\t                        right = _processCharacterDele2[1];\n\t                    } else {\n\t                        if (this.eventKeyCode === keyCode.Backspace) {\n\t                            left = left.substring(0, left.length - 1);\n\t                        } else {\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t                    }\n\t                } else {\n\t                    this._expandSelectionOnSign(false);\n\t\n\t                    var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\t\n\t                    var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\t\n\t                    left = _getUnformattedLeftAn4[0];\n\t                    right = _getUnformattedLeftAn4[1];\n\t                }\n\t\n\t                this._setValueParts(left, right);\n\t            }\n\t\n\t            /**\n\t             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\n\t             * Returns TRUE if the keycode is allowed.\n\t             * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\n\t             *\n\t             * @param {Event} e\n\t             * @returns {boolean}\n\t             */\n\t\n\t        }, {\n\t            key: '_processCharacterInsertion',\n\t            value: function _processCharacterInsertion(e) {\n\t                var settingsClone = this.settingsClone;\n\t\n\t                var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n\t                    _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n\t                    left = _getUnformattedLeftAn6[0],\n\t                    right = _getUnformattedLeftAn6[1];\n\t\n\t                settingsClone.throwInput = true;\n\t\n\t                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n\t                // Do not allow decimal character if no decimal part allowed\n\t                if (e.key === settingsClone.decimalCharacter || settingsClone.decimalCharacterAlternative && e.key === settingsClone.decimalCharacterAlternative || (e.key === '.' || e.key === ',') && this.eventKeyCode === keyCode.DotNumpad) {\n\t                    if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n\t                        return true;\n\t                    }\n\t\n\t                    // Do not allow decimal character before negativeSignCharacter character\n\t                    if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n\t                        return true;\n\t                    }\n\t\n\t                    // Do not allow decimal character if other decimal character present\n\t                    if (contains(left, settingsClone.decimalCharacter)) {\n\t                        return true;\n\t                    }\n\t\n\t                    if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n\t                        return true;\n\t                    }\n\t\n\t                    if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n\t                        right = right.substr(1);\n\t                    }\n\t\n\t                    this._setValueParts(left + settingsClone.decimalCharacter, right);\n\t\n\t                    return true;\n\t                }\n\t\n\t                // Prevent minus if not allowed\n\t                if ((e.key === '-' || e.key === '+') && settingsClone.negativeSignCharacter === '-') {\n\t                    if (!settingsClone) {\n\t                        return true;\n\t                    }\n\t\n\t                    // Caret is always after minus\n\t                    if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') {\n\t                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n\t                            left = settingsClone.negativeSignCharacter;\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t\n\t                        // Change number sign, remove part if should\n\t                        if (left.charAt(0) === '-' || contains(left, settingsClone.negativeSignCharacter)) {\n\t                            left = left.substring(1, left.length);\n\t                        } else {\n\t                            left = e.key === '-' ? settingsClone.negativeSignCharacter + left : left;\n\t                        }\n\t                    } else {\n\t                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n\t                            left = settingsClone.negativeSignCharacter;\n\t                            right = right.substring(1, right.length);\n\t                        }\n\t\n\t                        // Change number sign, remove part if should\n\t                        if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n\t                            left = left.substring(1, left.length);\n\t                        } else {\n\t                            left = e.key === '-' ? settingsClone.negativeSignCharacter + left : left;\n\t                        }\n\t                    }\n\t\n\t                    this._setValueParts(left, right);\n\t\n\t                    return true;\n\t                }\n\t\n\t                // If the user tries to insert digit before minus sign\n\t                var eventNumber = Number(e.key);\n\t                if (eventNumber >= 0 && eventNumber <= 9) {\n\t                    if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n\t                        left = settingsClone.negativeSignCharacter;\n\t                        right = right.substring(1, right.length);\n\t                    }\n\t\n\t                    if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && e.key !== '0') {\n\t                        left = settingsClone.negativeSignCharacter + left;\n\t                    }\n\t\n\t                    this._setValueParts(left + e.key, right);\n\t\n\t                    return true;\n\t                }\n\t\n\t                // Prevent any other character\n\t                settingsClone.throwInput = false;\n\t\n\t                return false;\n\t            }\n\t\n\t            /**\n\t             * Formatting of just processed value while keeping the cursor position\n\t             *\n\t             * @param {Event} e\n\t             * @private\n\t             */\n\t\n\t        }, {\n\t            key: '_formatValue',\n\t            value: function _formatValue(e) {\n\t                var _this = this;\n\t\n\t                var settingsClone = this.settingsClone;\n\t                var leftLength = this.value;\n\t\n\t                var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n\t                    _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n\t                    left = _getUnformattedLeftAn8[0];\n\t\n\t                // No grouping separator and no currency sign\n\t\n\t\n\t                if ((settingsClone.digitGroupSeparator === '' || settingsClone.digitGroupSeparator !== '' && !contains(leftLength, settingsClone.digitGroupSeparator)) && (settingsClone.currencySymbol === '' || settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol))) {\n\t                    var _leftLength$split = leftLength.split(settingsClone.decimalCharacter),\n\t                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n\t                        subParts = _leftLength$split2[0];\n\t\n\t                    var nSign = '';\n\t                    if (contains(subParts, '-')) {\n\t                        nSign = '-';\n\t                        subParts = subParts.replace('-', '');\n\t                        left = left.replace('-', '');\n\t                    }\n\t\n\t                    // Strip leading zero on positive value if needed\n\t                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n\t                        left = left.slice(1);\n\t                    }\n\t\n\t                    // Strip leading zero on negative value if needed\n\t                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n\t                        left = left.slice(1);\n\t                    }\n\t\n\t                    left = nSign + left;\n\t                }\n\t\n\t                var value = addGroupSeparators(this.value, this.settingsClone);\n\t                var position = value.length;\n\t                if (value) {\n\t                    // Prepare regexp which searches for cursor position from unformatted left part\n\t                    var leftAr = left.split('');\n\t\n\t                    // Fixes caret position with trailing minus sign\n\t                    if ((settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') && leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n\t                        leftAr.shift();\n\t\n\t                        if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) && settingsClone.caretFix) {\n\t                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n\t                                leftAr.push('-');\n\t                                settingsClone.caretFix = e.type === 'keydown';\n\t                            }\n\t\n\t                            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n\t                                leftAr.push('-');\n\t                                settingsClone.caretFix = e.type === 'keydown';\n\t                            }\n\t\n\t                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n\t                                (function () {\n\t                                    var signParts = settingsClone.currencySymbol.split('');\n\t                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n\t                                    var escapedParts = [];\n\t                                    $.each(signParts, function (i, miniParts) {\n\t                                        miniParts = signParts[i];\n\t                                        if (isInArray(miniParts, escapeChr)) {\n\t                                            escapedParts.push('\\\\' + miniParts);\n\t                                        } else {\n\t                                            escapedParts.push(miniParts);\n\t                                        }\n\t                                    });\n\t\n\t                                    if (_this.eventKeyCode === keyCode.Backspace) {\n\t                                        escapedParts.push('-');\n\t                                    }\n\t\n\t                                    // Pushing the escaped sign\n\t                                    leftAr.push(escapedParts.join(''));\n\t                                    settingsClone.caretFix = e.type === 'keydown';\n\t                                })();\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    for (var i = 0; i < leftAr.length; i++) {\n\t                        if (!leftAr[i].match('\\\\d')) {\n\t                            leftAr[i] = '\\\\' + leftAr[i];\n\t                        }\n\t                    }\n\t\n\t                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\t\n\t                    // Search cursor position in formatted value\n\t                    var newLeft = value.match(leftReg);\n\t                    if (newLeft) {\n\t                        position = newLeft[0].length;\n\t\n\t                        // If we are just before the sign which is in prefix position\n\t                        if ((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter || position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n\t                            // Place caret after prefix sign\n\t                            position = this.settingsClone.currencySymbol.length + (value.charAt(0) === '-' ? 1 : 0);\n\t                        }\n\t                    } else {\n\t                        if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n\t                            // If we could not find a place for cursor and have a sign as a suffix\n\t                            // Place caret before suffix currency sign\n\t                            position -= settingsClone.currencySymbol.length;\n\t                        }\n\t\n\t                        if (settingsClone.suffixText) {\n\t                            // If we could not find a place for cursor and have a suffix\n\t                            // Place caret before suffix\n\t                            position -= settingsClone.suffixText.length;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                // Only update the value if it has changed. This prevents modifying the selection, if any.\n\t                if (value !== this.that.value || value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\n\t                    this.that.value = value;\n\t                    this._setCaretPosition(position);\n\t                }\n\t\n\t                this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n\t            }\n\t        }]);\n\t\n\t        return AutoNumericHolder;\n\t    }();\n\t\n\t    /**\n\t     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n\t     *\n\t     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n\t     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n\t     *\n\t     * It then loops through the string and un-formats the inputs with autoNumeric.\n\t     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n\t     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\n\t     *\n\t     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n\t     * @param {HTMLElement} that - A reference to the current DOM element\n\t     * @returns {*}\n\t     * @private\n\t     */\n\t\n\t\n\t    function _getStringOrArray() {\n\t        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\t        var that = arguments[1];\n\t\n\t        var $this = getCurrentElement(that);\n\t        var formIndex = $('form').index($this);\n\t        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n\t        var aiIndex = [];\n\t\n\t        // all input index\n\t        var scIndex = [];\n\t\n\t        // successful control index\n\t        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\t\n\t        // from jQuery serialize method\n\t        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\t\n\t        // from jQuery serialize method\n\t        var rCheckableType = /^(?:checkbox|radio)$/i;\n\t        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\t\n\t        var count = 0;\n\t\n\t        // index of successful elements\n\t        $.each(allFormElements, function (i, field) {\n\t            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n\t                scIndex.push(count);\n\t                count++;\n\t            } else {\n\t                scIndex.push(-1);\n\t            }\n\t        });\n\t\n\t        // index of all inputs tags except checkbox\n\t        count = 0;\n\t        $.each(allFormElements, function (i, field) {\n\t            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n\t                aiIndex.push(count);\n\t                count++;\n\t            } else {\n\t                aiIndex.push(-1);\n\t                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n\t                    count++;\n\t                }\n\t            }\n\t        });\n\t\n\t        if (getArrayBehavior) {\n\t            var formFields = $this.serializeArray();\n\t\n\t            $.each(formFields, function (i, field) {\n\t                var scElement = scIndex.indexOf(i);\n\t\n\t                if (scElement > -1 && aiIndex[scElement] > -1) {\n\t                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n\t                    var settings = testInput.data('autoNumeric');\n\t\n\t                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                        field.value = testInput.autoNumeric('getLocalized').toString();\n\t                    }\n\t                }\n\t            });\n\t\n\t            return formFields;\n\t        } else {\n\t            var _ret2 = function () {\n\t                // getString() behavior\n\t                var formFields = $this.serialize();\n\t                var formParts = formFields.split('&');\n\t\n\t                $.each(formParts, function (i) {\n\t                    var _formParts$i$split = formParts[i].split('='),\n\t                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n\t                        inputName = _formParts$i$split2[0],\n\t                        inputValue = _formParts$i$split2[1];\n\t\n\t                    var scElement = scIndex.indexOf(i);\n\t\n\t                    // If the current element is a valid element\n\t                    if (scElement > -1 && aiIndex[scElement] > -1) {\n\t                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n\t                        var settings = testInput.data('autoNumeric');\n\t\n\t                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                            if (inputValue !== null) {\n\t                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n\t                                formParts[i] = inputName + '=' + modifiedInputValue;\n\t                            }\n\t                        }\n\t                    }\n\t                });\n\t\n\t                return {\n\t                    v: formParts.join('&')\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Handler for 'focusin' events\n\t     *\n\t     * @param {object} $this jQuery-selected DOM element\n\t     * @param {AutoNumericHolder} holder\n\t     * @param {Event} e\n\t     */\n\t    function onFocusInAndMouseEnter($this, holder, e) {\n\t        var settings = holder.settingsClone;\n\t\n\t        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n\t            settings.onOff = true;\n\t\n\t            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n\t                $this.val(toggleNegativeBracket(e.target.value, settings));\n\t            }\n\t\n\t            var result = void 0;\n\t            //TODO Do not repeat yourself with the `$this.autoNumeric('set', settings.rawValue);` line\n\t            if (settings.decimalPlacesShownOnFocus) {\n\t                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n\t                $this.autoNumeric('set', settings.rawValue);\n\t            } else if (settings.scaleDivisor) {\n\t                settings.decimalPlacesOverride = settings.oDec;\n\t                $this.autoNumeric('set', settings.rawValue);\n\t            } else if (settings.noSeparatorOnFocus) {\n\t                settings.digitGroupSeparator = '';\n\t                settings.currencySymbol = '';\n\t                settings.suffixText = '';\n\t                $this.autoNumeric('set', settings.rawValue);\n\t            } else if ((result = stripAllNonNumberCharacters(e.target.value, settings, true)) !== settings.rawValue) {\n\t                $this.autoNumeric('set', result);\n\t            }\n\t\n\t            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n\t            holder.valueOnFocus = e.target.value;\n\t            holder.lastVal = holder.valueOnFocus;\n\t            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n\t            if (onEmpty !== null && onEmpty !== '' && settings.emptyInputBehavior === 'focus') {\n\t                $this.val(onEmpty);\n\t                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n\t                    setElementSelection(e.target, 0, 0);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Handler for 'keydown' events.\n\t     * The user just started pushing any key, hence one event is sent.\n\t     *\n\t     * Note :\n\t     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\n\t     * - keydown\n\t     * - keypress\n\t     * - input\n\t     * - keyup\n\t     *\n\t     * ...when inputting a modifier key (ie. 'ctrl') :\n\t     * - keydown\n\t     * - keyup\n\t     *\n\t     * If 'delete' or 'backspace' is entered, the following events are sent :\n\t     * - keydown\n\t     * - input\n\t     * - keyup\n\t     *\n\t     * If 'enter' is entered and the value has not changed, the following events are sent :\n\t     * - keydown\n\t     * - keypress\n\t     * - keyup\n\t     *\n\t     * If 'enter' is entered and the value has been changed, the following events are sent :\n\t     * - keydown\n\t     * - keypress\n\t     * - change\n\t     * - keyup\n\t     *\n\t     * When a paste is done, the following events are sent :\n\t     * - input (if paste is done with the mouse)\n\t     *\n\t     * - keydown (if paste is done with ctrl+v)\n\t     * - keydown\n\t     * - input\n\t     * - keyup\n\t     * - keyup\n\t     *\n\t     * @param {AutoNumericHolder} holder\n\t     * @param {Event} e\n\t     */\n\t    function onKeydown(holder, e) {\n\t        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n\t        holder._updateAutoNumericHolderEventKeycode(e);\n\t        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\n\t\n\t        if (holder.that.readOnly) {\n\t            holder.processed = true;\n\t\n\t            return;\n\t        }\n\t\n\t        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n\t        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n\t            triggerEvent('change', e.target);\n\t            holder.valueOnFocus = e.target.value;\n\t        }\n\t\n\t        holder._updateAutoNumericHolderProperties(e);\n\t\n\t        if (holder._skipAlways(e)) {\n\t            holder.processed = true;\n\t\n\t            return;\n\t        }\n\t\n\t        // Check if the key is a delete/backspace key\n\t        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\n\t            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n\t            holder.processed = true;\n\t            holder._formatValue(e);\n\t\n\t            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n\t            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n\t                // Throw an input event when a character deletion is detected\n\t                triggerEvent('input', e.target);\n\t                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n\t            }\n\t\n\t            holder.lastVal = e.target.value;\n\t            holder.settingsClone.throwInput = true;\n\t\n\t            return;\n\t        }\n\t\n\t        holder.formatted = false; //TODO Is this line needed?\n\t    }\n\t\n\t    /**\n\t     * Handler for 'keypress' events.\n\t     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\n\t     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\n\t     *\n\t     * @param {AutoNumericHolder} holder\n\t     * @param {Event} e\n\t     */\n\t    function onKeypress(holder, e) {\n\t        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n\t        if (e.key === keyName.Insert) {\n\t            return;\n\t        }\n\t\n\t        var processed = holder.processed;\n\t        holder._updateAutoNumericHolderProperties(e);\n\t\n\t        if (holder._skipAlways(e)) {\n\t            return;\n\t        }\n\t\n\t        if (processed) {\n\t            e.preventDefault();\n\t\n\t            return;\n\t        }\n\t\n\t        var isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\n\t        if (isCharacterInsertionAllowed) {\n\t            holder._formatValue(e);\n\t            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n\t                // Throws input event on adding a character\n\t                triggerEvent('input', e.target);\n\t                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n\t            } else {\n\t                // If the value has not changed, we do not allow the input event to be sent\n\t                e.preventDefault();\n\t            }\n\t\n\t            holder.lastVal = e.target.value;\n\t            holder.settingsClone.throwInput = true;\n\t\n\t            return;\n\t        }\n\t\n\t        e.preventDefault();\n\t\n\t        holder.formatted = false;\n\t    }\n\t\n\t    /**\n\t     * Handler for 'keyup' events.\n\t     * The user just released any key, hence one event is sent.\n\t     *\n\t     * @param {AutoNumericHolder} holder\n\t     * @param {object} settings\n\t     * @param {Event} e\n\t     */\n\t    function onKeyup(holder, settings, e) {\n\t        holder._updateAutoNumericHolderProperties(e);\n\t\n\t        var skip = holder._skipAlways(e);\n\t        delete holder.valuePartsBeforePaste;\n\t        if (skip || e.target.value === '') {\n\t            return;\n\t        }\n\t\n\t        // Added to properly place the caret when only the currency sign is present\n\t        if (e.target.value === holder.settingsClone.currencySymbol) {\n\t            if (holder.settingsClone.currencySymbolPlacement === 's') {\n\t                setElementSelection(e.target, 0, 0);\n\t            } else {\n\t                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\n\t            }\n\t        } else if (holder.eventKeyCode === keyCode.Tab) {\n\t            setElementSelection(e.target, 0, e.target.value.length);\n\t        }\n\t\n\t        if (e.target.value === holder.settingsClone.suffixText || holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '') {\n\t            setElementSelection(e.target, 0, 0);\n\t        }\n\t\n\t        // Saves the extended decimal to preserve the data when navigating away from the page\n\t        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n\t            saveValueToPersistentStorage(e.target, settings, 'set');\n\t        }\n\t\n\t        if (!holder.formatted) {\n\t            holder._formatValue(e);\n\t        }\n\t\n\t        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n\t        if (e.target.value !== holder.initialValueOnKeydown) {\n\t            triggerEvent('autoNumeric:formatted', e.target);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Handler for 'focusout' events\n\t     *\n\t     * @param {object} $this jQuery-selected DOM element\n\t     * @param {AutoNumericHolder} holder\n\t     * @param {Event} e\n\t     */\n\t    function onFocusOutAndMouseLeave($this, holder, e) {\n\t        if (!$this.is(':focus')) {\n\t            var value = e.target.value;\n\t            var origValue = value;\n\t            var settings = holder.settingsClone;\n\t            settings.onOff = false;\n\t\n\t            if (settings.saveValueToSessionStorage) {\n\t                saveValueToPersistentStorage(e.target, settings, 'set');\n\t            }\n\t\n\t            if (settings.noSeparatorOnFocus === true) {\n\t                settings.digitGroupSeparator = settings.oSep;\n\t                settings.currencySymbol = settings.oSign;\n\t                settings.suffixText = settings.oSuffix;\n\t            }\n\t\n\t            if (settings.decimalPlacesShownOnFocus !== null) {\n\t                settings.decimalPlacesOverride = settings.oDec;\n\t                settings.allowDecimalPadding = settings.oPad;\n\t                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n\t            }\n\t\n\t            value = stripAllNonNumberCharacters(value, settings, true);\n\t\n\t            if (value !== '') {\n\t                if (settings.trailingNegative) {\n\t                    value = '-' + value;\n\t                    settings.trailingNegative = false;\n\t                }\n\t\n\t                var _checkIfInRangeWithOv3 = checkIfInRangeWithOverrideOption(value, settings),\n\t                    _checkIfInRangeWithOv4 = _slicedToArray(_checkIfInRangeWithOv3, 2),\n\t                    minTest = _checkIfInRangeWithOv4[0],\n\t                    maxTest = _checkIfInRangeWithOv4[1];\n\t\n\t                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n\t                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n\t                    settings.rawValue = value;\n\t\n\t                    if (settings.scaleDivisor) {\n\t                        value = value / settings.scaleDivisor;\n\t                        value = value.toString();\n\t                    }\n\t\n\t                    settings.decimalPlacesOverride = settings.scaleDivisor && settings.scaleDecimalPlaces ? +settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n\t                    value = roundValue(value, settings);\n\t                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n\t                } else {\n\t                    if (!minTest) {\n\t                        $this.trigger('autoNumeric:minExceeded');\n\t                    }\n\t                    if (!maxTest) {\n\t                        $this.trigger('autoNumeric:maxExceeded');\n\t                    }\n\t\n\t                    value = settings.rawValue;\n\t                }\n\t            } else {\n\t                if (settings.emptyInputBehavior === 'zero') {\n\t                    settings.rawValue = '0';\n\t                    value = roundValue('0', settings);\n\t                } else {\n\t                    settings.rawValue = '';\n\t                }\n\t            }\n\t\n\t            var groupedValue = checkEmpty(value, settings, false);\n\t            if (groupedValue === null) {\n\t                groupedValue = addGroupSeparators(value, settings);\n\t            }\n\t\n\t            if (groupedValue !== origValue) {\n\t                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n\t                $this.val(groupedValue);\n\t            }\n\t\n\t            if (groupedValue !== holder.valueOnFocus) {\n\t                $this.change();\n\t                delete holder.valueOnFocus;\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Handler for 'paste' events\n\t     *\n\t     * @param {object} $this jQuery-selected DOM element\n\t     * @param {AutoNumericHolder} holder\n\t     * @param {Event} e\n\t     */\n\t    function onPaste($this, holder, e) {\n\t        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n\t        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n\t        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n\t        e.preventDefault();\n\t\n\t        var rawPastedText = e.clipboardData.getData('text/plain');\n\t\n\t        // 0. Special case if the user has selected all the input text before pasting\n\t        var initialFormattedValue = e.target.value;\n\t        var selectionStart = e.target.selectionStart || 0;\n\t        var selectionEnd = e.target.selectionEnd || 0;\n\t        var selectionSize = selectionEnd - selectionStart;\n\t        var isAllInputTextSelected = false;\n\t\n\t        if (selectionSize === initialFormattedValue.length) {\n\t            isAllInputTextSelected = true;\n\t        }\n\t\n\t        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n\t        var isPasteNegative = isNegative(rawPastedText);\n\t        if (isPasteNegative) {\n\t            // 1a. Remove the negative sign from the pasted text\n\t            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n\t        }\n\t        var rawPastedTextSize = rawPastedText.length; // This use the 'cleaned' paste text\n\t\n\t        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n\t        var pastedText = preparePastedText(rawPastedText, holder);\n\t\n\t        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n\t        if (!isNumber(pastedText) || pastedText === '') {\n\t            if (holder.settings.onInvalidPaste === 'error') {\n\t                //TODO Should we send a warning instead of throwing an error?\n\t                throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n\t            }\n\t\n\t            return;\n\t        }\n\t\n\t        // 4. Calculate the paste result\n\t        var caretPositionOnInitialTextAfterPasting = void 0;\n\t        var initialUnformattedNumber = void 0;\n\t        if (e.target.value === '') {\n\t            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\n\t            initialUnformattedNumber = '';\n\t        } else {\n\t            initialUnformattedNumber = $this.autoNumeric('get');\n\t        }\n\t        var isInitialValueNegative = isNegative(initialUnformattedNumber);\n\t        var isPasteNegativeAndInitialValueIsPositive = void 0;\n\t        var result = void 0;\n\t\n\t        // If the pasted content is negative, then the result will be negative too\n\t        if (isPasteNegative && !isInitialValueNegative) {\n\t            initialUnformattedNumber = '-' + initialUnformattedNumber;\n\t            isInitialValueNegative = true;\n\t            isPasteNegativeAndInitialValueIsPositive = true;\n\t        } else {\n\t            isPasteNegativeAndInitialValueIsPositive = false;\n\t        }\n\t\n\t        switch (holder.settings.onInvalidPaste) {\n\t            /* 4a. Truncate paste behavior:\n\t             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\n\t             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\n\t             * Otherwise paste all the numbers in the clipboard.\n\t             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\n\t             *\n\t             * 4b. Replace paste behavior:\n\t             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\n\t             */\n\t            /* eslint no-case-declarations: 0 */\n\t            case 'truncate':\n\t            case 'replace':\n\t                var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n\t                var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\t\n\t                if (selectionStart !== selectionEnd) {\n\t                    // a. If there is a selection, remove the selected part, and return the left and right part\n\t                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\n\t                } else {\n\t                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n\t                    result = preparePastedText(initialFormattedValue, holder);\n\t                }\n\t\n\t                // Add back the negative sign if needed\n\t                if (isInitialValueNegative) {\n\t                    result = setRawNegativeSign(result);\n\t                }\n\t\n\t                // Build the unformatted result string\n\t                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n\t                if (isPasteNegativeAndInitialValueIsPositive) {\n\t                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n\t                    caretPositionOnInitialTextAfterPasting++;\n\t                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n\t                }\n\t\n\t                var leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n\t                var rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n\t                // -- Here, we are good to go to continue on the same basis\n\t\n\t                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n\t                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n\t                var minParse = parseStr(holder.settings.minimumValue);\n\t                var maxParse = parseStr(holder.settings.maximumValue);\n\t                var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n\t                var pastedTextIndex = 0;\n\t                var modifiedLeftPart = leftPart;\n\t\n\t                while (pastedTextIndex < pastedText.length) {\n\t                    // Modify the result with another pasted character\n\t                    modifiedLeftPart += pastedText[pastedTextIndex];\n\t                    result = modifiedLeftPart + rightPart;\n\t\n\t                    // Check the range limits\n\t                    if (!checkIfInRange(result, minParse, maxParse)) {\n\t                        // The result is out of the range limits, stop the loop here\n\t                        break;\n\t                    }\n\t\n\t                    // Save the last good known result\n\t                    lastGoodKnownResult = result;\n\t\n\t                    // Update the local variables for the next loop\n\t                    pastedTextIndex++;\n\t                }\n\t\n\t                // Update the last caret position where to insert a new number\n\t                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\t\n\t                //XXX Here we have the result for the `truncate` option\n\t                if (holder.settings.onInvalidPaste === 'truncate') {\n\t                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n\t                    result = lastGoodKnownResult;\n\t                    break;\n\t                }\n\t                //XXX ...else we need to continue modifying the result for the 'replace' option\n\t\n\t                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n\t                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n\t                //    If you do get to the range limits, use the previous known good value within those limits.\n\t                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n\t                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n\t                var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n\t                var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\t\n\t                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n\t                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n\t                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n\t                        lastGoodKnownResultIndex++;\n\t                        continue;\n\t                    }\n\t\n\t                    // This replace one character at a time\n\t                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\t\n\t                    // Check the range limits\n\t                    if (!checkIfInRange(result, minParse, maxParse)) {\n\t                        // The result is out of the range limits, stop the loop here\n\t                        break;\n\t                    }\n\t\n\t                    // Save the last good known result\n\t                    lastGoodKnownResult = result;\n\t\n\t                    // Update the local variables for the next loop\n\t                    pastedTextIndex++;\n\t                    lastGoodKnownResultIndex++;\n\t                }\n\t\n\t                // Update the last caret position where to insert a new number\n\t                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\t\n\t                result = lastGoodKnownResult;\n\t\n\t                break;\n\t            /* 4c. Normal paste behavior:\n\t             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\n\t             */\n\t            case 'error':\n\t            case 'ignore':\n\t            case 'clamp':\n\t            default:\n\t                // Test if there is a selection in the input\n\t                if (selectionStart === selectionEnd) {\n\t                    // There is no selection, and this is the caret position : Insert the paste into the element.value at that caret position\n\t                    var indexWhereToInsertThePastedText = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n\t                    if (isPasteNegativeAndInitialValueIsPositive) {\n\t                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n\t                        indexWhereToInsertThePastedText++;\n\t                    }\n\t\n\t                    result = insertCharAtPosition(initialUnformattedNumber, pastedText, indexWhereToInsertThePastedText);\n\t\n\t                    caretPositionOnInitialTextAfterPasting = indexWhereToInsertThePastedText + rawPastedTextSize - countDotsInText(rawPastedText); // I must not count the characters that have been removed from the pasted text (ie. '.')\n\t                } else {\n\t                    // There is a selection : replace the selection with the paste content\n\t                    var firstPart = e.target.value.slice(0, selectionStart);\n\t                    var lastPart = e.target.value.slice(selectionEnd, e.target.value.length);\n\t                    result = firstPart + pastedText + lastPart;\n\t\n\t                    // Finally, remove any unwanted non-number characters\n\t                    if (firstPart !== '' || lastPart !== '') {\n\t                        // If the whole input has been selected prior to pasting, then firstPart and lastPart are empty, hence we only use the pastedText variable, otherwise we remove the potential decimal character in the result variable\n\t                        result = preparePastedText(result, holder);\n\t                    }\n\t\n\t                    // Add back the negative sign if needed\n\t                    if (isInitialValueNegative) {\n\t                        result = setRawNegativeSign(result);\n\t                    }\n\t\n\t                    if (isAllInputTextSelected) {\n\t                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n\t                        caretPositionOnInitialTextAfterPasting = result.length;\n\t                    } else {\n\t                        // Normal case\n\t                        var indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\n\t\n\t                        if (isPasteNegativeAndInitialValueIsPositive) {\n\t                            // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n\t                            indexSelectionEndInRawValue++;\n\t                        }\n\t\n\t                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n\t                        var selectedText = e.target.value.slice(selectionStart, selectionEnd);\n\t                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + rawPastedTextSize - countDotsInText(rawPastedText);\n\t                    }\n\t                }\n\t        }\n\t\n\t        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n\t        if (!isNumber(result) || result === '') {\n\t            if (holder.settings.onInvalidPaste === 'error') {\n\t                throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n\t                //TODO This is not DRY ; refactor with above\n\t            }\n\t            return;\n\t        }\n\t\n\t        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n\t        /*\n\t         * If 'error' (this is the default) :\n\t         *      - Normal paste behavior.\n\t         *      - Try to set the new value, if it fails, then throw an error in the console.\n\t         *      - Do not change the input value, do not change the current selection.\n\t         * If 'ignore' :\n\t         *      - Normal paste behavior.\n\t         *      - Try to set the new value, if it fails, do nothing more.\n\t         *      - Do not change the input value, do not change the current selection.\n\t         * If 'clamp' :\n\t         *      - Normal paste behavior.\n\t         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\n\t         *        paste result.\n\t         *      - Change the caret position to be positioned on the left hand side of the decimal character.\n\t         * If 'truncate' :\n\t         *      - Truncate paste behavior.\n\t         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n\t         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\n\t         *      - Change the caret position to be positioned after the last pasted character.\n\t         * If 'replace' :\n\t         *      - Replace paste behavior.\n\t         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n\t          *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\n\t         *      - Change the caret position to be positioned after the last pasted character.\n\t         */\n\t        var valueHasBeenSet = false;\n\t        var valueHasBeenClamped = false;\n\t        try {\n\t            $this.autoNumeric('set', result);\n\t            valueHasBeenSet = true;\n\t        } catch (error) {\n\t            var clampedValue = void 0;\n\t            switch (holder.settings.onInvalidPaste) {\n\t                case 'clamp':\n\t                    clampedValue = clampToRangeLimits(result, holder.settings);\n\t                    try {\n\t                        $this.autoNumeric('set', clampedValue);\n\t                    } catch (error) {\n\t                        throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n\t                    }\n\t\n\t                    valueHasBeenClamped = true;\n\t                    valueHasBeenSet = true;\n\t                    result = clampedValue; // This is used only for setting the caret position later\n\t                    break;\n\t                case 'error':\n\t                case 'truncate':\n\t                case 'replace':\n\t                    // Throw an error message\n\t                    throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + holder.settings.minimumValue + '] and maximum [' + holder.settings.maximumValue + '] value range.');\n\t                // falls through\n\t                case 'ignore':\n\t                // Do nothing\n\t                // falls through\n\t                default:\n\t                    return; // ...and nothing else should be changed\n\t            }\n\t        }\n\t\n\t        // 7. Then lastly, set the caret position at the right logical place\n\t        var caretPositionInFormattedNumber = void 0;\n\t        if (valueHasBeenSet) {\n\t            switch (holder.settings.onInvalidPaste) {\n\t                case 'clamp':\n\t                    if (valueHasBeenClamped) {\n\t                        if (holder.settings.currencySymbolPlacement === 's') {\n\t                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n\t                        } else {\n\t                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\n\t                        }\n\t\n\t                        break;\n\t                    } // else if the value has not been clamped, the default behavior is used...\n\t                // falls through\n\t                case 'error':\n\t                case 'ignore':\n\t                case 'truncate':\n\t                case 'replace':\n\t                default:\n\t                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n\t                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\n\t                    setElementSelection(e.target, caretPositionInFormattedNumber);\n\t            }\n\t        }\n\t\n\t        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n\t        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\n\t            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n\t            triggerEvent('input', e.target);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\n\t     *\n\t     * @param {AutoNumericHolder} holder\n\t     * @param {Event} e\n\t     */\n\t    function onBlur(holder, e) {\n\t        if (e.target.value !== holder.valueOnFocus) {\n\t            triggerEvent('change', e.target);\n\t            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery, which adds '.00' at the end of an integer\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Handler for 'submit' events\n\t     *\n\t     * @param {object} $this jQuery-selected DOM element\n\t     * @param {AutoNumericHolder} holder\n\t     */\n\t    function onSubmit($this, holder) {\n\t        $this.closest('form').on('submit.autoNumeric', function () {\n\t            if (holder) {\n\t                var $settings = holder.settingsClone;\n\t\n\t                if ($settings.unformatOnSubmit) {\n\t                    $this.val($settings.rawValue);\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n\t     *\n\t     * @param {object} $this jQuery-selected DOM element\n\t     * @returns {boolean|*}\n\t     */\n\t    function getInputIfSupportedTagAndType($this) {\n\t        // Supported input type\n\t        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t\n\t        // Checks for non-supported input types\n\t        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n\t            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n\t        }\n\t\n\t        // Checks for non-supported tags\n\t        var currentElementTag = $this.prop('tagName').toLowerCase();\n\t        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n\t            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n\t        }\n\t\n\t        return $input;\n\t    }\n\t\n\t    /**\n\t     * Routine to format the default value on page load\n\t     *\n\t     * @param {object} settings\n\t     * @param {object} $input jQuery-selected <input> element\n\t     * @param {object} $this jQuery-selected DOM element\n\t     */\n\t    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n\t        var setValue = true;\n\t\n\t        if ($input) {\n\t            var currentValue = $this.val();\n\t            /*\n\t             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n\t             * precedence and should get formatted on init (if this input value is a valid number and that the\n\t             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\n\t             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n\t             *\n\t             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\n\t             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n\t             * changed the input value, and then it means we should not overwrite his own decision to do so.\n\t             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n\t             * we should ignore `defaultValueOverride` altogether.\n\t             */\n\t            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n\t                // Check if the `value` is valid or not\n\t                var testedCurrentValue = parseFloat(currentValue.replace(',', '.'));\n\t                //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n\t                if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n\t                    $this.autoNumeric('set', testedCurrentValue);\n\t                    setValue = false;\n\t                } else {\n\t                    // If not, inform the developer that nothing usable has been provided\n\t                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n\t                }\n\t            } else {\n\t                /* Checks for :\n\t                 * - page reload from back button, and\n\t                 * - ASP.net form post back\n\t                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n\t                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n\t                 */\n\t                //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n\t                if (settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue || settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(currentValue.replace(',', '.'))) {\n\t                    if (settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage || settings.scaleDivisor && settings.saveValueToSessionStorage) {\n\t                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\n\t                    }\n\t\n\t                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n\t                    if (!settings.saveValueToSessionStorage) {\n\t                        var toStrip = void 0;\n\t\n\t                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n\t                            settings.onOff = true;\n\t                            toStrip = toggleNegativeBracket(currentValue, settings);\n\t                        } else {\n\t                            toStrip = currentValue;\n\t                        }\n\t\n\t                        settings.rawValue = (settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && settings.negativeSignCharacter !== '' && contains(currentValue, '-') ? '-' + stripAllNonNumberCharacters(toStrip, settings, true) : stripAllNonNumberCharacters(toStrip, settings, true);\n\t                    }\n\t\n\t                    setValue = false;\n\t                }\n\t            }\n\t\n\t            if (currentValue === '') {\n\t                switch (settings.emptyInputBehavior) {\n\t                    case 'focus':\n\t                        setValue = false;\n\t                        break;\n\t                    case 'always':\n\t                        $this.val(settings.currencySymbol);\n\t                        setValue = false;\n\t                        break;\n\t                    case 'zero':\n\t                        $this.autoNumeric('set', '0');\n\t                        setValue = false;\n\t                        break;\n\t                    default:\n\t                    //\n\t                }\n\t            } else if (setValue && currentValue === $this.attr('value')) {\n\t                $this.autoNumeric('set', currentValue);\n\t            }\n\t        }\n\t\n\t        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n\t            if (settings.defaultValueOverride !== null) {\n\t                if (settings.defaultValueOverride === $this.text()) {\n\t                    $this.autoNumeric('set', $this.text());\n\t                }\n\t            } else {\n\t                $this.autoNumeric('set', $this.text());\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\n\t     *\n\t     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\n\t     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\n\t     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\n\t     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\n\t     *\n\t     * @param {object} options\n\t     * @param {object} settings\n\t     */\n\t    function correctPNegOption(options, settings) {\n\t        //TODO Merge the options and settings parameter to use only `settings`\n\t        if (!isUndefined(options) && isUndefinedOrNullOrEmpty(options.negativePositiveSignPlacement) && options.currencySymbol !== '') {\n\t            switch (settings.currencySymbolPlacement) {\n\t                case 's':\n\t                    settings.negativePositiveSignPlacement = 'p';\n\t                    break;\n\t                case 'p':\n\t                    settings.negativePositiveSignPlacement = 'r';\n\t                    break;\n\t                default:\n\t                //\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Analyze and save the minimumValue and maximumValue integer size for later uses\n\t     *\n\t     * @param {object} settings\n\t     */\n\t    function calculateVMinAndVMaxIntegerSizes(settings) {\n\t        var _settings$maximumValu = settings.maximumValue.toString().split('.'),\n\t            _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n\t            maximumValueIntegerPart = _settings$maximumValu2[0];\n\t\n\t        var _ref3 = !settings.minimumValue && settings.minimumValue !== 0 ? [] : settings.minimumValue.toString().split('.'),\n\t            _ref4 = _slicedToArray(_ref3, 1),\n\t            minimumValueIntegerPart = _ref4[0];\n\t\n\t        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n\t        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\t\n\t        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n\t        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n\t    }\n\t\n\t    /**\n\t     * Modify `decimalPlacesOverride` as needed\n\t     *\n\t     * @param {object} settings\n\t     */\n\t    function correctMDecOption(settings) {\n\t        if (!isNull(settings.scaleDivisor) && !isNull(settings.scaleDecimalPlaces)) {\n\t            // Override the maximum number of decimal places with the one defined with the number of decimals to show when not in focus, if set\n\t            settings.decimalPlacesOverride = settings.scaleDecimalPlaces;\n\t        } else if (isNull(settings.decimalPlacesOverride)) {\n\t            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n\t        }\n\t        settings.oDec = String(settings.decimalPlacesOverride);\n\t\n\t        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n\t        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n\t    }\n\t\n\t    /**\n\t     * Sets the alternative decimal separator key.\n\t     *\n\t     * @param {object} settings\n\t     */\n\t    function setsAlternativeDecimalSeparatorCharacter(settings) {\n\t        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n\t            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n\t                settings.decimalCharacterAlternative = ',';\n\t            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n\t                settings.decimalCharacterAlternative = '.';\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Caches regular expressions for stripAllNonNumberCharacters\n\t     *\n\t     * @param {object} settings\n\t     */\n\t    function cachesUsualRegularExpressions(settings) {\n\t        var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n\t        settings.aNegRegAutoStrip = aNegReg;\n\t        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.negativeSignCharacter ? '\\\\' + settings.negativeSignCharacter : '') + '\\\\' + settings.decimalCharacter + '\\\\d].*?(\\\\d|\\\\' + settings.decimalCharacter + '\\\\d)');\n\t        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + '\\\\d]\\\\D*$');\n\t\n\t        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n\t        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n\t        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(\\\\d+\\\\' + settings.decimalCharacter + '\\\\d+)|(\\\\d*(?:\\\\' + settings.decimalCharacter + '\\\\d*)?))');\n\t\n\t        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n\t        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(\\\\d)');\n\t    }\n\t\n\t    /**\n\t     * Modify the user settings to make them 'exploitable' later.\n\t     *\n\t     * @param {object} settings\n\t     */\n\t    function transformOptionsValuesToDefaultTypes(settings) {\n\t        $.each(settings, function (key, value) {\n\t            // Convert the string 'true' and 'false' to real Boolean\n\t            if (value === 'true' || value === 'false') {\n\t                settings[key] = value === 'true';\n\t            }\n\t\n\t            // Convert numbers in options to strings\n\t            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n\t            if (typeof value === 'number' && key !== 'aScale') {\n\t                settings[key] = value.toString();\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Convert the old settings options name to new ones.\n\t     *\n\t     * @param {object} options\n\t     */\n\t    function convertOldOptionsToNewOnes(options) {\n\t        //TODO Delete this function once the old options are not used anymore\n\t        var oldOptionsConverter = {\n\t            // Old option name, with their corresponding new option\n\t            aSep: 'digitGroupSeparator',\n\t            nSep: 'noSeparatorOnFocus',\n\t            dGroup: 'digitalGroupSpacing',\n\t            aDec: 'decimalCharacter',\n\t            altDec: 'decimalCharacterAlternative',\n\t            aSign: 'currencySymbol',\n\t            pSign: 'currencySymbolPlacement',\n\t            pNeg: 'negativePositiveSignPlacement',\n\t            aSuffix: 'suffixText',\n\t            oLimits: 'overrideMinMaxLimits',\n\t            vMax: 'maximumValue',\n\t            vMin: 'minimumValue',\n\t            mDec: 'decimalPlacesOverride',\n\t            eDec: 'decimalPlacesShownOnFocus',\n\t            scaleDecimal: 'scaleDecimalPlaces',\n\t            aStor: 'saveValueToSessionStorage',\n\t            mRound: 'roundingMethod',\n\t            aPad: 'allowDecimalPadding',\n\t            nBracket: 'negativeBracketsTypeOnBlur',\n\t            wEmpty: 'emptyInputBehavior',\n\t            lZero: 'leadingZero',\n\t            aForm: 'formatOnPageLoad',\n\t            sNumber: 'selectNumberOnly',\n\t            anDefault: 'defaultValueOverride',\n\t            unSetOnSubmit: 'unformatOnSubmit',\n\t            outputType: 'outputFormat',\n\t            debug: 'showWarnings',\n\t            // Current options :\n\t            digitGroupSeparator: true,\n\t            noSeparatorOnFocus: true,\n\t            digitalGroupSpacing: true,\n\t            decimalCharacter: true,\n\t            decimalCharacterAlternative: true,\n\t            currencySymbol: true,\n\t            currencySymbolPlacement: true,\n\t            negativePositiveSignPlacement: true,\n\t            suffixText: true,\n\t            overrideMinMaxLimits: true,\n\t            maximumValue: true,\n\t            minimumValue: true,\n\t            decimalPlacesOverride: true,\n\t            decimalPlacesShownOnFocus: true,\n\t            scaleDivisor: true,\n\t            scaleDecimalPlaces: true,\n\t            scaleSymbol: true,\n\t            saveValueToSessionStorage: true,\n\t            onInvalidPaste: true,\n\t            roundingMethod: true,\n\t            allowDecimalPadding: true,\n\t            negativeBracketsTypeOnBlur: true,\n\t            emptyInputBehavior: true,\n\t            leadingZero: true,\n\t            formatOnPageLoad: true,\n\t            selectNumberOnly: true,\n\t            defaultValueOverride: true,\n\t            unformatOnSubmit: true,\n\t            outputFormat: true,\n\t            showWarnings: true,\n\t            failOnUnknownOption: true,\n\t            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n\t            onOff: true,\n\t            runOnce: true,\n\t            rawValue: true,\n\t            trailingNegative: true,\n\t            caretFix: true,\n\t            throwInput: true,\n\t            strip: true,\n\t            tagList: true,\n\t            negativeSignCharacter: true,\n\t            mIntPos: true,\n\t            mIntNeg: true,\n\t            oDec: true,\n\t            oPad: true,\n\t            oBracket: true,\n\t            oSep: true,\n\t            oSign: true,\n\t            oSuffix: true,\n\t            aNegRegAutoStrip: true,\n\t            skipFirstAutoStrip: true,\n\t            skipLastAutoStrip: true,\n\t            allowedAutoStrip: true,\n\t            numRegAutoStrip: true,\n\t            stripReg: true,\n\t            holder: true\n\t        };\n\t\n\t        for (var option in options) {\n\t            if (options.hasOwnProperty(option)) {\n\t                if (oldOptionsConverter[option] === true) {\n\t                    // If the option is a 'new' option, we continue looping\n\t                    continue;\n\t                }\n\t\n\t                if (oldOptionsConverter.hasOwnProperty(option)) {\n\t                    // Else we have an 'old' option name\n\t                    warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\t\n\t                    // Then we modify the initial option object to use the new options instead of the old ones\n\t                    options[oldOptionsConverter[option]] = options[option];\n\t                    delete options[option];\n\t                } else if (options.failOnUnknownOption) {\n\t                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n\t                    throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n\t     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\n\t     *\n\t     * @param {object} options\n\t     * @param {object} $this jQuery-selected DOM element\n\t     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\n\t     * @returns {object|null}\n\t     */\n\t    function getInitialSettings(options, $this) {\n\t        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n\t        var settings = $this.data('autoNumeric');\n\t\n\t        // If the user used old options, we convert them to new ones\n\t        if (update || !isNull(options)) {\n\t            convertOldOptionsToNewOnes(options);\n\t        }\n\t\n\t        if (update || isUndefined(settings)) {\n\t            if (update) {\n\t                // The settings are updated\n\t                settings = $.extend(settings, options);\n\t            } else {\n\t                // If we couldn't grab any settings create them from the default ones and combine them with the options passed\n\t                // The settings are generated for the first time\n\t                // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n\t                var tagData = $this.data();\n\t                settings = $.extend({}, defaultSettings, tagData, options, {\n\t                    onOff: false,\n\t                    runOnce: false,\n\t                    rawValue: '',\n\t                    trailingNegative: false,\n\t                    caretFix: false,\n\t                    throwInput: true, // Throw input event\n\t                    strip: true,\n\t                    tagList: allowedTagList\n\t                });\n\t            }\n\t\n\t            // Modify the user settings to make them 'exploitable'\n\t            transformOptionsValuesToDefaultTypes(settings);\n\t\n\t            // Improve the `negativePositiveSignPlacement` option if needed\n\t            correctPNegOption(options, settings);\n\t\n\t            // Set the negative sign if needed\n\t            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n\t\n\t            // Additional changes to the settings object (from the original autoCode() function)\n\t            runCallbacksFoundInTheSettingsObject($this, settings);\n\t            calculateVMinAndVMaxIntegerSizes(settings);\n\t            correctMDecOption(settings);\n\t            setsAlternativeDecimalSeparatorCharacter(settings);\n\t            cachesUsualRegularExpressions(settings);\n\t\n\t            // Validate the settings\n\t            validate(settings, false); // Throws if necessary\n\t\n\t            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n\t            keepAnOriginalSettingsCopy(settings);\n\t\n\t            // Save our new settings\n\t            $this.data('autoNumeric', settings);\n\t\n\t            return settings;\n\t        } else {\n\t            return null;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Methods supported by autoNumeric\n\t     */\n\t    var methods = {\n\t        /**\n\t         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n\t         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '})\n\t         *\n\t         * @example\n\t         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\n\t         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\n\t         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\n\t         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\n\t         *\n\t         * @param {object} options\n\t         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\n\t         */\n\t        init: function init(options) {\n\t            return this.each(function () {\n\t                var $this = $(this);\n\t                var $input = getInputIfSupportedTagAndType($this);\n\t\n\t                var settings = getInitialSettings(options, $this, false);\n\t                if (isNull(settings)) {\n\t                    return this;\n\t                }\n\t\n\t                // Create the AutoNumericHolder object that store the field properties\n\t                var holder = getAutoNumericHolder($this, settings, false);\n\t\n\t                if (!settings.runOnce && settings.formatOnPageLoad) {\n\t                    formatDefaultValueOnPageLoad(settings, $input, $this);\n\t                }\n\t\n\t                settings.runOnce = true;\n\t\n\t                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n\t                if ($input) {\n\t                    this.addEventListener('focusin', function (e) {\n\t                        onFocusInAndMouseEnter($this, holder, e);\n\t                    }, false);\n\t                    this.addEventListener('mouseenter', function (e) {\n\t                        onFocusInAndMouseEnter($this, holder, e);\n\t                    }, false);\n\t                    this.addEventListener('focusout', function (e) {\n\t                        onFocusOutAndMouseLeave($this, holder, e);\n\t                    }, false);\n\t                    this.addEventListener('mouseleave', function (e) {\n\t                        onFocusOutAndMouseLeave($this, holder, e);\n\t                    }, false);\n\t                    this.addEventListener('keydown', function (e) {\n\t                        onKeydown(holder, e);\n\t                    }, false);\n\t                    this.addEventListener('keypress', function (e) {\n\t                        onKeypress(holder, e);\n\t                    }, false);\n\t                    this.addEventListener('keyup', function (e) {\n\t                        onKeyup(holder, settings, e);\n\t                    }, false);\n\t                    this.addEventListener('blur', function (e) {\n\t                        onBlur(holder, e);\n\t                    }, false);\n\t                    this.addEventListener('paste', function (e) {\n\t                        onPaste($this, holder, e);\n\t                    }, false);\n\t                    onSubmit($this, holder); //TODO Switch to `addEventListener'\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * Method to stop and remove autoNumeric for the current element.\n\t         * Note: this does not remove the formatting.\n\t         *\n\t         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\n\t         *\n\t         * @returns {*|jQuery}\n\t         */\n\t        destroy: function destroy() {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    $this.val('');\n\t                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n\t                    $this.removeData('autoNumeric');\n\t                    $this.off('.autoNumeric');\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\n\t         *\n\t         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\n\t         *\n\t         * @returns {*|jQuery}\n\t         */\n\t        wipe: function wipe() {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    $this.val('');\n\t                    settings.rawValue = '';\n\t                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * Method that updates the autoNumeric settings.\n\t         * It can be called multiple times if needed.\n\t         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '}).\n\t         *\n\t         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\n\t         *\n\t         * @param {object} options\n\t         * @returns {*|jQuery}\n\t         */\n\t        update: function update(options) {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var strip = $this.autoNumeric('get');\n\t                var settings = getInitialSettings(options, $this, true);\n\t\n\t                // Update the AutoNumericHolder object that store the field properties\n\t                getAutoNumericHolder($this, settings, true);\n\t\n\t                if ($this.val() !== '' || $this.text() !== '') {\n\t                    return $this.autoNumeric('set', strip);\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * Method to format the value passed as a parameter.\n\t         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n\t         * and must contain only numbers and one decimal (period) character\n\t         *\n\t         * @example $(someSelector).autoNumeric('set', 'value'); // Formats the value being passed as the second parameter\n\t         *\n\t         * @param {*} newValue\n\t         * @returns {*|jQuery}\n\t         */\n\t        set: function set(newValue) {\n\t            return $(this).each(function () {\n\t                if (newValue === null || isUndefined(newValue)) {\n\t                    return;\n\t                }\n\t\n\t                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t                var value = newValue.toString();\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n\t                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method');\n\t                }\n\t\n\t                // allows locale decimal separator to be a comma - no thousand separator allowed\n\t                value = fromLocale(value);\n\t\n\t                // Throws an error if the value being set is not numeric\n\t                if (!isNumber(Number(value))) {\n\t                    warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n\t                    return $this.val('');\n\t                }\n\t\n\t                if (value !== '') {\n\t                    var _checkIfInRangeWithOv5 = checkIfInRangeWithOverrideOption(value, settings),\n\t                        _checkIfInRangeWithOv6 = _slicedToArray(_checkIfInRangeWithOv5, 2),\n\t                        minTest = _checkIfInRangeWithOv6[0],\n\t                        maxTest = _checkIfInRangeWithOv6[1];\n\t\n\t                    if (minTest && maxTest) {\n\t                        if ($input && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n\t                            settings.rawValue = value;\n\t                        }\n\t\n\t                        // checks if the value falls within the min max range\n\t                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                            if (settings.scaleDivisor && !settings.onOff) {\n\t                                value = value / settings.scaleDivisor;\n\t                                value = value.toString();\n\t                                settings.decimalPlacesOverride = settings.scaleDecimalPlaces ? settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n\t                            }\n\t\n\t                            value = roundValue(value, settings);\n\t                            if (settings.decimalPlacesShownOnFocus === null && settings.scaleDivisor === null) {\n\t                                settings.rawValue = value;\n\t                            }\n\t\n\t                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n\t                            value = addGroupSeparators(value, settings);\n\t                        }\n\t\n\t                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n\t                            saveValueToPersistentStorage($this[0], settings, 'set');\n\t                        }\n\t                    } else {\n\t                        settings.rawValue = '';\n\t                        saveValueToPersistentStorage($this[0], settings, 'wipe');\n\t                        var attemptedValue = value;\n\t                        value = '';\n\t                        if (!minTest) {\n\t                            $this.trigger('autoNumeric:minExceeded');\n\t                        }\n\t\n\t                        if (!maxTest) {\n\t                            $this.trigger('autoNumeric:maxExceeded');\n\t                        }\n\t\n\t                        throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\t\n\t                        return $this.val('');\n\t                    }\n\t                } else {\n\t                    return $this.val('');\n\t                }\n\t\n\t                if (!settings.onOff && settings.scaleSymbol) {\n\t                    value = value + settings.scaleSymbol;\n\t                }\n\t\n\t                if ($input) {\n\t                    return $this.val(value);\n\t                }\n\t\n\t                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                    return $this.text(value);\n\t                }\n\t\n\t                return false;\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * Method to un-format inputs.\n\t         * This is handy to use right before form submission.\n\t         *\n\t         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\n\t         * Please see option \"outputFormat\" for more details\n\t         *\n\t         * @example $(someSelector).autoNumeric('unSet');\n\t         *\n\t         * @returns {*|jQuery}\n\t         */\n\t        unSet: function unSet() {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    settings.onOff = true;\n\t                    $this.val($this.autoNumeric('getLocalized'));\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * Method to re-format inputs.\n\t         * This is handy to use right after form submission.\n\t         *\n\t         * This is called after the 'unSet' method to reformat the input\n\t         *\n\t         * @example $(someSelector).autoNumeric('reSet');\n\t         *\n\t         * @returns {*|jQuery}\n\t         */\n\t        reSet: function reSet() {\n\t            return $(this).each(function () {\n\t                var $this = getCurrentElement(this);\n\t                var settings = $this.data('autoNumeric');\n\t                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n\t                    $this.autoNumeric('set', $this.val());\n\t                }\n\t            });\n\t        },\n\t\n\t\n\t        /**\n\t         * Return the unformatted value as a string.\n\t         *\n\t         * @usage $(someSelector).autoNumeric('get');\n\t         *\n\t         * @returns {string}\n\t         */\n\t        get: function get() {\n\t            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n\t            var $this = getCurrentElement(this);\n\t            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n\t            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\t            var settings = $this.data('autoNumeric');\n\t            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n\t                throwError('Initializing autoNumeric is required prior to calling the \"get\" method.');\n\t            }\n\t\n\t            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n\t            var value = '';\n\t            if ($input) {\n\t                value = $this.eq(0).val();\n\t            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n\t                value = $this.eq(0).text();\n\t            } else {\n\t                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n\t            }\n\t\n\t            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n\t                value = settings.rawValue;\n\t            } else {\n\t                if (!(/\\d/.test(value) || Number(value) === 0) && settings.emptyInputBehavior === 'focus') {\n\t                    return '';\n\t                }\n\t\n\t                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n\t                    settings.onOff = true;\n\t                    value = toggleNegativeBracket(value, settings);\n\t                }\n\t\n\t                if (settings.runOnce || settings.formatOnPageLoad === false) {\n\t                    value = stripAllNonNumberCharacters(value, settings, true);\n\t                }\n\t\n\t                value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n\t            }\n\t\n\t            // Always return a numeric string\n\t            return value;\n\t        },\n\t\n\t\n\t        /**\n\t         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\n\t         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n\t         * - a plain number (if the setting 'number' is used).\n\t         *\n\t         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n\t         * Check the \"outputFormat\" option definition for more details.\n\t         *\n\t         * @returns {*}\n\t         */\n\t        getLocalized: function getLocalized() {\n\t            var $this = getCurrentElement(this);\n\t            var value = $this.autoNumeric('get');\n\t            var settings = $this.data('autoNumeric');\n\t\n\t            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n\t                value = '0';\n\t            }\n\t\n\t            return toLocale(value, settings.outputFormat);\n\t        },\n\t\n\t\n\t        /**\n\t         * Return the input unformatted value as a number.\n\t         *\n\t         * @returns {number}\n\t         */\n\t        getNumber: function getNumber() {\n\t            var $this = getCurrentElement(this);\n\t            var value = $this.autoNumeric('get');\n\t\n\t            return toLocale(value, 'number');\n\t        },\n\t\n\t\n\t        /**\n\t         * Return the current formatted value of the autoNumeric element.\n\t         * @usage aNInput.autoNumeric('getFormatted'))\n\t         *\n\t         * @returns {string}\n\t         */\n\t        getFormatted: function getFormatted() {\n\t            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n\t            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n\t                throwError('Unable to get the formatted string from the element.');\n\t            }\n\t\n\t            return this[0].value;\n\t        },\n\t\n\t\n\t        /**\n\t         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n\t         *\n\t         * It then loops through the string and un-formats the inputs with autoNumeric.\n\t         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n\t         *\n\t         * @returns {string}\n\t         */\n\t        getString: function getString() {\n\t            return _getStringOrArray(false, this);\n\t        },\n\t\n\t\n\t        /**\n\t         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n\t         *\n\t         * It then loops through the string and un-formats the inputs with autoNumeric.\n\t         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n\t         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n\t         *\n\t         * @returns {{}|[]}\n\t         */\n\t        getArray: function getArray() {\n\t            return _getStringOrArray(true, this);\n\t        },\n\t\n\t\n\t        /**\n\t         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\n\t         *\n\t         * @example\n\t         * $(someSelector).autoNumeric('getSettings');\n\t         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\n\t         *\n\t         * @returns {object}\n\t         */\n\t        getSettings: function getSettings() {\n\t            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\n\t            return this.data('autoNumeric');\n\t        }\n\t    };\n\t\n\t    /**\n\t     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n\t     * It initialize autoNumeric on the given element.\n\t     *\n\t     * @param {string} method The method name (ie. 'set', 'get', etc.)\n\t     * @param {*} args\n\t     * @returns {*}\n\t     */\n\t    $.fn.autoNumeric = function (method) {\n\t        if (methods[method]) {\n\t            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                args[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            return methods[method].apply(this, args);\n\t        }\n\t\n\t        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n\t            // The options have been passed directly, without using a named method\n\t            return methods.init.apply(this, [method]);\n\t        }\n\t\n\t        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n\t    };\n\t\n\t    /**\n\t     * Return the default autoNumeric settings.\n\t     *\n\t     * @returns {object}\n\t     */\n\t    getDefaultConfig = function getDefaultConfig() {\n\t        return defaultSettings;\n\t    };\n\t\n\t    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\t\n\t    /**\n\t     * Public function that allows formatting without an element trigger.\n\t     *\n\t     * @param {number} value\n\t     * @param {object} options\n\t     * @returns {*}\n\t     */\n\t    autoFormat = function autoFormat(value, options) {\n\t        if (isUndefined(value) || value === null) {\n\t            return null;\n\t        }\n\t\n\t        // Check the validity of the `value` parameter\n\t        if (!isNumber(value)) {\n\t            throwError('A number is needed to be able to format it, [' + value + '] given.');\n\t        }\n\t\n\t        // Initiate a very basic settings object\n\t        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n\t        if (value < 0) {\n\t            settings.negativeSignCharacter = '-';\n\t        }\n\t        var valueString = value.toString();\n\t        valueString = fromLocale(valueString);\n\t\n\t        if (isNull(settings.decimalPlacesOverride)) {\n\t            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n\t        }\n\t\n\t        // Basic tests to check if the given valueString is valid\n\t\n\t        var _checkIfInRangeWithOv7 = checkIfInRangeWithOverrideOption(valueString, settings),\n\t            _checkIfInRangeWithOv8 = _slicedToArray(_checkIfInRangeWithOv7, 2),\n\t            minTest = _checkIfInRangeWithOv8[0],\n\t            maxTest = _checkIfInRangeWithOv8[1];\n\t\n\t        if (!minTest || !maxTest) {\n\t            // Throw a custom event\n\t            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n\t            throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\t        }\n\t\n\t        // Everything is ok, proceed to rounding, formatting and grouping\n\t        valueString = roundValue(valueString, settings);\n\t        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n\t        valueString = addGroupSeparators(valueString, settings);\n\t\n\t        return valueString;\n\t    };\n\t\n\t    $.fn.autoFormat = autoFormat; // The jQuery export\n\t\n\t    /**\n\t     * Public function that allows unformatting without an element.\n\t     *\n\t     * @param {string|number} value\n\t     * @param {object} options\n\t     * @returns {*}\n\t     */\n\t    autoUnFormat = function autoUnFormat(value, options) {\n\t        if (isUndefined(value) || value === null) {\n\t            return null;\n\t        }\n\t\n\t        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n\t        if (isNumber(value)) {\n\t            return Number(value);\n\t        }\n\t\n\t        if (isArray(value) || isObject(value)) {\n\t            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n\t            // Check the validity of the `value` parameter\n\t            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n\t        }\n\t\n\t        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n\t        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n\t        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n\t        value = value.toString();\n\t\n\t        if (value.charAt(0) === '-') {\n\t            settings.negativeSignCharacter = '-';\n\t        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n\t            settings.negativeSignCharacter = '-';\n\t            settings.onOff = true;\n\t            value = toggleNegativeBracket(value, settings);\n\t        }\n\t\n\t        value = value.replace(autoStrip, '');\n\t        value = value.replace(',', '.');\n\t        value = toLocale(value, settings.outputFormat);\n\t\n\t        return value;\n\t    };\n\t\n\t    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\t\n\t    /**\n\t     * Validate the given option object.\n\t     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n\t     *\n\t     * This tests if the options are not conflicting and are well formatted.\n\t     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n\t     *\n\t     * @param {*} userOptions\n\t     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n\t     * @throws Error\n\t     */\n\t    validate = function validate(userOptions) {\n\t        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n\t            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n\t        }\n\t\n\t        // If the user used old options, we convert them to new ones\n\t        if (!isNull(userOptions)) {\n\t            convertOldOptionsToNewOnes(userOptions);\n\t        }\n\t\n\t        // The user can choose if the `userOptions` has already been extended with the default options, or not\n\t        var options = void 0;\n\t        if (shouldExtendDefaultOptions) {\n\t            options = $.extend({}, defaultSettings, userOptions);\n\t        } else {\n\t            options = userOptions;\n\t        }\n\t\n\t        // First things first, we test that the `showWarnings` option is valid\n\t        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n\t            throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n\t        }\n\t\n\t        // Define the regular expressions needed for the following tests\n\t        var testPositiveInteger = /^[0-9]+$/;\n\t        var testNumericalCharacters = /[0-9]+/;\n\t        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n\t        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n\t        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\t\n\t        // Then tests the options individually\n\t        if (!isInArray(options.digitGroupSeparator, [',', '.', ' ', '', \"'\"])) {\n\t            throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\', \"\\'\" or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n\t            throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n\t        }\n\t\n\t        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n\t            throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.decimalCharacter, [',', '.'])) {\n\t            throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.decimalCharacter + '] given.');\n\t        }\n\t\n\t        // Checks if the decimal and thousand characters are the same\n\t        if (options.decimalCharacter === options.digitGroupSeparator) {\n\t            throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n\t        }\n\t\n\t        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n\t            throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n\t        }\n\t\n\t        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n\t            throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n\t            throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r'])) {\n\t            throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.negativePositiveSignPlacement + '] given.');\n\t        }\n\t\n\t        if (!isString(options.suffixText) || options.suffixText !== '' && (contains(options.suffixText, '-') || testNumericalCharacters.test(options.suffixText))) {\n\t            throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n\t            throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n\t        }\n\t\n\t        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n\t            throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n\t        }\n\t\n\t        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n\t            throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n\t        }\n\t\n\t        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n\t            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n\t        }\n\t\n\t        if (!(isNull(options.decimalPlacesOverride) || isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n\t        isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n\t        ) {\n\t                throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n\t            }\n\t\n\t        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n\t        var vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n\t        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n\t            warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', options.showWarnings);\n\t        }\n\t\n\t        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n\t            warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', options.showWarnings);\n\t        }\n\t\n\t        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n\t            throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n\t        }\n\t\n\t        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n\t        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n\t            warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n\t        }\n\t\n\t        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n\t            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n\t            throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n\t            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n\t            throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.onInvalidPaste, ['error', 'ignore', 'clamp', 'truncate', 'replace'])) {\n\t            throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.roundingMethod, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n\t            throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n\t            throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.allowDecimalPadding + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n\t            throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n\t            throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n\t        }\n\t\n\t        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n\t            throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n\t            throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n\t            throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n\t            throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n\t            throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n\t        }\n\t\n\t        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n\t            throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n\t        }\n\t\n\t        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\n\t            throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n\t        }\n\t    };\n\t\n\t    $.fn.autoValidate = validate;\n\t\n\t    /**\n\t     * Return TRUE is the settings/options are valid, FALSE otherwise.\n\t     *\n\t     * @param {object} options\n\t     * @returns {boolean}\n\t     */\n\t    areSettingsValid = function areSettingsValid(options) {\n\t        var isValid = true;\n\t        try {\n\t            validate(options);\n\t        } catch (error) {\n\t            isValid = false;\n\t        }\n\t\n\t        return isValid;\n\t    };\n\t\n\t    /**\n\t     * Create a custom event and immediately sent it from the given element.\n\t     * By default, if no element is given, the event is thrown from `document`.\n\t     *\n\t     * @param {string} eventName\n\t     * @param {Element} element\n\t     * @param {object} detail\n\t     */\n\t    function triggerEvent(eventName) {\n\t        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n\t        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t        var event = void 0;\n\t        if (window.CustomEvent) {\n\t            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n\t        } else {\n\t            event = document.createEvent('CustomEvent');\n\t            event.initCustomEvent(eventName, true, true, { detail: detail });\n\t        }\n\t\n\t        element.dispatchEvent(event);\n\t    }\n\t\n\t    /**\n\t     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n\t     */\n\t    (function () {\n\t        if (typeof window.CustomEvent === 'function') {\n\t            return false;\n\t        }\n\t\n\t        function CustomEvent(event, params) {\n\t            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n\t            var evt = document.createEvent('CustomEvent');\n\t            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n\t            return evt;\n\t        }\n\t\n\t        CustomEvent.prototype = window.Event.prototype;\n\t        window.CustomEvent = CustomEvent;\n\t    })();\n\t});\n\t\n\t/**\n\t * This exports the interface for the autoNumeric object\n\t */\n\texports.default = {\n\t    format: autoFormat,\n\t    unFormat: autoUnFormat,\n\t    getDefaultConfig: getDefaultConfig,\n\t    validate: validate, // an.validate(options) : throws if necessary\n\t    areSettingsValid: areSettingsValid };\n\t}.call(window));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// autoNumeric.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fdeb28f1ad001b5b70a4","/**\n *               autoNumeric.js\n *\n * @version      2.0-beta.15\n * @date         2016-12-27 UTC 14:00\n *\n * @author       Bob Knothe\n * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\n *               cf. AUTHORS.md.\n * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n * @since        2009-08-09\n *\n * @summary      autoNumeric is a jQuery plugin that automatically formats currency\n * (money) and numbers as-you-type in a form inputs. It supports most\n * international numeric formats and currency signs including those used in\n * Europe, North and South America, Asia, as well as India's' lakhs.\n *\n *               Note : Some functions are borrowed from big.js\n * @link         https://github.com/MikeMcl/big.js/\n *\n * Please report any bugs to https://github.com/BobKnothe/autoNumeric\n *\n * @license      Released under the MIT License\n * @link         http://www.opensource.org/licenses/mit-license.php\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nlet autoFormat;\nlet autoUnFormat;\nlet getDefaultConfig;\nlet validate;\nlet areSettingsValid;\n\n// AutoNumeric default settings\n/**\n * List of allowed tag on which autoNumeric can be used.\n */\nconst allowedTagList = [\n    'b',\n    'caption',\n    'cite',\n    'code',\n    'const',\n    'dd',\n    'del',\n    'div',\n    'dfn',\n    'dt',\n    'em',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'ins',\n    'kdb',\n    'label',\n    'li',\n    'option',\n    'output',\n    'p',\n    'q',\n    's',\n    'sample',\n    'span',\n    'strong',\n    'td',\n    'th',\n    'u',\n];\n\n/**\n * Defaults options are public - these can be overridden by the following:\n * - HTML5 data attributes\n * - Options passed by the 'init' or 'update' methods\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n */\nconst defaultSettings = {\n    /* Allowed thousand separator characters\n     * comma = \",\"\n     * period \"full stop\" = \".\"\n     * quote = \"'\"\n     * space = \" \"\n     * none = \"\"\n     * NOTE: do not use numeric characters\n     * Deprecated older option name : aSep\n     */\n    digitGroupSeparator: ',',\n\n    /* When true => removes the thousand separator, currency symbol & suffix \"focusin\"\n     * example if the input value \"$ 1,999.88 suffix\"\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n     * Deprecated older option name : nSep\n     */\n    noSeparatorOnFocus: false,\n\n    /* Digital grouping for the thousand separator used in Format\n     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\n     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n     * digitalGroupSpacing: \"3\", results in 999,999,999 default\n     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\n     * Deprecated older option name : dGroup\n     */\n    digitalGroupSpacing: '3',\n\n    /* Allowed decimal separator characters\n     * period \"full stop\" = \".\"\n     * comma = \",\"\n     * Deprecated older option name : aDec\n     */\n    decimalCharacter: '.',\n\n    /* Allow to declare alternative decimal separator which is automatically replaced by decimalCharacter\n     * developed for countries the use a comma \",\" as the decimal character\n     * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n     * Deprecated older option name : altDec\n     */\n    decimalCharacterAlternative: null,\n\n    /* currencySymbol = allowed currency symbol\n     * Must be in quotes currencySymbol: \"$\"\n     * space to the right of the currency symbol currencySymbol: '$ '\n     * space to the left of the currency symbol currencySymbol: ' $'\n     * Deprecated older option name : aSign\n     */\n    currencySymbol: '',\n\n    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\n     * for prefix currencySymbolPlacement: \"p\" (default)\n     * for suffix currencySymbolPlacement: \"s\"\n     * Deprecated older option name : pSign\n     */\n    currencySymbolPlacement: 'p',\n\n    /* Placement of negative sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\n     * -1,234.56  => default no options required\n     * -$1,234.56 => {currencySymbol: \"$\"}\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"}\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"}\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\n     * Deprecated older option name : pNeg\n     */\n    negativePositiveSignPlacement: 'l',\n\n    /* Additional suffix\n     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\n     * Numeric characters and negative sign not allowed'\n     * Deprecated older option name : aSuffix\n     */\n    suffixText: '',\n\n    /* Override min max limits\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\n     * Deprecated older option name : oLimits\n     */\n    overrideMinMaxLimits: null,\n\n    /* Maximum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be larger than minimumValue\n     * Deprecated older option name : vMax\n     */\n    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\n    /* Minimum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be smaller than maximumValue\n     * Deprecated older option name : vMin\n     */\n    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\n    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\n     * Deprecated older option name : mDec\n     */\n    decimalPlacesOverride: null,\n\n    /* Expanded decimal places visible when input has focus - example:\n     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n     * the \"get\" method returns the extended decimal places\n     * Deprecated older option name : eDec\n     */\n    decimalPlacesShownOnFocus: null,\n\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\n     * [\"divisor\", \"decimal places\", \"symbol\"]\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\n     */\n    scaleDivisor: null,\n\n    /*\n     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n     * Deprecated older option name : scaleDecimal\n     */\n    scaleDecimalPlaces: null,\n\n    /*\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n     * This is optional too.\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\n     * if ie 6 or 7 the value will be saved as a session cookie\n     * Deprecated older option name : aStor\n     */\n    saveValueToSessionStorage: false,\n\n    /*\n     * Manage how autoNumeric react when the user tries to paste an invalid number.\n     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\n     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\n     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\n     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\n     *                The non-pasted numbers are dropped and therefore not used at all.\n     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\n     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\n     *\n     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\n     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\n     *          Only the first number will be used (here '123').\n     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\n     */\n    //TODO Shouldn't we use `truncate` as the default value?\n    onInvalidPaste: 'error',\n\n    /* method used for rounding\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n     * roundingMethod: \"U05\" Rounds up to next .05\n     * roundingMethod: \"D05\" Rounds down to next .05\n     * Deprecated older option name : mRound\n     */\n    roundingMethod: 'S',\n\n    /* Controls decimal padding\n     * allowDecimalPadding: true - always Pad decimals with zeros\n     * allowDecimalPadding: false - does not pad with zeros.\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\n     *\n     * thanks to Jonas Johansson for the suggestion\n     * Deprecated older option name : aPad\n     */\n    allowDecimalPadding: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n     * Those brackets are visible only when the field does NOT have the focus.\n     * The left and right symbols should be enclosed in quotes and separated by a comma\n     * negativeBracketsTypeOnBlur: null - (default)\n     * negativeBracketsTypeOnBlur: '(,)', negativeBracketsTypeOnBlur: '[,]', negativeBracketsTypeOnBlur: '<,>' or negativeBracketsTypeOnBlur: '{,}'\n     * Deprecated older option name : nBracket\n     */\n    negativeBracketsTypeOnBlur: null,\n\n    /* Displayed on empty string \"\"\n     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\n     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\n     * emptyInputBehavior: \"always\" - always displays the currency sign only\n     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\n     * Deprecated older option name : wEmpty\n     */\n    emptyInputBehavior: 'focus',\n\n    /* Controls leading zero behavior\n     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n     * leadingZero: \"deny\", - allows only one leading zero on values less than one\n     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n     * Deprecated older option name : lZero\n     */\n    leadingZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\n     * true = automatically formats the default value on initialization\n     * false = will not format the default value on initialization\n     * Deprecated older option name : aForm\n     */\n    formatOnPageLoad: true,\n\n    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\n     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\n     * Deprecated older option name : sNumber\n     */\n    selectNumberOnly: false,\n\n    /* Helper option for ASP.NET postback\n     * should be the value of the unformatted default value\n     * examples:\n     * no default value=\"\" {defaultValueOverride: \"\"}\n     * value=1234.56 {defaultValueOverride: '1234.56'}\n     * Deprecated older option name : anDefault\n     */\n    defaultValueOverride: null,\n\n    /* Removes formatting on submit event\n     * this output format: positive nnnn.nn, negative -nnnn.nn\n     * review the 'unSet' method for other formats\n     * Deprecated older option name : unSetOnSubmit\n     */\n    unformatOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n     * Deprecated older option name : outputType\n     */\n    outputFormat: null,\n\n    /* Error handling function\n     * true => all warning are shown\n     * false => no warnings are shown, only the thrown errors\n     * Deprecated older option name : debug\n     */\n    showWarnings: true,\n\n    /*\n     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\n     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\n     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\n     */\n    failOnUnknownOption: false,\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n * //TODO Replace every call to this object with a call to `keyName`\n * @deprecated\n */\nconst keyCode = {\n    Backspace:      8,\n    Tab:            9,\n    Enter:          13,\n    Shift:          16,\n    Ctrl:           17,\n    Alt:            18,\n    PauseBreak:     19,\n    CapsLock:       20,\n    Esc:            27,\n    Space:          32,\n    PageUp:         33,\n    PageDown:       34,\n    End:            35,\n    Home:           36,\n    LeftArrow:      37,\n    UpArrow:        38,\n    RightArrow:     39,\n    DownArrow:      40,\n    Insert:         45,\n    Delete:         46,\n    num0:           48,\n    num1:           49,\n    num2:           50,\n    num3:           51,\n    num4:           52,\n    num5:           53,\n    num6:           54,\n    num7:           55,\n    num8:           56,\n    num9:           57,\n    a:              65,\n    b:              66,\n    c:              67,\n    d:              68,\n    e:              69,\n    f:              70,\n    g:              71,\n    h:              72,\n    i:              73,\n    j:              74,\n    k:              75,\n    l:              76,\n    m:              77,\n    n:              78,\n    o:              79,\n    p:              80,\n    q:              81,\n    r:              82,\n    s:              83,\n    t:              84,\n    u:              85,\n    v:              86,\n    w:              87,\n    x:              88,\n    y:              89,\n    z:              90,\n    Windows:        91,\n    RightClick:     93,\n    numpad0:        96,\n    numpad1:        97,\n    numpad2:        98,\n    numpad3:        99,\n    numpad4:        100,\n    numpad5:        101,\n    numpad6:        102,\n    numpad7:        103,\n    numpad8:        104,\n    numpad9:        105,\n    MultiplyNumpad: 106,\n    PlusNumpad:     107,\n    MinusNumpad:    109,\n    DotNumpad:      110,\n    SlashNumpad:    111,\n    F1:             112,\n    F2:             113,\n    F3:             114,\n    F4:             115,\n    F5:             116,\n    F6:             117,\n    F7:             118,\n    F8:             119,\n    F9:             120,\n    F10:            121,\n    F11:            122,\n    F12:            123,\n    NumLock:        144,\n    ScrollLock:     145,\n    MyComputer:     182,\n    MyCalculator:   183,\n    Semicolon:      186,\n    Equal:          187,\n    Comma:          188,\n    Hyphen:         189,\n    Dot:            190,\n    Slash:          191,\n    Backquote:      192,\n    LeftBracket:    219,\n    Backslash:      220,\n    RightBracket:   221,\n    Quote:          222,\n    Command:        224,\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\n * Those names are listed here :\n * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n */\nconst keyName = {\n    // Special values\n    Unidentified:   'Unidentified',\n\n    // Modifier keys\n    Alt:            'Alt',\n    AltGr:          'AltGraph',\n    CapsLock:       'CapsLock', // Under Chrome, e.key is empty for CapsLock\n    Ctrl:           'Control',\n    Fn:             'Fn',\n    FnLock:         'FnLock',\n    Hyper:          'Hyper', // 'OS' under Firefox\n    Meta:           'Meta', // The Windows, Command or  key // 'OS' under Firefox and IE9\n    Windows:        'Meta', // This is a non-official key name\n    Command:        'Meta', // This is a non-official key name\n    NumLock:        'NumLock',\n    ScrollLock:     'ScrollLock',\n    Shift:          'Shift',\n    Super:          'Super', // 'OS' under Firefox\n    Symbol:         'Symbol',\n    SymbolLock:     'SymbolLock',\n\n    // Whitespace keys\n    Enter:          'Enter',\n    Tab:            'Tab',\n    Space:          ' ', // 'Spacebar' for Firefox <37, and IE9\n\n    // Navigation keys\n    DownArrow:      'ArrowDown', // 'Down' for Firefox <=36, and IE9\n    LeftArrow:      'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n    RightArrow:     'ArrowRight', // 'Right' for Firefox <=36, and IE9\n    UpArrow:        'ArrowUp', // 'Up' for Firefox <=36, and IE9\n    End:            'End',\n    Home:           'Home',\n    PageDown:       'PageDown',\n    PageUp:         'PageUp',\n\n    // Editing keys\n    Backspace:      'Backspace',\n    Clear:          'Clear',\n    Copy:           'Copy',\n    CrSel:          'CrSel', // 'Crsel' for Firefox <=36, and IE9\n    Cut:            'Cut',\n    Delete:         'Delete', // 'Del' for Firefox <=36, and IE9\n    EraseEof:       'EraseEof',\n    ExSel:          'ExSel', // 'Exsel' for Firefox <=36, and IE9\n    Insert:         'Insert',\n    Paste:          'Paste',\n    Redo:           'Redo',\n    Undo:           'Undo',\n\n    // UI keys\n    Accept:         'Accept',\n    Again:          'Again',\n    Attn:           'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n    Cancel:         'Cancel',\n    ContextMenu:    'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n    Esc:            'Escape', // 'Esc' for Firefox <=36, and IE9\n    Execute:        'Execute',\n    Find:           'Find',\n    Finish:         'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n    Help:           'Help',\n    Pause:          'Pause',\n    Play:           'Play',\n    Props:          'Props',\n    Select:         'Select',\n    ZoomIn:         'ZoomIn',\n    ZoomOut:        'ZoomOut',\n\n    // Device keys\n    BrightnessDown: 'BrightnessDown',\n    BrightnessUp:   'BrightnessUp',\n    Eject:          'Eject',\n    LogOff:         'LogOff',\n    Power:          'Power',\n    PowerOff:       'PowerOff',\n    PrintScreen:    'PrintScreen',\n    Hibernate:      'Hibernate', // 'Unidentified' for Firefox <=37\n    Standby:        'Standby', // 'Unidentified' for Firefox <=36, and IE9\n    WakeUp:         'WakeUp',\n\n    // IME and composition keys\n    Compose:        'Compose',\n    Dead:           'Dead',\n\n    // Function keys\n    F1:             'F1',\n    F2:             'F2',\n    F3:             'F3',\n    F4:             'F4',\n    F5:             'F5',\n    F6:             'F6',\n    F7:             'F7',\n    F8:             'F8',\n    F9:             'F9',\n    F10:            'F10',\n    F11:            'F11',\n    F12:            'F12',\n\n    // Document keys\n    Print:          'Print',\n\n    // 'Normal' keys\n    num0:           '0',\n    num1:           '1',\n    num2:           '2',\n    num3:           '3',\n    num4:           '4',\n    num5:           '5',\n    num6:           '6',\n    num7:           '7',\n    num8:           '8',\n    num9:           '9',\n    numpad0:        '0',\n    numpad1:        '1',\n    numpad2:        '2',\n    numpad3:        '3',\n    numpad4:        '4',\n    numpad5:        '5',\n    numpad6:        '6',\n    numpad7:        '7',\n    numpad8:        '8',\n    numpad9:        '9',\n    a:              'a',\n    b:              'b',\n    c:              'c',\n    d:              'd',\n    e:              'e',\n    f:              'f',\n    g:              'g',\n    h:              'h',\n    i:              'i',\n    j:              'j',\n    k:              'k',\n    l:              'l',\n    m:              'm',\n    n:              'n',\n    o:              'o',\n    p:              'p',\n    q:              'q',\n    r:              'r',\n    s:              's',\n    t:              't',\n    u:              'u',\n    v:              'v',\n    w:              'w',\n    x:              'x',\n    y:              'y',\n    z:              'z',\n    MultiplyNumpad: '*',\n    PlusNumpad:     '+',\n    MinusNumpad:    '-',\n    DotNumpad:      '.',\n    SlashNumpad:    '/',\n    Semicolon:      ';',\n    Equal:          '=',\n    Comma:          ',',\n    Hyphen:         '-',\n    Minus:          '-',\n    Plus:           '+',\n    Dot:            '.',\n    Slash:          '/',\n    Backquote:      '`',\n    LeftBracket:    '[',\n    RightBracket:   ']',\n    Backslash:      '\\\\',\n    Quote:          \"'\",\n};\n\n(function(factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\nif (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['jquery'], factory);\n} else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'));\n} else {\n    // Browser globals\n    factory(window.jQuery);\n}\n}($ => {\n    // Helper functions\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value The value to test\n     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value The value to test\n     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\n     */\n    function isUndefined(value) {\n        return value === void(0);\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void(0) || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return (typeof str === 'string' || str instanceof String);\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof(value) === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param {string} value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        const lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return typeof reference === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param {object} obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (const prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE if the parameter is a number (or a number written as a string).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isNumber(n) {\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    /**\n     * Return TRUE if the parameter is an integer (and not a float).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isInt(n) {\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n    }\n\n    /**\n     * Return the pasted text that will be used.\n     *\n     * @param {string} text\n     * @param {AutoNumericHolder} holder\n     * @returns {string|void|XML|*}\n     */\n    function preparePastedText(text, holder) {\n        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {*} needle\n     * @param {Array} array\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') { // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'object' && Object.prototype.toString.call(arr) === '[object Array]');\n        }\n        else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    // function hasDecimals(str) {\n    //     const [, decimalPart] = str.split('.');\n    //     return !isUndefined(decimalPart);\n    // }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     *\n     * @param {string} str\n     * @returns {int}\n     */\n    function decimalPlaces(str) {\n        const [, decimalPart] = str.split('.');\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Return the code for the key used to generate the given event.\n     *\n     * @param {Event} event\n     * @returns {string|Number}\n     */\n    function keyCodeNumber(event) {\n        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n        return (typeof event.which === 'undefined')?event.keyCode:event.which;\n    }\n\n    /**\n     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\n     *\n     * @param {string} value\n     * @param {object} parsedMinValue Parsed via the `parseStr()` function\n     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\n     * @returns {boolean}\n     */\n    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n        const parsedValue = parseStr(value);\n        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\n    }\n\n    /**\n     * Return TRUE if the given string contains a negative sign on the first character.\n     *\n     * @param {string} string A number represented by a string\n     * @returns {boolean}\n     */\n    function isNegative(string) {\n        return string.charAt(0) === '-';\n    }\n\n    /**\n     * Return the negative version of the value (represented as a string) given as a parameter.\n     *\n     * @param {string} value\n     * @returns {*}\n     */\n    function setRawNegativeSign(value) {\n        if (!isNegative(value)) {\n            return `-${value}`;\n        }\n\n        return value;\n    }\n\n    /**\n     * Insert a character or a string at the index given (0 being the far left side).\n     *\n     * @param {string} str\n     * @param {string} char\n     * @param {int} caretPosition\n     * @returns {string}\n     */\n    function insertCharAtPosition(str, char, caretPosition) {\n        return `${str.slice(0, caretPosition)}${char}${str.slice(caretPosition)}`;\n    }\n\n    /**\n     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\n     *\n     * @param {string} string\n     * @param {int} index\n     * @param {string} newCharacter\n     * @returns {string}\n     */\n    function replaceCharAt(string, index, newCharacter) {\n        return `${string.substr(0, index)}${newCharacter}${string.substr(index + newCharacter.length)}`;\n    }\n\n    /**\n     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\n     *\n     * @param {string|number} value\n     * @param {object} settings\n     * @returns {number}\n     */\n    function clampToRangeLimits(value, settings) {\n        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n    }\n\n    /**\n     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\n     *\n     * @param {string} formattedNumberString\n     * @param {int} caretPosition This must be a positive integer\n     * @param {string} decimalCharacter\n     * @returns {number}\n     */\n    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n        const numberDotOrNegativeSign = new RegExp(`[0-9${decimalCharacter}-]`); // No need to escape the decimal character here, since it's in `[]`\n\n        let numberDotAndNegativeSignCount = 0;\n        for (let i = 0; i < caretPosition; i++) {\n            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n                numberDotAndNegativeSignCount++;\n            }\n        }\n\n        return numberDotAndNegativeSignCount;\n    }\n\n    /**\n     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\n     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\n     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\n     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\n     *\n     * @example\n     * 1234567|89.01   : position 7 (rawNumberString)\n     * 123.456.7|89,01 : position 9 (formattedNumberString)\n     *\n     * @param {string} rawNumberString\n     * @param {int} caretPositionInRawValue\n     * @param {string} formattedNumberString\n     * @param {string} decimalCharacter\n     * @returns {*}\n     */\n    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n        const formattedNumberStringSize = formattedNumberString.length;\n        const rawNumberStringSize = rawNumberString.length;\n\n        let formattedNumberStringIndex;\n        let rawNumberStringIndex = 0;\n        for (formattedNumberStringIndex = 0;\n             formattedNumberStringIndex < formattedNumberStringSize &&\n             rawNumberStringIndex < rawNumberStringSize &&\n             rawNumberStringIndex < caretPositionInRawValue;\n             formattedNumberStringIndex++) {\n            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] ||\n                (rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter)) {\n                rawNumberStringIndex++;\n            }\n        }\n\n        return formattedNumberStringIndex;\n    }\n\n    /**\n     * Return the number of dot '.' in the given text.\n     *\n     * @param {string} text\n     * @returns {number}\n     */\n    function countDotsInText(text) {\n        return countCharInText('.', text);\n    }\n\n    /**\n     * Count the number of occurrence of the given character, in the given text.\n     *\n     * @param {string} character\n     * @param {string} text\n     * @returns {number}\n     */\n    function countCharInText(character, text) {\n        let charCounter = 0;\n        for (let i = 0; i < text.length; i++) {\n            if (text[i] === character) {\n                charCounter++;\n            }\n        }\n\n        return charCounter;\n    }\n\n    /**\n     * Return the index that can be used to set the caret position.\n     * This takes into account that the position is starting at '0', not 1.\n     *\n     * @param {int} characterCount\n     * @returns {number}\n     */\n    function convertCharacterCountToIndexPosition(characterCount) {\n        return Math.max(characterCount, characterCount - 1);\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     *\n     * @param {HTMLElement|EventTarget} that\n     * @returns {{}}\n     */\n    function getElementSelection(that) {\n        const position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            const select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     *\n     * @param {HTMLElement|EventTarget} that\n     * @param {int} start\n     * @param {int|null} end\n     */\n    function setElementSelection(that, start, end = null) {\n        if (isUndefinedOrNullOrEmpty(end)) {\n            end = start;\n        }\n\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            const range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function that throw error messages\n     *\n     * @param {string} message\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\n     * Function that display a warning messages, according to the debug level.\n     *\n     * @param {string} message\n     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\n     */\n    function warning(message, showWarning = true) {\n        if (showWarning) {\n            /* eslint no-console: 0 */\n            console.warn(`Warning: ${message}`);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\n     * Run any callbacks found in the settings object.\n     * Any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     * @param {object} $this jQuery-selected DOM element\n     * @param {object} settings\n     */\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\n        // Loops through the settings object (option array) to find the following\n        $.each(settings, (k, val) => {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the maximum decimal length from the minimumValue and maximumValue settings\n     *\n     * @param {string} minimumValue\n     * @param {string} maximumValue\n     * @returns {number}\n     */\n    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n    }\n\n    /**\n     * Strip all unwanted non-number characters and leave only a number alert\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {boolean} leftOrAll\n     * @returns {string|*}\n     */\n\n    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\n        if (settings.currencySymbol !== '') {\n            // Remove currency sign\n            s = s.replace(settings.currencySymbol, '');\n        }\n        if (settings.suffixText) {\n            // Remove suffix\n            while (contains(s, settings.suffixText)) {\n                s = s.replace(settings.suffixText, '');\n            }\n        }\n\n        // First replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.negativePositiveSignPlacement === 's' || (settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p')) && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // Then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // Then remove any uninteresting characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.decimalCharacterAlternative) {\n            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n        }\n\n        // Get only number string\n        const m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n\n        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n            let nSign = '';\n            const [integerPart, decimalPart] = s.split(settings.decimalCharacter);\n            let modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n                nSign = settings.negativeSignCharacter;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n            }\n\n            // Strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // Strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            s = `${nSign}${modifiedIntegerPart}${isUndefined(decimalPart)?'':settings.decimalCharacter + decimalPart}`;\n        }\n\n        if ((leftOrAll && settings.leadingZero === 'deny') ||\n            (!settings.onOff && settings.leadingZero === 'allow')) {\n            s = s.replace(settings.stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * Sets or removes brackets on negative values, depending on the focus state.\n     * The focus state is 'stored' in the settings object under the `settings.onOff` attribute. //TODO Use another object to keep track of internal data that are not settings\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function toggleNegativeBracket(s, settings) {\n        if ((settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l') || (settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p')) {\n            const [firstBracket, lastBracket] = settings.negativeBracketsTypeOnBlur.split(',');\n            if (!settings.onOff) {\n                s = s.replace(settings.negativeSignCharacter, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.negativeSignCharacter);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Convert locale format to Javascript numeric string\n     * Allows locale decimal separator to be a period or a comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     *\n     * @param {string} s\n     * @returns {string|void|XML|*}\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n     * See the \"outputFormat\" option definition for more details.\n     *\n     * @param {string|null} value\n     * @param {string} locale\n     * @returns {*}\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        let result;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = contains(value, '-') ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = contains(result, '-') ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default :\n                throwError(`The given outputFormat [${locale}] option is not recognized.`);\n        }\n\n        return result;\n    }\n\n    /**\n     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string}\n     */\n    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace(settings.negativeSignCharacter, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is formatted with decimals\n            s += '0.00';\n        }\n\n        return s;\n    }\n\n    /**\n     * Modify the negative sign and the decimal character to use those defined in the settings.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string}\n     */\n    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace('-', settings.negativeSignCharacter);\n        }\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace('.', settings.decimalCharacter);\n        }\n\n        return s;\n    }\n\n    /**\n     * Private function to check for empty value\n     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @param {boolean} signOnEmpty\n     * @returns {*}\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n                return (settings.negativePositiveSignPlacement === 'l') ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\n     * Modify the input value by adding the group separators, as defined in the settings.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function addGroupSeparators(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\n        }\n\n        if (settings.trailingNegative && !contains(inputValue, '-')) {\n            inputValue = '-' + inputValue;\n        }\n\n        const empty = checkEmpty(inputValue, settings, true);\n        const isNegative = contains(inputValue, '-');\n        if (isNegative) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (!isNull(empty)) {\n            return empty;\n        }\n\n        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n        let digitalGroup;\n        switch (settings.digitalGroupSpacing) {\n            case '2':\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                break;\n            case '2s':\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                break;\n            case '4':\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                break;\n            default :\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // Splits the string at the decimal string\n        let [integerPart, decimalPart] = inputValue.split(settings.decimalCharacter);\n        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n            [integerPart, decimalPart] = inputValue.split(settings.decimalCharacterAlternative);\n        }\n\n        if (settings.digitGroupSeparator !== '') {\n            // Re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, `$1${settings.digitGroupSeparator}$2`);\n            }\n        }\n\n        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.decimalPlacesOverride) {\n                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n            }\n\n            // Joins the whole number with the decimal value\n            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n        } else {\n            // Otherwise if it's an integer\n            inputValue = integerPart;\n        }\n\n        if (settings.currencySymbolPlacement === 'p') {\n            if (isNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n                        break;\n                    default :\n                        //\n                }\n            } else {\n                inputValue = settings.currencySymbol + inputValue;\n            }\n        }\n\n        if (settings.currencySymbolPlacement === 's') {\n            if (isNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n                        break;\n                    case 'l':\n                        inputValue = inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n                        break;\n                    case 'p':\n                        inputValue = settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default :\n                    //\n                }\n            } else {\n                inputValue = inputValue + settings.currencySymbol;\n            }\n        }\n\n        // Removes the negative sign and places brackets\n        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || inputValue.charAt(0) === '-')) {\n            inputValue = toggleNegativeBracket(inputValue, settings);\n        }\n        settings.trailingNegative = false;\n\n        return inputValue + settings.suffixText;\n    }\n\n    /**\n     * Truncate not needed zeros\n     *\n     * @param {string} roundedInputValue\n     * @param {int} temporaryDecimalPlacesOverride\n     * @returns {void|XML|string|*}\n     */\n    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\n        let regex;\n        switch (temporaryDecimalPlacesOverride) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default :\n                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n                regex = new RegExp(`(\\\\.\\\\d{${temporaryDecimalPlacesOverride}}(?:\\\\d*[1-9])?)0*`);\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (temporaryDecimalPlacesOverride === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\n     * Round the input value using the rounding method defined in the settings.\n     * This function accepts multiple rounding methods. See the documentation for more details about those.\n     *\n     * Note : This is handled as text since JavaScript math function can return inaccurate values.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function roundValue(inputValue, settings) {\n        inputValue = (inputValue === '') ? '0' : inputValue.toString();\n        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n            switch (settings.roundingMethod) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default :\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            let result;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        let ivRounded = '';\n        let i = 0;\n        let nSign = '';\n        let temporaryDecimalPlacesOverride;\n\n        // sets the truncate zero method\n        if (settings.allowDecimalPadding) {\n            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n        } else {\n            temporaryDecimalPlacesOverride = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (inputValue.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if ((Number(inputValue) > 0 && settings.leadingZero !== 'keep') || (inputValue.length > 0 && settings.leadingZero === 'allow')) {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        const dPos = inputValue.lastIndexOf('.');\n        const inputValueHasADot = dPos === -1;\n\n        // Virtual decimal position\n        const vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        let cDec = (inputValue.length - 1) - vdPos;\n\n        if (cDec <= settings.decimalPlacesOverride) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < temporaryDecimalPlacesOverride) {\n                if (inputValueHasADot) {\n                    ivRounded += settings.decimalCharacter;\n                }\n\n                let zeros = '000000';\n                while (cDec < temporaryDecimalPlacesOverride) {\n                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > temporaryDecimalPlacesOverride) {\n                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\n            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return (Number(ivRounded) === 0) ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        let rLength;\n        if (inputValueHasADot) {\n            rLength = settings.decimalPlacesOverride - 1;\n        } else {\n            rLength = settings.decimalPlacesOverride + dPos;\n        }\n\n        const tRound = Number(inputValue.charAt(rLength + 1));\n        const odd = (inputValue.charAt(rLength) === '.') ? (inputValue.charAt(rLength - 1) % 2) : (inputValue.charAt(rLength) % 2);\n        let ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if ((tRound > 4 && settings.roundingMethod === 'S')                  || // Round half up symmetric\n            (tRound > 4 && settings.roundingMethod === 'A' && nSign === '')  || // Round half up asymmetric positive values\n            (tRound > 5 && settings.roundingMethod === 'A' && nSign === '-') || // Round half up asymmetric negative values\n            (tRound > 5 && settings.roundingMethod === 's')                  || // Round half down symmetric\n            (tRound > 5 && settings.roundingMethod === 'a' && nSign === '')  || // Round half down asymmetric positive values\n            (tRound > 4 && settings.roundingMethod === 'a' && nSign === '-') || // Round half down asymmetric negative values\n            (tRound > 5 && settings.roundingMethod === 'B')                  || // Round half even \"Banker's Rounding\"\n            (tRound === 5 && settings.roundingMethod === 'B' && odd === 1)   || // Round half even \"Banker's Rounding\"\n            (tRound > 0 && settings.roundingMethod === 'C' && nSign === '')  || // Round to ceiling toward positive infinite\n            (tRound > 0 && settings.roundingMethod === 'F' && nSign === '-') || // Round to floor toward negative infinite\n            (tRound > 0 && settings.roundingMethod === 'U')) {                  // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = (ivArray.length - 1); i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\n\n        return (Number(ivRounded) === 0) ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {boolean} isPaste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, isPaste) {\n        s = (isPaste) ? roundValue(s, settings) : s;\n\n        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n            const [integerPart, decimalPart] = s.split(settings.decimalCharacter);\n\n            // truncate decimal part to satisfying length since we would round it anyway\n            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n                if (settings.decimalPlacesOverride > 0) {\n                    const modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n                    s = `${integerPart}${settings.decimalCharacter}${modifiedDecimalPart}`;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\n     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\n     *\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n     *\n     * @param {number|string} n A numeric value.\n     * @returns {{}}\n     */\n    function parseStr(n) {\n        const x = {}; // A Big number instance.\n        let e;\n        let i;\n        let nL;\n        let j;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = (n.search(/[1-9]/i) === -1) ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings.\n     * This uses the parsed strings for the above parseStr function.\n     *\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n     *\n     * @param {object} y Big number instance\n     * @param {object} x Big number instance\n     * @returns {*}\n     */\n    function testMinMax(y, x) {\n        const xc = x.c;\n        const yc = y.c;\n        let i = x.s;\n        let j = y.s;\n        let k = x.e;\n        let l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            let result;\n            if (!xc[0]) {\n                result = !yc[0]?0:-j;\n            } else {\n                result = i;\n            }\n            return result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        const xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return (k > l ^ xNeg)?1:-1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = (k < l) ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return (xc[i] > yc[i] ^ xNeg)?1:-1;\n            }\n        }\n\n        // Compare lengths\n        let result;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = (k > l ^ xNeg)?1:-1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Check that the number satisfy the format conditions\n     * and lays between settings.minimumValue and settings.maximumValue\n     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function checkIfInRangeWithOverrideOption(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        const minParse = parseStr(settings.minimumValue);\n        const maxParse = parseStr(settings.maximumValue);\n        const valParse = parseStr(s);\n\n        let result;\n        switch (settings.overrideMinMaxLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * Thanks to Anthony & Evan C\n     *\n     * @param {Element|string} element\n     * @returns {*|jQuery|HTMLElement}\n     */\n    function getCurrentElement(element) {\n        /*\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\n         * for jQuery to be able to parse the selector correctly.\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\n         */\n        if (isString(element)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            element = `#${element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1')}`;\n        }\n\n        return $(element);\n    }\n\n    /**\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {object} settings\n     * @param {boolean} update\n     * @returns {*}\n     */\n    function getAutoNumericHolder($this, settings, update = false) {\n        let data = $this.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $this.data('autoNumeric', data);\n        }\n\n        let holder = data.holder;\n        if (update || (isUndefined(holder) && settings)) {\n            holder = new AutoNumericHolder($this.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n     *\n     * @param {object} settings\n     */\n    function keepAnOriginalSettingsCopy(settings) {\n        //TODO Rename the old option names to the new ones\n        settings.oDec     = settings.decimalPlacesOverride;\n        settings.oPad     = settings.allowDecimalPadding;\n        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n        settings.oSep     = settings.digitGroupSeparator;\n        settings.oSign    = settings.currencySymbol;\n        settings.oSuffix  = settings.suffixText;\n    }\n\n    /**\n     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\n     * This is taken from Quirksmode.\n     *\n     * @param {string} name\n     * @returns {*}\n     */\n    function readCookie(name) {\n        const nameEQ = name + '=';\n        const ca = document.cookie.split(';');\n        let c = '';\n        for (let i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported.\n     * This is taken from Modernizr.\n     *\n     * @returns {boolean}\n     */\n    function storageTest() {\n        const mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\n     *\n     * @param {Element|EventTarget} element\n     * @param {object} settings\n     * @param {string} action\n     * @returns {*}\n     */\n    function saveValueToPersistentStorage(element, settings, action) {\n        if (settings.saveValueToSessionStorage) {\n            const storedName = (element.name !== '' && !isUndefined(element.name)) ?`AUTO_${decodeURIComponent(element.name)}` :`AUTO_${element.id}`;\n            let date;\n            let expires;\n\n            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (action) {\n                    case 'set':\n                        document.cookie = `${storedName}=${settings.rawValue}; expires= ; path=/`;\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + (-1 * 24 * 60 * 60 * 1000));\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = `${storedName}='' ;${expires}; path=/`;\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (action) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n    class AutoNumericHolder {\n        /**\n         * Class constructor\n         *\n         * @param {HTMLElement} that - A reference to the current DOM element\n         * @param {object} settings\n         */\n        constructor(that, settings) {\n            this.settings = settings;\n            this.that = that;\n            this.$that = $(that);\n            this.formatted = false;\n            this.settingsClone = settings;\n            this.value = that.value;\n        }\n\n        /**\n         * Update the value and the selection values inside the AutoNumericHolder object.\n         * This keeps tracks of the input value, as well as the current selection.\n         * This also resets the 'processed' and 'formatted' state.\n         *\n         * Note : Those two can change between the keydown, keypress and keyup events, that's why\n         *        this function is called on each event handler.\n         *\n         * @private\n         */\n        _updateAutoNumericHolderProperties() {\n            this.value = this.that.value;\n            this.selection = getElementSelection(this.that);\n            this.processed = false;\n            this.formatted = false;\n        }\n\n        /**\n         * Update the keycode of the key that triggered the given event.\n         * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\n         *\n         * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\n         * e.key describe the key name used to trigger the event.\n         * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\n             * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n         * The key list is described here\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n         *\n         * @param {Event} e\n         * @private\n         */\n        _updateAutoNumericHolderEventKeycode(e) {\n            // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\n            this.eventKeyCode = keyCodeNumber(e);\n        }\n\n        /**\n         * Set the text selection inside the input with the given start and end position.\n         *\n         * @param {int} start\n         * @param {int} end\n         * @param {undefined|boolean} setReal\n         * @private\n         */\n        _setSelection(start, end, setReal) {\n            //TODO Modify setReal to be more explicit (and a boolean)\n            start = Math.max(start, 0);\n            end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\n            this.selection = {\n                start,\n                end,\n                length: end - start,\n            };\n\n            if (isUndefined(setReal) || setReal) {\n                setElementSelection(this.that, start, end);\n            }\n        }\n\n        /**\n         * Set the caret position inside the input at the given position.\n         *\n         * @param {int} pos\n         * @param {undefined|boolean} setReal\n         * @private\n         */\n        _setCaretPosition(pos, setReal) {\n            //TODO Modify setReal to be more explicit (and a boolean)\n            this._setSelection(pos, pos, setReal);\n        }\n\n        /**\n         * Return an array containing the string parts located on the left and right side of the caret or selection.\n         * Those parts are left 'untouched', ie. formatted by autoNumeric.\n         *\n         * @returns {[string, string]} The parts on the left and right of the caret or selection\n         * @private\n         */\n        _getLeftAndRightPartAroundTheSelection() {\n            const value = this.value;\n            const left = value.substring(0, this.selection.start);\n            const right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        }\n\n        /**\n         * Return an array containing the string parts located on the left and right side of the caret or selection.\n         * Those parts are unformatted (stripped) of any non-numbers characters.\n         *\n         * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\n         * @private\n         */\n        _getUnformattedLeftAndRightPartAroundTheSelection() {\n            const settingsClone = this.settingsClone;\n            let [left, right] = this._getLeftAndRightPartAroundTheSelection();\n\n            // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n            let stripZeros = true;\n            if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                stripZeros = false;\n            }\n            left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\n\n            right = stripAllNonNumberCharacters(right, this.settingsClone, false);\n\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                right = (right === '-') ? '' : right;\n            }\n\n            settingsClone.trailingNegative = false;\n\n            return [left, right];\n        }\n\n        /**\n         * Strip parts from excess characters and leading zeros.\n         *\n         * @param {string} left\n         * @param {string} right\n         * @returns {[*,*]}\n         * @private\n         */\n        _normalizeParts(left, right) {\n            const settingsClone = this.settingsClone;\n\n            // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n            let stripZeros = true;\n            if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                stripZeros = false;\n            }\n            left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\n\n            // If right is not empty and first character is not decimalCharacter\n            right = stripAllNonNumberCharacters(right, settingsClone, false);\n\n            // Prevents multiple leading zeros from being entered\n            if (settingsClone.leadingZero === 'deny' &&\n                (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) &&\n                Number(left) === 0 &&\n                !contains(left, settingsClone.decimalCharacter)  && right !== '') {\n                left = left.substring(0, left.length - 1);\n            }\n\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                settingsClone.trailingNegative = false;\n            }\n\n            // Insert zero if has leading dot\n            this.newValue = left + right;\n            if (settingsClone.decimalCharacter) {\n                const m = this.newValue.match(new RegExp(`^${settingsClone.aNegRegAutoStrip}\\\\${settingsClone.decimalCharacter}`));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    this.newValue = left + right;\n                }\n            }\n\n            return [left, right];\n        }\n\n        /**\n         * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\n         *\n         * @param {string} left\n         * @param {string} right\n         * @param {boolean} isPaste\n         * @returns {boolean}\n         * @private\n         */\n        _setValueParts(left, right, isPaste = false) {\n            const settingsClone = this.settingsClone;\n            const parts = this._normalizeParts(left, right);\n            const [minTest, maxTest] = checkIfInRangeWithOverrideOption(this.newValue, settingsClone);\n            let position = parts[0].length;\n            this.newValue = parts.join('');\n\n            if (minTest && maxTest) {\n                this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\n                const testValue = (contains(this.newValue, ',')) ? this.newValue.replace(',', '.') : this.newValue;\n                if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n                    settingsClone.rawValue = '';\n                } else {\n                    settingsClone.rawValue = testValue;\n                }\n\n                if (position > this.newValue.length) {\n                    position = this.newValue.length;\n                }\n\n                // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n                    // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n                    if (parts[1] === '') {\n                        position = 1;\n                    } else {\n                        position = 0;\n                    }\n                }\n\n                this.value = this.newValue;\n                this._setCaretPosition(position, false);\n\n                return true;\n            }\n\n            if (!minTest) {\n                this.$that.trigger('autoNumeric:minExceeded');\n            } else if (!maxTest) {\n                this.$that.trigger('autoNumeric:maxExceeded');\n            }\n\n            return false;\n        }\n\n        /**\n         * Helper function for `_expandSelectionOnSign()`.\n         *\n         * @returns {*} Sign position of a formatted value\n         * @private\n         */\n        _getSignPosition() {\n            const settingsClone = this.settingsClone;\n            const currencySymbol = settingsClone.currencySymbol;\n            const that = this.that;\n\n            if (currencySymbol) {\n                const currencySymbolLen = currencySymbol.length;\n                if (settingsClone.currencySymbolPlacement === 'p') {\n                    const hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n                    return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n                }\n                const valueLen = that.value.length;\n                return [valueLen - currencySymbolLen, valueLen];\n            }\n\n            return [1000, -1];\n        }\n\n        /**\n         * Expands selection to cover whole sign\n         * Prevents partial deletion/copying/overwriting of a sign\n         *\n         * @param {undefined|boolean} setReal\n         * @private\n         */\n        _expandSelectionOnSign(setReal) {\n            //TODO Modify setReal to be more explicit (and a boolean only)\n            //TODO Use array destructuring here to set signPosition to more explicit variables\n            const signPosition = this._getSignPosition();\n            const selection = this.selection;\n\n            // If selection catches something except sign and catches only space from sign\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                // Then select without empty space\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                    if (selection.start < signPosition[0]) {\n                        this._setSelection(selection.start, signPosition[0], setReal);\n                    } else {\n                        this._setSelection(signPosition[1], selection.end, setReal);\n                    }\n                } else {\n                    // Else select with whole sign\n                    this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                }\n            }\n        }\n\n        /**\n         * Try to strip pasted value to digits\n         */\n        _checkPaste() {\n            if (!isUndefined(this.valuePartsBeforePaste)) {\n                const oldParts = this.valuePartsBeforePaste;\n                const [left, right] = this._getLeftAndRightPartAroundTheSelection();\n\n                // Try to strip the pasted value first\n                delete this.valuePartsBeforePaste;\n\n                const modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\n                if (!this._setValueParts(modifiedLeftPart, right, true)) {\n                    this.value = oldParts.join('');\n                    this._setCaretPosition(oldParts[0].length, false);\n                }\n            }\n        }\n\n        /**\n         * Process pasting, cursor moving and skipping of not interesting keys.\n         * If this function returns TRUE, then further processing is not performed.\n         *\n         * @param {Event} e\n         * @returns {boolean}\n         * @private\n         */\n        _skipAlways(e) {\n            // Catch the ctrl up on ctrl-v\n            if (((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste)) || (e.shiftKey && this.eventKeyCode === keyCode.Insert)) {\n                //TODO Move this test inside the `onKeyup` handler\n                this._checkPaste();\n                return false;\n            }\n\n            // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n            if ((this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12) ||\n                (this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick) ||\n                (this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space) ||\n                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\n                (this.eventKeyCode < keyCode.Backspace &&\n                (e.which === 0 || e.which === this.eventKeyCode)) ||\n                this.eventKeyCode === keyCode.NumLock ||\n                this.eventKeyCode === keyCode.ScrollLock ||\n                this.eventKeyCode === keyCode.Insert ||\n                this.eventKeyCode === keyCode.Command) {\n                return true;\n            }\n\n            // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n            if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\n                if (this.settings.selectNumberOnly) {\n                    // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                    e.preventDefault();\n                    const valueLen = this.that.value.length;\n                    const currencySymbolLen = this.settings.currencySymbol.length;\n                    const negLen = (!contains(this.that.value, '-'))?0:1;\n                    const suffixTextLen = this.settings.suffixText.length;\n                    const currencySymbolPlacement = this.settings.currencySymbolPlacement;\n                    const negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\n                    let start;\n                    if (currencySymbolPlacement === 's') {\n                        start = 0;\n                    } else {\n                        start = (negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0)?currencySymbolLen + 1:currencySymbolLen;\n                    }\n\n                    let end;\n                    if (currencySymbolPlacement === 'p') {\n                        end = valueLen - suffixTextLen;\n                    } else {\n                        switch (negativePositiveSignPlacement) {\n                            case 'l':\n                                end = valueLen - (suffixTextLen + currencySymbolLen);\n                                break;\n                            case 'r':\n                                end = (currencySymbolLen > 0)?valueLen - (currencySymbolLen + negLen + suffixTextLen):valueLen - (currencySymbolLen + suffixTextLen);\n                                break;\n                            default :\n                                end = valueLen - (currencySymbolLen + suffixTextLen);\n                        }\n                    }\n\n                    setElementSelection(this.that, start, end);\n                }\n\n                return true;\n            }\n\n            // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n            if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\n                if (e.type === 'keydown') {\n                    this._expandSelectionOnSign();\n                }\n\n                // Try to prevent wrong paste\n                if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n                        }\n                    } else {\n                        this._checkPaste();\n                    }\n                }\n\n                return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\n            }\n\n            if (e.ctrlKey || e.metaKey) {\n                return true;\n            }\n\n            // Jump over thousand separator\n            //TODO Move this test inside the `onKeydown` handler\n            if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\n                if (e.type === 'keydown' && !e.shiftKey) {\n                    if (this.eventKeyCode === keyCode.LeftArrow &&\n                        (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator ||\n                        this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\n                        this._setCaretPosition(this.selection.start - 1);\n                    } else if (this.eventKeyCode === keyCode.RightArrow &&\n                        (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator ||\n                        this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\n                        this._setCaretPosition(this.selection.start + 1);\n                    }\n                }\n                return true;\n            }\n\n            return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\n        }\n\n        /**\n         * Process deletion of characters when the minus sign is to the right of the numeric characters.\n         *\n         * @param {string} left The part on the left of the caret or selection\n         * @param {string} right The part on the right of the caret or selection\n         * @returns {[string, string]}\n         * @private\n         */\n        _processCharacterDeletionIfTrailingNegativeSign([left, right]) {\n            const settingsClone = this.settingsClone;\n            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                if (this.eventKeyCode === keyCode.Backspace) {\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '');\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '');\n                    if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\n            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length);\n                if (this.eventKeyCode === keyCode.Backspace) {\n                    if (this.selection.start === (this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) && contains(this.value, settingsClone.negativeSignCharacter)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && ((this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter)) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    if (left[0] === '-') {\n                        right = right.substring(1);\n                    }\n                    if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length);\n                if (this.eventKeyCode === keyCode.Backspace) {\n                    if (this.selection.start === (this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && this.selection.start <= (this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length)) {\n                        left = left.substring(0, left.length - 1);\n                    } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '');\n                    if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n                        left = left.substring(1);\n                    }\n                    right = right.substring(1);\n                }\n            }\n\n            return [left, right];\n        }\n\n        /**\n         * Process the deletion of characters.\n         */\n        _processCharacterDeletion() {\n            const settingsClone = this.settingsClone;\n\n            let left;\n            let right;\n\n            if (!this.selection.length) {\n                [left, right] = this._getUnformattedLeftAndRightPartAroundTheSelection();\n                if (left === '' && right === '') {\n                    settingsClone.throwInput = false;\n                }\n\n                if (((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') ||\n                     (settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r'))) &&\n                     contains(this.value, '-')) { //TODO Change `this.value` to `this.that.value`?\n                    [left, right] = this._processCharacterDeletionIfTrailingNegativeSign([left, right]);\n                } else {\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        left = left.substring(0, left.length - 1);\n                    } else {\n                        right = right.substring(1, right.length);\n                    }\n                }\n            } else {\n                this._expandSelectionOnSign(false);\n                [left, right] = this._getUnformattedLeftAndRightPartAroundTheSelection();\n            }\n\n            this._setValueParts(left, right);\n        }\n\n        /**\n         * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\n         * Returns TRUE if the keycode is allowed.\n         * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\n         *\n         * @param {Event} e\n         * @returns {boolean}\n         */\n        _processCharacterInsertion(e) {\n            const settingsClone = this.settingsClone;\n            let [left, right] = this._getUnformattedLeftAndRightPartAroundTheSelection();\n            settingsClone.throwInput = true;\n\n            // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // Do not allow decimal character if no decimal part allowed\n            if (e.key === settingsClone.decimalCharacter ||\n                (settingsClone.decimalCharacterAlternative && e.key === settingsClone.decimalCharacterAlternative) ||\n                ((e.key === '.' || e.key === ',') && this.eventKeyCode === keyCode.DotNumpad)) {\n                if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n                    return true;\n                }\n\n                // Do not allow decimal character before negativeSignCharacter character\n                if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n                    return true;\n                }\n\n                // Do not allow decimal character if other decimal character present\n                if (contains(left, settingsClone.decimalCharacter)) {\n                    return true;\n                }\n\n                if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n                    return true;\n                }\n\n                if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n                    right = right.substr(1);\n                }\n\n                this._setValueParts(left + settingsClone.decimalCharacter, right);\n\n                return true;\n            }\n\n            // Prevent minus if not allowed\n            if ((e.key === '-' || e.key === '+') && settingsClone.negativeSignCharacter === '-') {\n                if (!settingsClone) {\n                    return true;\n                }\n\n                // Caret is always after minus\n                if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') || (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p')) {\n                    if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                        left = settingsClone.negativeSignCharacter;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // Change number sign, remove part if should\n                    if (left.charAt(0) === '-' || contains(left, settingsClone.negativeSignCharacter)) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = (e.key === '-') ? settingsClone.negativeSignCharacter + left : left;\n                    }\n                } else {\n                    if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                        left = settingsClone.negativeSignCharacter;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // Change number sign, remove part if should\n                    if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = (e.key === '-') ? settingsClone.negativeSignCharacter + left : left;\n                    }\n                }\n\n                this._setValueParts(left, right);\n\n                return true;\n            }\n\n            // If the user tries to insert digit before minus sign\n            const eventNumber = Number(e.key);\n            if (eventNumber >= 0 && eventNumber <= 9) {\n                if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                    left = settingsClone.negativeSignCharacter;\n                    right = right.substring(1, right.length);\n                }\n\n                if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && e.key !== '0') {\n                    left = settingsClone.negativeSignCharacter + left;\n                }\n\n                this._setValueParts(left + e.key, right);\n\n                return true;\n            }\n\n            // Prevent any other character\n            settingsClone.throwInput = false;\n\n            return false;\n        }\n\n        /**\n         * Formatting of just processed value while keeping the cursor position\n         *\n         * @param {Event} e\n         * @private\n         */\n        _formatValue(e) {\n            const settingsClone = this.settingsClone;\n            const leftLength = this.value;\n            let [left] = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n            // No grouping separator and no currency sign\n            if ((settingsClone.digitGroupSeparator  === '' || (settingsClone.digitGroupSeparator !== ''  && !contains(leftLength, settingsClone.digitGroupSeparator))) &&\n                (settingsClone.currencySymbol === '' || (settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol)))) {\n                let [subParts] = leftLength.split(settingsClone.decimalCharacter);\n                let nSign = '';\n                if (contains(subParts, '-')) {\n                    nSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // Strip leading zero on positive value if needed\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // Strip leading zero on negative value if needed\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                left = nSign + left;\n            }\n\n            const value = addGroupSeparators(this.value, this.settingsClone);\n            let position = value.length;\n            if (value) {\n                // Prepare regexp which searches for cursor position from unformatted left part\n                const leftAr = left.split('');\n\n                // Fixes caret position with trailing minus sign\n                if ((settingsClone.negativePositiveSignPlacement === 's' || (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p')) &&\n                    leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n                    leftAr.shift();\n\n                    if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) &&\n                        settingsClone.caretFix) {\n                        if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                            leftAr.push('-');\n                            settingsClone.caretFix = e.type === 'keydown';\n                        }\n\n                        if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                            leftAr.push('-');\n                            settingsClone.caretFix = e.type === 'keydown';\n                        }\n\n                        if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                            const signParts = settingsClone.currencySymbol.split('');\n                            const escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                            const escapedParts = [];\n                            $.each(signParts, (i, miniParts) => {\n                                miniParts = signParts[i];\n                                if (isInArray(miniParts, escapeChr)) {\n                                    escapedParts.push('\\\\' + miniParts);\n                                } else {\n                                    escapedParts.push(miniParts);\n                                }\n                            });\n\n                            if (this.eventKeyCode === keyCode.Backspace) {\n                                escapedParts.push('-');\n                            }\n\n                            // Pushing the escaped sign\n                            leftAr.push(escapedParts.join(''));\n                            settingsClone.caretFix = e.type === 'keydown';\n                        }\n                    }\n                }\n\n                for (let i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                const leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // Search cursor position in formatted value\n                const newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // If we are just before the sign which is in prefix position\n                    if (((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter) || (position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter)) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n                        // Place caret after prefix sign\n                        position = this.settingsClone.currencySymbol.length + (value.charAt(0) === '-' ? 1 : 0);\n                    }\n                } else {\n                    if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n                        // If we could not find a place for cursor and have a sign as a suffix\n                        // Place caret before suffix currency sign\n                        position -= settingsClone.currencySymbol.length;\n                    }\n\n                    if (settingsClone.suffixText) {\n                        // If we could not find a place for cursor and have a suffix\n                        // Place caret before suffix\n                        position -= settingsClone.suffixText.length;\n                    }\n                }\n            }\n\n            // Only update the value if it has changed. This prevents modifying the selection, if any.\n            if (value !== this.that.value ||\n                value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\n                this.that.value = value;\n                this._setCaretPosition(position);\n            }\n\n            this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n        }\n    }\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @param {HTMLElement} that - A reference to the current DOM element\n     * @returns {*}\n     * @private\n     */\n    function _getStringOrArray(getArrayBehavior = true, that) {\n        const $this = getCurrentElement(that);\n        const formIndex = $('form').index($this);\n        const allFormElements = $(`form:eq(${formIndex})`)[0];\n        const aiIndex = [];\n\n        // all input index\n        const scIndex = [];\n\n        // successful control index\n        const rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        const rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        const rCheckableType = /^(?:checkbox|radio)$/i;\n        const rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        let count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, (i, field) => {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, (i, field) => {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            const formFields = $this.serializeArray();\n\n            $.each(formFields, (i, field) => {\n                const scElement = scIndex.indexOf(i);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    const testInput = $(`form:eq(${formIndex}) input:eq(${aiIndex[scElement]})`);\n                    const settings = testInput.data('autoNumeric');\n\n                    if (typeof settings === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        }\n        else {\n            // getString() behavior\n            const formFields = $this.serialize();\n            const formParts = formFields.split('&');\n\n            $.each(formParts, i => {\n                const [inputName, inputValue] = formParts[i].split('=');\n                const scElement = scIndex.indexOf(i);\n\n                // If the current element is a valid element\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    const testInput = $(`form:eq(${formIndex}) input:eq(${aiIndex[scElement]})`);\n                    const settings = testInput.data('autoNumeric');\n\n                    if (typeof settings === 'object') {\n                        if (inputValue !== null) {\n                            const modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                            formParts[i] = `${inputName}=${modifiedInputValue}`;\n                        }\n                    }\n                }\n            });\n\n            return formParts.join('&');\n        }\n    }\n\n    /**\n     * Handler for 'focusin' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onFocusInAndMouseEnter($this, holder, e) {\n        const settings = holder.settingsClone;\n\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n            settings.onOff = true;\n\n            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                $this.val(toggleNegativeBracket(e.target.value, settings));\n            }\n\n            let result;\n            //TODO Do not repeat yourself with the `$this.autoNumeric('set', settings.rawValue);` line\n            if (settings.decimalPlacesShownOnFocus) {\n                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.scaleDivisor) {\n                settings.decimalPlacesOverride = settings.oDec;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.noSeparatorOnFocus) {\n                settings.digitGroupSeparator = '';\n                settings.currencySymbol = '';\n                settings.suffixText = '';\n                $this.autoNumeric('set', settings.rawValue);\n            } else if ((result = stripAllNonNumberCharacters(e.target.value, settings, true)) !== settings.rawValue) {\n                $this.autoNumeric('set', result);\n            }\n\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n            holder.valueOnFocus = e.target.value;\n            holder.lastVal = holder.valueOnFocus;\n            const onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n            if ((onEmpty !== null && onEmpty !== '') && settings.emptyInputBehavior === 'focus') {\n                $this.val(onEmpty);\n                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n                    setElementSelection(e.target, 0, 0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handler for 'keydown' events.\n     * The user just started pushing any key, hence one event is sent.\n     *\n     * Note :\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\n     * - keydown\n     * - keypress\n     * - input\n     * - keyup\n     *\n     * ...when inputting a modifier key (ie. 'ctrl') :\n     * - keydown\n     * - keyup\n     *\n     * If 'delete' or 'backspace' is entered, the following events are sent :\n     * - keydown\n     * - input\n     * - keyup\n     *\n     * If 'enter' is entered and the value has not changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - keyup\n     *\n     * If 'enter' is entered and the value has been changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - change\n     * - keyup\n     *\n     * When a paste is done, the following events are sent :\n     * - input (if paste is done with the mouse)\n     *\n     * - keydown (if paste is done with ctrl+v)\n     * - keydown\n     * - input\n     * - keyup\n     * - keyup\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onKeydown(holder, e) {\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n        holder._updateAutoNumericHolderEventKeycode(e);\n        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\n\n        if (holder.that.readOnly) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n            triggerEvent('change', e.target);\n            holder.valueOnFocus = e.target.value;\n        }\n\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // Check if the key is a delete/backspace key\n        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n            holder.processed = true;\n            holder._formatValue(e);\n\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n            if ((e.target.value !== holder.lastVal) && holder.settingsClone.throwInput) {\n                // Throw an input event when a character deletion is detected\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false; //TODO Is this line needed?\n    }\n\n    /**\n     * Handler for 'keypress' events.\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onKeypress(holder, e) {\n        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n        if (e.key === keyName.Insert) {\n            return;\n        }\n\n        const processed = holder.processed;\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            return;\n        }\n\n        if (processed) {\n            e.preventDefault();\n\n            return;\n        }\n\n        const isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\n        if (isCharacterInsertionAllowed) {\n            holder._formatValue(e);\n            if ((e.target.value !== holder.lastVal) && holder.settingsClone.throwInput) {\n                // Throws input event on adding a character\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n            }\n            else {\n                // If the value has not changed, we do not allow the input event to be sent\n                e.preventDefault();\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        e.preventDefault();\n\n        holder.formatted = false;\n    }\n\n    /**\n     * Handler for 'keyup' events.\n     * The user just released any key, hence one event is sent.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {object} settings\n     * @param {Event} e\n     */\n    function onKeyup(holder, settings, e) {\n        holder._updateAutoNumericHolderProperties(e);\n\n        const skip = holder._skipAlways(e);\n        delete holder.valuePartsBeforePaste;\n        if (skip || e.target.value === '') {\n            return;\n        }\n\n        // Added to properly place the caret when only the currency sign is present\n        if (e.target.value === holder.settingsClone.currencySymbol) {\n            if (holder.settingsClone.currencySymbolPlacement === 's') {\n                setElementSelection(e.target, 0, 0);\n            } else {\n                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\n            }\n        } else if (holder.eventKeyCode === keyCode.Tab) {\n            setElementSelection(e.target, 0, e.target.value.length);\n        }\n\n        if ((e.target.value === holder.settingsClone.suffixText) ||\n            (holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '')) {\n            setElementSelection(e.target, 0, 0);\n        }\n\n        // Saves the extended decimal to preserve the data when navigating away from the page\n        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n            saveValueToPersistentStorage(e.target, settings, 'set');\n        }\n\n        if (!holder.formatted) {\n            holder._formatValue(e);\n        }\n\n        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n        if (e.target.value !== holder.initialValueOnKeydown) {\n            triggerEvent('autoNumeric:formatted', e.target);\n        }\n    }\n\n    /**\n     * Handler for 'focusout' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onFocusOutAndMouseLeave($this, holder, e) {\n        if (!$this.is(':focus')) {\n            let value = e.target.value;\n            const origValue = value;\n            const settings = holder.settingsClone;\n            settings.onOff = false;\n\n            if (settings.saveValueToSessionStorage) {\n                saveValueToPersistentStorage(e.target, settings, 'set');\n            }\n\n            if (settings.noSeparatorOnFocus === true) {\n                settings.digitGroupSeparator = settings.oSep;\n                settings.currencySymbol = settings.oSign;\n                settings.suffixText = settings.oSuffix;\n            }\n\n            if (settings.decimalPlacesShownOnFocus !== null) {\n                settings.decimalPlacesOverride = settings.oDec;\n                settings.allowDecimalPadding = settings.oPad;\n                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n            }\n\n            value = stripAllNonNumberCharacters(value, settings, true);\n\n            if (value !== '') {\n                if (settings.trailingNegative) {\n                    value = '-' + value;\n                    settings.trailingNegative = false;\n                }\n\n                const [minTest, maxTest] = checkIfInRangeWithOverrideOption(value, settings);\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                    settings.rawValue = value;\n\n                    if (settings.scaleDivisor) {\n                        value = value / settings.scaleDivisor;\n                        value = value.toString();\n                    }\n\n                    settings.decimalPlacesOverride = (settings.scaleDivisor && settings.scaleDecimalPlaces) ? +settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n                    value = roundValue(value, settings);\n                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                } else {\n                    if (!minTest) {\n                        $this.trigger('autoNumeric:minExceeded');\n                    }\n                    if (!maxTest) {\n                        $this.trigger('autoNumeric:maxExceeded');\n                    }\n\n                    value = settings.rawValue;\n                }\n            } else {\n                if (settings.emptyInputBehavior === 'zero') {\n                    settings.rawValue = '0';\n                    value = roundValue('0', settings);\n                } else {\n                    settings.rawValue = '';\n                }\n            }\n\n            let groupedValue = checkEmpty(value, settings, false);\n            if (groupedValue === null) {\n                groupedValue = addGroupSeparators(value, settings);\n            }\n\n            if (groupedValue !== origValue) {\n                groupedValue = (settings.scaleSymbol) ? groupedValue + settings.scaleSymbol : groupedValue;\n                $this.val(groupedValue);\n            }\n\n            if (groupedValue !== holder.valueOnFocus) {\n                $this.change();\n                delete holder.valueOnFocus;\n            }\n        }\n    }\n\n    /**\n     * Handler for 'paste' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onPaste($this, holder, e) {\n        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n        e.preventDefault();\n\n        let rawPastedText = e.clipboardData.getData('text/plain');\n\n        // 0. Special case if the user has selected all the input text before pasting\n        const initialFormattedValue = e.target.value;\n        const selectionStart = e.target.selectionStart || 0;\n        const selectionEnd = e.target.selectionEnd || 0;\n        const selectionSize = selectionEnd - selectionStart;\n        let isAllInputTextSelected = false;\n\n        if (selectionSize === initialFormattedValue.length) {\n            isAllInputTextSelected = true;\n        }\n\n        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n        const isPasteNegative = isNegative(rawPastedText);\n        if (isPasteNegative) {\n            // 1a. Remove the negative sign from the pasted text\n            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n        }\n        const rawPastedTextSize = rawPastedText.length; // This use the 'cleaned' paste text\n\n        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n        const pastedText = preparePastedText(rawPastedText, holder);\n\n        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n        if (!isNumber(pastedText) || pastedText === '') {\n            if (holder.settings.onInvalidPaste === 'error') {\n                //TODO Should we send a warning instead of throwing an error?\n                throwError(`The pasted value '${rawPastedText}' is not a valid paste content.`);\n            }\n\n            return;\n        }\n\n        // 4. Calculate the paste result\n        let caretPositionOnInitialTextAfterPasting;\n        let initialUnformattedNumber;\n        if (e.target.value === '') {\n            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\n            initialUnformattedNumber = '';\n        } else {\n            initialUnformattedNumber = $this.autoNumeric('get');\n        }\n        let isInitialValueNegative = isNegative(initialUnformattedNumber);\n        let isPasteNegativeAndInitialValueIsPositive;\n        let result;\n\n        // If the pasted content is negative, then the result will be negative too\n        if (isPasteNegative && !isInitialValueNegative) {\n            initialUnformattedNumber = `-${initialUnformattedNumber}`;\n            isInitialValueNegative = true;\n            isPasteNegativeAndInitialValueIsPositive = true;\n        }\n        else {\n            isPasteNegativeAndInitialValueIsPositive = false;\n        }\n\n        switch (holder.settings.onInvalidPaste) {\n            /* 4a. Truncate paste behavior:\n             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\n             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\n             * Otherwise paste all the numbers in the clipboard.\n             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\n             *\n             * 4b. Replace paste behavior:\n             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\n             */\n            /* eslint no-case-declarations: 0 */\n            case 'truncate':\n            case 'replace':\n                const leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n                const rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                const leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                const rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                // -- Here, we are good to go to continue on the same basis\n\n                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n                const minParse = parseStr(holder.settings.minimumValue);\n                const maxParse = parseStr(holder.settings.maximumValue);\n                let lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n                let pastedTextIndex = 0;\n                let modifiedLeftPart = leftPart;\n\n                while (pastedTextIndex < pastedText.length) {\n                    // Modify the result with another pasted character\n                    modifiedLeftPart += pastedText[pastedTextIndex];\n                    result = modifiedLeftPart + rightPart;\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\n                //XXX Here we have the result for the `truncate` option\n                if (holder.settings.onInvalidPaste === 'truncate') {\n                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n                    result = lastGoodKnownResult;\n                    break;\n                }\n                //XXX ...else we need to continue modifying the result for the 'replace' option\n\n                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n                //    If you do get to the range limits, use the previous known good value within those limits.\n                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n                let lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n                const lastGoodKnownResultSize = lastGoodKnownResult.length;\n\n                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n                        lastGoodKnownResultIndex++;\n                        continue;\n                    }\n\n                    // This replace one character at a time\n                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                    lastGoodKnownResultIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\n                result = lastGoodKnownResult;\n\n                break;\n            /* 4c. Normal paste behavior:\n             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\n             */\n            case 'error':\n            case 'ignore':\n            case 'clamp':\n            default:\n                // Test if there is a selection in the input\n                if (selectionStart === selectionEnd) {\n                    // There is no selection, and this is the caret position : Insert the paste into the element.value at that caret position\n                    let indexWhereToInsertThePastedText = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                        indexWhereToInsertThePastedText++;\n                    }\n\n                    result = insertCharAtPosition(initialUnformattedNumber, pastedText, indexWhereToInsertThePastedText);\n\n                    caretPositionOnInitialTextAfterPasting = indexWhereToInsertThePastedText + rawPastedTextSize - countDotsInText(rawPastedText); // I must not count the characters that have been removed from the pasted text (ie. '.')\n                } else {\n                    // There is a selection : replace the selection with the paste content\n                    const firstPart = e.target.value.slice(0, selectionStart);\n                    const lastPart = e.target.value.slice(selectionEnd, e.target.value.length);\n                    result = firstPart + pastedText + lastPart;\n\n                    // Finally, remove any unwanted non-number characters\n                    if (firstPart !== '' || lastPart !== '') {\n                        // If the whole input has been selected prior to pasting, then firstPart and lastPart are empty, hence we only use the pastedText variable, otherwise we remove the potential decimal character in the result variable\n                        result = preparePastedText(result, holder);\n                    }\n\n                    // Add back the negative sign if needed\n                    if (isInitialValueNegative) {\n                        result = setRawNegativeSign(result);\n                    }\n\n                    if (isAllInputTextSelected) {\n                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n                        caretPositionOnInitialTextAfterPasting = result.length;\n                    } else {\n                        // Normal case\n                        let indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\n\n                        if (isPasteNegativeAndInitialValueIsPositive) {\n                            // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                            indexSelectionEndInRawValue++;\n                        }\n\n                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n                        const selectedText = e.target.value.slice(selectionStart, selectionEnd);\n                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + rawPastedTextSize - countDotsInText(rawPastedText);\n                    }\n                }\n        }\n\n        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n        if (!isNumber(result) || result === '') {\n            if (holder.settings.onInvalidPaste === 'error') {\n                throwError(`The pasted value '${rawPastedText}' would result into an invalid content '${result}'.`); //TODO Should we send a warning instead of throwing an error?\n                //TODO This is not DRY ; refactor with above\n            }\n            return;\n        }\n\n        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n        /*\n         * If 'error' (this is the default) :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, then throw an error in the console.\n         *      - Do not change the input value, do not change the current selection.\n         * If 'ignore' :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, do nothing more.\n         *      - Do not change the input value, do not change the current selection.\n         * If 'clamp' :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\n         *        paste result.\n         *      - Change the caret position to be positioned on the left hand side of the decimal character.\n         * If 'truncate' :\n         *      - Truncate paste behavior.\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\n         *      - Change the caret position to be positioned after the last pasted character.\n         * If 'replace' :\n         *      - Replace paste behavior.\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n          *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\n         *      - Change the caret position to be positioned after the last pasted character.\n         */\n        let valueHasBeenSet = false;\n        let valueHasBeenClamped = false;\n        try {\n            $this.autoNumeric('set', result);\n            valueHasBeenSet = true;\n        }\n        catch (error) {\n            let clampedValue;\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    clampedValue = clampToRangeLimits(result, holder.settings);\n                    try {\n                        $this.autoNumeric('set', clampedValue);\n                    }\n                    catch (error) {\n                        throwError(`Fatal error: Unable to set the clamped value '${clampedValue}'.`);\n                    }\n\n                    valueHasBeenClamped = true;\n                    valueHasBeenSet = true;\n                    result = clampedValue; // This is used only for setting the caret position later\n                    break;\n                case 'error':\n                case 'truncate':\n                case 'replace':\n                    // Throw an error message\n                    throwError(`The pasted value '${rawPastedText}' results in a value '${result}' that is outside of the minimum [${holder.settings.minimumValue}] and maximum [${holder.settings.maximumValue}] value range.`);\n                    // falls through\n                case 'ignore':\n                    // Do nothing\n                    // falls through\n                default :\n                    return; // ...and nothing else should be changed\n            }\n        }\n\n        // 7. Then lastly, set the caret position at the right logical place\n        let caretPositionInFormattedNumber;\n        if (valueHasBeenSet) {\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    if (valueHasBeenClamped) {\n                        if (holder.settings.currencySymbolPlacement === 's') {\n                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n                        } else {\n                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\n                        }\n\n                        break;\n                    } // else if the value has not been clamped, the default behavior is used...\n                    // falls through\n                case 'error':\n                case 'ignore':\n                case 'truncate':\n                case 'replace':\n                default :\n                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\n                    setElementSelection(e.target, caretPositionInFormattedNumber);\n            }\n        }\n\n        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\n            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n            triggerEvent('input', e.target);\n        }\n    }\n\n    /**\n     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onBlur(holder, e) {\n        if (e.target.value !== holder.valueOnFocus) {\n            triggerEvent('change', e.target);\n            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery, which adds '.00' at the end of an integer\n        }\n    }\n\n    /**\n     * Handler for 'submit' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', () => {\n            if (holder) {\n                const $settings = holder.settingsClone;\n\n                if ($settings.unformatOnSubmit) {\n                    $this.val($settings.rawValue);\n                }\n            }\n        });\n    }\n\n    /**\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @returns {boolean|*}\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError(`The input type \"${$this.prop('type')}\" is not supported by autoNumeric`);\n        }\n\n        // Checks for non-supported tags\n        const currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError(`The <${currentElementTag}> tag is not supported by autoNumeric`);\n        }\n\n        return $input;\n    }\n\n    /**\n     * Routine to format the default value on page load\n     *\n     * @param {object} settings\n     * @param {object} $input jQuery-selected <input> element\n     * @param {object} $this jQuery-selected DOM element\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        let setValue = true;\n\n        if ($input) {\n            const currentValue = $this.val();\n            /*\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n             * precedence and should get formatted on init (if this input value is a valid number and that the\n             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n             *\n             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\n             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n             * we should ignore `defaultValueOverride` altogether.\n             */\n            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                const testedCurrentValue = parseFloat(currentValue.replace(',', '.'));\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                    $this.autoNumeric('set', testedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError(`The value [${currentValue}] used in the input is not a valid value autoNumeric can work with.`);\n                }\n            } else {\n                /* Checks for :\n                 * - page reload from back button, and\n                 * - ASP.net form post back\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                 */\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                if ((settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue) ||\n                    (settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value')) ||\n                    (currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(currentValue.replace(',', '.')))) {\n                    if ((settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage) ||\n                        (settings.scaleDivisor && settings.saveValueToSessionStorage)) {\n                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\n                    }\n\n                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n                    if (!settings.saveValueToSessionStorage) {\n                        let toStrip;\n\n                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                            settings.onOff = true;\n                            toStrip = toggleNegativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        settings.rawValue = ((settings.negativePositiveSignPlacement === 's' || (settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p')) && settings.negativeSignCharacter !== '' && contains(currentValue, '-'))?'-' + stripAllNonNumberCharacters(toStrip, settings, true):stripAllNonNumberCharacters(toStrip, settings, true);\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.emptyInputBehavior) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        $this.val(settings.currencySymbol);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default :\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.defaultValueOverride !== null) {\n                if (settings.defaultValueOverride === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\n     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\n     *\n     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\n     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\n     *\n     * @param {object} options\n     * @param {object} settings\n     */\n    function correctPNegOption(options, settings) {\n        //TODO Merge the options and settings parameter to use only `settings`\n        if (!isUndefined(options) && isUndefinedOrNullOrEmpty(options.negativePositiveSignPlacement) && options.currencySymbol !== '') {\n            switch (settings.currencySymbolPlacement) {\n                case 's':\n                    settings.negativePositiveSignPlacement = 'p';\n                    break;\n                case 'p':\n                    settings.negativePositiveSignPlacement = 'r';\n                    break;\n                default :\n                //\n            }\n        }\n    }\n\n    /**\n     * Analyze and save the minimumValue and maximumValue integer size for later uses\n     *\n     * @param {object} settings\n     */\n    function calculateVMinAndVMaxIntegerSizes(settings) {\n        let [maximumValueIntegerPart] = settings.maximumValue.toString().split('.');\n        let [minimumValueIntegerPart] = (!settings.minimumValue && settings.minimumValue !== 0)?[]:settings.minimumValue.toString().split('.');\n        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\n        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n    }\n\n    /**\n     * Modify `decimalPlacesOverride` as needed\n     *\n     * @param {object} settings\n     */\n    function correctMDecOption(settings) {\n        if (!isNull(settings.scaleDivisor) && !isNull(settings.scaleDecimalPlaces)) {\n            // Override the maximum number of decimal places with the one defined with the number of decimals to show when not in focus, if set\n            settings.decimalPlacesOverride = settings.scaleDecimalPlaces;\n        }\n        else if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n        settings.oDec = String(settings.decimalPlacesOverride);\n\n        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n    }\n\n    /**\n     * Sets the alternative decimal separator key.\n     *\n     * @param {object} settings\n     */\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\n        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n                settings.decimalCharacterAlternative = ',';\n            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n                settings.decimalCharacterAlternative = '.';\n            }\n        }\n    }\n\n    /**\n     * Caches regular expressions for stripAllNonNumberCharacters\n     *\n     * @param {object} settings\n     */\n    function cachesUsualRegularExpressions(settings) {\n        const aNegReg = settings.negativeSignCharacter?`([-\\\\${settings.negativeSignCharacter}]?)`:'(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(`${aNegReg}[^-${(settings.negativeSignCharacter?`\\\\${settings.negativeSignCharacter}`:'')}\\\\${settings.decimalCharacter}\\\\d].*?(\\\\d|\\\\${settings.decimalCharacter}\\\\d)`);\n        settings.skipLastAutoStrip = new RegExp(`(\\\\d\\\\${settings.decimalCharacter}?)[^\\\\${settings.decimalCharacter}\\\\d]\\\\D*$`);\n\n        const allowed = `-0123456789\\\\${settings.decimalCharacter}`;\n        settings.allowedAutoStrip = new RegExp(`[^${allowed}]`, 'gi');\n        settings.numRegAutoStrip = new RegExp(`${aNegReg}(?:\\\\${settings.decimalCharacter}?(\\\\d+\\\\${settings.decimalCharacter}\\\\d+)|(\\\\d*(?:\\\\${settings.decimalCharacter}\\\\d*)?))`);\n\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n        settings.stripReg = new RegExp(`^${settings.aNegRegAutoStrip}0*(\\\\d)`);\n    }\n\n    /**\n     * Modify the user settings to make them 'exploitable' later.\n     *\n     * @param {object} settings\n     */\n    function transformOptionsValuesToDefaultTypes(settings) {\n        $.each(settings, (key, value) => {\n            // Convert the string 'true' and 'false' to real Boolean\n            if (value === 'true' || value === 'false') {\n                settings[key] = value === 'true';\n            }\n\n            // Convert numbers in options to strings\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n            if (typeof value === 'number' && key !== 'aScale') {\n                settings[key] = value.toString();\n            }\n        });\n    }\n\n    /**\n     * Convert the old settings options name to new ones.\n     *\n     * @param {object} options\n     */\n    function convertOldOptionsToNewOnes(options) {\n        //TODO Delete this function once the old options are not used anymore\n        const oldOptionsConverter = {\n            // Old option name, with their corresponding new option\n            aSep                         : 'digitGroupSeparator',\n            nSep                         : 'noSeparatorOnFocus',\n            dGroup                       : 'digitalGroupSpacing',\n            aDec                         : 'decimalCharacter',\n            altDec                       : 'decimalCharacterAlternative',\n            aSign                        : 'currencySymbol',\n            pSign                        : 'currencySymbolPlacement',\n            pNeg                         : 'negativePositiveSignPlacement',\n            aSuffix                      : 'suffixText',\n            oLimits                      : 'overrideMinMaxLimits',\n            vMax                         : 'maximumValue',\n            vMin                         : 'minimumValue',\n            mDec                         : 'decimalPlacesOverride',\n            eDec                         : 'decimalPlacesShownOnFocus',\n            scaleDecimal                 : 'scaleDecimalPlaces',\n            aStor                        : 'saveValueToSessionStorage',\n            mRound                       : 'roundingMethod',\n            aPad                         : 'allowDecimalPadding',\n            nBracket                     : 'negativeBracketsTypeOnBlur',\n            wEmpty                       : 'emptyInputBehavior',\n            lZero                        : 'leadingZero',\n            aForm                        : 'formatOnPageLoad',\n            sNumber                      : 'selectNumberOnly',\n            anDefault                    : 'defaultValueOverride',\n            unSetOnSubmit                : 'unformatOnSubmit',\n            outputType                   : 'outputFormat',\n            debug                        : 'showWarnings',\n            // Current options :\n            digitGroupSeparator          : true,\n            noSeparatorOnFocus           : true,\n            digitalGroupSpacing          : true,\n            decimalCharacter             : true,\n            decimalCharacterAlternative  : true,\n            currencySymbol               : true,\n            currencySymbolPlacement      : true,\n            negativePositiveSignPlacement: true,\n            suffixText                   : true,\n            overrideMinMaxLimits         : true,\n            maximumValue                 : true,\n            minimumValue                 : true,\n            decimalPlacesOverride        : true,\n            decimalPlacesShownOnFocus    : true,\n            scaleDivisor                 : true,\n            scaleDecimalPlaces           : true,\n            scaleSymbol                  : true,\n            saveValueToSessionStorage    : true,\n            onInvalidPaste               : true,\n            roundingMethod               : true,\n            allowDecimalPadding          : true,\n            negativeBracketsTypeOnBlur   : true,\n            emptyInputBehavior           : true,\n            leadingZero                  : true,\n            formatOnPageLoad             : true,\n            selectNumberOnly             : true,\n            defaultValueOverride         : true,\n            unformatOnSubmit             : true,\n            outputFormat                 : true,\n            showWarnings                 : true,\n            failOnUnknownOption          : true,\n            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n            onOff                : true,\n            runOnce              : true,\n            rawValue             : true,\n            trailingNegative     : true,\n            caretFix             : true,\n            throwInput           : true,\n            strip                : true,\n            tagList              : true,\n            negativeSignCharacter: true,\n            mIntPos              : true,\n            mIntNeg              : true,\n            oDec                 : true,\n            oPad                 : true,\n            oBracket             : true,\n            oSep                 : true,\n            oSign                : true,\n            oSuffix              : true,\n            aNegRegAutoStrip     : true,\n            skipFirstAutoStrip   : true,\n            skipLastAutoStrip    : true,\n            allowedAutoStrip     : true,\n            numRegAutoStrip      : true,\n            stripReg             : true,\n            holder               : true,\n        };\n\n        for (const option in options) {\n            if (options.hasOwnProperty(option)) {\n                if (oldOptionsConverter[option] === true) {\n                    // If the option is a 'new' option, we continue looping\n                    continue;\n                }\n\n                if (oldOptionsConverter.hasOwnProperty(option)) {\n                    // Else we have an 'old' option name\n                    warning(`You are using the deprecated option name '${option}'. Please use '${oldOptionsConverter[option]}' instead from now on. The old option name will be dropped soon.`, true);\n\n                    // Then we modify the initial option object to use the new options instead of the old ones\n                    options[oldOptionsConverter[option]] = options[option];\n                    delete options[option];\n                } else if (options.failOnUnknownOption) {\n                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n                    throwError(`Option name '${option}' is unknown. Please fix the options passed to autoNumeric`);\n                }\n            }\n        }\n    }\n\n    /**\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\n     *\n     * @param {object} options\n     * @param {object} $this jQuery-selected DOM element\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\n     * @returns {object|null}\n     */\n    function getInitialSettings(options, $this, update = false) {\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        let settings = $this.data('autoNumeric');\n\n        // If the user used old options, we convert them to new ones\n        if (update || !isNull(options)) {\n            convertOldOptionsToNewOnes(options);\n        }\n\n        if (update || isUndefined(settings)) {\n            if (update) {\n                // The settings are updated\n                settings = $.extend(settings, options);\n            } else {\n                // If we couldn't grab any settings create them from the default ones and combine them with the options passed\n                // The settings are generated for the first time\n                // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n                const tagData = $this.data();\n                settings = $.extend({}, defaultSettings, tagData, options, {\n                    onOff           : false,\n                    runOnce         : false,\n                    rawValue        : '',\n                    trailingNegative: false,\n                    caretFix        : false,\n                    throwInput      : true, // Throw input event\n                    strip           : true,\n                    tagList         : allowedTagList,\n                });\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            transformOptionsValuesToDefaultTypes(settings);\n\n            // Improve the `negativePositiveSignPlacement` option if needed\n            correctPNegOption(options, settings);\n\n            // Set the negative sign if needed\n            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n\n            // Additional changes to the settings object (from the original autoCode() function)\n            runCallbacksFoundInTheSettingsObject($this, settings);\n            calculateVMinAndVMaxIntegerSizes(settings);\n            correctMDecOption(settings);\n            setsAlternativeDecimalSeparatorCharacter(settings);\n            cachesUsualRegularExpressions(settings);\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n            keepAnOriginalSettingsCopy(settings);\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    const methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\n         *\n         * @param {object} options\n         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\n         */\n        init(options) {\n            return this.each(function() {\n                const $this = $(this);\n                const $input = getInputIfSupportedTagAndType($this);\n\n                const settings = getInitialSettings(options, $this, false);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // Create the AutoNumericHolder object that store the field properties\n                const holder = getAutoNumericHolder($this, settings, false);\n\n                if (!settings.runOnce && settings.formatOnPageLoad) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    this.addEventListener('focusin', e => { onFocusInAndMouseEnter($this, holder, e); }, false);\n                    this.addEventListener('mouseenter', e => { onFocusInAndMouseEnter($this, holder, e); }, false);\n                    this.addEventListener('focusout', e => { onFocusOutAndMouseLeave($this, holder, e); }, false);\n                    this.addEventListener('mouseleave', e => { onFocusOutAndMouseLeave($this, holder, e); }, false);\n                    this.addEventListener('keydown', e => { onKeydown(holder, e); }, false);\n                    this.addEventListener('keypress', e => { onKeypress(holder, e); }, false);\n                    this.addEventListener('keyup', e => { onKeyup(holder, settings, e); }, false);\n                    this.addEventListener('blur', e => { onBlur(holder, e); }, false);\n                    this.addEventListener('paste', e => { onPaste($this, holder, e); }, false);\n                    onSubmit($this, holder); //TODO Switch to `addEventListener'\n                }\n            });\n        },\n\n        /**\n         * Method to stop and remove autoNumeric for the current element.\n         * Note: this does not remove the formatting.\n         *\n         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\n         *\n         * @returns {*|jQuery}\n         */\n        destroy() {\n            return $(this).each(function() {\n                const $this = getCurrentElement(this);\n                const settings = $this.data('autoNumeric');\n                if (typeof settings === 'object') {\n                    $this.val('');\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n        /**\n         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\n         *\n         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\n         *\n         * @returns {*|jQuery}\n         */\n        wipe() {\n            return $(this).each(function() {\n                const $this = getCurrentElement(this);\n                const settings = $this.data('autoNumeric');\n                if (typeof settings === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                }\n            });\n        },\n\n        /**\n         * Method that updates the autoNumeric settings.\n         * It can be called multiple times if needed.\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '}).\n         *\n         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\n         *\n         * @param {object} options\n         * @returns {*|jQuery}\n         */\n        update(options) {\n            return $(this).each(function() {\n                const $this = getCurrentElement(this);\n                const strip = $this.autoNumeric('get');\n                const settings = getInitialSettings(options, $this, true);\n\n                // Update the AutoNumericHolder object that store the field properties\n                getAutoNumericHolder($this, settings, true);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n        /**\n         * Method to format the value passed as a parameter.\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         *\n         * @example $(someSelector).autoNumeric('set', 'value'); // Formats the value being passed as the second parameter\n         *\n         * @param {*} newValue\n         * @returns {*|jQuery}\n         */\n        set(newValue) {\n            return $(this).each(function() {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                const $this = getCurrentElement(this);\n                const settings = $this.data('autoNumeric');\n                const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                let value = newValue.toString();\n                if (typeof settings !== 'object') {\n                    throwError(`Initializing autoNumeric is required prior to calling the \"set\" method`);\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!isNumber(Number(value))) {\n                    warning(`The value \"${value}\" being \"set\" is not numeric and therefore cannot be used appropriately.`, settings.showWarnings);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    const [minTest, maxTest] = checkIfInRangeWithOverrideOption(value, settings);\n                    if (minTest && maxTest) {\n                        if ($input && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.decimalPlacesOverride = (settings.scaleDecimalPlaces) ? settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n                            }\n\n                            value = roundValue(value, settings);\n                            if (settings.decimalPlacesShownOnFocus === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n\n                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                            value = addGroupSeparators(value, settings);\n                        }\n\n                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            saveValueToPersistentStorage($this[0], settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        saveValueToPersistentStorage($this[0], settings, 'wipe');\n                        const attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError(`The value [${attemptedValue}] being set falls outside of the minimumValue [${settings.minimumValue}] and maximumValue [${settings.maximumValue}] range set for this element`);\n\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return $this.val(value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n        /**\n         * Method to un-format inputs.\n         * This is handy to use right before form submission.\n         *\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\n         * Please see option \"outputFormat\" for more details\n         *\n         * @example $(someSelector).autoNumeric('unSet');\n         *\n         * @returns {*|jQuery}\n         */\n        unSet() {\n            return $(this).each(function() {\n                const $this = getCurrentElement(this);\n                const settings = $this.data('autoNumeric');\n                if (typeof settings === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n        /**\n         * Method to re-format inputs.\n         * This is handy to use right after form submission.\n         *\n         * This is called after the 'unSet' method to reformat the input\n         *\n         * @example $(someSelector).autoNumeric('reSet');\n         *\n         * @returns {*|jQuery}\n         */\n        reSet() {\n            return $(this).each(function() {\n                const $this = getCurrentElement(this);\n                const settings = $this.data('autoNumeric');\n                if (typeof settings === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n        /**\n         * Return the unformatted value as a string.\n         *\n         * @usage $(someSelector).autoNumeric('get');\n         *\n         * @returns {string}\n         */\n        get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            const $this = getCurrentElement(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            const $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            const settings = $this.data('autoNumeric');\n            if (typeof settings !== 'object') {\n                throwError(`Initializing autoNumeric is required prior to calling the \"get\" method.`);\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            let value = '';\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError(`The \"<${$this.prop('tagName').toLowerCase()}>\" tag is not supported by autoNumeric`);\n            }\n\n            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!((/\\d/).test(value) || Number(value) === 0) && settings.emptyInputBehavior === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n                    settings.onOff = true;\n                    value = toggleNegativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.formatOnPageLoad === false) {\n                    value = stripAllNonNumberCharacters(value, settings, true);\n                }\n\n                value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n            }\n\n            // Always return a numeric string\n            return value;\n        },\n\n        /**\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n         * - a plain number (if the setting 'number' is used).\n         *\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n         * Check the \"outputFormat\" option definition for more details.\n         *\n         * @returns {*}\n         */\n        getLocalized() {\n            const $this = getCurrentElement(this);\n            let value = $this.autoNumeric('get');\n            const settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputFormat);\n        },\n\n        /**\n         * Return the input unformatted value as a number.\n         *\n         * @returns {number}\n         */\n        getNumber() {\n            const $this = getCurrentElement(this);\n            const value = $this.autoNumeric('get');\n\n            return toLocale(value, 'number');\n        },\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         *\n         * @returns {string}\n         */\n        getString() {\n            return _getStringOrArray(false, this);\n        },\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         *\n         * @returns {{}|[]}\n         */\n        getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n        /**\n         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\n         *\n         * @example\n         * $(someSelector).autoNumeric('getSettings');\n         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\n         *\n         * @returns {object}\n         */\n        getSettings() {\n            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\n            return this.data('autoNumeric');\n        },\n    };\n\n    /**\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n     * It initialize autoNumeric on the given element.\n     *\n     * @param {string} method The method name (ie. 'set', 'get', etc.)\n     * @param {*} args\n     * @returns {*}\n     */\n    $.fn.autoNumeric = function(method, ...args) {\n        if (methods[method]) {\n            return methods[method].apply(this, args);\n        }\n\n        if (typeof method === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError(`Method \"${method}\" is not supported by autoNumeric`);\n    };\n\n    /**\n     * Return the default autoNumeric settings.\n     *\n     * @returns {object}\n     */\n    getDefaultConfig = () => defaultSettings;\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\n     * Public function that allows formatting without an element trigger.\n     *\n     * @param {number} value\n     * @param {object} options\n     * @returns {*}\n     */\n    autoFormat = (value, options) => {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Check the validity of the `value` parameter\n        if (!isNumber(value)) {\n            throwError(`A number is needed to be able to format it, [${value}] given.`);\n        }\n\n        // Initiate a very basic settings object\n        const settings = $.extend({}, defaultSettings, { strip: false }, options);\n        if (value < 0) {\n            settings.negativeSignCharacter = '-';\n        }\n        let valueString = value.toString();\n        valueString = fromLocale(valueString);\n\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n\n        // Basic tests to check if the given valueString is valid\n        const [minTest, maxTest] = checkIfInRangeWithOverrideOption(valueString, settings);\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            triggerEvent('autoFormat.autoNumeric', document, `Range test failed`);\n            throwError(`The value [${valueString}] being set falls outside of the minimumValue [${settings.minimumValue}] and maximumValue [${settings.maximumValue}] range set for this element`);\n        }\n\n        // Everything is ok, proceed to rounding, formatting and grouping\n        valueString = roundValue(valueString, settings);\n        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n        valueString = addGroupSeparators(valueString, settings);\n\n        return valueString;\n    };\n\n    $.fn.autoFormat = autoFormat; // The jQuery export\n\n    /**\n     * Public function that allows unformatting without an element.\n     *\n     * @param {string|number} value\n     * @param {object} options\n     * @returns {*}\n     */\n    autoUnFormat = (value, options) => {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n        if (isNumber(value)) {\n            return Number(value);\n        }\n\n        if (isArray(value) || isObject(value)) { //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n            // Check the validity of the `value` parameter\n            throwError(`A number or a string representing a number is needed to be able to unformat it, [${value}] given.`);\n        }\n\n        const settings = $.extend({}, defaultSettings, { strip: false }, options);\n        const allowed = `-0123456789\\\\${settings.decimalCharacter}`;\n        const autoStrip = new RegExp(`[^${allowed}]`, 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.negativeSignCharacter = '-';\n        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n            settings.negativeSignCharacter = '-';\n            settings.onOff = true;\n            value = toggleNegativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        value = toLocale(value, settings.outputFormat);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = (userOptions, shouldExtendDefaultOptions = true) => {\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError(`The userOptions are invalid ; it should be a valid object, [${userOptions}] given.`);\n        }\n\n        // If the user used old options, we convert them to new ones\n        if (!isNull(userOptions)) {\n            convertOldOptionsToNewOnes(userOptions);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        let options;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        // First things first, we test that the `showWarnings` option is valid\n        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n            throwError(`The debug option 'showWarnings' is invalid ; it should be either 'false' or 'true', [${options.showWarnings}] given.`);\n        }\n\n        // Define the regular expressions needed for the following tests\n        const testPositiveInteger = /^[0-9]+$/;\n        const testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        const testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        const testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.digitGroupSeparator, [',', '.', ' ', '', \"'\"])) {\n            throwError(`The thousand separator character option 'digitGroupSeparator' is invalid ; it should be ',', '.', ' ', \"'\" or empty (''), [${options.digitGroupSeparator}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n            throwError(`The 'noSeparatorOnFocus' option is invalid ; it should be either 'false' or 'true', [${options.noSeparatorOnFocus}] given.`);\n        }\n\n        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n            throwError(`The digital grouping for thousand separator option 'digitalGroupSpacing' is invalid ; it should be a positive integer, [${options.digitalGroupSpacing}] given.`);\n        }\n\n        if (!isInArray(options.decimalCharacter, [',', '.'])) {\n            throwError(`The decimal separator character option 'decimalCharacter' is invalid ; it should be '.' or ',', [${options.decimalCharacter}] given.`);\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.decimalCharacter === options.digitGroupSeparator) {\n            throwError(`autoNumeric will not function properly when the decimal character 'decimalCharacter' [${options.decimalCharacter}] and the thousand separator 'digitGroupSeparator' [${options.digitGroupSeparator}] are the same character.`);\n        }\n\n        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n            throwError(`The alternate decimal separator character option 'decimalCharacterAlternative' is invalid ; it should be a string, [${options.decimalCharacterAlternative}] given.`);\n        }\n\n        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n            throwError(`The currency symbol option 'currencySymbol' is invalid ; it should be a string, [${options.currencySymbol}] given.`);\n        }\n\n        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n            throwError(`The placement of the currency sign option 'currencySymbolPlacement' is invalid ; it should either be 'p' (prefix) or 's' (suffix), [${options.currencySymbolPlacement}] given.`);\n        }\n\n        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r'])) {\n            throwError(`The placement of the negative sign option 'negativePositiveSignPlacement' is invalid ; it should either be 'p' (prefix), 's' (suffix), 'l' (left) or 'r' (right), [${options.negativePositiveSignPlacement}] given.`);\n        }\n\n        if (!isString(options.suffixText) || (options.suffixText !== '' && (contains(options.suffixText, '-') || testNumericalCharacters.test(options.suffixText)))) {\n            throwError(`The additional suffix option 'suffixText' is invalid ; it should not contains the negative sign '-' nor any numerical characters, [${options.suffixText}] given.`);\n        }\n\n        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError(`The override min & max limits option 'overrideMinMaxLimits' is invalid ; it should either be 'ceiling', 'floor' or 'ignore', [${options.overrideMinMaxLimits}] given.`);\n        }\n\n        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n            throwError(`The maximum possible value option 'maximumValue' is invalid ; it should be a string that represents a positive or negative number, [${options.maximumValue}] given.`);\n        }\n\n        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n            throwError(`The minimum possible value option 'minimumValue' is invalid ; it should be a string that represents a positive or negative number, [${options.minimumValue}] given.`);\n        }\n\n        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n            throwError(`The minimum possible value option is greater than the maximum possible value option ; 'minimumValue' [${options.minimumValue}] should be smaller than 'maximumValue' [${options.maximumValue}].`);\n        }\n\n        if (!(isNull(options.decimalPlacesOverride) ||\n            (isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0) || // If integer option\n            (isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)))  // If string option\n        ) {\n            throwError(`The maximum number of decimal places option 'decimalPlacesOverride' is invalid ; it should be a positive integer, [${options.decimalPlacesOverride}] given.`);\n        }\n\n        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n        const vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n            warning(`Setting 'decimalPlacesOverride' to [${options.decimalPlacesOverride}] will override the decimals declared in 'minimumValue' [${options.minimumValue}] and 'maximumValue' [${options.maximumValue}].`, options.showWarnings);\n        }\n\n        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n            warning(`Setting 'allowDecimalPadding' to [false] will override the current 'decimalPlacesOverride' setting [${options.decimalPlacesOverride}].`, options.showWarnings);\n        }\n\n        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n            throwError(`The number of expanded decimal places option 'decimalPlacesShownOnFocus' is invalid ; it should be a positive integer, [${options.decimalPlacesShownOnFocus}] given.`);\n        }\n\n        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n            warning(`The extended decimal places 'decimalPlacesShownOnFocus' [${options.decimalPlacesShownOnFocus}] should be greater than the 'decimalPlacesOverride' [${options.decimalPlacesOverride}] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?`, options.showWarnings);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError(`The scale divisor option 'scaleDivisor' is invalid ; it should be a positive number, preferably an integer, [${options.scaleDivisor}] given.`);\n        }\n\n        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n            throwError(`The scale number of decimals option 'scaleDecimalPlaces' is invalid ; it should be a positive integer, [${options.scaleDecimalPlaces}] given.`);\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError(`The scale symbol option 'scaleSymbol' is invalid ; it should be a string, [${options.scaleSymbol}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n            throwError(`The save to session storage option 'saveValueToSessionStorage' is invalid ; it should be either 'false' or 'true', [${options.saveValueToSessionStorage}] given.`);\n        }\n\n        if (!isInArray(options.onInvalidPaste, [\n            'error',\n            'ignore',\n            'clamp',\n            'truncate',\n            'replace',\n        ])) {\n            throwError(`The paste behavior option 'onInvalidPaste' is invalid ; it should either be 'error', 'ignore', 'clamp', 'truncate' or 'replace' (cf. documentation), [${options.onInvalidPaste}] given.`);\n        }\n\n        if (!isInArray(options.roundingMethod, [\n            'S',\n            'A',\n            's',\n            'a',\n            'B',\n            'U',\n            'D',\n            'C',\n            'F',\n            'N05',\n            'CHF',\n            'U05',\n            'D05',\n        ])) {\n            throwError(`The rounding method option 'roundingMethod' is invalid ; it should either be 'S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05' or 'D05' (cf. documentation), [${options.roundingMethod}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n            throwError(`The control decimal padding option 'allowDecimalPadding' is invalid ; it should be either 'false' or 'true', [${options.allowDecimalPadding}] given.`);\n        }\n\n        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError(`The brackets for negative values option 'negativeBracketsTypeOnBlur' is invalid ; it should either be '(,)', '[,]', '<,>' or '{,}', [${options.negativeBracketsTypeOnBlur}] given.`);\n        }\n\n        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n            throwError(`The display on empty string option 'emptyInputBehavior' is invalid ; it should either be 'focus', 'press', 'always' or 'zero', [${options.emptyInputBehavior}] given.`);\n        }\n\n        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n            throwError(`The leading zero behavior option 'leadingZero' is invalid ; it should either be 'allow', 'deny' or 'keep', [${options.leadingZero}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n            throwError(`The format on initialization option 'formatOnPageLoad' is invalid ; it should be either 'false' or 'true', [${options.formatOnPageLoad}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n            throwError(`The select number only option 'selectNumberOnly' is invalid ; it should be either 'false' or 'true', [${options.selectNumberOnly}] given.`);\n        }\n\n        if (!isNull(options.defaultValueOverride) && (options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride))) {\n            throwError(`The unformatted default value option 'defaultValueOverride' is invalid ; it should be a string that represents a positive or negative number, [${options.defaultValueOverride}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n            throwError(`The remove formatting on submit option 'unformatOnSubmit' is invalid ; it should be either 'false' or 'true', [${options.unformatOnSubmit}] given.`);\n        }\n\n        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, [\n            'string',\n            'number',\n            '.',\n            '-.',\n            ',',\n            '-,',\n            '.-',\n            ',-',\n        ])) {\n            throwError(`The custom locale format option 'outputFormat' is invalid ; it should either be null, 'string', 'number', '.', '-.', ',', '-,', '.-' or ',-', [${options.outputFormat}] given.`);\n        }\n\n        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\n            throwError(`The debug option 'failOnUnknownOption' is invalid ; it should be either 'false' or 'true', [${options.failOnUnknownOption}] given.`);\n        }\n    };\n\n    $.fn.autoValidate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function(options) {\n        let isValid = true;\n        try {\n            validate(options);\n        }\n        catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Create a custom event and immediately sent it from the given element.\n     * By default, if no element is given, the event is thrown from `document`.\n     *\n     * @param {string} eventName\n     * @param {Element} element\n     * @param {object} detail\n     */\n    function triggerEvent(eventName, element = document, detail = null) {\n        let event;\n        if (window.CustomEvent) {\n            event = new CustomEvent(eventName, { detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n        } else {\n            event = document.createEvent('CustomEvent');\n            event.initCustomEvent(eventName, true, true, { detail });\n        }\n\n        element.dispatchEvent(event);\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function() {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void(0) };\n            const evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n}));\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexport default {\n    format  : autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig,\n    validate, // an.validate(options) : throws if necessary\n    areSettingsValid, //an.areSettingsValid(options) : return true or false //TODO Is this redundant? Should we let the developers wrap each autoNumeric.validate() calls in try/catch block? Or should we just facilitate their life by doing it already?\n\n    //TODO Complete the interface with functions having the following signatures :\n    //init         : an.init(options, input)\n    //get          : an.get(input)\n    //set          : an.set(value, input)\n    //formString   : an.formString(form)\n    //formArray    : an.formArray(form)\n    //getFormatted : an.getFormatted(input)\n    //unset        : an.unset(input) //to rename to 'unformat'? (and merge with autoUnFormat/unFormat?)\n    //reformat     : an.reformat(input) // 'reSet' is very to close to 'reset' and therefore should be renamed. We could still expose 'reSet', but add a @deprecated tag on its declaration.\n    //settings     : an.settings(input)\n    //update       : an.update(options, input)\n    //wipe         : an.wipe(input)\n    //destroy      : an.destroy(input)\n\n    //raw          : an.raw(input) // Return the unformatted value as a string\n    //number       : an.number(input) // Return the unformatted value as a number (Warning: This can lead to precision problems with big numbers)\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/autoNumeric.js","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"jQuery\",\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\"}\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}
