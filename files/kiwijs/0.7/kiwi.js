/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * The base class that is used when you are wanting to create a new Game. Handles the initialisation of all of the various individual game managers and holds the RAF which is used for the game loop.
    *
    * @class Game
    * @namespace Kiwi
    * @constructor
    * @param [domParent=''] {String} The ID of a DOM element that the game should use as its 'container'. If you are targeting Cocoon then you don't need to worry about this and can leave it blank.
    * @param [name='KiwiGame'] {String} The name of the game that is being created.
    * @param [state=null] {Any} The state to load initially. This can either be the name of a state, but preferably this would be the state object itself.
    * @param [options] {Object} Any special options for the game. E.g. Is DEBUG_ON or DEBUG_OFF, RENDERER_CANVAS or RENDERER_WEBGL, TARGET_BROWSER or TARGET_COCOON
    * @return {Game}
    *
    */
    var Game = (function () {
        function Game(domParent, name, state, options) {
            if (typeof domParent === "undefined") { domParent = ''; }
            if (typeof name === "undefined") { name = 'KiwiGame'; }
            if (typeof state === "undefined") { state = null; }
            if (typeof options === "undefined") { options = {}; }
            var _this = this;
            /**
            * [REQUIRES DESCRIPTION]
            * @property _dom
            * @type Bootstrap
            * @private
            */
            this._startup = null;
            /**
            * The audio manager that handles all of the audio in game. Inside you can globally mute the audio, create new sounds, e.t.c.
            * @property audio
            * @type AudioManager
            * @public
            */
            this.audio = null;
            /**
            * Used to get the coordinates of any DOM element on the game.
            * @property browser
            * @type Browser
            * @public
            */
            this.browser = null;
            /**
            * The global file store for this game. This handles the storage and access of information loaded, as well as tags that maybe set for them individual files.
            * @property fileStore
            * @type FileStore
            * @public
            */
            this.fileStore = null;
            /**
            * Handles any user input with the game. These could via the users keyboard, mouse or touch events.
            * @property input
            * @type InputManager
            * @public
            */
            this.input = null;
            /**
            * Manages the cameras the are on the stage. Single default Camera only in this version.
            * @property cameras
            * @type CameraManager
            * @public
            */
            this.cameras = null;
            /**
            * Manages plugins registration and initialisation for the game instance.
            * @property pluginManager
            * @type PluginManager
            * @public
            */
            this.pluginManager = null;
            /**
            * Loads files from outside sources and checks to see that they have loaded correctly or not.
            * @property loader
            * @type Loader
            * @public
            */
            this.loader = null;
            /**
            * The Request Animation Frame that is being used for the update and render loops.
            * @property raf
            * @type RequestAnimationFrame
            * @public
            */
            this.raf = null;
            /**
            * The ONLY stage that is being used for this game.
            * @property stage
            * @type Stage
            * @public
            */
            this.stage = null;
            /**
            * Manages all of the states that exist for this game. Via the manager you can create new states, switch states and do various other tasks.
            * @property states
            * @type StateManager
            * @public
            */
            this.states = null;
            /**
            * Holds a reference to the clocks that are being used and has a MASTER clock that is being used for the game.
            * @property time
            * @type ClockManager
            * @public
            */
            this.time = null;
            /**
            * The tween manager holds a reference to all of the tweens that are created and currently being used.
            * @property tweens
            * @type TweenManager
            * @public
            */
            this.tweens = null;
            /**
            * A Random Data Generator. This is useful for create unique ids and random information.
            * @property rnd
            * @type RandomDataGenerator
            * @public
            */
            this.rnd = null;
            /**
            * The framerate at which the game will update at.
            * @property _framerate
            * @type Number
            * @default 60
            * @public
            */
            this._frameRate = 60;
            /**
            * The interval between frames.
            * @property _interval
            * @type Number
            * @default 1000/60
            * @private
            */
            this._interval = 1000 / 60;
            /**
            * The current interval between frames.
            * @property _delta
            * @type number
            * @private
            */
            this._delta = 0;
            console.log(name + ' is being created.');

            //Have they specified debugging
            if (options.debug !== 'undefined' && typeof options.debug === 'number') {
                switch (options.debug) {
                    case Kiwi.DEBUG_ON:
                        this._debugOption = options.debug;
                        console.log('Debugging turned ON.');
                        break;
                    case Kiwi.DEBUG_OFF:
                        this._debugOption = options.debug;
                        console.log('Debugging turned OFF.');
                        break;
                    default:
                        this._debugOption = Kiwi.DEBUG_ON;
                        console.error('Debug option passed, but is not a valid option. Turned ON by default.');
                        break;
                }
            } else {
                this._debugOption = Kiwi.DEBUG_ON;
                console.log('Debug option not specified. Turned ON by default.');
            }

            if (options.bootCallback !== 'undefined') {
                console.log("boot callback provided");
                this.bootCallbackOption = options.bootCallback;
            }

            //Which device are they targetting
            if (options.deviceTarget !== 'undefined' && typeof options.deviceTarget === 'number') {
                switch (options.deviceTarget) {
                    case Kiwi.TARGET_BROWSER:
                        this._deviceTargetOption = options.deviceTarget;
                        console.log('Targeting BROWSERS.');
                        break;
                    case Kiwi.TARGET_COCOON:
                        this._deviceTargetOption = options.deviceTarget;
                        console.log('Targeting COCOONJS.');
                        break;
                    default:
                        this._deviceTargetOption = Kiwi.TARGET_BROWSER;
                        console.error('Target device specified, but is not a valid option. Defaulting to BROWSER.');
                        break;
                }
            } else {
                this._deviceTargetOption = Kiwi.TARGET_BROWSER;
                console.log('Targeted device not specified. Defaulting to BROWSER');
            }

            //What renderer are they using?
            if (options.renderer !== 'undefined' && typeof options.renderer === 'number') {
                switch (options.renderer) {
                    case Kiwi.RENDERER_CANVAS:
                        this._renderOption = options.renderer;
                        console.log('Rendering using CANVAS.');
                        break;
                    case Kiwi.RENDERER_WEBGL:
                        this._renderOption = options.renderer;
                        console.log('Rendering using WEBGL.');
                        break;
                    default:
                        this._renderOption = Kiwi.RENDERER_CANVAS;
                        console.log('Renderer specified, but is not a valid option. Defaulting to CANVAS.');
                        break;
                }
            } else {
                this._renderOption = Kiwi.RENDERER_CANVAS;
                console.log('Renderer not specified. Defaulting to CANVAS');
            }

            this.id = Kiwi.GameManager.register(this);
            this._startup = new Kiwi.System.Bootstrap();

            this.audio = new Kiwi.Sound.AudioManager(this);
            this.browser = new Kiwi.System.Browser(this);

            this.fileStore = new Kiwi.Files.FileStore(this);
            this.input = new Kiwi.Input.InputManager(this);

            this.stage = new Kiwi.Stage(this, name);

            if (this._renderOption === Kiwi.RENDERER_CANVAS) {
                this.renderer = new Kiwi.Renderers.CanvasRenderer(this);
            } else {
                this.renderer = new Kiwi.Renderers.GLRenderManager(this);
            }

            this.cameras = new Kiwi.CameraManager(this);

            if (this._deviceTargetOption !== Kiwi.TARGET_COCOON)
                this.huds = new Kiwi.HUD.HUDManager(this);
            this.loader = new Kiwi.Files.Loader(this);

            this.states = new Kiwi.StateManager(this);
            this.rnd = new Kiwi.Utils.RandomDataGenerator([Date.now.toString()]);
            this.time = new Kiwi.Time.ClockManager(this);
            this.tweens = new Kiwi.Animations.Tweens.TweenManager(this);

            //  If we have a state then pass it to the StateManager
            if (state !== null) {
                this.states.addState(state, true);
            } else {
                console.log('Default State not passed.');
            }

            this.pluginManager = new Kiwi.PluginManager(this, options.plugins);

            if (this.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                if (domParent !== '') {
                    if (document.getElementById(domParent))
                        console.log('Game being created inside ' + domParent + '.');
                    else
                        console.log('The element "' + domParent + '" could not be found. Appending the game to the body.');
                } else {
                    console.log('No DOM parent specified. Appending the game to the body.');
                }

                this._startup.boot(domParent, function () {
                    return _this.start();
                });
            } else {
                if (domParent !== '')
                    console.log('Not Targetting a BROWSER. DOM Parent parameter ignored.');

                this.start();
            }
        }
        Object.defineProperty(Game.prototype, "renderOption", {
            /**
            * Returns the render mode of the game. This is READ ONLY and is decided once the game gets initialised.
            * @property renderOption
            * @type number
            * @public
            */
            get: function () {
                return this._renderOption;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Game.prototype, "deviceTargetOption", {
            /**
            * Returns the device target option for the game. This is READ ONLY and is decided once the game gets initialised.
            * @property deviceTargetOption
            * @type number
            * @public
            */
            get: function () {
                return this._deviceTargetOption;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Game.prototype, "debugOption", {
            /**
            * Returns the debug option. This is READ ONLY and is decided once the game gets initialised.
            * @property debugOption
            * @type number
            * @public
            */
            get: function () {
                return this._debugOption;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Game.prototype, "debug", {
            /**
            * Returns true if debug option is set to Kiwi.DEBUG_ON
            * @property debug
            * @type boolean
            * @public
            */
            get: function () {
                return this._debugOption === Kiwi.DEBUG_ON;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * The type of object that the game is.
        * @method objType
        * @return {String} The type of object
        * @public
        */
        Game.prototype.objType = function () {
            return "Game";
        };

        Object.defineProperty(Game.prototype, "frameRate", {
            /**
            * The current frameRate that the update/render loops are running at. Note that this may not be an  accurate representation.
            * @property frameRate
            * @return string
            * @public
            */
            get: function () {
                return this._frameRate;
            },
            set: function (value) {
                //cannot exceed 60. The raf will stop this anyway.
                if (value > 60)
                    value = 60;

                if (value >= 0) {
                    this._frameRate = value;
                    this._interval = 1000 / this._frameRate;
                }
            },
            enumerable: true,
            configurable: true
        });

        /**
        * The start method gets executed when the game is ready to be booted, and handles the start-up of the managers.
        * Once the managers have started up the start loop will then begin to create the game loop.
        * @method start
        * @private
        */
        Game.prototype.start = function () {
            var _this = this;
            if (Kiwi.DEVICE === null) {
                Kiwi.DEVICE = new Kiwi.System.Device();
            }

            this.browser.boot();
            this.stage.boot(this._startup);
            this.renderer.boot();
            this.cameras.boot();
            if (this._deviceTargetOption !== Kiwi.TARGET_COCOON)
                this.huds.boot();

            this.time.boot();
            this.input.boot();
            this.audio.boot();

            this.fileStore.boot();
            this.loader.boot();
            this.states.boot();

            this.pluginManager.boot();

            this._lastTime = Date.now();

            this.raf = new Kiwi.Utils.RequestAnimationFrame(function () {
                return _this.loop();
            });
            this.raf.start();
            if (this.bootCallbackOption) {
                console.log("invoked boot callback");
                this.bootCallbackOption();
            }
        };

        /**
        * The loop that the whole game is using.
        * @method loop
        * @private
        */
        Game.prototype.loop = function () {
            this._delta = this.raf.currentTime - this._lastTime;
            if (this._delta > this._interval) {
                //Only update if there is a current state
                this.time.update();
                this.audio.update();
                this.input.update();
                this.tweens.update();
                this.cameras.update();
                if (this._deviceTargetOption !== Kiwi.TARGET_COCOON)
                    this.huds.update();
                this.states.update();
                this.pluginManager.update();

                if (this.states.current !== null) {
                    this.cameras.render();
                    this.states.postRender();
                }

                this._lastTime = this.raf.currentTime - (this._delta % this._interval);
            }
        };
        return Game;
    })();
    Kiwi.Game = Game;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * Each game contains a single Stage which controls the creation of the elements required for a Kiwi game to work.
    * Such as the Canvas and the rendering contexts, as well as the width/height of the game and the position it should be on the screen.
    *
    * @class Stage
    * @namespace Kiwi
    * @constructor
    * @param game {Kiwi.Game}
    * @param name {String}
    * @return {Stage} Kiwi.Stage
    *
    */
    var Stage = (function () {
        function Stage(game, name) {
            /**
            * Calculates and returns the amount that the container has been scale buy.
            * Mainly used for re-calculating input coordinates.
            * Note: For COCOONJS this returns 1 since COCOONJS translates the points itself.
            * This property is READ ONLY.
            * @property scale
            * @type Number
            * @default 1
            * @public
            */
            this._scale = 1;
            /**
            * A point which determines the offset of this Stage
            * @property offset
            * @type Point
            * @public
            */
            this.offset = new Kiwi.Geom.Point();
            /**
            * The parent div in which the layers and input live
            * @property container
            * @type HTMLDivElement
            * @public
            */
            this.container = null;
            this._game = game;

            this.name = name;

            this.domReady = false;

            //  Properties
            this._alpha = 1;

            this._x = 0;
            this._y = 0;

            this._width = Stage.DEFAULT_WIDTH;
            this._height = Stage.DEFAULT_HEIGHT;
            this.color = 'ffffff';

            this.onResize = new Kiwi.Signal();
        }
        /**
        * Returns the type of this object.
        * @method objType
        * @return string
        * @public
        */
        Stage.prototype.objType = function () {
            return "Stage";
        };

        Object.defineProperty(Stage.prototype, "alpha", {
            /**
            * Get the current alpha of the stage. 0 = invisible, 1 = fully visible.
            * @property alpha
            * @type number
            * @public
            */
            get: function () {
                return this._alpha;
            },
            set: function (value) {
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    this.container.style.opacity = String(Kiwi.Utils.GameMath.clamp(value, 1, 0));
                }

                // Doesnt work in cocoon
                this._alpha = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Stage.prototype, "x", {
            /**
            * The X coordinate of the stage. This number should be the same as the stages left property.
            * @property x
            * @type number
            * @public
            */
            get: function () {
                return this._x;
            },
            set: function (value) {
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    this.container.style.left = String(value + 'px');
                } else if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                    this.canvas.style.left = String(value + 'px');
                }
                this._x = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Stage.prototype, "y", {
            /**
            * Get the Y coordinate of the stage. This number should be the same as the stages top property.
            * @property y
            * @type number
            * @public
            */
            get: function () {
                return this._y;
            },
            set: function (value) {
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    this.container.style.top = String(value + 'px');
                } else if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                    this.canvas.style.top = String(value + 'px');
                }
                this._y = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Stage.prototype, "width", {
            /**
            * The width of the stage.
            * @property width
            * @type number
            * @public
            * @readonly
            */
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Stage.prototype, "height", {
            /**
            * The height of the stage
            * @property height
            * @type number
            * @public
            * @readonly
            */
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Stage.prototype, "scale", {
            get: function () {
                return this._scale;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Stage.prototype, "color", {
            /**
            * Get the background color of the stage. This returns a hex style color string such as "#ffffff"
            * @property color
            * @type string
            * @public
            */
            get: function () {
                return this._color;
            },
            set: function (val) {
                this._color = "#" + val;
                var bigint = parseInt(val, 16);
                var r = (bigint >> 16) & 255;
                var g = (bigint >> 8) & 255;
                var b = bigint & 255;
                this._normalizedColor = { r: r, g: g, b: b, a: 1 };
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Stage.prototype, "normalizedColor", {
            /**
            * Get the normalized background color of the stage. returns a object with rgba values between 0 and 1.
            * @property color
            * @type string
            * @public
            */
            get: function () {
                return this._normalizedColor;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * Is executed when the DOM has loaded and the game is just starting.
        * @method boot
        * @param {HTMLElement} dom
        * @public
        */
        Stage.prototype.boot = function (dom) {
            var _this = this;
            this.domReady = true;
            this.container = dom.container;

            if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                this.offset = this._game.browser.getOffsetPoint(this.container);
                this._x = this.offset.x;
                this._y = this.offset.y;
                this._width = this.container.clientWidth;
                this._height = this.container.clientHeight;

                window.addEventListener("resize", function (event) {
                    return _this._windowResized(event);
                }, true);
            }

            this._createCompositeCanvas();
            if (this._game.debugOption === Kiwi.DEBUG_ON) {
                //this._createDebugCanvas();
            }
        };

        /**
        * Method that is fired when the window is resized.
        * Used to calculate the new offset and see what the scale of the stage currently is.
        * @method _windowResized
        * @param event {UIEvent}
        * @private
        */
        Stage.prototype._windowResized = function (event) {
            this.offset = this._game.browser.getOffsetPoint(this.container);
            this._scale = this._width / this.container.clientWidth;
        };

        /**
        * [DESCRIPTION REQUIRED]
        * @method _createComponsiteCanvas
        * @private
        */
        Stage.prototype._createCompositeCanvas = function () {
            //If we are using cocoon then create a accelerated screen canvas
            if (this._game.deviceTargetOption == Kiwi.TARGET_COCOON) {
                this.canvas = document.createElement(navigator['isCocoonJS'] ? 'screencanvas' : 'canvas');
                //otherwise default to normal canvas
            } else {
                this.canvas = document.createElement("canvas");
            }

            this.canvas.id = this._game.id + "compositeCanvas";
            this.canvas.style.position = "absolute";
            this.canvas.width = this.width;
            this.canvas.height = this.height;

            //get 2d or gl context - should add in error checking here
            if (this._game.renderOption === Kiwi.RENDERER_CANVAS) {
                this.ctx = this.canvas.getContext("2d");
                this.ctx.fillStyle = '#fff';
                this.gl = null;
            } else if (this._game.renderOption === Kiwi.RENDERER_WEBGL) {
                this.gl = this.canvas.getContext("webgl");
                this.gl.clearColor(1, 1, .95, .7);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                this.ctx = null;
            }

            if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                this.container.appendChild(this.canvas);
            } else {
                document.body.appendChild(this.canvas);
            }
        };

        /**
        * Set the stage width and height
        * @method resize
        * @param width {number} new stage width
        * @param height {number} new stage height
        * @public
        */
        Stage.prototype.resize = function (width, height) {
            this.canvas.height = height;
            this.canvas.width = width;
            this._height = height;
            this._width = width;

            if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                this.container.style.height = String(height + 'px');
                this.container.style.width = String(width + 'px');
                this._scale = this._width / this.container.clientWidth;
            }

            this.onResize.dispatch(this._width, this._height);
        };

        /**
        * [DESCRIPTION REQUIRED]
        * @method _createDebugCanvas
        * @private
        */
        Stage.prototype._createDebugCanvas = function () {
            if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                //debug canvas not supported in cocoon, creating canvas and context anyway.
            }
            this.debugCanvas = document.createElement("canvas");
            this.debugCanvas.id = this._game.id + "debugCanvas";
            this.debugCanvas.style.position = "absolute";
            this.debugCanvas.style.display = "none";
            this.debugCanvas.width = this.width;
            this.debugCanvas.height = this.height;
            this.dctx = this.debugCanvas.getContext("2d");
            this.clearDebugCanvas();

            if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                this.container.appendChild(this.debugCanvas);
            }
        };

        /**
        * [DESCRIPTION REQUIRED]
        * @method clearDebugCanvas
        * @param [color='rgba(255,0,0,0.2)'] {string} debug color
        * @public
        */
        Stage.prototype.clearDebugCanvas = function (color) {
            this.dctx.fillStyle = color || "rgba(255,0,0,.2)";
            this.dctx.clearRect(0, 0, this.width, this.height);
            this.dctx.fillRect(0, 0, this.width, this.height);
        };

        /**
        * [DESCRIPTION REQUIRED]
        * @method toggleDebugCanvas
        * @public
        */
        Stage.prototype.toggleDebugCanvas = function () {
            this.debugCanvas.style.display = (this.debugCanvas.style.display === "none") ? "block" : "none";
        };
        Stage.DEFAULT_WIDTH = 800;

        Stage.DEFAULT_HEIGHT = 600;
        return Stage;
    })();
    Kiwi.Stage = Stage;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * The component manager is a class that is used to handle a number of components that are active on a particular object.
    * This way if you want to check to see if a particular component is on an object you can ask the component manager,
    * Or when updating components you can tell the component manager to update and all of the components will update as well.
    *
    * @class ComponentManager
    * @namespace Kiwi
    * @constructor
    * @param type {number} - The type of object that this component manager's owner is.
    * @param owner {IChild} - The owner of this component manager.
    * @return {ComponentManager}
    *
    */
    var ComponentManager = (function () {
        function ComponentManager(type, owner) {
            this._components = {};

            this._type = type;
            this._owner = owner;
        }
        /**
        * Returns the type of this object
        * @method objType
        * @return {string} The type of this object
        * @public
        */
        ComponentManager.prototype.objType = function () {
            return "ComponentManager";
        };

        /**
        * Returns true if this contains the component given, false otherwise.
        * @method hasComponent
        * @param value {String} the name of the component
        * @return {boolean} True if this component manager contains the given component, false otherwise.
        * @public
        */
        ComponentManager.prototype.hasComponent = function (value) {
            if (this._components[value]) {
                return true;
            }

            return false;
        };

        /**
        * Returns true if this contains the component given and the component is active, false otherwise.
        * @method hasActiveComponent
        * @param value {String} The name of the component.
        * @return {boolean} true if this manager contains the component and it is active, false otherwise.
        * @public
        */
        ComponentManager.prototype.hasActiveComponent = function (value) {
            if (this._components[value] && this._components[value].active === true) {
                return true;
            }

            return false;
        };

        /**
        * Get an existing component that has been added to the layer by its name
        * @method getComponent
        * @param value {String} The component name
        * @return {Component} The component, if found, otherwise null
        * @public
        */
        ComponentManager.prototype.getComponent = function (value) {
            if (this._components[value]) {
                return this._components[value];
            }

            return null;
        };

        /**
        * Adds a Component to the manager.
        * @method add
        * @param component {Component} The component to add
        * @return {Component} The component that was added
        * @public
        */
        ComponentManager.prototype.add = function (component) {
            this._components[component.name] = component;

            return component;
        };

        /**
        * Adds a batch of components to the manager at a single time.
        * @method addBatch
        * @param value* {Component} The component/s that you would like to add.
        * @public
        */
        ComponentManager.prototype.addBatch = function () {
            var paramsArr = [];
            for (var _i = 0; _i < (arguments.length - 0); _i++) {
                paramsArr[_i] = arguments[_i + 0];
            }
            for (var i = 0; i < paramsArr.length; i++) {
                this.add(paramsArr[i]);
            }
        };

        /**
        * Removes a component from the component manager
        * @method removeComponent
        * @param component {Component} The component to be removed.
        * @param [destroy=true] {boolean} If the destroy method is to be called on the component when it is removed.
        * @return {boolean} true if the component was removed successfully
        * @public
        */
        ComponentManager.prototype.removeComponent = function (component, destroy) {
            if (typeof destroy === "undefined") { destroy = true; }
            var name = component.name;

            if (this._components[name]) {
                if (destroy) {
                    this._components[name].destroy();
                }

                delete this._components[name];

                return true;
            }

            return false;
        };

        /**
        * Removes a component based on its name
        * @method removeComponentByName
        * @param name {String} The name of the component to be removed
        * @param [destroy=true] {boolean} If the destroy method is to be called on the component when it is removed.
        * @return {boolean} true if the component was removed successfully
        * @public
        */
        ComponentManager.prototype.removeComponentByName = function (name, destroy) {
            if (typeof destroy === "undefined") { destroy = true; }
            if (this._components[name]) {
                if (destroy) {
                    this._components[name].destroy();
                }

                delete this._components[name];

                return true;
            }

            return false;
        };

        /**
        * Removes all of the components from the component manager.
        * @method removeAll
        * @param [destroy=true] {boolean} If true will destroy all components
        * @public
        */
        ComponentManager.prototype.removeAll = function (destroy) {
            if (typeof destroy === "undefined") { destroy = true; }
            for (var key in this._components) {
                this.removeComponent(this._components[key], destroy);
            }
        };

        /**
        * Calls preUpdate on all active Components
        * @method preUpdate
        * @public
        */
        ComponentManager.prototype.preUpdate = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].preUpdate();
                }
            }
        };

        /**
        * Calls update on all active Components
        * @method update
        * @public
        */
        ComponentManager.prototype.update = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].update();
                }
            }
        };

        /**
        * Calls postUpdate on all active Components
        * @method postUpdate
        * @public
        */
        ComponentManager.prototype.postUpdate = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].postUpdate();
                }
            }
        };

        /**
        * Calls preRender on all active Components
        * @method preRender
        * @public
        */
        ComponentManager.prototype.preRender = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].preRender();
                }
            }
        };

        /**
        * Renders all active Components
        * @method render
        * @public
        */
        ComponentManager.prototype.render = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].render();
                }
            }
        };

        /**
        * Calls postRender on all active Components
        * @method postRender
        * @public
        */
        ComponentManager.prototype.postRender = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].postRender();
                }
            }
        };
        return ComponentManager;
    })();
    Kiwi.ComponentManager = ComponentManager;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    *
    * @class PluginManager
    * @namespace Kiwi
    * @constructor
    * @param game {Game} The state that this entity belongs to. Used to generate the Unique ID and for garbage collection.
    * @param plugins {string[]} The entities position on the x axis.
    * @return {PluginManager} This PluginManager.
    *
    */
    var PluginManager = (function () {
        function PluginManager(game, plugins) {
            console.log("creating PluginManager");
            this._game = game;
            this._plugins = plugins || new Array();
            this._bootObjects = new Array();
            this.validatePlugins();
            this._createPlugins();
        }
        Object.defineProperty(PluginManager, "availablePlugins", {
            /**
            * An array of objects represetning all available plugins, each containing the name and version number of an available plugin
            * @property getAvailablePlugins
            * @type Array
            * @static
            * @private
            */
            get: function () {
                var plugins = [];
                for (var i = 0; i < PluginManager._availablePlugins.length; i++) {
                    plugins.push({ name: PluginManager._availablePlugins[i].name, version: PluginManager._availablePlugins[i].version });
                }
                return plugins;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * Registers a plugin object as available. Any game instance can choose to use the plugin.
        * Plugins need only be registered once per webpage. If registered a second time it will be ignored.
        * Two plugins with the same names cannot be reigstered simultaneously, even if different versions.
        * @method register
        * @param {object} plugin
        * @public
        * @static
        */
        PluginManager.register = function (plugin) {
            console.log("Attempting to register plugin :" + plugin.name);
            if (this._availablePlugins.indexOf(plugin) == -1) {
                //check if plugin with same name is registered
                var uniqueName = true;
                for (var i = 0; i < this._availablePlugins.length; i++) {
                    if (plugin.name === this._availablePlugins[i].name) {
                        uniqueName = false;
                    }
                }

                if (uniqueName) {
                    this._availablePlugins.push(plugin);
                    console.log("Registered plugin " + plugin.name + ": version " + plugin.version);
                } else {
                    console.log("A plugin with the same name has already been registered. Ignoring this plugin.");
                }
            } else {
                console.log("This plugin has already been registered. Ignoring second registration.");
            }
        };

        Object.defineProperty(PluginManager.prototype, "objType", {
            /**
            * Identifies the object as a PluginManager.
            * @property objType
            * @type string
            * @public
            */
            get: function () {
                return "PluginManager";
            },
            enumerable: true,
            configurable: true
        });

        /**
        * Builds a list of valid plugins used by the game instance. Each plugin name that is supplied in the Kiwi.Game constructor configuration object
        * is checked against the Kiwi.Plugins namespace to ensure that a property of the same name exists.
        * This will ignore plugin that are registered but not used by the game instance.
        * @method validatePlugins
        * @public
        */
        PluginManager.prototype.validatePlugins = function () {
            var validPlugins = new Array();

            for (var i = 0; i < this._plugins.length; i++) {
                var plugin = this._plugins[i];
                if (typeof plugin == 'string' || plugin instanceof String) {
                    if (Kiwi.Plugins.hasOwnProperty(plugin) && this.pluginIsRegistered(plugin)) {
                        validPlugins.push(plugin);
                        console.log("Plugin '" + plugin + "' appears to be valid.");
                        console.log("Name:" + Kiwi.Plugins[plugin].name);
                        console.log("Version:" + Kiwi.Plugins[plugin].version);
                    } else {
                        console.log("Plugin '" + plugin + "' appears to be invalid. No property with that name exists on the Kiwi.Plugins object or the Plugin is not registered. Check that the js file containing the plugin has been included. This plugin will be ignored");
                    }
                } else {
                    console.log("The supplied plugin name at index " + i + "is not a string and will be ignored");
                }
            }
            this._plugins = validPlugins;
        };

        /**
        * Returns true if a plugin identified by the supplied pluginName is registered.
        * @method pluginIsRegistered
        * @param {string} pluginName
        * @public
        */
        PluginManager.prototype.pluginIsRegistered = function (pluginName) {
            var isRegistered = false;
            for (var i = 0; i < Kiwi.PluginManager._availablePlugins.length; i++) {
                if (Kiwi.PluginManager._availablePlugins[i].name === pluginName) {
                    isRegistered = true;
                }
            }
            return isRegistered;
        };

        /**
        * Called after all other core objects and services created by the Kiwi.Game constructor are created.
        * Attempts to find a "create" function on each plugin and calls it if it exists.
        * The create function may return an object on which a boot function exists - to be called during boot process.
        * @method _createPlugins
        * @private
        */
        PluginManager.prototype._createPlugins = function () {
            for (var i = 0; i < this._plugins.length; i++) {
                var plugin = this._plugins[i];
                if (Kiwi.Plugins[plugin].hasOwnProperty("create")) {
                    console.log("'Create' function found on plugin '" + plugin + "'");
                    var bootObject = Kiwi.Plugins[plugin].create(this._game);
                    if (bootObject)
                        this._bootObjects.push(bootObject);
                } else {
                    console.log("No 'Create' function found on plugin '" + plugin + "'");
                }
            }
        };

        /**
        * Calls the boot functions on any objects that plugins used by the game instance have designated during creation.
        * @method boot
        * @public
        */
        PluginManager.prototype.boot = function () {
            console.log("boot pluginmanager");
            for (var i = 0; i < this._bootObjects.length; i++) {
                console.log("Booting plugin " + i);
                if ("boot" in this._bootObjects[i]) {
                    this._bootObjects[i].boot.call(this._bootObjects[i]);
                } else {
                    console.log("Warning! No boot function found on boot object");
                }
            }
        };

        PluginManager.prototype.update = function () {
            for (var i = 0; i < this._bootObjects.length; i++) {
                if ("update" in this._bootObjects[i]) {
                    this._bootObjects[i].update.call(this._bootObjects[i]);
                }
            }
        };
        PluginManager._availablePlugins = new Array();
        return PluginManager;
    })();
    Kiwi.PluginManager = PluginManager;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * Used to handle the creation and management of Cameras on a Game. Each Game will always have created for it a CameraManager and a default Camera on the manager. More Cameras can always be created by used of the create method of a CameraManager.
    *
    * @class CameraManager
    * @namespace Kiwi
    * @constructor
    * @param {Game} game
    * @return {CameraManager}
    */
    var CameraManager = (function () {
        function CameraManager(game) {
            this._game = game;
            this._cameras = [];
            this._nextCameraID = 0;
        }
        /**
        * Returns the type of this object
        * @method objType
        * @return {String} The type of this object
        * @public
        */
        CameraManager.prototype.objType = function () {
            return "CameraManager";
        };

        /**
        * Initializes the CameraManager, creates a new camera and assigns it to the defaultCamera
        * @method boot
        * @public
        */
        CameraManager.prototype.boot = function () {
            this.create("defaultCamera", 0, 0, this._game.stage.width, this._game.stage.height);
            this.defaultCamera = this._cameras[0];
        };

        /**
        * Creates a new Camera and adds it to the collection of cameras.
        * @param {String} name. The name of the new camera.
        * @param {Number} x. The x position of the new camera.
        * @param {Number} y. The y position of the new camera.
        * @param {Number} width. The width of the new camera.
        * @param {Number} height. The height of the new camera.
        * @return {Camera} The new camera object.
        * @public
        */
        CameraManager.prototype.create = function (name, x, y, width, height) {
            var newCamera = new Kiwi.Camera(this._game, this._nextCameraID++, name, x, y, width, height);

            //newCamera.parent = state;
            this._cameras.push(newCamera);

            return newCamera;
        };

        /**
        * Removes the given camera, if it is present in the camera managers camera collection.
        * @method remove
        * @param camera {Camera}
        * @return {boolean} True if the camera was removed, false otherwise.
        * @public
        */
        CameraManager.prototype.remove = function (camera) {
            var i = this._cameras.indexOf(camera);

            if (i !== -1) {
                //  Send Layer a killed call
                this._cameras.splice(i, 1);
                return true;
            }

            return false;
        };

        /**
        * Calls update on all the cameras.
        * @method update
        * @public
        */
        CameraManager.prototype.update = function () {
            if (this._cameras.length === 0) {
                return false;
            }

            for (var i = 0; i < this._cameras.length; i++) {
                this._cameras[i].update();
            }
        };

        /**
        * Calls the render method on all the cameras
        * @method render
        * @public
        */
        CameraManager.prototype.render = function () {
            if (this._cameras.length === 0) {
                return false;
            }

            for (var i = 0; i < this._cameras.length; i++) {
                //render each layer
                //this._game.layers.render(this._cameras[i]);
                this._cameras[i].render();
            }
        };

        /**
        * Removes all cameras in the camera Manager except the default camera. Does nothing if in multi camera mode.
        * @method removeAll - note should not remove default
        * @public
        */
        CameraManager.prototype.removeAll = function () {
            this._cameras.length = 0; //are you sure.
        };
        return CameraManager;
    })();
    Kiwi.CameraManager = CameraManager;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * A lightweight object that contains values relating to the configuration of a State in a Kiwi Game.
    *
    * @class StateConfig
    * @namespace Kiwi
    * @constructor
    * @param {State} parent
    * @param {String} name
    * @return {StateConfig} This Object
    *
    */
    var StateConfig = (function () {
        function StateConfig(parent, name) {
            /**
            * The name of the State, must be unique within your game.
            * @property name
            * @type String
            * @public
            */
            this.name = '';
            /**
            * Currently unused.
            * @property isPersistent
            * @type boolean
            * @default false
            * @public
            */
            this.isPersistent = false;
            /**
            * If this State has been created (the create method has been executed).
            * Essentually has the same meaning as 'isReady'.
            * @property isCreated
            * @type boolean
            * @default false
            * @public
            */
            this.isCreated = false;
            /**
            * If the State has been initialised already (so the Boot and Init methods have been executed already).
            * A State only get Initialised once which is when it switched to for this first time.
            * @property isInitialised
            * @type boolean
            * @default false
            * @public
            */
            this.isInitialised = false;
            /**
            * If the State that this config is on is 'ready' to be used (e.g. all the assets have been loaded and libraries complied)
            * or if it isn't and so it is still at the 'loading' stage.
            * @property isReady
            * @type boolean
            * @default false
            * @public
            */
            this.isReady = false;
            /**
            * If the State that this config is on contains a Preloader Method.
            * @property hasPreloader
            * @type boolean
            * @default false
            * @public
            */
            this.hasPreloader = false;
            /**
            * The number of times the State that this config belongs to has been active/used.
            * @property runCount
            * @type Number
            * @default 0
            * @public
            */
            this.runCount = 0;
            /**
            * The type of state this is. Currently Unused.
            * @property type
            * @type Number
            * @default 0
            * @public
            */
            this.type = 0;
            this._state = parent;
            this.name = name;

            //If it has a preload method.
            //*cough* of course it does.
            if (typeof this._state['preload'] === 'function') {
                this.hasPreloader = true;
            }
        }
        /**
        * The type of object that this is.
        * @method objType
        * @return {String}
        * @public
        */
        StateConfig.prototype.objType = function () {
            return "StateConfig";
        };

        /**
        * Resets the properties contained on this StateConfig object.
        * This is executed when a State is about to be destroyed as so reset's it to be switched to again.
        * @method
        *
        */
        StateConfig.prototype.reset = function () {
            this.isReady = false;
            this.isCreated = false;
            this.createParams = [];
            this.initParams = [];
        };
        return StateConfig;
    })();
    Kiwi.StateConfig = StateConfig;
})(Kiwi || (Kiwi = {}));
/**
* Module - Kiwi (Core)
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * The state manager handles the starting, parsing, looping and swapping of game states. Thus there is only ever one state manager per game.
    *
    * @class StateManager
    * @namespace Kiwi
    * @constructor
    * @param game {Game} The game that this statemanager belongs to.
    * @return {StateMananger} This Object
    *
    */
    var StateManager = (function () {
        function StateManager(game) {
            /**
            * The current State that the game is at.
            * @property current
            * @type State
            * @default null
            * @public
            */
            this.current = null;
            /**
            * The name of the new state that is to be switched to.
            * @property _newStateKey
            * @type string
            * @defualt null
            * @private
            */
            this._newStateKey = null;
            this._game = game;

            this._states = [];
        }
        /**
        * The type of object this is.
        * @method objType
        * @return string
        * @public
        */
        StateManager.prototype.objType = function () {
            return "StateManager";
        };

        /**
        * Checks to see if a key exists. Internal use only.
        * @method checkKeyExists
        * @param key {String}
        * @return {boolean}
        * @private
        */
        StateManager.prototype.checkKeyExists = function (key) {
            for (var i = 0; i < this._states.length; i++) {
                if (this._states[i].config.name === key) {
                    return true;
                }
            }

            return false;
        };

        /**
        * Checks to see if the state passed is valid or not.
        * @method checkValidState
        * @param {State} state
        * @return {boolean}
        * @private
        */
        StateManager.prototype.checkValidState = function (state) {
            if (!state['game'] || !state['config']) {
                return false;
            }

            return true;
        };

        /**
        * Adds the given State to the StateManager.
        * The State must have a unique key set on it, or it will fail to be added to the manager.
        * Returns true if added successfully, otherwise false (can happen if State is already in the StateManager)
        *
        * @method addState
        * @param state {Any} The Kiwi.State instance to add.
        * @param [switchTo=false] {boolean} If set to true automatically switch to the given state after adding it
        * @return {boolean} true if the State was added successfully, otherwise false
        * @public
        */
        StateManager.prototype.addState = function (state, switchTo) {
            if (typeof switchTo === "undefined") { switchTo = false; }
            var tempState;

            //What type is the state that was passed.
            if (typeof state === 'function') {
                tempState = new state();
            } else if (typeof state === 'string') {
                tempState = window[state];
            } else {
                tempState = state;
            }

            //Does a state with that name already exist?
            if (tempState.config.name && this.checkKeyExists(tempState.config.name) === true) {
                if (this._game.debug)
                    console.error('Could not add ' + tempState.config.name + ' as a State with that name already exists.');

                return false;
            }

            tempState.game = this._game;

            //Is it a valid state?
            if (this.checkValidState(tempState) === false) {
                if (this._game.debug)
                    console.error(tempState.config.name + ' isn\'t a valid state. Make sure you are using the Kiwi.State class!');

                return false;
            } else {
                this._states.push(tempState);

                if (this._game.debug)
                    console.log(tempState.config.name + ' was successfully added.');

                if (switchTo === true) {
                    this.setCurrentState(tempState.config.name);
                }

                return true;
            }
        };

        /**
        * Is executed once the DOM has finished loading.
        * This is an INTERNAL Kiwi method.
        * @method boot
        * @public
        */
        StateManager.prototype.boot = function () {
        };

        /**
        * Switches to the name (key) of the state that you pass.
        * Does not work if the state you are switching to is already the current state OR if that state does not exist yet.
        * @method setCurrentState
        * @param {String} key
        * @return {boolean}
        * @private
        */
        StateManager.prototype.setCurrentState = function (key) {
            //  Bail out if they are trying to switch to the already current state
            if (this.current !== null && this.current.config.name === key || this.checkKeyExists(key) === false) {
                return false;
            }

            if (this._game.debug)
                console.log('Switching to ' + key + ' State.');

            this._newStateKey = key;
            return true;
        };

        /**
        * Actually switches to a state that is stored in the 'newStateKey' property. This method is executed after the update loops have been executed to help prevent developer errors.
        * @method bootNewState
        * @private
        */
        StateManager.prototype.bootNewState = function () {
            // Destroy the current if there is one.
            if (this.current !== null) {
                this.current.shutDown();

                this._game.input.reset(); //Reset the input component
                this.current.destroy(true); //Destroy ALL IChildren ever created on that state.
                this._game.fileStore.removeStateFiles(this.current); //Clear the fileStore of not global files.
                this.current.config.reset(); //Reset the config setting
            }

            //Set the current state, reset the key
            this.current = this.getState(this._newStateKey);
            this._newStateKey = null;

            //Initalise the state and execute the preload method?
            this.checkInit();
            this.checkPreload();
        };

        /**
        * Swaps the current state.
        * If the state has already been loaded (via addState) then you can just pass the key.
        * Otherwise you can pass the state object as well and it will load it then swap to it.
        *
        * @method switchState
        * @param key {String} The name/key of the state you would like to switch to.
        * @param [state=null] {Any} The state that you want to switch to. This is only used to create the state if it doesn't exist already.
        * @param [initParams=null] {Object} Any parameters that you would like to pass to the init method of that new state.
        * @param [createParams=null] {Object} Any parameters that you would like to pass to the create method of that new state.
        * @return {boolean}
        * @public
        */
        StateManager.prototype.switchState = function (key, state, initParams, createParams) {
            if (typeof state === "undefined") { state = null; }
            if (typeof initParams === "undefined") { initParams = null; }
            if (typeof createParams === "undefined") { createParams = null; }
            //  If we have a current state that isn't yet ready (preload hasn't finished) then abort now
            if (this.current !== null && this.current.config.isReady === false) {
                if (this._game.debug)
                    console.error('Cannot change to a new state till the current state has finished loading!');

                return false;
            }

            // If state key doesn't exist then lets add it.
            if (this.checkKeyExists(key) === false && state !== null) {
                if (this.addState(state, false) === false) {
                    return false;
                }
            }

            // Store the parameters (if any)
            if (initParams !== null || createParams !== null) {
                var newState = this.getState(key);
                newState.config.initParams = [];
                newState.config.createParams = [];

                for (var initParameter in initParams) {
                    newState.config.initParams.push(initParams[initParameter]);
                }

                for (var createParameter in createParams) {
                    newState.config.createParams.push(createParams[createParameter]);
                }
            }

            return this.setCurrentState(key);
        };

        /**
        * Gets a state by the key that is passed.
        * @method getState
        * @param {String} key
        * @return {State}
        * @private
        */
        StateManager.prototype.getState = function (key) {
            for (var i = 0; i < this._states.length; i++) {
                if (this._states[i].config.name === key) {
                    return this._states[i];
                }
            }

            return null;
        };

        /*
        *----------------
        * Check Methods
        *----------------
        */
        /**
        * Checks to see if the state that is being switched to needs to load some files or not.
        * If it does it loads the file, if it does not it runs the create method.
        * @method checkPreload
        * @private
        */
        StateManager.prototype.checkPreload = function () {
            var _this = this;
            //Rebuild the Libraries before the preload is executed
            this.rebuildLibraries();

            if (this.current.config.hasPreloader === true) {
                this._game.loader.init(function (percent, bytes, file) {
                    return _this.onLoadProgress(percent, bytes, file);
                }, function () {
                    return _this.onLoadComplete();
                });
                this.current.preload();
                this._game.loader.startLoad();
            } else {
                this.current.config.isReady = true;
                this.callCreate();
            }
        };

        /**
        * Checks to see if the state being switched to contains a create method.
        * If it does then it calls the create method.
        * @method callCreate
        * @private
        */
        StateManager.prototype.callCreate = function () {
            if (this._game.debug)
                console.log("Calling State:Create");

            //Execute the create with params if there are some there.
            if (this.current.config.createParams) {
                this.current.create.apply(this.current, this.current.config.createParams);
                //Otherwise just execute the method.
            } else {
                this.current.create.call(this.current);
            }

            this.current.config.runCount++;
            this.current.config.isCreated = true;
        };

        /**
        * Checks to see if the state has a init method and then executes that method if it is found.
        * @method checkInit
        * @private
        */
        StateManager.prototype.checkInit = function () {
            //Has the state already been initialised?
            if (this.current.config.isInitialised === false) {
                //Boot the state.
                this.current.boot();

                //Execute the Init method with params
                if (this.current.config.initParams) {
                    this.current.init.apply(this.current, this.current.config.initParams);
                    //Execute the Init method with out params
                } else {
                    this.current.init.call(this.current);
                }

                this.current.config.isInitialised = true;
            }
        };

        /**
        * Is execute whilst files are being loaded by the state.
        * @method onLoadProgress
        * @param {Number} percent
        * @param {Number} bytesLoaded
        * @param {File} file
        * @private
        */
        StateManager.prototype.onLoadProgress = function (percent, bytesLoaded, file) {
            this.current.loadProgress(percent, bytesLoaded, file);
        };

        /**
        * Executed when the preloading has completed. Then executes the loadComplete and create methods of the new state.
        * @method onLoadComplete
        * @private
        */
        StateManager.prototype.onLoadComplete = function () {
            this.current.loadComplete();

            if (this._game.debug) {
                console.log("Rebuilding Libraries");
            }

            //Rebuild the Libraries again to have access the new files that were loaded.
            this.rebuildLibraries();
            if (this._game.renderOption == Kiwi.RENDERER_WEBGL) {
                this._game.renderer.initState(this.current);
            }

            this.current.config.isReady = true;
            this.callCreate();
        };

        /**
        * Rebuilds the texture, audio and data libraries that are on the current state. Thus updating what files the user has access to.
        * @method rebuildLibraries
        * @private
        */
        StateManager.prototype.rebuildLibraries = function () {
            this.current.audioLibrary.rebuild(this._game.fileStore, this.current);
            this.current.dataLibrary.rebuild(this._game.fileStore, this.current);
            this.current.textureLibrary.rebuild(this._game.fileStore, this.current);
        };

        /**
        * The update loop that is accessable on the state manager.
        * @method update
        * @public
        */
        StateManager.prototype.update = function () {
            if (this.current !== null) {
                //Is the state ready?
                if (this.current.config.isReady === true) {
                    this.current.preUpdate();
                    this.current.update();
                    this.current.postUpdate();
                } else {
                    this.current.loadUpdate();
                }
            }

            //Do we need to switch states?
            if (this._newStateKey !== null) {
                this.bootNewState();
            }
        };

        /**
        * PostRender - Called after all of the rendering has been executed in a frame.
        * @method postRender
        * @public
        */
        StateManager.prototype.postRender = function () {
            if (this.current !== null) {
                if (this.current.config.isReady === true) {
                    this.current.postRender();
                }
            }
        };
        return StateManager;
    })();
    Kiwi.StateManager = StateManager;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * An Entity serves as a container for game objects to extend from and thus you should never directly instantiate this class.
    * Each Entity has a unique ID (UID) which is automatically generated upon instantiation.
    * Every entity requires that you pass to it the state that it belongs too, that way when you switch states the appropriate entitys can be deleted.
    *
    * @class Entity
    * @namespace Kiwi
    * @constructor
    * @param state {State} The state that this entity belongs to. Used to generate the Unique ID and for garbage collection.
    * @param x {Number} The entities position on the x axis.
    * @param y {Number} The entities position on the y axis.
    * @return {Entity} This entity.
    *
    */
    var Entity = (function () {
        function Entity(state, x, y) {
            /**
            * The group that this entity belongs to. If added onto the state then this is the state.
            * @property _parent
            * @type Group
            * @private
            */
            this._parent = null;
            /**
            * The actual alpha of this entity.
            * @property _alpha
            * @type Number
            * @private
            */
            this._alpha = 1;
            /**
            * A boolean that indicates whether or not this entity is visible or not. Note that is does not get set to false if the alpha is 0.
            * @property _visible
            * @type boolean
            * @default true
            * @private
            */
            this._visible = true;
            /**
            * The width of the entity in pixels.
            * @property width
            * @type number
            * @default 0
            * @public
            */
            this.width = 0;
            /**
            * The height of the entity in pixels.
            * @property height
            * @type number
            * @default 0
            * @public
            */
            this.height = 0;
            /**
            * Used as a reference to a single Cell in the atlas that is to be rendered.
            * E.g. If you had a spritesheet with 3 frames/cells and you wanted the second frame to be displayed you would change this value to 1
            * @property cellIndex
            * @type number
            * @default 0
            * @public
            */
            this.cellIndex = 0;
            /**
            * A name for this Entity. This is not checked for uniqueness within the Game, but is very useful for debugging
            * @property name
            * @type string
            * @default ''
            * @public
            */
            this.name = '';
            /**
            * The clock that this entity use's for time based calculations. This generated by the state on instatiation.
            * @property _clock
            * @type Clock
            * @private
            */
            this._clock = null;
            //  Properties
            this.state = state;
            this.game = state.game;
            this.id = this.game.rnd.uuid();
            this.state.addToTrackingList(this);
            this._clock = this.game.time.clock;

            this._exists = true;
            this._active = true;
            this._willRender = true;
            this.components = new Kiwi.ComponentManager(Kiwi.ENTITY, this);
            this.transform = new Kiwi.Geom.Transform();
            this.transform.x = x;
            this.transform.y = y;
        }
        Object.defineProperty(Entity.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            /**
            * The group that this entity belongs to/is a child of once added to one. If added onto the state then this is the state.
            * @property parent
            * @type Group
            * @param val {Group}
            * @public
            */
            set: function (val) {
                this.transform.parent = (val !== null) ? val.transform : null;
                this._parent = val;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "x", {
            /**
            * X coordinate of this Entity. This is just aliased to the transform property.
            * @property x
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.x;
            },
            set: function (value) {
                this.transform.x = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "y", {
            /**
            * Y coordinate of this Entity. This is just aliased to the transform property.
            * @property y
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.y;
            },
            set: function (value) {
                this.transform.y = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Entity.prototype, "scaleX", {
            /**
            * Scale X of this Entity. This is just aliased to the transform property.
            * @property scaleX
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.scaleX;
            },
            set: function (value) {
                this.transform.scaleX = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "scaleY", {
            /**
            * Scale Y coordinate of this Entity. This is just aliased to the transform property.
            * @property scaleY
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.scaleY;
            },
            set: function (value) {
                this.transform.scaleY = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Entity.prototype, "rotation", {
            /**
            * Rotation of this Entity. This is just aliased to the transform property.
            * @property rotation
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.rotation;
            },
            set: function (value) {
                this.transform.rotation = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "rotPointX", {
            /**
            * The rotation point on the x-axis. This is just aliased to the rotPointX on the transform object.
            * @property rotPointX
            * @type number
            * @public
            */
            get: function () {
                return this.transform.rotPointX;
            },
            set: function (value) {
                this.transform.rotPointX = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "rotPointY", {
            /**
            * The rotation point on the y-axis. This is just aliased to the rotPointY on the transform object.
            * @property rotPointY
            * @type number
            * @public
            */
            get: function () {
                return this.transform.rotPointY;
            },
            set: function (value) {
                this.transform.rotPointY = value;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * Returns the type of child that this is.
        * @type Number
        * @return {Number} returns the type of child that the entity is
        * @public
        */
        Entity.prototype.childType = function () {
            return Kiwi.ENTITY;
        };


        Object.defineProperty(Entity.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            /**
            * Alpha of this entity. A number between 0 (invisible) and 1 (completely visible).
            * @property alpha
            * @type Number
            * @public
            */
            set: function (value) {
                if (value <= 0)
                    value = 0;
                if (value > 1)
                    value = 1;
                this._alpha = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            /**
            * Set the visiblity of this entity. True or False.
            * @property visibility
            * @type boolean
            * @default true
            * @public
            */
            set: function (value) {
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "exists", {
            get: function () {
                return this._exists;
            },
            /**
            * Toggles the existence of this Entity. An Entity that no longer exists can be garbage collected or re-allocated in a pool.
            * @property exists
            * @type boolean
            * @public
            */
            set: function (value) {
                this._exists = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "active", {
            get: function () {
                return this._active;
            },
            /**
            * Toggles the active state of this Entity. An Entity that is active has its update method called by its parent.
            * This method should be over-ridden to handle specific dom/canvas/webgl implementations.
            * @property active
            * @type boolean
            * @public
            */
            set: function (value) {
                this._active = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "willRender", {
            get: function () {
                return this._willRender;
            },
            /**
            * Toggles if this Entity will be rendered by a canvas layer. Use the visibile component for DOM layers.
            * @property willRender
            * @type boolean
            * @default true
            * @public
            */
            set: function (value) {
                this._willRender = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "inputEnabled", {
            get: function () {
                return this._inputEnabled;
            },
            /**
            * Controls if this Entity is input enabled or not (i.e. responds to touch/mouse events)
            * This method should be over-ridden to handle specific game object implementations.
            * @property inputEnabled
            * @type boolean
            * @public
            */
            set: function (value) {
                this._inputEnabled = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "clock", {
            get: function () {
                return this._clock;
            },
            /**
            * The Clock used to update this all of this Entities components (defaults to the Game MasterClock)
            * @property clock
            * @type Clock
            * @public
            */
            set: function (value) {
                this._clock = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Entity.prototype, "dirty", {
            get: function () {
                return this._dirty;
            },
            /**
            * A value used by components to control if the Entity needs re-rendering
            * @property dirty
            * @type boolean
            * @public
            */
            set: function (value) {
                this._dirty = value;
            },
            enumerable: true,
            configurable: true
        });

        //  Both of these methods can and often should be over-ridden by classes extending Entity to handle specific implementations
        /**
        * The type of this object.
        * @method objType
        * @return {String} The type of the object
        * @public
        */
        Entity.prototype.objType = function () {
            return "Entity";
        };

        /**
        * This isn't called until the Entity has been added to a Group or a State
        * @method update
        * @public
        */
        Entity.prototype.update = function () {
        };

        /**
        * This isn't called until the Entity has been added to a layer.
        * This functionality is handled by the sub classes.
        * @method render
        * @param {Camera} camera
        * @public
        */
        Entity.prototype.render = function (camera) {
        };

        Entity.prototype.renderGL = function (gl, camera, params) {
            if (typeof params === "undefined") { params = null; }
        };

        /**
        * Used to completely destroy this entity and of its components. Used for garbage collection and developers can also use it as needed.
        * @method destroy
        * @param [immediate=false] {boolean} If the object should be immediately removed or if it should be removed at the end of the next update loop.
        * @public
        */
        Entity.prototype.destroy = function (immediate) {
            if (typeof immediate === "undefined") { immediate = false; }
            this._exists = false;
            this._active = false;
            this._willRender = false;

            if (immediate === true) {
                if (this.parent !== null && typeof this.parent !== "undefined")
                    this.parent.removeChild(this);
                if (this.state)
                    this.state.removeFromTrackingList(this);
                delete this._parent;
                delete this.transform;
                delete this._clock;
                delete this.state;
                delete this.game;
                delete this.atlas;

                if (this.components)
                    this.components.removeAll(true);
                delete this.components;
            }
        };
        return Entity;
    })();
    Kiwi.Entity = Entity;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * The base class that all components extend from and thus contains all of the common functionality that is required of every Component.
    *
    * @class Component
    * @namespace Kiwi
    * @constructor
    * @param owner {IChild} The IChild that this component belongs to.
    * @param componentName {String} The name of this component.
    * @return {Component}
    */
    var Component = (function () {
        function Component(owner, name) {
            /**
            * An active Component is one that has its update method called by its parent.
            * @property active
            * @type boolean
            * @default true
            * @public
            */
            this.active = true;
            /**
            * The state of this component.
            * @property dirty
            * @type boolean
            * @default false
            * @public
            */
            this.dirty = false;
            this.owner = owner;
            this.game = this.owner.game;
            this.name = name;
            this.active = true;
        }
        /**
        * Returns the type of this object
        * @method objType
        * @return {String} The type of this object
        * @public
        */
        Component.prototype.objType = function () {
            return "Component";
        };

        /**
        * Components can preUpdate, that is update before the parent updates. This is to be overriden by subclasses.
        * @method preUpdate
        * @public
        */
        Component.prototype.preUpdate = function () {
        };

        /**
        * If the component is being added to a State rather than a Game Object then over-ride its update method to perform required tasks.
        * @method update
        * @public
        */
        Component.prototype.update = function () {
        };

        /**
        * Components can postUpdate, that is run an update after the parent has updated. This is to be overriden by subclasses.
        * @method postUpdate
        * @public
        */
        Component.prototype.postUpdate = function () {
        };

        /**
        * Destroys this component and all of the properties that exist on it.
        * @method destroy
        * @public
        */
        Component.prototype.destroy = function () {
            this.active = false;
            delete this.game;
            delete this.owner;

            this.name = '';
        };
        return Component;
    })();
    Kiwi.Component = Component;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * Is a class the implements the IChild structure who's purpose is to contain multiple children/members, those of which also implement the IChild interface. The members of the Group's coordinates are also in relation to the Group that they were added to. So if you moved an entire Group, each member of that Group would also 'move'.
    *
    * @class Group
    * @namespace Kiwi
    * @constructor
    * @param state {State} The State that this Group is a part of.
    * @param [name=''] {String} The name of this group.
    * @return {Group}
    *
    */
    var Group = (function () {
        function Group(state, name) {
            if (typeof name === "undefined") { name = ''; }
            /**
            * A name for this Group. This is not checked for uniqueness within the Game, but is very useful for debugging.
            * @property name
            * @type string
            * @default ''
            * @public
            */
            this.name = '';
            /**
            * The parent group of this group.
            * @property _parent
            * @type Group
            * @private
            */
            this._parent = null;
            /**
            * The game this Group belongs to
            * @property game
            * @type Game
            * @public
            */
            this.game = null;
            /**
            * The State that this Group belongs to
            * @property state
            * @type State
            * @public
            **/
            this.state = null;
            /**
            * An indication of whether or not this group is 'dirty' and thus needs to be re-rendered or not.
            * @property _dirty
            * @type boolean
            * @private
            */
            this._dirty = true;
            /**
            * A temporary property that holds a boolean indicating whether or not the group's children should be destroyed or not.
            * @property _destroyRemoveChildren
            * @type boolean
            * @private
            */
            this._tempRemoveChildren = null;
            //prevents the state going AHHH...since the state extends group.
            if (state !== null) {
                this.state = state;
                this.game = this.state.game;
                this.id = this.game.rnd.uuid();
                this.state.addToTrackingList(this);
            }

            //  Properties
            this.name = name;
            this.components = new Kiwi.ComponentManager(Kiwi.GROUP, this);

            this._exists = true;
            this._active = true;
            this._willRender = true;

            this.transform = new Kiwi.Geom.Transform();
            this.members = [];

            this._willRender = true;
        }
        /**
        * Returns the type of this object
        * @method objType
        * @return {String} The type of this object
        * @public
        */
        Group.prototype.objType = function () {
            return 'Group';
        };

        /*
        * Represents the type of child that this is. Note: A 'CHILD' is any object that extends from ICHILD.
        * @method childType
        * @return number
        * @public
        */
        Group.prototype.childType = function () {
            return Kiwi.GROUP;
        };

        Object.defineProperty(Group.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            /**
            * Set's the parent of this entity. Note that this also sets the transforms parent of this entity to be the passed groups transform.
            * @property parent
            * @type Group
            * @public
            */
            set: function (val) {
                //check to see if the parent is not an descendor
                //if (this.containsDescendant(val) === false) {
                this.transform.parent = (val !== null) ? val.transform : null;
                this._parent = val;
                //}
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Group.prototype, "x", {
            /**
            * The X coordinate of this group. This is just aliased to the transform property.
            * @property x
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.x;
            },
            set: function (value) {
                this.transform.x = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Group.prototype, "y", {
            /**
            * The Y coordinate of this group. This is just aliased to the transform property.
            * @property y
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.y;
            },
            set: function (value) {
                this.transform.y = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Group.prototype, "scaleX", {
            /*
            * The Scale X of this group. This is just aliased to the transform property.
            * @property scaleX
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.scaleX;
            },
            set: function (value) {
                this.transform.scaleX = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Group.prototype, "scaleY", {
            /*
            * The Scale Y coordinate of this group. This is just aliased to the transform property.
            * @property scaleY
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.scaleY;
            },
            set: function (value) {
                this.transform.scaleY = value;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Group.prototype, "rotation", {
            /*
            * The rotation of this group. This is just aliased to the transform property.
            * @property rotation
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.rotation;
            },
            set: function (value) {
                this.transform.rotation = value;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * Returns the total number of children in this Group. Doesn't distinguish between alive and dead children.
        * @method numChildren
        * @return {Number} The number of children in this Group
        * @public
        */
        Group.prototype.numChildren = function () {
            return this.members.length;
        };

        Object.defineProperty(Group.prototype, "dirty", {
            get: function () {
                return this._dirty;
            },
            /**
            * Sets all children of the Group to be dirty.
            * @property dirty
            * @type boolean
            * @public
            */
            set: function (value) {
                if (value !== undefined) {
                    this._dirty = value;

                    for (var i = 0; i < this.members.length; i++) {
                        this.members[i].dirty = value;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });

        /**
        * Checks if the given entity is in this group
        * @method contains
        * @param child {IChild} The IChild that you want to checked.
        * @return {boolean} true if entity exists in group.
        * @public
        */
        Group.prototype.contains = function (child) {
            return (this.members.indexOf(child) === -1) ? false : true;
        };

        /**
        * Checks to see if the given IChild is contained in this group as a descendant
        * @method containsDescendant
        * @param child {IChild} The IChild that you want to check.
        * @return {boolean}
        * @public
        */
        Group.prototype.containsDescendant = function (child) {
            for (var i = 0; i < this.members.length; i++) {
                console.log(i);
                var curMember = this.members[i];
                if (curMember.id == child.id || curMember.childType() == Kiwi.Group && curMember.containsDesendant(child)) {
                    return true;
                }
            }
            return false;
        };

        /**
        * Checks to see if one child is an ansector of another child.
        * @method containsAncestor
        * @param descendant {IChild} The IChild that you are checking.
        * @param ancestor {Group} The parent (ancestor) that you are checking for.
        * @return {boolean}
        * @public
        */
        Group.prototype.containsAncestor = function (descendant, ancestor) {
            if (descendant.parent === null || descendant.parent === undefined) {
                return false;
            }
            if (descendant.parent == ancestor)
                return true;
            return descendant.parent.containsAncestor(descendant.parent, ancestor);
        };

        /**
        * Adds an Entity to this Group. The Entity must not already be in this Group.
        * @method addChild
        * @param child {IChild} The child to be added.
        * @return {IChild} The child that was added.
        * @public
        */
        Group.prototype.addChild = function (child) {
            //make sure you aren't adding a state or itself
            if (child.childType() === Kiwi.STATE || child == this)
                return;

            //make sure it is not itself.
            if (child.parent !== null)
                child.parent.removeChild(child);

            //check to see if the child is already part of a group.
            this.members.push(child);
            child.parent = this;

            return child;
        };

        /**
        * Adds an Entity to this Group in the specific location. The Entity must not already be in this Group and it must be supported by the Group.
        * @method addChildAt
        * @param child {IChild} The child to be added.
        * @param index {Number} The index the child will be set at.
        * @return {IChild} The child.
        * @public
        */
        Group.prototype.addChildAt = function (child, index) {
            if (child.childType() === Kiwi.STATE || child == this)
                return;

            if (child.parent !== null)
                child.parent.removeChild(child);

            this.members.splice(index, 0, child);
            child.parent = this;

            return child;
        };

        /**
        * Adds an Entity to this Group before another child. The Entity must not already be in this Group and it must be supported by the Group.
        * @method addChildBefore
        * @param child {IChild} The child to be added.
        * @param beforeChild {Entity} The child before which the child will be added.
        * @return {IChild} The child.
        * @public
        */
        Group.prototype.addChildBefore = function (child, beforeChild) {
            if (child.transform.parent !== this.transform && beforeChild.transform.parent === this.transform) {
                var index = this.getChildIndex(beforeChild);

                this.members.splice(index, 0, child);
                child.parent = this;
            }

            return child;
        };

        /**
        * Adds an Entity to this Group after another child. The Entity must not already be in this Group and it must be supported by the Group..
        * @method addChildAfter
        * @param child {IChild} The child to be added.
        * @param beforeChild {IChild} The child after which the child will be added.
        * @return {IChild} The child.
        * @public
        */
        Group.prototype.addChildAfter = function (child, beforeChild) {
            if (child.transform.parent !== this.transform && beforeChild.transform.parent === this.transform) {
                var index = this.getChildIndex(beforeChild) + 1;

                this.members.splice(index, 0, child);
                child.parent = this;
            }

            return child;
        };

        /**
        * Get the child at a specific position in this Group by its index.
        * @method getChildAt
        * @param index {Number} The index of the child
        * @return {IChild} The child, if found or null if not.
        * @public
        */
        Group.prototype.getChildAt = function (index) {
            if (this.members[index]) {
                return this.members[index];
            } else {
                return null;
            }
        };

        /**
        * Get a child from this Group by its name.
        * @method getChildByName
        * @param name {String} The name of the child
        * @return {IChild} The child, if found or null if not.
        * @public
        */
        Group.prototype.getChildByName = function (name) {
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].name === name) {
                    return this.members[i];
                }
            }

            return null;
        };

        /**
        * Get a child from this Group by its UUID.
        * @method getChildByID
        * @param id {String} The ID of the child.
        * @return {IChild} The child, if found or null if not.
        * @public
        */
        Group.prototype.getChildByID = function (id) {
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].id === id) {
                    return this.members[i];
                }
            }

            return null;
        };

        /**
        * Returns the index position of the Entity or -1 if not found.
        * @method getChildIndex
        * @param child {IChild} The child.
        * @return {Number} The index of the child or -1 if not found.
        * @public
        */
        Group.prototype.getChildIndex = function (child) {
            return this.members.indexOf(child);
        };

        /**
        * Removes an Entity from this Group if it is a child of it.
        * @method removeChild
        * @param child {IChild} The child to be removed.
        * @param [destroy=false] {boolean} If the entity that gets removed should be destroyed as well.
        * @return {IChild} The child.
        * @public
        */
        Group.prototype.removeChild = function (child, destroy) {
            if (typeof destroy === "undefined") { destroy = false; }
            if (child.parent === this) {
                var index = this.getChildIndex(child);

                if (index > -1) {
                    this.members.splice(index, 1);
                    child.parent = null;

                    if (destroy) {
                        child.destroy();
                    }
                }
            }

            return child;
        };

        /**
        * Removes the Entity from this Group at the given position.
        * @method removeChildAt
        * @param index {Number} The index of the child to be removed.
        * @return {IChild} The child, or null.
        */
        Group.prototype.removeChildAt = function (index) {
            if (this.members[index]) {
                var child = this.members[index];

                return this.removeChild(child);
            } else {
                return null;
            }
        };

        /**
        * Removes all Entities from this Group within the given range.
        * @method removeChildren
        * @param begin {Number} The begining index.
        * @param end {Number} The last index of the range.
        * @param destroy {Number} If the children should be destroyed as well.
        * @return {Number} The number of removed entities.
        * @public
        */
        Group.prototype.removeChildren = function (begin, end, destroy) {
            if (typeof begin === "undefined") { begin = 0; }
            if (typeof end === "undefined") { end = 0x7fffffff; }
            if (typeof destroy === "undefined") { destroy = false; }
            end -= begin;

            var removed = this.members.splice(begin, end);

            for (var i = 0; i < removed.length; i++) {
                removed[i].parent = null;

                if (destroy) {
                    removed[i].destroy();
                }
            }

            return removed.length;
        };

        /**
        * Sets a new position of an existing Entity within the Group.
        * @method setChildIndex
        * @param child {IChild} The child in this Group to change.
        * @param index {Number} The index for the child to be set at.
        * @return {boolean} true if the Entity was moved to the new position, otherwise false.
        * @public
        */
        Group.prototype.setChildIndex = function (child, index) {
            //  If the Entity isn't in this Group, or is already at that index then bail out
            if (child.parent !== this || this.getChildIndex(child) === index) {
                return false;
            }

            this.removeChild(child);
            this.addChildAt(child, index);

            return true;
        };

        /**
        * Swaps the position of two existing Entities that are a direct child of this group.
        * @method swapChildren
        * @param child1 {IChild} The first child in this Group to swap.
        * @param child2 {IChild} The second child in this Group to swap.
        * @return {boolean} true if the Entities were swapped successfully, otherwise false.
        * @public
        */
        Group.prototype.swapChildren = function (child1, child2) {
            //  If either Entity isn't in this Group, or is already at that index then bail out
            if (child1.parent !== this || child2.parent !== this) {
                return false;
            }

            var index1 = this.getChildIndex(child1);
            var index2 = this.getChildIndex(child2);

            if (index1 !== -1 && index2 !== -1 && index1 !== index2) {
                this.members[index1] = child2;
                this.members[index2] = child1;

                return true;
            }

            return false;
        };

        /**
        * Swaps the position of two existing Entities within the Group based on their index.
        * @method swapChildrenAt
        * @param index1 {Number} The position of the first Entity in this Group to swap.
        * @param index2 {Number} The position of the second Entity in this Group to swap.
        * @return {boolean} true if the Entities were swapped successfully, otherwise false.
        * @public
        */
        Group.prototype.swapChildrenAt = function (index1, index2) {
            var child1 = this.getChildAt(index1);
            var child2 = this.getChildAt(index2);

            if (child1 !== null && child2 !== null) {
                //  If either Entity isn't in this Group, or is already at that index then bail out
                if (child1 == child2 || child1.parent !== this || child2.parent !== this) {
                    return false;
                }

                this.members[index1] = child2;
                this.members[index2] = child1;

                return true;
            }

            return false;
        };

        /**
        * Replaces a child Entity in this Group with a new one.
        * @method replaceChild
        * @param oldChild {IChild} The Entity in this Group to be removed.
        * @param newChild {IChild} The new Entity to insert into this Group at the old Entities position.
        * @return {boolean} true if the Entities were replaced successfully, otherwise false.
        * @public
        */
        Group.prototype.replaceChild = function (oldChild, newChild) {
            //fall through if replacing child with the same child
            if (oldChild === newChild)
                return false;

            // get the index of the existing child
            var index = this.getChildIndex(oldChild);

            if (index > -1) {
                // remove the new child from the group if the group contains it, so it can be reinserted in new position
                if (newChild.parent) {
                    newChild.parent.removeChild(newChild);
                }

                this.removeChildAt(index);

                this.addChildAt(newChild, index);
                newChild.parent = null;

                return true;
            }

            return false;
        };

        /**
        * Loops through each member in the group and run a method on for each one.
        * @method forEach
        * @param context {any} The context that the callbacks are to have when called.
        * @param callback {any} The callback method to execute on each member.
        * @param [params]* {any} Any extra parameters.
        * @public
        */
        Group.prototype.forEach = function (context, callback) {
            var params = [];
            for (var _i = 0; _i < (arguments.length - 2); _i++) {
                params[_i] = arguments[_i + 2];
            }
            if (this.members.length > 0) {
                this.members.forEach(function (child) {
                    return callback.apply(context, [child].concat(params));
                });
            }
        };

        /**
        * Loop through each member of the groups that is alive.
        * @method forEachAlive
        * @param context {any} The context that the callbacks are to have when called.
        * @param callback {any} The callback method to execute on each member.
        * @param [params]* {any} Any extra parameters.
        * @public
        */
        Group.prototype.forEachAlive = function (context, callback) {
            var params = [];
            for (var _i = 0; _i < (arguments.length - 2); _i++) {
                params[_i] = arguments[_i + 2];
            }
            if (this.members.length > 0) {
                this.members.forEach(function (child) {
                    if (child.exists)
                        callback.apply(context, [child].concat(params));
                });
            }
        };

        /**
        * Sets a property on every member. If componentName is null the property is set on the entity itself, otherwise it is set on the named component. Uses runtime string property lookups. Not optimal for large groups if speed is an issue.
        * @method setAll
        * @param componentName {string} The name of the component to set the property on - set to null to set a property on the entity.
        * @param property {string} The name of the property to set.
        * @param value {any} The value to set the property to.
        * @public
        */
        Group.prototype.setAll = function (componentName, property, value) {
            if (componentName === null) {
                for (var i = 0; i < this.members.length; i++) {
                    this.members[i][property] = value;
                }
            } else {
                for (var i = 0; i < this.members.length; i++) {
                    this.members[i][componentName][property] = value;
                }
            }
        };

        /**
        * Calls a function on every member. If componentName is null the function is called on the entity itself, otherwise it is called on the named component. Uses runtime string property lookups. Not optimal for large groups if speed is an issue.
        * @method callAll
        * @param componentName {string} The name of the component to call the function on - set to null to call a function on the entity.
        * @param functionName {string} The name of the function to call.
        * @param args {Array} An array of arguments to pas to the function.
        * @public
        */
        Group.prototype.callAll = function (componentName, functionName, args) {
            if (componentName === null) {
                for (var i = 0; i < this.members.length; i++) {
                    this.members[i][functionName].apply(this.members[i], args);
                }
            } else {
                for (var i = 0; i < this.members.length; i++) {
                    this.members[i][componentName][functionName].apply(this.members[i][componentName], args);
                }
            }
        };

        /**
        * The update loop for this group.
        * @method update
        * @public
        */
        Group.prototype.update = function () {
            this.components.preUpdate();

            this.components.update();
            if (this.members.length > 0) {
                for (var i = 0; i < this.members.length; i++) {
                    if (this.members[i].active === true) {
                        this.members[i].update();
                    }

                    if (this.members[i].exists === false) {
                        this.members[i].destroy(true);
                    }
                }
            }

            this.components.postUpdate();
        };


        Object.defineProperty(Group.prototype, "exists", {
            get: function () {
                return this._exists;
            },
            /**
            * Toggles the exitence of this Group. An Entity that no longer exists can be garbage collected or re-allocated in a pool
            * This method should be over-ridden to handle specific canvas/webgl implementations.
            * @property exists
            * @type boolean
            * @public
            */
            set: function (value) {
                this._exists = value;
            },
            enumerable: true,
            configurable: true
        });


        Object.defineProperty(Group.prototype, "active", {
            get: function () {
                return this._active;
            },
            /**
            * Toggles the active state of this Entity. An Entity that is active has its update method called by its parent.
            * This method should be over-ridden to handle specific dom/canvas/webgl implementations.
            * @property active
            * @type boolean
            * @default true
            * @public
            */
            set: function (value) {
                this._active = value;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * The render method that is required by the IChild.
        * This method never gets called as the render is only worried about rendering entities.
        * @method render
        * @param camera {Camera}
        * @public
        */
        Group.prototype.render = function (camera) {
        };

        /**
        * Removes the first Entity from this Group marked as 'alive'
        * @method removeFirstAlive
        * @param [destroy=false] {boolean} If the entity should run the destroy method when it is removed.
        * @return {IChild} The Entity that was removed from this Group if alive, otherwise null
        * @public
        */
        Group.prototype.removeFirstAlive = function (destroy) {
            if (typeof destroy === "undefined") { destroy = false; }
            return this.removeChild(this.getFirstAlive(), destroy);
        };

        /**
        * Returns the first Entity from this Group marked as 'alive' or null if no members are alive
        * @method getFirstAlive
        * @return {IChild}
        * @public
        */
        Group.prototype.getFirstAlive = function () {
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].exists === true) {
                    return this.members[i];
                }
            }

            return null;
        };

        /**
        * Returns the first member of the Group which is not 'alive', returns null if all members are alive.
        * @method getFirstDead
        * @return {IChild}
        * @public
        */
        Group.prototype.getFirstDead = function () {
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].exists === false) {
                    return this.members[i];
                }
            }

            return null;
        };

        /**
        * Returns the number of member which are marked as 'alive'
        * @method countLiving
        * @return {Number}
        * @public
        */
        Group.prototype.countLiving = function () {
            var total = 0;

            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].exists === true) {
                    total++;
                }
            }

            return total;
        };

        /**
        * Returns the number of member which are not marked as 'alive'
        * @method countDead
        * @return {Number}
        * @public
        */
        Group.prototype.countDead = function () {
            var total = 0;

            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].exists === false) {
                    total++;
                }
            }

            return total;
        };

        /**
        * Returns a member at random from the group.
        * @param {Number}	StartIndex	Optional offset off the front of the array. Default value is 0, or the beginning of the array.
        * @param {Number}	Length		Optional restriction on the number of values you want to randomly select from.
        * @return {IChild}	A child from the members list.
        * @public
        */
        Group.prototype.getRandom = function (start, length) {
            if (typeof start === "undefined") { start = 0; }
            if (typeof length === "undefined") { length = 0; }
            if (this.members.length === 0) {
                return null;
            }

            if (length === 0) {
                length = this.members.length;
            }

            if (start < 0 || start > length) {
                start = 0;
            }

            var rnd = start + (Math.random() * (start + length));

            if (rnd > this.members.length) {
                return this.members[this.members.length - 1];
            } else {
                return this.members[rnd];
            }
        };

        /**
        * Clear all children from this Group
        * @method clear
        * @public
        */
        Group.prototype.clear = function () {
            this.members.length = 0;
        };

        Object.defineProperty(Group.prototype, "willRender", {
            get: function () {
                return this._willRender;
            },
            /**
            * Controls whether render is automatically caleld by the parent.
            * @property willRender
            * @type boolean
            * @return {boolean}
            * @public
            */
            set: function (value) {
                this._willRender = value;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * Removes all children and destroys the Group.
        * @method destroy
        * @param [immediate=false] {boolean} If the object should be immediately removed or if it should be removed at the end of the next update loop.
        * @param [destroyChildren=true] {boolean} If all of the children on the group should also have their destroy methods called.
        * @public
        */
        Group.prototype.destroy = function (immediate, destroyChildren) {
            if (typeof immediate === "undefined") { immediate = false; }
            if (typeof destroyChildren === "undefined") { destroyChildren = true; }
            this._exists = false;
            this._active = false;
            this._willRender = false;

            if (immediate === true) {
                if (this._tempRemoveChildren !== null)
                    destroyChildren = this._tempRemoveChildren;

                if (destroyChildren == true) {
                    for (var i = 0; i < this.members.length; i++) {
                        this.members[i].destroy(true);
                    }
                } else {
                    this.removeChildren();
                }

                if (this.parent !== null)
                    this.parent.removeChild(this);
                if (this.state)
                    this.state.removeFromTrackingList(this);
                delete this.transform;
                if (this.components)
                    this.components.removeAll();
                delete this.components;
                delete this.name;
                delete this.members;
                delete this.game;
                delete this.state;
                delete this._tempRemoveChildren;
            } else {
                this._tempRemoveChildren = destroyChildren;
            }
        };
        return Group;
    })();
    Kiwi.Group = Group;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Kiwi;
(function (Kiwi) {
    /**
    *
    *
    * @class State
    * @namespace Kiwi
    * @extends Group
    * @constructor
    * @param name {String}
    * @return {State}
    */
    var State = (function (_super) {
        __extends(State, _super);
        function State(name) {
            _super.call(this, null, name);
            /**
            * A reference to the Kiwi.Game that this State belongs to
            * @property game
            * @type Game
            * @public
            */
            this.game = null;

            this.config = new Kiwi.StateConfig(this, name);
            this.components = new Kiwi.ComponentManager(Kiwi.STATE, this);
            this.transform.parent = null;
            this._trackingList = [];
        }
        /**
        * Returns the type of object this state is.
        * @method objType
        * @return String
        * @public
        */
        State.prototype.objType = function () {
            return "State";
        };

        /**
        * Returns the type of child this is.
        * @method childType
        * @return Number
        * @public
        */
        State.prototype.childType = function () {
            return Kiwi.GROUP;
        };

        /**
        * Is executed when this state is about to be switched too. Just before the preload method.
        * ONLY occurs on games targetting browsers.
        * @method boot
        * @public
        */
        State.prototype.boot = function () {
            this.textureLibrary = new Kiwi.Textures.TextureLibrary(this.game);
            this.textures = this.textureLibrary.textures;
            this.audioLibrary = new Kiwi.Sound.AudioLibrary(this.game);
            this.audio = this.audioLibrary.audio;
            this.dataLibrary = new Kiwi.Files.DataLibrary(this.game);
            this.data = this.dataLibrary.data;
        };

        /**
        * Currently unused.
        * @method setType
        * @param {Number} value
        * @public
        */
        State.prototype.setType = function (value) {
            if (this.config.isInitialised === false) {
                this.config.type = value;
            }
        };

        /*
        *--------------
        * Methods that should be Over-Ridden
        *--------------
        */
        /**
        * Gets executed when the state has been initalised and gets switched to for the first time.
        * This method only ever gets called once and it is before the preload method.
        * @method init
        * @param[values] * {Any }
        * @public
        */
        State.prototype.init = function () {
            var paramsArr = [];
            for (var _i = 0; _i < (arguments.length - 0); _i++) {
                paramsArr[_i] = arguments[_i + 0];
            }
        };

        /**
        * This method is where you would load of all the assets that are requried for this state or in the entire game.
        * @method preload
        * @public
        */
        State.prototype.preload = function () {
        };

        /**
        * This method is progressively called whilst loading a file.
        * This can be used to create a 'progress' bar for each file.
        * @method loadProgress
        * @param {Number} percent
        * @param {Number} bytesLoaded
        * @param {Kiwi.Files} file
        * @public
        */
        State.prototype.loadProgress = function (percent, bytesLoaded, file) {
        };

        /**
        * Gets executed when the game is finished loading and it is about to 'create' the state.
        * @method loadComplete
        * @public
        */
        State.prototype.loadComplete = function () {
        };

        /**
        * The game loop that gets executed while the game is loading.
        * @method loadUpdate
        * @public
        */
        State.prototype.loadUpdate = function () {
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].active === true) {
                    this.members[i].update();
                }
            }
        };

        /**
        * Is executed once all of the assets have loaded and the game is ready to be 'created'.
        * @method create
        * @param [values]* {Any}
        * @public
        */
        State.prototype.create = function () {
            var paramsArr = [];
            for (var _i = 0; _i < (arguments.length - 0); _i++) {
                paramsArr[_i] = arguments[_i + 0];
            }
        };

        /**
        * Is called every frame before the update loop. When overriding make sure you include a super call.
        * @method preUpdate
        * @public
        */
        State.prototype.preUpdate = function () {
            this.components.preUpdate();
        };

        /**
        * The update loop that is executed every frame while the game is 'playing'. When overriding make sure you include a super call too.
        * @method update
        * @public
        */
        State.prototype.update = function () {
            this.components.update();

            for (var i = 0; i < this.members.length; i++) {
                //Should the update loop be executed?
                if (this.members[i].active === true) {
                    this.members[i].update();
                }

                //Does the child need to be destroyed?
                if (this.members[i].exists === false) {
                    this.members[i].destroy(true);
                }
            }
        };

        /**
        * The post update loop is executed every frame after the update method.
        * When overriding make sure you include a super call at the end of the method.
        * @method postUpdate
        * @public
        */
        State.prototype.postUpdate = function () {
            this.components.postUpdate();
        };

        /**
        * Called after all of the layers have rendered themselves, useful for debugging
        * @method postRender
        * @public
        */
        State.prototype.postRender = function () {
        };

        /**
        * Called just before this State is going to be Shut Down and another one is going to be switched too.
        * @method shutDown
        * @public
        */
        State.prototype.shutDown = function () {
        };

        /*
        *--------------
        * Loading Methods
        *--------------
        */
        /**
        * Adds a new image file that is be loaded when the state gets up to the loading all of the assets.
        *
        * @method addImage
        * @param key {String} A key for this image so that you can access it when the loading has finished.
        * @param url {String} The location of the image.
        * @param [storeAsGlobal=true] {boolean} If the image should be deleted when switching to another state or if the other states should still be able to access this image.
        * @param [width] {Number} The width of the image. If not passed the width will be automatically calculated.
        * @param [height] {Number} The height of the image. If not passed the height will be automatically calculated.
        * @param [offsetX] {Number} The offset of the image when rendering on the x axis.
        * @param [offsetY] {Number} The offset of the image when rendering on the y axis.
        * @public
        */
        State.prototype.addImage = function (key, url, storeAsGlobal, width, height, offsetX, offsetY) {
            if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
            this.game.loader.addImage(key, url, width, height, offsetX, offsetY, storeAsGlobal);
        };

        /**
        * Adds a new spritesheet image file that is be loaded when the state gets up to the loading all of the assets.
        *
        * @method addSpriteSheet
        * @param key {String} A key for this image so that you can access it when the loading has finished.
        * @param url {String} The location of the image.
        * @param frameWidth {Number} The width of a single frame in the spritesheet
        * @param frameHeight {Number} The height of a single frame in the spritesheet
        * @param [storeAsGlobal=true] {boolean} If the image should be deleted when switching to another state or if the other states should still be able to access this image.
        * @param [numCells] {Number} The number of cells/frames that are in the spritesheet. If not specified will calculate this based of the width/height of the image.
        * @param [rows] {Number} The number of cells that are in a row. If not specified will calculate this based of the width/height of the image.
        * @param [cols] {Number} The number of cells that are in a column. If not specified will calculate this based of the width/height of the image.
        * @param [sheetOffsetX=0] {Number} The offset of the whole spritesheet on the x axis.
        * @param [sheetOffsetY=0] {Number} The offset of the whole spritesheet on the y axis.
        * @param [cellOffsetX=0] {Number} The spacing between cells on the x axis.
        * @param [cellOffsetY=0] {Number} The spacing between cells on the y axis.
        * @public
        */
        State.prototype.addSpriteSheet = function (key, url, frameWidth, frameHeight, storeAsGlobal, numCells, rows, cols, sheetOffsetX, sheetOffsetY, cellOffsetX, cellOffsetY) {
            if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
            this.game.loader.addSpriteSheet(key, url, frameWidth, frameHeight, numCells, rows, cols, sheetOffsetX, sheetOffsetY, cellOffsetX, cellOffsetY, storeAsGlobal);
        };

        /**
        * Adds a new texture atlas that is to be loaded when the states gets up to the stage of loading the assets.
        *
        * @method addTextureAtlas
        * @param key {String} A key for this image so that you can access it when the loading has finished.
        * @param imageURL {String} The location of the image.
        * @param [jsonID] {String} The id for the json file that is to be loaded. So that you can access it outside of the texture atlas.
        * @param [jsonURL] {String} The location of the json file you have loaded.
        * @param [storeAsGlobal=true] {boolean} If the image should be delete when switching to another state or if the other states should still be able to access this image.
        * @public
        */
        State.prototype.addTextureAtlas = function (key, imageURL, jsonID, jsonURL, storeAsGlobal) {
            if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
            this.game.loader.addTextureAtlas(key, imageURL, jsonID, jsonURL, storeAsGlobal);
        };

        /**
        * Adds a json file that is to be loaded when the state gets up to the stage of loading the assets.
        *
        * @method addJSON
        * @param key {string} A key for this json so that you can access it when the loading has finished
        * @param url {string} The location of the JSON file.
        * @param [storeAsGlobal=true] {boolean} If the json should be deleted when switching to another state or if the other states should still be able to access this json.
        * @public
        */
        State.prototype.addJSON = function (key, url, storeAsGlobal) {
            if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
            this.game.loader.addJSON(key, url, storeAsGlobal);
        };

        /**
        * Adds a new audio file that is to be loaded when the state gets up to the stage of loading the assets.
        *
        * @method addAudio
        * @param key {string} A key for this audio so that you can access it when the loading has finished
        * @param url {string} The location of the audio file.
        * @param [storeAsGlobal=true] {boolean} If the audio should be deleted when switching to another state or if the other states should still be able to access this audio.
        */
        State.prototype.addAudio = function (key, url, storeAsGlobal) {
            if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
            this.game.loader.addAudio(key, url, storeAsGlobal);
        };

        /**
        * Adds a new IChild to the tracking list. This is an INTERNAL Kiwi method and DEVS shouldn't really need to worry about it.
        * @method addToTrackingList
        * @param {IChild} child
        * @public
        */
        State.prototype.addToTrackingList = function (child) {
            //check to see that its not already in the tracking list.
            if (this._trackingList.indexOf(child) !== -1)
                return;

            //add to the list
            this._trackingList.push(child);
        };

        /**
        * Removes a IChild from the tracking list. This should only need to happen when a child is being destroyed.
        * This is an INTERNAL Kiwi method and DEVS shouldn't really need to worry about it.
        * @method removeFromTrackingList
        * @param {IChild} child
        * @public
        */
        State.prototype.removeFromTrackingList = function (child) {
            //check to see that it is in the tracking list.
            var n = this._trackingList.indexOf(child);
            if (n > -1) {
                this._trackingList.splice(n, 1);
            }
        };

        /**
        * Destroys all of IChilds that are not currently on stage. All IChilds that currently don't have this STATE as an ancestor.
        * Returns the number of IChilds removed.
        * @method destroyUnused
        * @return {Number}
        * @public
        */
        State.prototype.destroyUnused = function () {
            var d = 0;
            for (var i = 0; i < this._trackingList.length; i++) {
                if (this.containsAncestor(this._trackingList[i], this) === false) {
                    this._trackingList[i].destroy();
                    this._trackingList.splice(i, 1);
                    i--;
                    d++;
                }
            }

            return d;
        };

        /**
        * Destroys all of the IChild's on the start.
        * @method destroy
        * @param [deleteAll=true] If all of the IChild's ever created should have the destroy method executed also.
        * @public
        */
        State.prototype.destroy = function (deleteAll) {
            if (typeof deleteAll === "undefined") { deleteAll = true; }
            if (deleteAll == true) {
                for (var i = 0; i < this._trackingList.length; i++) {
                    //If the item is a group then we don't want it to destory it's children, as this method will do that eventually anyway.
                    this._trackingList[i].destroy(true, false);
                }
                this._trackingList = [];

                for (var i = 0; i < this.members.length; i++) {
                    this._destroyChildren(this.members[i]); //Shouldnt need this as they should already be dead
                    delete this.members[i];
                }
                this.members = [];
            }
        };

        /**
        * Recursively goes through a child given and runs the destroy method on all that are passed.
        * @method _destroyChildren
        * @param {IChild} child
        * @private
        */
        State.prototype._destroyChildren = function (child) {
            if (child.childType() == Kiwi.GROUP) {
                for (var i = 0; i < child.members.length; i++) {
                    this._destroyChildren(child.members[i]);
                }
            }
            child.destroy(true);
        };
        return State;
    })(Kiwi.Group);
    Kiwi.State = State;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * A Camera is used to render a particular section of the game world on the stage. Each Camera has a coordinates which are held in the transform property, and a width/height. Note: This class should never be directly instantiated but instead should be made through a CameraManager's 'create' method.
    *
    * @class Camera
    * @namespace Kiwi
    * @constructor
    * @param game {Game} The game that this camera belongs to.
    * @param id {Number} A unique ID for this camera
    * @param name {String} The name this camera goes by
    * @param x {Number} The x coordinate of the camera
    * @param y {Number} The y coordinate of the camera
    * @param width {Number} The width of the camera
    * @param height {Number} The cameras height
    * @return {Camera}
    *
    */
    var Camera = (function () {
        function Camera(game, id, name, x, y, width, height) {
            /**
            * If true then the camera will be resized to fit the stage when the stage is resized
            * @property fitToStage
            * @type boolean
            * @default true
            * @public
            */
            this.fitToStage = true;
            this._game = game;
            this.id = id;
            this.name = name;

            //size could autoresize to fit stage
            this.width = width;
            this.height = height;
            this.transform = new Kiwi.Geom.Transform(x, y);
            this.transform.rotPointX = x + width / 2;
            this.transform.rotPointY = y + height / 2;

            this._game.stage.onResize.add(this._updatedStageSize, this);
        }
        /**
        * The type of Object this is.
        * @method objType
        * @return {String}
        * @public
        */
        Camera.prototype.objType = function () {
            return "Camera";
        };

        /**
        * Updates the width/height of this camera. Is used when the stage resizes.
        * @method _updatedStageSize
        * @param width {Number} The new width of the camera.
        * @param height {Number} The new height of the camera.
        * @private
        */
        Camera.prototype._updatedStageSize = function (width, height) {
            this.width = width;
            this.height = height;
        };

        Object.defineProperty(Camera.prototype, "visible", {
            /**
            * Controls whether this Camera is rendered.
            * @property visible
            * @type boolean
            * @public
            */
            get: function () {
                return this._visible;
            },
            set: function (val) {
                this._visible = val;
            },
            enumerable: true,
            configurable: true
        });

        Object.defineProperty(Camera.prototype, "dirty", {
            /**
            * A value used by components to control if the camera needs re-rendering.
            * @property dirty
            * @type boolean
            * @public
            */
            get: function () {
                return this._dirty;
            },
            set: function (val) {
                this._dirty = val;
            },
            enumerable: true,
            configurable: true
        });

        /**
        * The update loop that is executed every frame.
        * @method update
        * @public
        */
        Camera.prototype.update = function () {
        };

        /**
        * The render loop that is executed whilst the game is playing.
        * @method render
        * @public
        */
        Camera.prototype.render = function () {
            this._game.renderer.render(this);
        };
        return Camera;
    })();
    Kiwi.Camera = Camera;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * A TypeScript conversion of JS Signals by Miller Medeiros.
    * Released under the MIT license
    * http://millermedeiros.github.com/js-signals/
    *
    * @class Signal
    * @namespace Kiwi
    *
    * @author Miller Medeiros, JS Signals
    */
    var Signal = (function () {
        function Signal() {
            /**
            * A list of all of the signal bindings that are on this signal.
            * @property _bindings
            * @type SignalBinding[]
            * @default []
            * @private
            */
            this._bindings = [];
            /**
            *
            * @property _prevParams
            * @type Any
            * @default null
            * @private
            */
            this._prevParams = null;
            /**
            * If Signal should keep record of previously dispatched parameters and
            * automatically execute listener during `add()`/`addOnce()` if Signal was
            * already dispatched before.
            * @property memorize
            * @type boolean
            * @default false
            * @public
            */
            this.memorize = false;
            /**
            * [REQUIRES DESCRIPTION]
            * @type boolean
            * @default true
            * @private
            */
            this._shouldPropagate = true;
            /**
            * If Signal is active and should broadcast events.
            * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
            * @property active
            * @type boolean
            * @default true
            * @public
            */
            this.active = true;
        }
        /**
        * Returns the type of this object
        * @method objType
        * @return {String} The type of this object
        * @public
        */
        Signal.prototype.objType = function () {
            return "Signal";
        };

        /**
        * Validates a event listener an is used to check to see if it is valid or not.
        * @method validateListener
        * @param listener {Any}
        * @param fnName {Any}
        */
        Signal.prototype.validateListener = function (listener, fnName) {
            if (typeof listener !== 'function') {
                throw new Error('listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName));
            }
        };

        /**
        * [REQUIRES DESCRIPTION]
        * @param listener {Function}
        * @param isOnce {boolean}
        * @param listenerContext {Object}
        * @param priority {Number}
        * @return {SignalBinding}
        * @private
        */
        Signal.prototype._registerListener = function (listener, isOnce, listenerContext, priority) {
            var prevIndex = this._indexOfListener(listener, listenerContext);
            var binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];

                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once') + '() the same listener without removing the relationship first.');
                }
            } else {
                binding = new Kiwi.SignalBinding(this, listener, isOnce, listenerContext, priority);

                this._addBinding(binding);
            }

            if (this.memorize && this._prevParams) {
                binding.execute(this._prevParams);
            }

            return binding;
        };

        /**
        *
        * @method _addBinding
        * @param binding {SignalBinding}
        * @private
        */
        Signal.prototype._addBinding = function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;

            do {
                --n;
            } while(this._bindings[n] && binding.priority <= this._bindings[n].priority);

            this._bindings.splice(n + 1, 0, binding);
        };

        /**
        * [REQUIRES DESCRIPTION]
        * @method _indexOfListener
        * @param listener {Function}
        * @param context {any}
        * @return {number}
        * @private
        */
        Signal.prototype._indexOfListener = function (listener, context) {
            var n = this._bindings.length;
            var cur;

            while (n--) {
                cur = this._bindings[n];

                if (cur.getListener() === listener && cur.context === context) {
                    return n;
                }
            }

            return -1;
        };

        /**
        * Check if listener was attached to Signal.
        * @param listener {Function}
        * @param [context=null] {Any}
        * @return {boolean} if Signal has the specified listener.
        * @public
        */
        Signal.prototype.has = function (listener, context) {
            if (typeof context === "undefined") { context = null; }
            return this._indexOfListener(listener, context) !== -1;
        };

        /**
        * Add a listener to the signal.
        * @param listener {Function} Signal handler function.
        * @param [listenerContext=null] {Any} Context on which listener will be executed (object that should represent the `this` variable inside listener function).
        * @param [priority=0] {Number} The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
        * @return {SignalBinding} An Object representing the binding between the Signal and listener.
        * @public
        */
        Signal.prototype.add = function (listener, listenerContext, priority) {
            if (typeof listenerContext === "undefined") { listenerContext = null; }
            if (typeof priority === "undefined") { priority = 0; }
            this.validateListener(listener, 'add');

            return this._registerListener(listener, false, listenerContext, priority);
        };

        /**
        * Add listener to the signal that should be removed after first execution (will be executed only once).
        * @param listener {Function} Signal handler function.
        * @param [listenerContext=null] {Any} Context on which listener will be executed (object that should represent the `this` variable inside listener function).
        * @param [priority=0] {Number} The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
        * @return {SignalBinding} An Object representing the binding between the Signal and listener.
        * @public
        */
        Signal.prototype.addOnce = function (listener, listenerContext, priority) {
            if (typeof listenerContext === "undefined") { listenerContext = null; }
            if (typeof priority === "undefined") { priority = 0; }
            this.validateListener(listener, 'addOnce');

            return this._registerListener(listener, true, listenerContext, priority);
        };

        /**
        * Remove a single listener from the dispatch queue.
        * @param listener {Function} Handler function that should be removed.
        * @param [context=null] {Any} Execution context (since you can add the same handler multiple times if executing in a different context).
        * @return {Function} Listener handler function.
        * @public
        */
        Signal.prototype.remove = function (listener, context) {
            if (typeof context === "undefined") { context = null; }
            this.validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);

            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }

            return listener;
        };

        /**
        * Remove all listeners from the Signal.
        * @method removeAll
        * @public
        */
        Signal.prototype.removeAll = function () {
            var n = this._bindings.length;

            while (n--) {
                this._bindings[n]._destroy();
            }

            this._bindings.length = 0;
        };

        /**
        * [REQUIRES DESCRIPTION]
        * @method getNumListeners
        * @return {number} Number of listeners attached to the Signal.
        * @public
        */
        Signal.prototype.getNumListeners = function () {
            return this._bindings.length;
        };

        /**
        * [REQUIRES DESCRIPTION]
        * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
        * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
        * @see Signal.prototype.disable
        * @method halt
        * @public
        */
        Signal.prototype.halt = function () {
            this._shouldPropagate = false;
        };

        /**
        * Dispatch/Broadcast Signal to all listeners added to the queue.
        * @method dispatch
        * @param [params]* {any} Parameters that should be passed to each handler.
        * @public
        */
        Signal.prototype.dispatch = function () {
            var paramsArr = [];
            for (var _i = 0; _i < (arguments.length - 0); _i++) {
                paramsArr[_i] = arguments[_i + 0];
            }
            if (!this.active) {
                return;
            }

            var n = this._bindings.length;
            var bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (!n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(0); //clone array in case add/remove items during dispatch

            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            do {
                n--;
            } while(bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        };

        /**
        * [REQUIRES DESCRIPTION]
        * Forget memorized arguments. See Signal.memorize
        * @method forget
        * @public
        */
        Signal.prototype.forget = function () {
            this._prevParams = null;
        };

        /**
        * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
        * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
        * @method dispose
        * @public
        */
        Signal.prototype.dispose = function () {
            this.removeAll();

            delete this._bindings;
            delete this._prevParams;
        };

        /**
        * @method toString
        * @return {string} String representation of the object.
        * @public
        */
        Signal.prototype.toString = function () {
            return '[Signal active:' + this.active + ' numListeners:' + this.getNumListeners() + ']';
        };
        Signal.VERSION = '1.0.0';
        return Signal;
    })();
    Kiwi.Signal = Signal;
})(Kiwi || (Kiwi = {}));
/**
* Module - Kiwi (Core)
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * An object that represents a binding between a Signal and a listener function.
    * Released under the MIT license
    * http://millermedeiros.github.com/js-signals/
    *
    * @class SignalBinding
    * @namespace Kiwi
    *
    * @author Miller Medeiros, JS Signals
    * @constructor
    * @internal
    * @name SignalBinding
    * @param {Signal} signal Reference to Signal object that listener is currently bound to.
    * @param {Function} listener Handler function bound to the signal.
    * @param {boolean} isOnce If binding should be executed just once.
    * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
    * @param {Number} [priority=0] The priority level of the event listener. (default = 0).
    *
    */
    var SignalBinding = (function () {
        /**
        * Object that represents a binding between a Signal and a listener function.
        * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
        * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
        * @author Miller Medeiros
        
        */
        function SignalBinding(signal, listener, isOnce, listenerContext, priority) {
            if (typeof priority === "undefined") { priority = 0; }
            /**
            * If binding is active and should be executed.
            * @property active
            * @type boolean
            * @default true
            * @public
            */
            this.active = true;
            /**
            * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
            * @property params
            * @type Any
            * @default null
            * @public
            */
            this.params = null;
            this._listener = listener;
            this._isOnce = isOnce;
            this.context = listenerContext;
            this._signal = signal;
            this.priority = priority || 0;
        }
        /**
        * The type of object that this is.
        * @method objType
        * @return String
        * @public
        */
        SignalBinding.prototype.objType = function () {
            return "SignalBinding";
        };

        /**
        * Call listener passing arbitrary parameters.
        * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
        * @method execute
        * @param {Array} [paramsArr]* Array of parameters that should be passed to the listener
        * @return {*} Value returned by the listener.
        * @public
        */
        SignalBinding.prototype.execute = function (paramsArr) {
            var handlerReturn;
            var params;

            if (this.active && !!this._listener) {
                params = this.params ? this.params.concat(paramsArr) : paramsArr;

                handlerReturn = this._listener.apply(this.context, params);

                if (this._isOnce) {
                    this.detach();
                }
            }

            return handlerReturn;
        };

        /**
        * Detach binding from signal.
        * - alias to: mySignal.remove(myBinding.getListener());
        * @method detach
        * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
        * @public
        */
        SignalBinding.prototype.detach = function () {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        };

        /**
        * @method isBound
        * @return {boolean} `true` if binding is still bound to the signal and have a listener.
        * @public
        */
        SignalBinding.prototype.isBound = function () {
            return (!!this._signal && !!this._listener);
        };

        /**
        * @method isOnce
        * @return {boolean} If SignalBinding will only be executed once.
        * @public
        */
        SignalBinding.prototype.isOnce = function () {
            return this._isOnce;
        };

        /**
        * @method getListener
        * @return {Function} Handler function bound to the signal.
        * @public
        */
        SignalBinding.prototype.getListener = function () {
            return this._listener;
        };

        /**
        * @method getSignal
        * @return {Signal} Signal that listener is currently bound to.
        * @public
        */
        SignalBinding.prototype.getSignal = function () {
            return this._signal;
        };

        /**
        * Delete instance properties
        * @method _destory
        * @public
        */
        SignalBinding.prototype._destroy = function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        };

        /**
        * @method toString
        * @return {string} String representation of the object.
        * @public
        */
        SignalBinding.prototype.toString = function () {
            return '[SignalBinding isOnce:' + this._isOnce + ', isBound:' + this.isBound() + ', active:' + this.active + ']';
        };
        return SignalBinding;
    })();
    Kiwi.SignalBinding = SignalBinding;
})(Kiwi || (Kiwi = {}));
var Kiwi;
(function (Kiwi) {
    /**
    * The GameObject namespace holds classes which are designed to be added to a State (either directly, or as an ancestor of a Group) and are the Objects that are used when wanting to render anything visual onto the current State. Each GameObject is a representation of a particular item in a game and as such has information that corresponds to that item (like where they are in the 'GameWorld', the scale of the GameObject, who their parent is, e.t.c). For Example: If you wanted to have a massive background image then you can use the StaticImage GameObject, as that is a relatively light-weight object). Or if you had Player with an Animation, which user's could interactive with, then you would use a Sprite, which is more robust.
    *
    * @module Kiwi
    * @submodule GameObjects
    * @main GameObjects
    */
    (function (GameObjects) {
        /**
        * A Sprite is a general purpose GameObject that contains majority of the functionality that is needed/would be wanted and as such should be used only when you are wanting a GameObject with a lot of interaction. When creating a Sprite you pass to it as TextureAtlas (for the image you want to render), now if that Texture Atlas isn't a SINGLE_IMAGE then the Sprite will have an AnimationManager Component to handle any SpriteSheet animations you need.
        *
        * @class Sprite
        * @namespace Kiwi.GameObjects
        * @extends Entity
        * @constructor
        * @param state {State} The state that this sprite belongs to
        * @param atlas {TextureAtlas} The texture you want to apply to this entity
        * @param [x=0] {Number} The sprites initial coordinates on the x axis.
        * @param [y=0] {Number} The sprites initial coordinates on the y axis.
        * @param [enableInput=false] {boolean} If the input component should be enabled or not.
        * @return {Sprite}
        */
        var Sprite = (function (_super) {
            __extends(Sprite, _super);
            function Sprite(state, atlas, x, y, enableInput) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof enableInput === "undefined") { enableInput = false; }
                _super.call(this, state, x, y);

                //Texture atlas error check
                if (typeof atlas == "undefined") {
                    console.error('A Texture Atlas was not passed when instantiating a new Sprite.');
                    this.willRender = false;
                    this.active = false;
                    return;
                }

                if (this.game.renderOption === Kiwi.RENDERER_WEBGL) {
                    this.glRenderer = this.game.renderer.requestSharedRenderer("TextureAtlasRenderer");
                }

                this.atlas = atlas;
                this.name = this.atlas.name;
                this.cellIndex = this.atlas.cellIndex;

                //may need to add an optional other cell frame index here
                this.width = atlas.cells[0].w;
                this.height = atlas.cells[0].h;
                this.transform.rotPointX = this.width / 2;
                this.transform.rotPointY = this.height / 2;

                //Create the components needed
                this.box = this.components.add(new Kiwi.Components.Box(this, x, y, this.width, this.height));
                this.input = this.components.add(new Kiwi.Components.Input(this, this.box, enableInput));

                //Check to see if this sprite could be animated or not
                if (this.atlas.type === Kiwi.Textures.TextureAtlas.SINGLE_IMAGE) {
                    this.animation = null;
                    this._isAnimated = false;
                } else {
                    this.animation = this.components.add(new Kiwi.Components.AnimationManager(this));
                    this._isAnimated = true;
                }
            }
            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {string}
            * @public
            */
            Sprite.prototype.objType = function () {
                return "Sprite";
            };

            /**
            * Called by parent when its update loop gets executed.
            * @method update
            * @public
            */
            Sprite.prototype.update = function () {
                _super.prototype.update.call(this);

                if (this._isAnimated) {
                    this.animation.update();
                    this.width = this.atlas.cells[this.cellIndex].w;
                    this.height = this.atlas.cells[this.cellIndex].h;
                }

                this.input.update();
            };

            /**
            * Called by the Layer to which this Game Object is attached
            * @method render
            * @param {Camera} camera
            * @public
            */
            Sprite.prototype.render = function (camera) {
                _super.prototype.render.call(this, camera);

                //if it is would even be visible.
                if (this.alpha > 0 && this.visible) {
                    var ctx = this.game.stage.ctx;
                    ctx.save();

                    if (this.alpha > 0 && this.alpha <= 1) {
                        ctx.globalAlpha = this.alpha;
                    }

                    //get entity/view matrix
                    var t = this.transform;
                    var m = t.getConcatenatedMatrix();

                    var ct = camera.transform;

                    //ctx.setTransform(m.a, m.b, m.c, m.d, m.tx + t.rotPointX, m.ty + t.rotPointY);
                    ctx.transform(m.a, m.b, m.c, m.d, m.tx + t.rotPointX - ct.rotPointX, m.ty + t.rotPointY - ct.rotPointY);

                    var cell = this.atlas.cells[this.cellIndex];
                    ctx.drawImage(this.atlas.image, cell.x, cell.y, cell.w, cell.h, -t.rotPointX, -t.rotPointY, cell.w, cell.h);
                    ctx.restore();
                }
            };

            Sprite.prototype.renderGL = function (gl, camera, params) {
                if (typeof params === "undefined") { params = null; }
                this.glRenderer.addToBatch(gl, this, camera);
            };
            return Sprite;
        })(Kiwi.Entity);
        GameObjects.Sprite = Sprite;
    })(Kiwi.GameObjects || (Kiwi.GameObjects = {}));
    var GameObjects = Kiwi.GameObjects;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule GameObjects
*
*/
var Kiwi;
(function (Kiwi) {
    (function (GameObjects) {
        /**
        * A light weight game object for displaying static images that would have little or no interaction with other GameObjects. An Example of this would be a background image. Note: Since a StaticImage is lightweight it doesn't have any AnimationManager to handle the switching of cells (If you were using a SpriteSheet/TextureAtlas). In order to switch cells you can change the value of the cellIndex property.
        *
        * @class StaticImage
        * @namespace Kiwi.GameObjects
        * @extends Entity
        * @constructor
        * @param state {State} The state that this static image belongs to
        * @param atlas {TextureAtlas} The texture atlas to use as the image.
        * @param [x=0] {Number} Its coordinates on the x axis
        * @param [y=0] {Number} The coordinates on the y axis
        * @return {StaticImage}
        */
        var StaticImage = (function (_super) {
            __extends(StaticImage, _super);
            function StaticImage(state, atlas, x, y) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                _super.call(this, state, x, y);

                if (this.game.renderOption === Kiwi.RENDERER_WEBGL) {
                    this.glRenderer = this.game.renderer.requestSharedRenderer("TextureAtlasRenderer");
                }

                //Texture atlas error check.
                if (typeof atlas == "undefined") {
                    console.error('A Texture Atlas was not passed when instantiating a new Static Image.');
                    this.willRender = false;
                    this.active = false;
                    return;
                }

                //Set coordinates and texture
                this.atlas = atlas;
                this.cellIndex = this.atlas.cellIndex;
                this.width = atlas.cells[0].w;
                this.height = atlas.cells[0].h;
                this.transform.rotPointX = this.width / 2;
                this.transform.rotPointY = this.height / 2;

                this.box = this.components.add(new Kiwi.Components.Box(this, x, y, this.width, this.height));
            }
            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {string}
            * @public
            */
            StaticImage.prototype.objType = function () {
                return "Sprite";
            };

            /**
            * Called by the Layer to which this Game Object is attached
            * @method render
            * @param {Camara} camera
            * @public
            */
            StaticImage.prototype.render = function (camera) {
                _super.prototype.render.call(this, camera);

                //if it is would even be visible.
                if (this.alpha > 0 && this.visible) {
                    var ctx = this.game.stage.ctx;
                    ctx.save();

                    if (this.alpha > 0 && this.alpha <= 1) {
                        ctx.globalAlpha = this.alpha;
                    }

                    //get entity/view matrix
                    var t = this.transform;
                    var m = t.getConcatenatedMatrix();

                    var ct = camera.transform;

                    //ctx.setTransform(m.a, m.b, m.c, m.d, m.tx + t.rotPointX, m.ty + t.rotPointY);
                    ctx.transform(m.a, m.b, m.c, m.d, m.tx + t.rotPointX - ct.rotPointX, m.ty + t.rotPointY - ct.rotPointY);

                    var cell = this.atlas.cells[this.cellIndex];
                    ctx.drawImage(this.atlas.image, cell.x, cell.y, cell.w, cell.h, -t.rotPointX, -t.rotPointY, cell.w, cell.h);
                    ctx.restore();
                }
            };

            StaticImage.prototype.renderGL = function (gl, camera, params) {
                if (typeof params === "undefined") { params = null; }
                this.glRenderer.addToBatch(gl, this, camera);
            };
            return StaticImage;
        })(Kiwi.Entity);
        GameObjects.StaticImage = StaticImage;
    })(Kiwi.GameObjects || (Kiwi.GameObjects = {}));
    var GameObjects = Kiwi.GameObjects;
})(Kiwi || (Kiwi = {}));
/**
* Kiwi - GameObjects
* @module Kiwi
* @submodule GameObjects
*
*/
var Kiwi;
(function (Kiwi) {
    (function (GameObjects) {
        /**
        * Textfield is a GameObject that is used when you are wanting to render text onto the current State. The Textfield is not designed to have any interaction with other GameObjects and as such it does not have many (if any) components or even a width/height.
        *
        * @class Textfield
        * @namespace Kiwi.GameObjects
        * @extends Entity
        * @constructor
        * @param state {State} The state that this Textfield belongs to
        * @param text {String} The text that is contained within this textfield.
        * @param [x=0] {Number} The new x coordinate from the Position component
        * @param [y=0] {Number} The new y coordinate from the Position component
        * @param [color='#000000'] {String} The color of the text.
        * @param [size=32] {Number} The size of the text in pixels.
        * @param [weight='normal'] {String} The weight of the text.
        * @param [fontFamily='sans-serif'] {String} The font family that is to be used when rendering.
        * @return {Textfield} This Game Object.
        */
        var Textfield = (function (_super) {
            __extends(Textfield, _super);
            function Textfield(state, text, x, y, color, size, weight, fontFamily) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof color === "undefined") { color = '#000000'; }
                if (typeof size === "undefined") { size = 32; }
                if (typeof weight === "undefined") { weight = 'normal'; }
                if (typeof fontFamily === "undefined") { fontFamily = 'sans-serif'; }
                _super.call(this, state, x, y);
                /**
                * If the temporary canvas is dirty and needs to be re-rendered. Only used when the text field rendering is being optimised.
                * @property _tempDirty
                * @type boolean
                */
                this._tempDirty = true;

                if (this.game.renderOption === Kiwi.RENDERER_WEBGL) {
                    this.glRenderer = this.game.renderer.requestSharedRenderer("TextureAtlasRenderer");
                }

                this._text = text;
                this._fontWeight = weight;
                this._fontSize = size;
                this._fontColor = color;
                this._fontFamily = fontFamily;
                this._textAlign = 'left';
                this._baseline = 'top';

                this._tempDirty = true;

                //Create the canvas
                this._canvas = document.createElement('canvas');
                this._canvas.width = 2;
                this._canvas.height = 2;
                this._ctx = this._canvas.getContext('2d');

                //Add it to the TextureLibrary
                this.atlas = new Kiwi.Textures.SingleImage(this.game.rnd.uuid(), this._canvas);
                this.state.textureLibrary.add(this.atlas);
                this.atlas.dirty = true;
            }
            /**
            * Returns the type of object that this is
            * @method objType
            * @return {string}
            * @public
            */
            Textfield.prototype.objType = function () {
                return "Textfield";
            };

            Object.defineProperty(Textfield.prototype, "text", {
                get: function () {
                    return this._text;
                },
                /**
                * The text that you would like to appear in this textfield.
                * @property text
                * @type string
                * @public
                */
                set: function (value) {
                    this._text = value;
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Textfield.prototype, "color", {
                get: function () {
                    return this._fontColor;
                },
                /**
                * The color of the font that is contained in this textfield.
                * @property color
                * @type string
                * @public
                */
                set: function (val) {
                    this._fontColor = val;
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Textfield.prototype, "fontWeight", {
                get: function () {
                    return this._fontWeight;
                },
                /**
                * The weight of the font.
                * @property fontWeight
                * @type string
                * @public
                */
                set: function (val) {
                    this._fontWeight = val;
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Textfield.prototype, "fontSize", {
                get: function () {
                    return this._fontSize;
                },
                /**
                * The size on font when being displayed onscreen.
                * @property fontSize
                * @type number
                * @public
                */
                set: function (val) {
                    this._fontSize = val;
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Textfield.prototype, "fontFamily", {
                get: function () {
                    return this._fontFamily;
                },
                /**
                * The font family that is being used to render the text.
                * @property fontFamily
                * @type string
                * @public
                */
                set: function (val) {
                    this._fontFamily = val;
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Textfield.prototype, "textAlign", {
                /**
                * Returns a string containing the text alignment for this textfield.
                * @type string
                * @public
                */
                get: function () {
                    return this._textAlign;
                },
                /**
                * Changes the alignment of the text. You can either use the static TEXT_ALIGN constants or pass a string.
                * @type string
                * @public
                */
                set: function (val) {
                    this._textAlign = val;
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * This method is used to render the text to an offscreen-canvas which is held in a TextureAtlas (which is generated upon the instanitation of this class).
            * This is so that the canvas doesn't render it every frame as it can be costly and so that it can be used in WebGL with the TextureAtlasRenderer.
            *
            * @method _renderText
            * @private
            */
            Textfield.prototype._renderText = function () {
                //Get/Set the width
                this._ctx.font = this._fontWeight + ' ' + this._fontSize + 'px ' + this._fontFamily;

                //Get the size of the text.
                var _measurements = this._ctx.measureText(this._text);
                var width = _measurements.width;
                var height = this._fontSize * 1.3;

                //Is the width base2?
                if (Kiwi.Utils.Common.base2Sizes.indexOf(width) == -1) {
                    var i = 0;
                    while (width > Kiwi.Utils.Common.base2Sizes[i])
                        i++;
                    width = Kiwi.Utils.Common.base2Sizes[i];
                }

                //Is the height base2?
                if (Kiwi.Utils.Common.base2Sizes.indexOf(height) == -1) {
                    var i = 0;
                    while (height > Kiwi.Utils.Common.base2Sizes[i])
                        i++;
                    height = Kiwi.Utils.Common.base2Sizes[i];
                }

                //Apply the width/height
                this._canvas.width = width;
                this._canvas.height = height;

                //Reapply the styles....cause it unapplies after a measurement...?!?
                this._ctx.font = this._fontWeight + ' ' + this._fontSize + 'px ' + this._fontFamily;
                this._ctx.fillStyle = this._fontColor;
                this._ctx.textBaseline = this._baseline;

                //Draw the text.
                this._ctx.fillText(this._text, 0, 0);

                //Update the cell and dirty/undirtyfiy
                this.atlas.cells[0] = { x: 0, y: 0, w: this._canvas.width, h: this._canvas.height };
                this._tempDirty = false;
                this.atlas.dirty = true;
            };

            /**
            * Called by the Layer to which this Game Object is attached
            * @method render
            * @param {Camera}
            * @public
            */
            Textfield.prototype.render = function (camera) {
                if (this.alpha > 0 && this.visible) {
                    //render on stage
                    var ctx = this.game.stage.ctx;
                    ctx.save();

                    var t = this.transform;
                    if (this.alpha > 0 && this.alpha <= 1) {
                        ctx.globalAlpha = this.alpha;
                    }

                    //Does the text need re-rendering
                    if (this._tempDirty)
                        this._renderText();

                    //Align the text
                    var x = 0;
                    switch (this._textAlign) {
                        case Kiwi.GameObjects.Textfield.TEXT_ALIGN_LEFT:
                            x = 0;
                            break;
                        case Kiwi.GameObjects.Textfield.TEXT_ALIGN_CENTER:
                            x = this._canvas.width / 2;
                            break;
                        case Kiwi.GameObjects.Textfield.TEXT_ALIGN_RIGHT:
                            x = this._canvas.width;
                            break;
                    }

                    //Draw the Image
                    var m = t.getConcatenatedMatrix();
                    ctx.setTransform(m.a, m.b, m.c, m.d, m.tx - x + t.rotPointX, m.ty + t.rotPointY);
                    ctx.drawImage(this._canvas, 0, 0, this._canvas.width, this._canvas.height, -t.rotPointX, -t.rotPointY, this._canvas.width, this._canvas.height);

                    ctx.restore();
                }
            };

            Textfield.prototype.renderGL = function (gl, camera, params) {
                if (typeof params === "undefined") { params = null; }
                //Does the text need re-rendering
                if (this._tempDirty)
                    this._renderText();

                //Set-up the xyuv and alpha
                var vertexItems = [];

                //Transform/Matrix
                var t = this.transform;
                var m = t.getConcatenatedMatrix();

                //See where the text should be.
                var x = 0;
                switch (this._textAlign) {
                    case Kiwi.GameObjects.Textfield.TEXT_ALIGN_LEFT:
                        x = 0;
                        break;
                    case Kiwi.GameObjects.Textfield.TEXT_ALIGN_CENTER:
                        x = -(this._canvas.width / 2);
                        break;
                    case Kiwi.GameObjects.Textfield.TEXT_ALIGN_RIGHT:
                        x = -(this._canvas.width);
                        break;
                }

                //Create the Point Objects.
                var pt1 = new Kiwi.Geom.Point(x - t.rotPointX, 0 - t.rotPointY);
                var pt2 = new Kiwi.Geom.Point(this._canvas.width + x - t.rotPointX, 0 - t.rotPointY);
                var pt3 = new Kiwi.Geom.Point(this._canvas.width + x - t.rotPointX, this._canvas.height - t.rotPointY);
                var pt4 = new Kiwi.Geom.Point(x - t.rotPointX, this._canvas.height - t.rotPointY);

                //Add on the matrix to the points
                pt1 = m.transformPoint(pt1);
                pt2 = m.transformPoint(pt2);
                pt3 = m.transformPoint(pt3);
                pt4 = m.transformPoint(pt4);

                //Append to the xyuv and alpha arrays
                vertexItems.push(pt1.x + t.rotPointX, pt1.y + t.rotPointY, 0, 0, this.alpha, pt2.x + t.rotPointX, pt2.y + t.rotPointY, this._canvas.width, 0, this.alpha, pt3.x + t.rotPointX, pt3.y + t.rotPointY, this._canvas.width, this._canvas.height, this.alpha, pt4.x + t.rotPointX, pt4.y + t.rotPointY, 0, this._canvas.height, this.alpha);

                //Add to the batch!
                this.glRenderer.concatBatch(vertexItems);
            };
            Textfield.TEXT_ALIGN_CENTER = 'center';

            Textfield.TEXT_ALIGN_RIGHT = 'right';

            Textfield.TEXT_ALIGN_LEFT = 'left';
            return Textfield;
        })(Kiwi.Entity);
        GameObjects.Textfield = Textfield;
    })(Kiwi.GameObjects || (Kiwi.GameObjects = {}));
    var GameObjects = Kiwi.GameObjects;
})(Kiwi || (Kiwi = {}));
/**
*
* @module GameObjects
* @submodule Tilemap
*
*/
var Kiwi;
(function (Kiwi) {
    (function (GameObjects) {
        (function (Tilemap) {
            /**
            * Define's the properties of a single Type of Tile for a TileMap. This class should not be directly instanted,
            * but instead when wanting to create new TileType's you should use the 'createdTileType' methods on a TileMap object.
            *
            * @class TileType
            * @namespace Kiwi.GameObjects.Tilemap
            * @constructor
            * @param tilemap {TileMap} The TileMap that this TileType is a part of.
            * @param index {Number} The index of this TileType, which Tiles use when wanting to use this TileType.
            * @param cellIndex {Number} The cell number to use when rendering this Type of Tile.
            * @return {TileType} This TileType
            * @public
            */
            var TileType = (function () {
                function TileType(tilemap, index, cellIndex) {
                    if (typeof cellIndex === "undefined") { cellIndex = -1; }
                    /**
                    * The collision information for this type of tile.
                    * It's values are the same as the Static properties inside of the ArcadePhysics Component.
                    * @property allowCollisions
                    * @type number
                    * @default NONE
                    * @public
                    */
                    this.allowCollisions = Kiwi.Components.ArcadePhysics.NONE;
                    /**
                    * The properties associated with this type of tile.
                    * These are set when loading a JSON file that had properties associated with a TileType.
                    * @property properties
                    * @type Object
                    * @public
                    */
                    this.properties = {};
                    this.tilemap = tilemap;
                    this.index = index;
                    this.cellIndex = cellIndex;
                }
                /**
                * The type of object that it is.
                * @method objType
                * @return {String}
                * @public
                */
                TileType.prototype.objType = function () {
                    return "TileType";
                };
                return TileType;
            })();
            Tilemap.TileType = TileType;
        })(GameObjects.Tilemap || (GameObjects.Tilemap = {}));
        var Tilemap = GameObjects.Tilemap;
    })(Kiwi.GameObjects || (Kiwi.GameObjects = {}));
    var GameObjects = Kiwi.GameObjects;
})(Kiwi || (Kiwi = {}));
/**
*
* @module GameObjects
* @submodule Tilemap
* @main Tilemap
*/
var Kiwi;
(function (Kiwi) {
    (function (GameObjects) {
        (function (Tilemap) {
            /**
            * A TileMap handles the creation of TileMapLayers and the TileTypes that they use.
            * Since a TileMap isn't a Entity itself you cannot add it to the Stage inorder to render that it manages,
            * Instead you have to add each layer lies within it. This way you can have other GameObjects behind/in-front of layers.
            *
            * @class TileMap
            * @namespace Kiwi.GameObjects.Tilemap
            * @constructor
            * @param state {State} The state that this Tilemap is on.
            * @param [tileMapDataKey] {String} The Data key for the JSON you would like to use.
            * @param [atlas] {TextureAtlas} The texture atlas that you would like the tilemap layers to use.
            * @param [startingCell=0] {number} The number for the initial cell that the first TileType should use. See 'createFromFileStore' for more information.
            * @return {TileMap}
            */
            var TileMap = (function () {
                function TileMap(state, tileMapData, atlas, startingCell) {
                    if (typeof startingCell === "undefined") { startingCell = 0; }
                    /**
                    * The default width of a single tile that a TileMapLayer is told to have upon its creation.
                    * @property tileWidth
                    * @type Number
                    * @default 0
                    * @public
                    */
                    this.tileWidth = 0;
                    /**
                    * The default height of a single tile that a TileMapLayer is told to have upon its creation.
                    * @property tileHeight
                    * @type Number
                    * @default 0
                    * @public
                    */
                    this.tileHeight = 0;
                    /**
                    * The default width of all TileMapLayers when they are created.
                    * This value is in Tiles.
                    * @property width
                    * @type Number
                    * @default 0
                    * @public
                    */
                    this.width = 0;
                    /**
                    * The default height of all TileMapLayers when they are created.
                    * This value is in Tiles.
                    * @property height
                    * @type Number
                    * @default 0
                    * @public
                    */
                    this.height = 0;
                    /**
                    * Any properties that were found in the JSON during creation.
                    * @property properties
                    * @type Object
                    * @public
                    */
                    this.properties = {};
                    this.tileTypes = [];
                    this.createTileType(-1);
                    this.layers = [];

                    this.state = state;
                    this.game = state.game;

                    if (tileMapData !== undefined && atlas !== undefined) {
                        this.createFromFileStore(tileMapData, atlas, startingCell);
                    } else if (tileMapData !== undefined || atlas !== undefined) {
                        console.log('You must pass BOTH the TileMapDataKey and TextureAtlas inorder to create a TileMap from the File Store.');
                    }
                }
                Object.defineProperty(TileMap.prototype, "widthInPixels", {
                    /**
                    * The width of the tilemap in pixels. This value is READ ONLY.
                    * @property widthInPixels
                    * @type Number
                    * @public
                    */
                    get: function () {
                        return this.width * this.tileWidth;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(TileMap.prototype, "heightInPixels", {
                    /**
                    * The height of the tilemap in pixels. This value is READ ONLY.
                    * @property heightInPixels
                    * @type Number
                    * @public
                    */
                    get: function () {
                        return this.height * this.tileHeight;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Creates new tilemap layers from a JSON file that you pass (has to be in the Tiled Format).
                * The texture atlas you pass is that one that eeach TileMapLayer found in the JSON will use, You can change the TextureAtlas afterwards.
                * New TileTypes will automatically be created. The number is based on the Tileset parameter of the JSON.
                * The cell used for new TileTypes will begin at 0 and increment each time a new TileType is created (and a cell exists). Otherwise new TileTypes will start will a cell of -1 (none).
                * @method createFromFileStore
                * @param tileMapData {Any} This can either
                * @param atlas {TextureAtlas} The texture atlas that you would like the tilemap layers to use.
                * @param [startingCell=0] {number} The number for the initial cell that the first TileType should use. If you pass -1 then no new TileTypes will be created.
                * @public
                */
                TileMap.prototype.createFromFileStore = function (tileMapData, atlas, startingCell) {
                    if (typeof startingCell === "undefined") { startingCell = 0; }
                    var json = null;

                    switch (typeof tileMapData) {
                        case 'string':
                            if (this.game.fileStore.exists(tileMapData) == false) {
                                console.error('The JSON file you have told to use for a TileMap does not exist.');
                                return false;
                            }

                            var json = JSON.parse(this.game.fileStore.getFile(tileMapData).data);
                            break;

                        case 'object':
                            json = tileMapData;
                            break;

                        default:
                            console.error('The type of TileMapData passed could not be idenified. Please either pass a name of JSON file to use OR an object to be used.');
                    }

                    //Get the map information
                    this.orientation = (json.orietation == undefined) ? "orthogonal" : json.orientation;
                    this.tileWidth = (json.tilewidth == undefined) ? 32 : json.tilewidth;
                    this.tileHeight = (json.tileheight == undefined) ? 32 : json.tileheight;
                    this.width = json.width;
                    this.height = json.height;

                    for (var prop in json.properties) {
                        this.properties[prop] = json.properties[prop];
                    }

                    //Generate the Tiles needed.
                    if (json.tilesets !== "undefined" && startingCell !== -1)
                        this._generateTypesFromTileset(json.tilesets, atlas, startingCell);

                    for (var i = 0; i < json.layers.length; i++) {
                        var layerData = json.layers[i];

                        switch (json.layers[i].type) {
                            case "tilelayer":
                                var w = (layerData.width !== undefined) ? layerData.width : this.width;
                                var h = (layerData.height !== undefined) ? layerData.height : this.height;

                                var layer = this.createNewLayer(layerData.name, atlas, layerData.data, w, h, layerData.x * this.tileWidth, layerData.y * this.tileHeight);

                                //Add the extra data...
                                layer.visible = (layerData.visible == undefined) ? true : layerData.visible;
                                layer.alpha = (layerData.opacity == undefined) ? 1 : layerData.opacity;
                                if (layerData.properties !== undefined)
                                    layer.properties = layerData.properties;

                                break;

                            case "objectgroup":
                                this.createNewObjectLayer();
                                break;

                            case "imagelayer":
                                this.createNewImageLayer();
                                break;
                        }
                    }
                };

                /**
                * Generates new TileTypes based upon the Tileset information that lies inside the Tiled JSON.
                * This is an INTERNAL method, which is used when the createFromFileStore method is executed.
                * @method _generateTypesFromTileset
                * @param tilesetData {Any[]} The tileset part of the JSON.
                * @param atlas {TextureAtlas} The Texture atlas which contains the cells that the new TileTypes will use.
                * @param startingCell {Number} The first cell number that would be used.
                * @private
                */
                TileMap.prototype._generateTypesFromTileset = function (tilesetData, atlas, startingCell) {
                    for (var i = 0; i < tilesetData.length; i++) {
                        var tileset = tilesetData[i];

                        //Tileset Information
                        var m = tileset.margin;
                        var s = tileset.spacing;
                        var tw = tileset.tilewidth;
                        var th = tileset.tileheight;
                        var iw = tileset.imagewidth - m;
                        var ih = tileset.imageheight - m;

                        for (var y = m; y < ih; y += th) {
                            for (var x = m; x < iw; x += tw) {
                                //Does the cell exist? Then use that.
                                var cell = (atlas.cells[startingCell] == undefined) ? -1 : startingCell;

                                this.createTileType(cell);
                                startingCell++; //Increase the cell to use by one.
                            }
                        }

                        for (var tp in tileset.tileproperties) {
                            this.tileTypes[(parseInt(tileset.firstgid) + parseInt(tp))].properties = tileset.tileproperties[tp];
                        }
                    }
                };

                /**
                * Method to set the default TileMap properties. Useful when wanting to create tilemaps programmatically.
                * @method setTo
                * @param tileWidth {Number} The width of a single tile.
                * @param tileHeight {Number} The height of a single tile.
                * @param width {Number} The width of the whole map.
                * @param height {Number} The height of the whole map.
                * @public
                */
                TileMap.prototype.setTo = function (tileWidth, tileHeight, width, height) {
                    this.tileWidth = tileWidth;
                    this.tileHeight = tileHeight;
                    this.width = width;
                    this.height = height;
                };

                /**
                *-----------------------
                * Creation of Tile Types
                *-----------------------
                **/
                /**
                * Generates a single new TileType. Returns the TileType that was generated.
                * @method createTileType
                * @param [cell=-1] {Number} The cell that is to be used. Default is -1 (which means none)
                * @return {TileType} The TileType generated.
                * @public
                */
                TileMap.prototype.createTileType = function (cell) {
                    if (typeof cell === "undefined") { cell = -1; }
                    var tileType = new Kiwi.GameObjects.Tilemap.TileType(this, this.tileTypes.length, cell);
                    this.tileTypes.push(tileType);

                    return tileType;
                };

                /**
                * Creates a new TileType for each cell that you pass.
                * @method createTileTypes
                * @param cells {Number[]} The cells that you want a new TileType created for.
                * @return {TileTypes[]} The TileTypes generated.
                * @public
                */
                TileMap.prototype.createTileTypes = function (cells) {
                    var types = [];
                    for (var i = 0; i < cells.length; i++) {
                        types.push(this.createTileType(cells[i]));
                    }
                    return types;
                };

                /**
                * Used to create a number of TileTypes based starting cell number and how many you want from there.
                * @method createTileTypesByRange
                * @param cellStart {Number} The starting number of the cell.
                * @param range {Number} How many cells (from the starting cell) should be created.
                * @return {TileTypes[]} The TileTypes generated.
                */
                TileMap.prototype.createTileTypesByRange = function (cellStart, range) {
                    var types = [];
                    for (var i = cellStart; i <= cellStart + range; i++) {
                        types.push(this.createTileType(i));
                    }
                    return types;
                };

                /**
                *-----------------------
                * Cell Modifications
                *-----------------------
                **/
                /**
                * Changes a single cellIndex that a TileType is to use when it is rendered.
                * @method setCell
                * @param type {number} The number of the TileType that is to change.
                * @param cell {number} The new cellIndex it should have.
                * @public
                */
                TileMap.prototype.setCell = function (type, cell) {
                    this.tileTypes[type].cellIndex = cell;
                };

                /**
                * Changes a range of cellIndexs for Tiles the same range of TileTypes.
                * @method setCellsByRange
                * @param typeStart {number} The starting TileType that is to be modified.
                * @param cellStart {number} The starting cellIndex that the first TileType should have.
                * @param range {number} How many times it should run.
                * @public
                */
                TileMap.prototype.setCellsByRange = function (typeStart, cellStart, range) {
                    for (var i = typeStart; i < typeStart + range; i++) {
                        this.tileTypes[i].cellIndex = cellStart;
                        cellStart++;
                    }
                };

                /**
                *-----------------------
                * Creation of Tilemap Layers
                *-----------------------
                **/
                /**
                * Creates a new TileMapLayer with the details that are provided.
                * If no width/height/tileWidth/tileHeight parameters are passed then the values will be what this TileMap has.
                * If no 'data' is provided then the map will be automatically filled with empty Types of Tiles.
                * Returns the new TileMapLayer that was created.
                * @method createNewLayer
                * @param name {String} Name of the TileMap.
                * @param atlas {TextureAtlas} The TextureAtlas that this layer should use.
                * @param data {Number[]} The tile information.
                * @param [w=this.width] {Number} The width of the whole tile map. In Tiles.
                * @param [h=this.height] {Number} The height of the whole tile map. In Tiles.
                * @param [x=0] {Number} The position of the tilemap on the x axis. In pixels.
                * @param [y=0] {Number} The position of the tilemap on the y axis. In pixels.
                * @param [tw=this.tileWidth] {Number} The width of a single tile.
                * @param [th=this.tileHeight] {Number} The height of a single tile.
                * @return {TileMapLayer} The TileMapLayer that was created.
                * @public
                */
                TileMap.prototype.createNewLayer = function (name, atlas, data, w, h, x, y, tw, th) {
                    if (typeof data === "undefined") { data = []; }
                    if (typeof w === "undefined") { w = this.width; }
                    if (typeof h === "undefined") { h = this.height; }
                    if (typeof x === "undefined") { x = 0; }
                    if (typeof y === "undefined") { y = 0; }
                    if (typeof tw === "undefined") { tw = this.tileWidth; }
                    if (typeof th === "undefined") { th = this.tileHeight; }
                    //Did the user provide enough data?
                    if (data.length < w * h) {
                        //No... So push empty cells instead
                        var i = data.length - 1;
                        while (++i < w * h) {
                            data.push(0);
                        }
                    }

                    //Create the new layer
                    var layer = new Kiwi.GameObjects.Tilemap.TileMapLayer(this, name, atlas, data, tw, th, x, y, w, h);

                    //Add the new layer to the array
                    this.layers.push(layer);

                    return layer;
                };

                /**
                * Eventually will create a new object layer. Currently does nothing.
                * @method createNewObjectLayer
                * @public
                */
                TileMap.prototype.createNewObjectLayer = function () {
                    console.log("OBJECT GROUP layers are currently not supported.");
                };

                /**
                * Eventually will create a new image layer. Currently does nothing.
                * @method createNewObjectLayer
                * @public
                */
                TileMap.prototype.createNewImageLayer = function () {
                    console.log("IMAGE layers are currently not supported.");
                };

                /**
                *-----------------------
                * TileMapLayer Management Functions
                *-----------------------
                **/
                /**
                * Get a layer by the name that it was given upon creation.
                * Returns null if no layer with that name was found.
                * @method getLayerByName
                * @param name {String} Name of the layer you would like to select.
                * @return {TileMapLayer} Either the layer with the name passed, or null if no Layer with that name was found.
                * @public
                */
                TileMap.prototype.getLayerByName = function (name) {
                    for (var i = 0; i < this.layers.length; i++) {
                        if (this.layers[i].name == name) {
                            return this.layers[i];
                        }
                    }
                    return null;
                };

                /**
                * Returns the layer with the number associated with it in the layers array.
                * @method getLayer
                * @param num {Number} Number of the Layer you would like to get.
                * @return {TileMapLayer}
                * @public
                */
                TileMap.prototype.getLayer = function (num) {
                    return (this.layers[num] !== undefined) ? this.layers[num] : null;
                };

                /**
                * The type of object that it is.
                * @method objType
                * @return {String}
                * @public
                */
                TileMap.prototype.objType = function () {
                    return "TileMap";
                };
                return TileMap;
            })();
            Tilemap.TileMap = TileMap;
        })(GameObjects.Tilemap || (GameObjects.Tilemap = {}));
        var Tilemap = GameObjects.Tilemap;
    })(Kiwi.GameObjects || (Kiwi.GameObjects = {}));
    var GameObjects = Kiwi.GameObjects;
})(Kiwi || (Kiwi = {}));
/**
*
* @module GameObjects
* @submodule Tilemap
*
*/
var Kiwi;
(function (Kiwi) {
    (function (GameObjects) {
        (function (Tilemap) {
            /**
            * Is GameObject that contains the information held for a single Layer of Tiles, along with methods to handle the rendering of those Tiles.
            * A TileMapLayer should not be directly created, but instead should be created through a TileMap object instead.
            *
            * @class TileMapLayer
            * @extends Entity
            * @namespace Kiwi.GameObjects.Tilemap
            * @constructor
            * @param tilemap {TileMap} The TileMap that this layer belongs to.
            * @param name {String} The name of this TileMapLayer.
            * @param atlas {TextureAtlas} The texture atlas that should be used when rendering this TileMapLayer onscreen.
            * @param data {Number[]} The information about the tiles.
            * @param tw {Number} The width of a single tile in pixels. Usually the same as the TileMap unless told otherwise.
            * @param th {Number} The height of a single tile in pixels. Usually the same as the TileMap unless told otherwise.
            * @param [x=0] {Number} The x coordinate of the tilemap in pixels.
            * @param [y=0] {Number} The y coordinate of the tilemap in pixels.
            * @param [w=0] {Number} The width of the whole tilemap in tiles. Usually the same as the TileMap unless told otherwise.
            * @param [h=0] {Number} The height of the whole tilemap in tiles. Usually the same as the TileMap unless told otherwise.
            * @return {TileMapLayer}
            */
            var TileMapLayer = (function (_super) {
                __extends(TileMapLayer, _super);
                function TileMapLayer(tilemap, name, atlas, data, tw, th, x, y, w, h) {
                    if (typeof x === "undefined") { x = 0; }
                    if (typeof y === "undefined") { y = 0; }
                    if (typeof w === "undefined") { w = 0; }
                    if (typeof h === "undefined") { h = 0; }
                    _super.call(this, tilemap.state, x, y);
                    /**
                    * Properties about that this TileMapLayer has when it was created from a JSON file.
                    * @property properties
                    * @type Object
                    * @public
                    */
                    this.properties = {};

                    //Request the Shared Texture Atlas renderer.
                    if (this.game.renderOption === Kiwi.RENDERER_WEBGL) {
                        this.glRenderer = this.game.renderer.requestSharedRenderer("TextureAtlasRenderer");
                    }

                    this.name = name;
                    this.atlas = atlas;
                    this.tilemap = tilemap;
                    this._data = data;
                    this.tileWidth = tw;
                    this.tileHeight = th;
                    this.width = w;
                    this.height = h;
                    this.cellIndex = null; //Cell Index doesn't matter for a TileMapLayer itself.

                    this.physics = this.components.add(new Kiwi.Components.ArcadePhysics(this, null));
                    this.physics.immovable = true;
                }
                /**
                * Returns the type of child that this is.
                * @type Number
                * @return {Number} returns the type of child that the entity is
                * @public
                */
                TileMapLayer.prototype.childType = function () {
                    return Kiwi.TILE_LAYER;
                };

                /**
                * The type of object that it is.
                * @method objType
                * @return {String}
                * @public
                */
                TileMapLayer.prototype.objType = function () {
                    return "TileMapLayer";
                };

                Object.defineProperty(TileMapLayer.prototype, "widthInPixels", {
                    /**
                    * The width of the layer in pixels. This property is READ ONLY.
                    * @property widthInPixels
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this.width * this.tilemap.tileWidth;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(TileMapLayer.prototype, "heightInPixels", {
                    /**
                    * The height of the layer in pixels. This property is READ ONLY.
                    * @property heightInPixels
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this.height * this.tilemap.tileHeight;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Returns the total number of tiles. Either for a particular type if passed, otherwise of any type if not passed.
                * @method countTiles
                * @param [type] {Number} The type of tile you want to count.
                * @return {Number} The number of tiles on this layer.
                * @public
                */
                TileMapLayer.prototype.countTiles = function (type) {
                    var cnt = 0;

                    for (var i = 0; i < this._data.length; i++) {
                        if (type == undefined && this._data[i] !== 0)
                            cnt++;
                        else if (type === this._data[i])
                            cnt++;
                    }

                    return cnt;
                };

                Object.defineProperty(TileMapLayer.prototype, "tileData", {
                    /**
                    *-----------------------
                    * Getting Tiles
                    *-----------------------
                    */
                    /**
                    * A list containing all of the types of tiles found on this TileMapLayer. This is READ ONLY.
                    * @property tileData
                    * @type number[]
                    * @public
                    */
                    get: function () {
                        return this._data;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Returns the index of the tile based on the x and y coordinates of the tile passed.
                * If no tile is a the coordinates given then -1 is returned instead.
                * Coordinates are in tiles not pixels.
                * @method getIndexFromXY
                * @param x {Number} The x coordinate of the Tile you would like to retrieve.
                * @param y {Number} The y coordinate of the Tile you would like to retrieve.
                * @return {Number} Either the index of the tile retrieved or -1 if none was found.
                * @public
                */
                TileMapLayer.prototype.getIndexFromXY = function (x, y) {
                    var num = x + y * this.width;

                    //Does the index exist?
                    if (num < 0 || num >= this._data.length)
                        return -1;
                    else
                        return num;
                };

                /**
                * Returns the TileType for a tile that is at a particular set of coordinates passed.
                * If no tile is found the null is returned instead.
                * Coordinates passed are in tiles.
                * @method getTileFromXY
                * @param x {Number}
                * @param y {Number}
                * @return {Number} The tile
                * @public
                */
                TileMapLayer.prototype.getTileFromXY = function (x, y) {
                    var t = this.getIndexFromXY(x, y);
                    return (t !== -1) ? this.tilemap.tileTypes[this._data[t]] : null;
                };

                /**
                * Returns the index of the tile based on the x and y pixel coordinates that are passed.
                * If no tile is a the coordinates given then -1 is returned instead.
                * Coordinates are in pixels not tiles and use the world coordinates of the tilemap.
                * @method getIndexFromCoords
                * @param x {Number} The x coordinate of the Tile you would like to retrieve.
                * @param y {Number} The y coordinate of the Tile you would like to retrieve.
                * @return {Number} Either the index of the tile retrieved or -1 if none was found.
                * @public
                */
                TileMapLayer.prototype.getIndexFromCoords = function (x, y) {
                    //Not with the bounds?
                    if (x > this.transform.worldX + this.widthInPixels || y > this.transform.worldY + this.heightInPixels || x < this.transform.worldX || y < this.transform.worldY)
                        return -1;

                    //Is so get the tile
                    var tx = Kiwi.Utils.GameMath.snapToFloor(x - this.transform.worldX, this.tileWidth) / this.tileWidth;
                    var ty = Kiwi.Utils.GameMath.snapToFloor(y - this.transform.worldY, this.tileHeight) / this.tileHeight;

                    return this.getIndexFromXY(tx, ty);
                };

                /**
                * Returns the TileType for a tile that is at a particular coordinate passed.
                * If no tile is found the null is returned instead.
                * Coordinates passed are in pixels and use the world coordinates of the tilemap.
                * @method getTileFromXY
                * @param x {Number}
                * @param y {Number}
                * @return {Number} The tile
                * @public
                */
                TileMapLayer.prototype.getTileFromCoords = function (x, y) {
                    var t = this.getIndexFromCoords(x, y);
                    return (t !== -1) ? this.tilemap.tileTypes[this._data[t]] : null;
                };

                /**
                * Returns the indexes of every tile of a type you pass.
                * @method getIndexsByType
                * @param type {Number}
                * @return {Number[]}
                * @public
                */
                TileMapLayer.prototype.getIndexesByType = function (type) {
                    var tiles = [];
                    for (var i = 0; i < this._data.length; i++) {
                        if (this._data[i] == type)
                            tiles.push(i);
                    }
                    return tiles;
                };

                /**
                *-----------------------
                * Tiles Manipulation
                *-----------------------
                */
                /**
                * Sets the tile to be used at the coordinates provided.
                * Can be used to override a tile that may already exist at the location.
                * @method setTile
                * @param x {number} The coordinate of the tile on the x axis.
                * @param y {number} The coordinate of the tile on the y axis.
                * @param tileType {number} The type of tile that should be now used.
                * @return {boolean} If a tile was changed or not.
                * @public
                */
                TileMapLayer.prototype.setTile = function (x, y, tileType) {
                    var x = this.getIndexFromXY(x, y);

                    if (x !== -1) {
                        this._data[x] = tileType;
                        return true;
                    }

                    return false;
                };

                /**
                * Sets the tile to be used at the index provided.
                * Can be used to override a tile that may already exist at the location.
                * @method setTileByIndex
                * @param index {number} The index of the tile that you want to change.
                * @param tileType {number} The new tile type to be used at that position.
                * @public
                */
                TileMapLayer.prototype.setTileByIndex = function (index, tileType) {
                    this._data[index] = tileType;
                };

                /**
                * Randomizes the types of tiles used in an area of the layer. You can choose which types of tiles to use, and the area.
                * Default tile types used are everyone avaiable.
                * @method randomizeTiles
                * @param [types] {number[]} A list of TileTypes that can be used. Default is every tiletype on the TileMap.
                * @param [x=0] {number} The starting tile on the x axis to fill.
                * @param [y=0] {number} The starting tile on the y axis to fill.
                * @param [width=this.width] {number} How far across you want to go.
                * @param [height=this.height] {number} How far down you want to go.
                * @public
                */
                TileMapLayer.prototype.randomizeTiles = function (types, x, y, width, height) {
                    if (typeof x === "undefined") { x = 0; }
                    if (typeof y === "undefined") { y = 0; }
                    if (typeof width === "undefined") { width = this.width; }
                    if (typeof height === "undefined") { height = this.height; }
                    if (types == undefined) {
                        types = [];
                        var i = 0;
                        while (i++ < this.tilemap.tileTypes.length) {
                            types.push(i);
                        }
                    }

                    for (var j = y; j < y + height; j++) {
                        for (var i = x; i < x + width; i++) {
                            var tile = this.getIndexFromXY(i, j);
                            if (tile !== -1)
                                this._data[tile] = this.game.rnd.pick(types);
                        }
                    }
                };

                /**
                * Makes all of the tiles in the area specified a single type that is passed.
                * @method fill
                * @param type {number} The type of tile you want to fill in the area with.
                * @param [x=0] {number} The starting tile on the x axis to fill.
                * @param [y=0] {number} The starting tile on the y axis to fill.
                * @param [width=this.width] {number} How far across you want to go.
                * @param [height=this.height] {number} How far down you want to go.
                * @public
                */
                TileMapLayer.prototype.fill = function (type, x, y, width, height) {
                    if (typeof x === "undefined") { x = 0; }
                    if (typeof y === "undefined") { y = 0; }
                    if (typeof width === "undefined") { width = this.width; }
                    if (typeof height === "undefined") { height = this.height; }
                    for (var j = y; j < y + height; j++) {
                        for (var i = x; i < x + width; i++) {
                            var tile = this.getIndexFromXY(i, j);
                            if (tile !== -1)
                                this._data[tile] = type;
                        }
                    }
                };

                /**
                * Replaces all tiles of typeA to typeB in the area specified. If no area is specified then it is on the whole layer.
                * @method replaceTiles
                * @param typeA {number} The type of tile you want to be replaced.
                * @param typeB {number} The type of tile you want to be used instead.
                * @param [x=0] {number} The starting tile on the x axis to fill.
                * @param [y=0] {number} The starting tile on the y axis to fill.
                * @param [width=this.width] {number} How far across you want to go.
                * @param [height=this.height] {number} How far down you want to go.
                * @public
                */
                TileMapLayer.prototype.replaceTiles = function (typeA, typeB, x, y, width, height) {
                    if (typeof x === "undefined") { x = 0; }
                    if (typeof y === "undefined") { y = 0; }
                    if (typeof width === "undefined") { width = this.width; }
                    if (typeof height === "undefined") { height = this.height; }
                    for (var j = y; j < y + height; j++) {
                        for (var i = x; i < x + width; i++) {
                            var tile = this.getIndexFromXY(i, j);
                            if (tile !== -1 && this._data[tile] == typeA)
                                this._data[tile] = typeB;
                        }
                    }
                };

                /**
                * Swaps all the tiles that are typeA -> typeB and typeB -> typeA inside the area specified. If no area is specified then it is on the whole layer.
                * @method swapTiles
                * @param typeA {number} The type of tile you want to be replaced with typeB.
                * @param typeB {number} The type of tile you want to be replaced with typeA.
                * @param [x=0] {number} The starting tile on the x axis to fill.
                * @param [y=0] {number} The starting tile on the y axis to fill.
                * @param [width=this.width] {number} How far across you want to go.
                * @param [height=this.height] {number} How far down you want to go.
                * @public
                */
                TileMapLayer.prototype.swapTiles = function (typeA, typeB, x, y, width, height) {
                    if (typeof x === "undefined") { x = 0; }
                    if (typeof y === "undefined") { y = 0; }
                    if (typeof width === "undefined") { width = this.width; }
                    if (typeof height === "undefined") { height = this.height; }
                    for (var j = y; j < y + height; j++) {
                        for (var i = x; i < x + width; i++) {
                            var tile = this.getIndexFromXY(i, j);

                            if (tile !== -1) {
                                if (this._data[tile] == typeA)
                                    this._data[tile] = typeB;
                                else if (this._data[tile] == typeB)
                                    this._data[tile] = typeA;
                            }
                        }
                    }
                };

                /**
                *-----------------------
                * Get Tiles By Collision Methods
                *-----------------------
                */
                /**
                * Returns the tiles which overlap with a provided entities box component.
                * Only collidable tiles on ANY side will be returned unless you pass a particular side.
                *
                * @method getOverlappingTiles
                * @param entity {Entity} The entity you would like to check for the overlap.
                * @param [collisionType=ANY] {Number} The particular type of collidable tiles which you would like to check for.
                * @return {Object[]} Returns an Array of Objects containing information about the tiles which were found. Index/X/Y information is contained within each Object.
                * @public
                */
                TileMapLayer.prototype.getOverlappingTiles = function (entity, collisionType) {
                    if (typeof collisionType === "undefined") { collisionType = Kiwi.Components.ArcadePhysics.ANY; }
                    //Do they have a box?
                    if (entity.components.hasComponent("Box") == false)
                        return [];

                    //Get the box off them
                    var b = entity.components.getComponent('Box').worldHitbox;

                    //Is the person within the map's bounds?
                    if (b.left > this.transform.worldX + this.widthInPixels || b.right < this.transform.worldX || b.bottom < this.transform.worldY || b.top > this.transform.worldY + this.heightInPixels)
                        return [];

                    //Get starting location and now many tiles from there we will check.
                    var x = Kiwi.Utils.GameMath.snapToFloor(b.x - this.transform.worldX, this.tileWidth) / this.tileWidth;
                    var y = Kiwi.Utils.GameMath.snapToFloor(b.y - this.transform.worldY, this.tileHeight) / this.tileHeight;
                    var w = Kiwi.Utils.GameMath.snapToCeil(b.width, this.tileWidth) / this.tileWidth;
                    var h = Kiwi.Utils.GameMath.snapToCeil(b.height, this.tileHeight) / this.tileHeight;

                    return this.getCollidableTiles(x, y, w + 1, h + 1, collisionType);
                };

                /**
                * Returns the tiles which can collide with other objects (on ANY side unless otherwise specified) within an area provided.
                * By default the area is the whole tilemap.
                * @method getCollidableTiles
                * @param [x=0] {Number} The x coordinate of the first tile to check.
                * @param [y=0] {Number} The y coordinate of the first tile to check.
                * @param [width=widthOfMap] {Number} The width from the x coordinate.
                * @param [height=heightOfmap] {Number} The height from the y coordinate.
                * @param [collisionType=ANY] {Number} The type of collidable tiles that should be return. By default ANY type of collidable tiles will be returned.
                * @return {Object[]} Returns an Array of Objects containing information about the tiles which were found. Index/X/Y information is contained within each Object.
                * @public
                */
                TileMapLayer.prototype.getCollidableTiles = function (x, y, width, height, collisionType) {
                    if (typeof x === "undefined") { x = 0; }
                    if (typeof y === "undefined") { y = 0; }
                    if (typeof width === "undefined") { width = this.width; }
                    if (typeof height === "undefined") { height = this.height; }
                    if (typeof collisionType === "undefined") { collisionType = Kiwi.Components.ArcadePhysics.ANY; }
                    var tiles = [];

                    //Make sure its within the map.
                    if (x > this.width || y > this.height)
                        return;

                    if (x < 0)
                        x = 0;
                    if (y < 0)
                        y = 0;

                    if (x + width > this.width)
                        width = this.width - x;
                    if (y + height > this.height)
                        height = this.height - y;

                    for (var j = y; j < y + height; j++) {
                        for (var i = x; i < x + width; i++) {
                            //Get the tile index.
                            var index = this.getIndexFromXY(i, j);

                            //Does that index exist? Should do but just in case.
                            if (index === -1)
                                continue;

                            var type = this.tileData[index];

                            //If the collision type matches the one passed.
                            if ((this.tilemap.tileTypes[type].allowCollisions & collisionType) !== Kiwi.Components.ArcadePhysics.NONE) {
                                tiles.push({
                                    index: index,
                                    type: type,
                                    x: i * this.tileWidth,
                                    y: j * this.tileHeight
                                });
                            }
                        }
                    }

                    return tiles;
                };

                /**
                * The update loop that is executed when this TileMapLayer is add to the Stage.
                * @method update
                * @public
                */
                TileMapLayer.prototype.update = function () {
                    _super.prototype.update.call(this);

                    this.physics.update();
                };

                /**
                * Used to calculate the position of the tilemap on the stage as well as how many tiles can fit on the screen.
                * All coordinates calculated are stored as temporary properties (maxX/Y, startX/Y).
                * @method _calculateBoundaries
                * @param camera {Camera}
                * @param matrix {Matrix}
                * @private
                */
                TileMapLayer.prototype._calculateBoundaries = function (camera, matrix) {
                    // Translation Stuff
                    var sx = 1 / this.scaleX;
                    var sy = 1 / this.scaleY;

                    // Work out how many tiles we can fit into our camera and round it up for the edges
                    this._maxX = Math.min(Math.ceil(camera.width / this.tileWidth) + 1, this.width) * sx;
                    this._maxY = Math.min(Math.ceil(camera.height / this.tileHeight) + 1, this.height) * sy;

                    // And now work out where in the tilemap the camera actually is
                    this._startX = Math.floor((-camera.transform.x - this.transform.worldX) / this.tileWidth * sx);
                    this._startY = Math.floor((-camera.transform.y - this.transform.worldY) / this.tileHeight * sy);

                    // Boundaries check for the start
                    if (this._startX < 0)
                        this._startX = 0;
                    if (this._startY < 0)
                        this._startY = 0;

                    // Check for the Maximum
                    if (this._maxX > this.width)
                        this._maxX = this.width;
                    if (this._maxY > this.height)
                        this._maxY = this.height;

                    // Width/Height
                    if (this._startX + this._maxX > this.width)
                        this._maxX = this.width - this._startX;
                    if (this._startY + this._maxY > this.height)
                        this._maxY = this.height - this._startY;
                };

                /**
                * The render loop which is used when using the Canvas renderer.
                * @method render
                * @param camera {Camera}
                * @public
                */
                TileMapLayer.prototype.render = function (camera) {
                    //When not to render the map.
                    if (this.visible === false || this.alpha < 0.1 || this.exists === false) {
                        return;
                    }

                    //Get the context.
                    var ctx = this.game.stage.ctx;
                    ctx.save();

                    //Make the map alphed out.
                    if (this.alpha > 0 && this.alpha <= 1) {
                        ctx.globalAlpha = this.alpha;
                    }

                    // Transform
                    var t = this.transform;
                    var m = t.getConcatenatedMatrix();

                    ctx.transform(m.a, m.b, m.c, m.d, m.tx + t.rotPointX - camera.transform.rotPointX, m.ty + t.rotPointY - camera.transform.rotPointY);

                    this._calculateBoundaries(camera, m);

                    for (var y = this._startY; y < this._startY + this._maxY; y++) {
                        for (var x = this._startX; x < this._startX + this._maxX; x++) {
                            if ((this._temptype = this.getTileFromXY(x, y)) && this._temptype.cellIndex !== -1) {
                                var cell = this.atlas.cells[this._temptype.cellIndex];

                                ctx.drawImage(this.atlas.image, cell.x, cell.y, cell.w, cell.h, x * this.tileWidth, y * this.tileHeight - (cell.h - this.tileHeight), cell.w, cell.h);
                            }
                        }
                    }

                    ctx.restore();
                    return true;
                };

                TileMapLayer.prototype.renderGL = function (gl, camera, params) {
                    if (typeof params === "undefined") { params = null; }
                    //Setup
                    var vertexItems = [];

                    //Create the point objects.
                    var pt1 = new Kiwi.Geom.Point();
                    var pt2 = new Kiwi.Geom.Point();
                    var pt3 = new Kiwi.Geom.Point();
                    var pt4 = new Kiwi.Geom.Point();

                    //Transform/Matrix
                    var t = this.transform;
                    var m = t.getConcatenatedMatrix();

                    //Find which ones we need to render. Needs to be updated for Rotation.
                    this._calculateBoundaries(camera, m);

                    for (var y = this._startY; y < this._startY + this._maxY; y++) {
                        for (var x = this._startX; x < this._startX + this._maxX; x++) {
                            //Get the tile type
                            this._temptype = this.getTileFromXY(x, y);

                            //Skip tiletypes that don't use a cellIndex.
                            if (this._temptype.cellIndex == -1)
                                continue;

                            //Get the cell index
                            var cell = this.atlas.cells[this._temptype.cellIndex];
                            var tx = x * this.tileWidth;
                            var ty = y * this.tileHeight;

                            //Set up the points
                            pt1.setTo(tx - t.rotPointX, ty - t.rotPointY - (cell.h - this.tileHeight));
                            pt2.setTo(tx + cell.w - t.rotPointX, ty - t.rotPointY - (cell.h - this.tileHeight));
                            pt3.setTo(tx + cell.w - t.rotPointX, ty + cell.h - t.rotPointY - (cell.h - this.tileHeight));
                            pt4.setTo(tx - t.rotPointX, ty + cell.h - t.rotPointY - (cell.h - this.tileHeight));

                            //Add on the matrix to the points
                            pt1 = m.transformPoint(pt1);
                            pt2 = m.transformPoint(pt2);
                            pt3 = m.transformPoint(pt3);
                            pt4 = m.transformPoint(pt4);

                            //Append to the xyuv array
                            vertexItems.push(pt1.x + t.rotPointX, pt1.y + t.rotPointY, cell.x, cell.y, this.alpha, pt2.x + t.rotPointX, pt2.y + t.rotPointY, cell.x + cell.w, cell.y, this.alpha, pt3.x + t.rotPointX, pt3.y + t.rotPointY, cell.x + cell.w, cell.y + cell.h, this.alpha, pt4.x + t.rotPointX, pt4.y + t.rotPointY, cell.x, cell.y + cell.h, this.alpha);
                        }
                    }

                    //Concat points to the Renderer.
                    this.glRenderer.concatBatch(vertexItems);
                };
                return TileMapLayer;
            })(Kiwi.Entity);
            Tilemap.TileMapLayer = TileMapLayer;
        })(GameObjects.Tilemap || (GameObjects.Tilemap = {}));
        var Tilemap = GameObjects.Tilemap;
    })(Kiwi.GameObjects || (Kiwi.GameObjects = {}));
    var GameObjects = Kiwi.GameObjects;
})(Kiwi || (Kiwi = {}));
/**
* Component's are a snipnets of code which are designed to provide extra functionality to various objects, such as IChild's/GameObjects/HUDWidgets/e.t.c. The code that components have are not necessarily needed for an object to work, but are instead provided to make common task's that you would do with those objects easier. An Example being that at times you may like to make a GameObject draggable by the user and so you can then add Input Component and execute the enableDrag on that GameObject. That would be task that not every GameObject would need, but only specific ones.
*
* @module Kiwi
* @submodule Components
* @main Components
*/
var Kiwi;
(function (Kiwi) {
    (function (Components) {
        /**
        * The AnimationManager is used to handle the creation and playment of Animations on a individual GameObject based on the TextureAtlas it has.
        * When the AnimationManager is instantiated it will loop through all of the Sequences on the TextureAtlas of the GameObject being used and will create a new Animation for each one.
        * Now when you create a new Animation that animation will automatically be added as a new Sequence to the corresponding Texture.
        * This way you don't need to create new Animations for a each Sprite that use's the same Texture.
        *
        * @class AnimationManager
        * @extends Component
        * @namespace Kiwi.Components
        * @constructor
        * @param entity {Entity} The entity that this animation component belongs to.
        * @return {AnimationManager}
        */
        var AnimationManager = (function (_super) {
            __extends(AnimationManager, _super);
            function AnimationManager(entity) {
                _super.call(this, entity, 'Animation');
                /**
                * A reference to the animation that is currently being played.
                * @property _currentAnimation
                * @type Animation
                * @default null
                * @private
                */
                this.currentAnimation = null;

                //get the entity and the animation.
                this.entity = entity;
                this._atlas = this.entity.atlas;
                this._animations = {};

                for (var i = 0; i < this._atlas.sequences.length; i++) {
                    this.createFromSequence(this._atlas.sequences[i], false);
                }

                //if a default animation already exists
                if (this._animations['default']) {
                    this.currentAnimation = this._animations['default'];
                    //otherwise create one.
                } else {
                    var defaultCells = [];
                    for (var i = 0; i < this._atlas.cells.length; i++) {
                        defaultCells.push(i);
                    }
                    this.currentAnimation = this.add('default', defaultCells, 0.1, true, false);
                }

                //Signals
                this.onChange = new Kiwi.Signal;
                this.onPlay = new Kiwi.Signal;
                this.onStop = new Kiwi.Signal;
                this.onUpdate = new Kiwi.Signal;
            }
            Object.defineProperty(AnimationManager.prototype, "isPlaying", {
                /**
                * Returns a boolean indicating whether or not the current animation is playing. This is READ ONLY.
                * @property isPlaying
                * @type boolean
                * @public
                */
                get: function () {
                    return this.currentAnimation.isPlaying;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * The type of object that this is.
            * @method objType
            * @type string
            * @public
            */
            AnimationManager.prototype.objType = function () {
                return "AnimationManager";
            };

            /**
            * Creates a new sequence and then adds that sequence as a new animation on this component. Returns that animation that was created.
            *
            * @method add
            * @param {string} name
            * @param cells {number[]} An array that contains a reference to the cells that are to be played in the animation.
            * @param speed {number} The amount of time that each frame should stay on screen for. In seconds.
            * @param [loop=false] {boolean} If when the animation reaches the last frame, it should go back to the start again.
            * @param [play=false] {boolean} If once created the animation should play right away.
            * @return {Animation} The Anim that was created.
            * @public
            */
            AnimationManager.prototype.add = function (name, cells, speed, loop, play) {
                if (typeof loop === "undefined") { loop = false; }
                if (typeof play === "undefined") { play = false; }
                var newSequence = new Kiwi.Animations.Sequence(name, cells, speed, loop);
                this._atlas.sequences.push(newSequence);

                return this.createFromSequence(newSequence, play);
            };

            /**
            * Creates a new animation based on a sequence that is passed.
            *
            * @method createFromSequence
            * @param sequence {Kiwi.Sequence} The sequence that the animation is based on.
            * @param [play=false] {boolean} If the animation should play once it has been created
            * @return {Animation} The Anim that was created.
            * @public
            */
            AnimationManager.prototype.createFromSequence = function (sequence, play) {
                if (typeof play === "undefined") { play = false; }
                this._animations[sequence.name] = new Kiwi.Animations.Animation(sequence.name, sequence, this.entity.clock, this);

                if (play)
                    this.play(sequence.name);

                return this._animations[sequence.name];
            };

            /**
            * Plays either the current animation or the name of the animation that you pass.
            *
            * @method play
            * @param [name] {string} The name of the animation that you want to play. If not passed it plays the current animation.
            * @public
            */
            AnimationManager.prototype.play = function (name) {
                if (typeof name === "undefined") { name = this.currentAnimation.name; }
                return this._play(name);
            };

            /**
            * Play an animation at a particular frameIndex.
            *
            * @method playAt
            * @param index {Number} The index of the frame in the Sequence that you would like to play.
            * @param [name] {String} The name of the animation that you want to play. If not passed, it plays it on the current animation.
            * @public
            */
            AnimationManager.prototype.playAt = function (index, name) {
                if (typeof name === "undefined") { name = this.currentAnimation.name; }
                return this._play(name, index);
            };

            /**
            * An internal method used to actually play the animation.
            *
            * @method _play
            * @param name {number} The name of the animation that is to be switched to.
            * @param [index=null] {string} The index of the frame in the Sequence that is to play.
            * @return {Animation}
            * @private
            */
            AnimationManager.prototype._play = function (name, index) {
                if (typeof index === "undefined") { index = null; }
                this._setCurrentAnimation(name);

                if (index !== null)
                    this.currentAnimation.playAt(index);
                else
                    this.currentAnimation.play();

                this.onPlay.dispatch(this.currentAnimation);
                this.updateCellIndex();
                return this.currentAnimation;
            };

            /**
            * Stops the current animation from playing.
            * @method stop
            * @public
            */
            AnimationManager.prototype.stop = function () {
                if (this.isPlaying === true) {
                    this.currentAnimation.stop();
                    this.onStop.dispatch(this.currentAnimation);
                }
            };

            /**
            * Pauses the current animation.
            * @method pause
            * @public
            */
            AnimationManager.prototype.pause = function () {
                this.currentAnimation.pause();
            };

            /**
            * Resumes the current animation. The animation should have already been paused.
            * @method resume
            * @public
            */
            AnimationManager.prototype.resume = function () {
                this.currentAnimation.resume();
            };

            /**
            * Either switches to a particular animation OR a particular frame in the current animation depending on if you pass the name of an animation that exists on this Manager (as a string) or a number refering to a frame index on the Animation.
            * When you switch to a particular animation then
            * You can also force the animation to play or to stop by passing a boolean in. But if left as null, the animation will base it off what is currently happening.
            * So if the animation is currently 'playing' then once switched to the animation will play. If not currently playing it will switch to and stop.
            *
            * @method switchTo
            * @param val {string|number}
            * @param [play=null] {boolean} Force the animation to play or stop. If null the animation base's it off what is currently happening.
            * @public
            */
            AnimationManager.prototype.switchTo = function (val, play) {
                if (typeof play === "undefined") { play = null; }
                var switched = false;
                switch (typeof val) {
                    case "string":
                        if (this.currentAnimation.name !== val) {
                            this._setCurrentAnimation(val);
                            switched = true;
                        }
                        break;
                    case "number":
                        this.currentAnimation.frameIndex = val;
                        switched = true;
                        break;
                }

                //Play if the dev forced it to OR if the animation was already playing
                if (play || play === null && this.isPlaying && switched)
                    this.play();
                if (play == false && this.isPlaying)
                    this.stop();

                this.updateCellIndex();
            };

            /**
            * Makes the current animation go to the next frame. If the animation is at the end of the sequence it then goes back to the start.
            * @method nextFrame
            * @public
            */
            AnimationManager.prototype.nextFrame = function () {
                this.currentAnimation.nextFrame();
                this.updateCellIndex();
            };

            /**
            * Makes the current animation go to the prev frame. If the animation is at the start, the animation will go the end of the sequence.
            * @method prevFrame
            * @public
            */
            AnimationManager.prototype.prevFrame = function () {
                this.currentAnimation.prevFrame();
                this.updateCellIndex();
            };

            /**
            * Internal method that sets the current animation to the animation passed.
            *
            * @method _setCurrentAnimation
            * @param {string} name
            * @private
            */
            AnimationManager.prototype._setCurrentAnimation = function (name) {
                if (this.currentAnimation.name !== name) {
                    if (this.currentAnimation !== null)
                        this.currentAnimation.stop();

                    if (this._animations[name]) {
                        this.currentAnimation = this._animations[name];
                        this.onChange.dispatch(name, this.currentAnimation);
                    }
                }
            };

            /**
            * The update loop, it only updates the currentAnimation and only if it is playing.
            * @method update
            * @public
            */
            AnimationManager.prototype.update = function () {
                if (this.currentAnimation) {
                    this.currentAnimation.update();
                }
            };

            Object.defineProperty(AnimationManager.prototype, "currentCell", {
                /**
                * Gets the cell that the current animation is current at. This is READ ONLY.
                * @property currentCell
                * @type number
                * @public
                */
                get: function () {
                    return this.currentAnimation.currentCell;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationManager.prototype, "frameIndex", {
                /**
                * Gets the current frame index of the cell in the sequence that is currently playing. This is READ ONLY.
                * @property frameIndex
                * @type number
                * @public
                */
                get: function () {
                    return this.currentAnimation.frameIndex;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AnimationManager.prototype, "length", {
                /**
                * Returns the length (Number of cells) of the current animation that is playing. This is READ ONLY.
                * @property length
                * @type number
                * @public
                */
                get: function () {
                    return this.currentAnimation.length;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Get a animation that is on the animation component.
            *
            * @method getAnimation
            * @param {string} name
            * @return {Animation}
            * @public
            */
            AnimationManager.prototype.getAnimation = function (name) {
                return this._animations[name];
            };

            /**
            * An internal method that is used to update the cell index of an entity when an animation says it needs to update.
            * @method updateCellIndex
            * @protected
            */
            AnimationManager.prototype.updateCellIndex = function () {
                if (typeof this.currentAnimation !== "undefined") {
                    this.onUpdate.dispatch(this.currentAnimation);
                    this.entity.cellIndex = this.currentAnimation.currentCell;
                }
            };

            /**
            * Destroys the animation component and runs the destroy method on all of the anims that it has.
            * @method destroy
            * @public
            */
            AnimationManager.prototype.destroy = function () {
                _super.prototype.destroy.call(this);

                for (var key in this._animations) {
                    this._animations[key].destroy();
                    delete this._animations[key];
                }
                delete this._animations;
                delete this.currentAnimation;
                delete this._atlas;
            };
            return AnimationManager;
        })(Kiwi.Component);
        Components.AnimationManager = AnimationManager;
    })(Kiwi.Components || (Kiwi.Components = {}));
    var Components = Kiwi.Components;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Components
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Components) {
        /**
        * The Box Component is used to handle the various 'bounds' that each GameObject has.
        * There are FOUR different types of bounds (each one is a rectangle) on each box depending on what you are wanting:
        * RawBounds: The bounding box of the GameObject before rotation.
        * RawHitbox: The hitbox of the GameObject before rotation. This can be modified to be different than the normal bounds but if not specified it will be the same as the raw bounds.
        * Bounds: The bounding box of the GameObject after rotation.
        * Hitbox: The hitbox of the GameObject after rotation. If you modified the raw hitbox then this one will be modified as well, otherwise it will be the same as the normal bounds.
        *
        * @class Box
        * @extends Component
        * @namespace Kiwi.Components
        * @constructor
        * @param parent {Entity} The entity that this box belongs to.
        * @param [x=0] {Number} Its position on the x axis
        * @param [y=0] {Number} Its position on the y axis
        * @param [width=0] {Number} The width of the box.
        * @param [height=0] {Number} The height of the box.
        * @return {Box}
        */
        var Box = (function (_super) {
            __extends(Box, _super);
            function Box(parent, x, y, width, height) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof width === "undefined") { width = 0; }
                if (typeof height === "undefined") { height = 0; }
                _super.call(this, parent, 'Box');

                this.entity = parent;
                this.dirty = true;

                this._rawBounds = new Kiwi.Geom.Rectangle(x, y, width, height);
                this._rawCenter = new Kiwi.Geom.Point(x + width / 2, y + height / 2);
                this._rawHitbox = new Kiwi.Geom.Rectangle();

                this._hitboxOffset = new Kiwi.Geom.Point();

                this.hitbox = new Kiwi.Geom.Rectangle(0, 0, width, height);
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {string}
            * @public
            */
            Box.prototype.objType = function () {
                return "Box";
            };

            Object.defineProperty(Box.prototype, "hitboxOffset", {
                /**
                * Returns the offset value of the hitbox as a point for the X/Y axis for the developer to use.
                * This is without rotation or scaling.
                * @property hitboxOffset
                * @type Point
                * @public
                */
                get: function () {
                    return this._hitboxOffset;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Box.prototype, "rawHitbox", {
                /**
                * Returns the raw hitbox rectangle for the developer to use.
                * 'Raw' means where it would be without rotation or scaling.
                * This is READ ONLY.
                * @property rawHitbox
                * @type Rectangle
                * @public
                */
                get: function () {
                    if (this.dirty) {
                        this._rawHitbox.x = this._rawBounds.x + this._hitboxOffset.x;
                        this._rawHitbox.y = this._rawBounds.y + this._hitboxOffset.y;
                    }

                    return this._rawHitbox;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Box.prototype, "hitbox", {
                /**
                * The 'normal' or transformed hitbox for the entity. This is its box after rotation/e.t.c.
                * @property hitbox
                * @type Rectangle
                * @public
                */
                get: function () {
                    if (this.dirty) {
                        this._transformedHitbox = this._rotateHitbox(this.rawHitbox.clone());
                    }

                    return this._transformedHitbox;
                },
                set: function (value) {
                    this._hitboxOffset.x = value.x;
                    this._hitboxOffset.y = value.y;

                    this._rawHitbox = value;

                    this._rawHitbox.x += this._rawBounds.x;
                    this._rawHitbox.y += this._rawBounds.y;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Box.prototype, "worldHitbox", {
                /**
                * Returns the transformed hitbox for the entity using its 'world' coordinates.
                * This is READ ONLY.
                * @property worldHitbox
                * @type Rectangle
                * @public
                */
                get: function () {
                    if (this.dirty) {
                        this._worldHitbox = this._rotateHitbox(this.rawHitbox.clone(), true);
                    }

                    return this._worldHitbox;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Box.prototype, "rawBounds", {
                /**
                * Returns the 'raw' bounds for this entity.
                * This is READ ONLY.
                * @property rawBounds
                * @type Rectangle
                * @public
                */
                get: function () {
                    if (this.dirty) {
                        this._rawBounds.x = this.entity.x;
                        this._rawBounds.y = this.entity.y;
                        this._rawBounds.width = this.entity.width;
                        this._rawBounds.height = this.entity.height;
                    }
                    return this._rawBounds;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Box.prototype, "rawCenter", {
                /**
                * Returns the raw center point of the box.
                * This is READ ONLY.
                * @property rawCenter
                * @type Point
                * @public
                */
                get: function () {
                    if (this.dirty) {
                        this._rawCenter.x = this.rawBounds.x + this.rawBounds.width / 2, this._rawCenter.y = this.rawBounds.y + this.rawBounds.height / 2;
                    }
                    return this._rawCenter;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Box.prototype, "center", {
                /**
                * Returns the center point for the box after it has been transformed.
                * This is READ ONLY.
                * @property center
                * @type Point
                * @public
                */
                get: function () {
                    if (this.dirty) {
                        var t = this.entity.transform;
                        var m = t.getConcatenatedMatrix();
                        m.setTo(m.a, m.b, m.c, m.d, t.x + t.rotPointX, t.y + t.rotPointY);
                        this._transformedCenter = m.transformPoint(new Kiwi.Geom.Point(this.entity.width / 2 - t.rotPointX, this.entity.height / 2 - t.rotPointY));
                    }
                    return this._transformedCenter;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Box.prototype, "bounds", {
                /**
                * Returns the 'transformed' or 'normal' bounds for this box.
                * This is READ ONLY.
                * @property bounds
                * @type Rectangle
                * @public
                */
                get: function () {
                    if (this.dirty) {
                        this._transformedBounds = this._rotateRect(this.rawBounds.clone());
                    }
                    return this._transformedBounds;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Box.prototype, "worldBounds", {
                /**
                * Returns the 'transformed' world bounds for this entity.
                * This is READ ONLY.
                * @property worldBounds
                * @type Rectangle
                * @public
                */
                get: function () {
                    if (this.dirty) {
                        this._worldBounds = this._rotateRect(this.rawBounds.clone(), true);
                    }
                    return this._worldBounds;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Private internal method only. Used to calculate the transformed bounds after rotation.
            * @method _rotateRect
            * @param rect {Rectangle}
            * @param [useWorldCoords=false] {Boolean}
            * @return {Rectangle}
            * @private
            */
            Box.prototype._rotateRect = function (rect, useWorldCoords) {
                if (typeof useWorldCoords === "undefined") { useWorldCoords = false; }
                var out = new Kiwi.Geom.Rectangle();
                var t = this.entity.transform;
                var m = t.getConcatenatedMatrix();

                //Use world coordinates?
                if (useWorldCoords) {
                    m.setTo(m.a, m.b, m.c, m.d, t.worldX + t.rotPointX, t.worldY + t.rotPointY);
                } else {
                    m.setTo(m.a, m.b, m.c, m.d, t.x + t.rotPointX, t.y + t.rotPointY);
                }

                out = this.extents(m.transformPoint({ x: -t.rotPointX, y: -t.rotPointY }), m.transformPoint({ x: -t.rotPointX + rect.width, y: -t.rotPointY }), m.transformPoint({ x: -t.rotPointX + rect.width, y: -t.rotPointY + rect.height }), m.transformPoint({ x: -t.rotPointX, y: -t.rotPointY + rect.height }));
                return out;
            };

            /**
            * A private method that is used to calculate the transformed hitbox's coordinates after rotation.
            * @method _rotateHitbox
            * @param rect {Rectangle}
            * @param [useWorldCoords=false] {Boolean}
            * @return {Rectangle}
            * @private
            */
            Box.prototype._rotateHitbox = function (rect, useWorldCoords) {
                if (typeof useWorldCoords === "undefined") { useWorldCoords = false; }
                var out = new Kiwi.Geom.Rectangle();
                var t = this.entity.transform;
                var m = t.getConcatenatedMatrix();

                //Use world coordinates?
                if (useWorldCoords) {
                    m.setTo(m.a, m.b, m.c, m.d, t.worldX + t.rotPointX, t.worldY + t.rotPointY);
                } else {
                    m.setTo(m.a, m.b, m.c, m.d, t.x + t.rotPointX, t.y + t.rotPointY);
                }

                out = this.extents(m.transformPoint({ x: -t.rotPointX + this._hitboxOffset.x, y: -t.rotPointY + this._hitboxOffset.y }), m.transformPoint({ x: -t.rotPointX + rect.width + this._hitboxOffset.x, y: -t.rotPointY + this._hitboxOffset.y }), m.transformPoint({ x: -t.rotPointX + rect.width + this._hitboxOffset.x, y: -t.rotPointY + rect.height + this._hitboxOffset.y }), m.transformPoint({ x: -t.rotPointX + this._hitboxOffset.x, y: -t.rotPointY + rect.height + this._hitboxOffset.y }));

                return out;
            };

            /**
            * Draws the various bounds on a context that is passed. Useful for debugging.
            * @method draw
            * @param {CanvasRenderingContext2D} ctx
            * @public
            */
            Box.prototype.draw = function (ctx) {
                var t = this.entity.transform;
                ctx.strokeStyle = "red";

                ctx.strokeRect(this.rawBounds.x, this.rawBounds.y, this.rawBounds.width, this.rawBounds.height);
                ctx.fillRect(this.rawCenter.x - 1, this.rawCenter.y - 1, 3, 3);
                ctx.strokeRect(t.x + t.rotPointX - 3, t.y + t.rotPointY - 3, 7, 7);
                ctx.strokeStyle = "blue";
                ctx.strokeRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
                ctx.strokeStyle = "green";
                ctx.strokeRect(this.hitbox.x, this.hitbox.y, this.hitbox.width, this.hitbox.height);
                ctx.strokeStyle = "white";
                ctx.strokeRect(this.rawHitbox.x, this.rawHitbox.y, this.rawHitbox.width, this.rawHitbox.height);
            };

            /*
            * [REQUIRES COMMENTING]
            * @method extents
            * @return Rectangle
            */
            Box.prototype.extents = function (topLeftPoint, topRightPoint, bottomRightPoint, bottomLeftPoint) {
                var left = Math.min(topLeftPoint.x, topRightPoint.x, bottomRightPoint.x, bottomLeftPoint.x);
                var right = Math.max(topLeftPoint.x, topRightPoint.x, bottomRightPoint.x, bottomLeftPoint.x);
                var top = Math.min(topLeftPoint.y, topRightPoint.y, bottomRightPoint.y, bottomLeftPoint.y);
                var bottom = Math.max(topLeftPoint.y, topRightPoint.y, bottomRightPoint.y, bottomLeftPoint.y);

                return new Kiwi.Geom.Rectangle(left, top, right - left, bottom - top);
            };

            /**
            * Destroys this component and all of the links it may have to other objects.
            * @method destroy
            * @public
            */
            Box.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                delete this.entity;
            };
            return Box;
        })(Kiwi.Component);
        Components.Box = Box;
    })(Kiwi.Components || (Kiwi.Components = {}));
    var Components = Kiwi.Components;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Components
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Components) {
        /**
        * The Input Component is used on GameObjects in which the user may interactive with via a Mouse or Touch
        * and as such this class contains useful methods and callbacks you can subscribe to.
        * By default the Input component is disabled (this is because when enabled the input component can be process intensive)
        * but you can enabled it yourself (which is recommened) BUT in case you forget the input component will automagically
        * be enabled once you access a Signal on this class.
        *
        * @class Input
        * @extends Component
        * @namespace Kiwi.Components
        * @constructor
        * @param owner {IChild} The IChild that owns this Input.
        * @param box {Box} The box that is to be used for the event firing.
        * @param [enabled=false] {boolean} If this input component should be enabled or not.
        * @return {Input}
        */
        var Input = (function (_super) {
            __extends(Input, _super);
            function Input(owner, box, enabled) {
                if (typeof enabled === "undefined") { enabled = false; }
                _super.call(this, owner, 'Input');
                /**
                * A reference to the pointer that is currently 'dragging' this IChild.
                * If not dragging then this is null.
                * @property _isDragging
                * @type Pointer
                * @default null
                * @private
                */
                this._isDragging = null;
                /**
                * Indicates if dragging is currently enabled.
                * @property _dragEnabled
                * @type boolean
                * @default false
                * @private
                */
                this._dragEnabled = false;
                /**
                * If when dragging, the IChild should snap to the center of the pointer it is being dragged by.
                * @property _dragSnapToCenter
                * @type boolean
                * @default false
                * @private
                */
                this._dragSnapToCenter = false;
                /**
                * Temporary property that gets updated everyframe with the pointer that is currently 'down' on this entity.
                * @property _nowDown
                * @type Pointer
                * @default null
                * @private
                */
                this._nowDown = null;
                /**
                * Temporary property that gets updated everyframe with the pointer that was just 'released' from being down on this entity
                * @property _nowUp
                * @type Pointer
                * @default null
                * @private
                */
                this._nowUp = null;
                /**
                * Temporary property of the pointer that is now within the bounds of the entity
                * @property _nowEntered
                * @type Pointer
                * @default null
                * @private
                */
                this._nowEntered = null;
                /**
                * Temporary property of the pointer that just left the bounds of the entity.
                * @property _nowLeft
                * @type Pointer
                * @default null
                * @private
                */
                this._nowLeft = null;
                /**
                * Temporary property of the pointer that just started draggging the entity.
                * @property _nowDragging
                * @type Pointer
                * @default null
                * @private
                */
                this._nowDragging = null;

                //  Signals
                this._onEntered = new Kiwi.Signal();
                this._onLeft = new Kiwi.Signal();
                this._onDown = new Kiwi.Signal();
                this._onUp = new Kiwi.Signal();
                this._onDragStarted = new Kiwi.Signal();
                this._onDragStopped = new Kiwi.Signal();

                //  Properties
                this._box = box;

                this._distance = new Kiwi.Geom.Point();

                this._withinBounds = null;
                this._outsideBounds = true;

                this._isUp = true;
                this._isDown = null;
                this._isDragging = null;
                this._justEntered = false;
                this._tempDragDisabled = false;
                this.enabled = enabled;
            }
            /**
            * The type of object this input is.
            * @method objType
            * @return string
            * @public
            */
            Input.prototype.objType = function () {
                return "Input";
            };

            Object.defineProperty(Input.prototype, "onEntered", {
                /**
                * Returns the onEntered Signal, that fires events when a pointer enters the hitbox of a entity.
                * Note: Accessing this signal enables the input.
                * This is READ ONLY.
                * @property onEntered
                * @type Signal
                * @public
                */
                get: function () {
                    if (this.enabled == false)
                        this.enabled = true;
                    return this._onEntered;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "onLeft", {
                /**
                * Returns the onLeft Signal, that fires events when a pointer leaves the hitbox of a entity.
                * Note: Accessing this signal enables the input.
                * This is READ ONLY.
                * @property onLeft
                * @type Signal
                * @public
                */
                get: function () {
                    if (this.enabled == false)
                        this.enabled = true;
                    return this._onLeft;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "onDown", {
                /**
                * Returns the onDown Signal, that fires events when a pointer is pressed within the bounds of the signal.
                * Note: Accessing this signal enables the input.
                * This is READ ONLY.
                * @property onDown
                * @type Signal
                * @public
                */
                get: function () {
                    if (this.enabled == false)
                        this.enabled = true;
                    return this._onDown;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "onUp", {
                /**
                * Returns the onUp Signal, that fires events when a pointer is released either within the bounds or was pressed initially within the bounds..
                * Note: Accessing this signal enables the input.
                * This is READ ONLY.
                * @property onUp
                * @type Signal
                * @public
                */
                get: function () {
                    if (this.enabled == false)
                        this.enabled = true;
                    return this._onUp;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "onDragStarted", {
                /**
                * Returns the onDragStarted Signal.
                * This is READ ONLY.
                * @property onDragStarted
                * @type Signal
                * @public
                */
                get: function () {
                    return this._onDragStarted;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "onDragStopped", {
                /**
                * Returns the onDragStopped Signal.
                * This is READ ONLY.
                * @property onDragStopped
                * @type Signal
                * @public
                */
                get: function () {
                    return this._onDragStopped;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "onRelease", {
                /**
                * A alias for the on release signal.
                * This is READ ONLY.
                * @property onRelease
                * @type Signal
                * @public
                */
                get: function () {
                    return this.onUp;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "onPress", {
                /**
                * A alias for the on press signal.
                * This is READ ONLY.
                * @property onPress
                * @type Signal
                * @public
                */
                get: function () {
                    return this.onDown;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "enabled", {
                /**
                * Get if the input is enabled or not. Note: Inputs should only be enabled when needed, otherwise unnecessary processing does occur which can result in a slower game.
                * @property enabled
                * @type boolean
                * @public
                */
                get: function () {
                    return this._enabled;
                },
                set: function (val) {
                    this._enabled = val;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "isDown", {
                /**
                * Used to see if a pointer is currently on this input. Returns a boolean indicating either true or false.
                * This is READ ONLY.
                * @property isDown
                * @type boolean
                * @public
                */
                get: function () {
                    return (this._isDown !== null);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "isUp", {
                /**
                * Used to see if no pointer is on this input (so it is up).
                * This is READ ONLY.
                * @property isUp
                * @type boolean
                * @public
                */
                get: function () {
                    return this._isUp;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "withinBounds", {
                /**
                * Check to see if any pointer is within the bounds of this input.
                * This is READ ONLY.
                * @property withinBounds
                * @type boolean
                * @public
                */
                get: function () {
                    return (this._withinBounds !== null);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "outsideBounds", {
                /**
                * See if no pointers are within the bounds of this entity.
                * This is READ ONLY.
                * @property outsideBounds
                * @type boolean
                * @public
                */
                get: function () {
                    return this._outsideBounds;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "isDragging", {
                /**
                * Returns a boolean indicating if this is currently dragging something.
                * This is READ ONLY.
                * @property isDragging
                * @type boolean
                * @public
                */
                get: function () {
                    return (this._isDragging !== null);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Input.prototype, "dragDistance", {
                /**
                * The drag distance that is used when dragging this object. See _dragDistance for more information.
                * @property dragDistance
                * @type number
                * @public
                */
                get: function () {
                    return this._dragDistance;
                },
                set: function (val) {
                    this._dragDistance = val;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Enables the dragging of this entity.
            * @method enableDrag
            * @param [snapToCenter=false] {boolean} If when dragging the Entity should snap to the center of the pointer.
            * @param [distance=1] {number} If when dragging the Entity should snap to numbers divisible by this amount.
            * @public
            */
            Input.prototype.enableDrag = function (snapToCenter, distance) {
                if (typeof snapToCenter === "undefined") { snapToCenter = false; }
                if (typeof distance === "undefined") { distance = 1; }
                if (this.enabled == false)
                    this.enabled = true;
                this._dragEnabled = true;
                this._dragSnapToCenter = snapToCenter;
                this._dragDistance = distance;
                this._isDragging = null;
            };

            /**
            * Disables the dragging of this entity.
            * @method disableDrag
            * @public
            */
            Input.prototype.disableDrag = function () {
                this._dragEnabled = false;
                this._isDragging = null;
            };

            /**
            * The update loop for the input.
            * @method update
            * @protected
            */
            Input.prototype.update = function () {
                if (this.enabled === false || !this.game || this.owner.active === false || this.owner.willRender === false) {
                    return;
                }

                //reset the temporary properties
                this._nowDown = null;
                this._nowUp = null;
                this._nowEntered = null;
                this._nowLeft = null;
                this._nowDragging = null;

                //Use the appropriate method of checking.
                if (Kiwi.DEVICE.touch) {
                    this._updateTouch();
                } else {
                    this._updateMouse();
                }

                //If the entity is dragging.
                if (this.isDragging) {
                    if (this._dragSnapToCenter === false) {
                        this.owner.transform.x = Kiwi.Utils.GameMath.snapTo((this._isDragging.x - this._distance.x), this._dragDistance);
                        this.owner.transform.y = Kiwi.Utils.GameMath.snapTo((this._isDragging.y - this._distance.y), this._dragDistance);
                    } else {
                        this.owner.transform.x = Kiwi.Utils.GameMath.snapTo((this._isDragging.x - this._box.worldHitbox.width / 2), this._dragDistance);
                        this.owner.transform.y = Kiwi.Utils.GameMath.snapTo((this._isDragging.y - this._box.worldHitbox.height / 2), this._dragDistance);
                    }
                }
            };

            /**
            * The update loop that gets executed when the game is using the touch manager.
            * @method _updateTouch
            * @private
            */
            Input.prototype._updateTouch = function () {
                for (var i = 0; i < this.game.input.touch.maximumPointers; i++) {
                    //if that pointer is active then see where it is
                    if (this.game.input.touch.fingers[i].active === true) {
                        this._evaluateTouchPointer(this.game.input.touch.fingers[i]);
                    } else if (this.isDown === true && this._isDown.id === this.game.input.touch.fingers[i].id) {
                        this._nowUp = this.game.input.touch.fingers[i];
                    } else if (this.isDown === false && this._nowUp === null && this.withinBounds === true && this._withinBounds.id === this.game.input.touch.fingers[i].id) {
                        this._nowUp = this.game.input.touch.fingers[i];
                    }
                }

                //Fire the events. LOTS OF CONDITIONS
                if (this._nowEntered !== null && this.withinBounds === false) {
                    this._withinBounds = this._nowEntered;
                    this._outsideBounds = false;
                    this._onEntered.dispatch(this.owner, this._nowEntered);
                }

                if (this._nowLeft !== null && this.withinBounds === true) {
                    this._withinBounds = null;
                    this._outsideBounds = true;
                    this._onLeft.dispatch(this.owner, this._nowLeft);
                }

                if (this._nowDown !== null && this.isDown === false) {
                    this._onDown.dispatch(this.owner, this._nowDown);
                    this._isDown = this._nowDown;
                    this._isUp = false;
                    this._withinBounds = this._nowDown;
                    this._outsideBounds = false;
                }

                if (this._dragEnabled == true && this.isDragging === false && this._nowDragging !== null) {
                    this._onDragStarted.dispatch(this.owner, this._nowDragging);
                    this._isDragging = this._nowDragging;
                }

                if (this._nowUp !== null) {
                    this._onUp.dispatch(this.owner, this._nowUp);
                    this._isDown = null;
                    this._isUp = true;
                    this._withinBounds = null;
                    this._outsideBounds = true;

                    //dispatch drag event
                    if (this.isDragging === true && this._isDragging.id == this._nowUp.id) {
                        this._isDragging = null;
                        this._onDragStopped.dispatch(this.owner, this._nowUp);
                    }
                }
            };

            /**
            * A private method for checking to see if a touch pointer should activate any events.
            * @method _evaluateTouchPointer
            * @param pointer {Finger} The pointer you are checking against.
            * @private
            */
            Input.prototype._evaluateTouchPointer = function (pointer) {
                //if nothing isdown or what is down is the current pointer
                if (this.isDown === false || this._isDown.id === pointer.id) {
                    if (Kiwi.Geom.Intersect.circleToRectangle(pointer.circle, this._box.worldHitbox).result) {
                        if (this.isDown === true && this._isDown.id === pointer.id || this.isDown === false && pointer.duration > 1) {
                            this._nowEntered = pointer;
                        }

                        if (this.isDown === false && pointer.frameDuration < 2) {
                            this._nowDown = pointer;
                        }

                        if (this._dragEnabled && this.isDragging == false && this.isDown == true) {
                            this._distance.x = pointer.x - this._box.worldHitbox.left;
                            this._distance.y = pointer.y - this._box.worldHitbox.top;
                            this._nowDragging = pointer;
                        }
                    } else {
                        if (this.isDown === true) {
                            this._nowLeft = pointer;
                        } else if (this.withinBounds === true && this._withinBounds.id == pointer.id) {
                            this._nowLeft = pointer;
                        }
                    }
                }
            };

            /**
            * The update loop that runs when the mouse manager is the method for interacting with the screen.
            * @method _updateMouse
            * @private
            */
            Input.prototype._updateMouse = function () {
                this._evaluateMousePointer(this.game.input.mouse.cursor);

                //dispatch the events
                if (this._nowLeft !== null) {
                    this._onLeft.dispatch(this.owner, this._nowLeft);
                }

                if (this._nowEntered !== null) {
                    this._onEntered.dispatch(this.owner, this._nowEntered);
                }

                if (this._nowDown !== null && this.isDown === false) {
                    this._onDown.dispatch(this.owner, this._nowDown);
                    this._isDown = this._nowDown;
                    this._isUp = false;
                }

                if (this._dragEnabled == true && this.isDragging === false && this._nowDragging !== null) {
                    this._onDragStarted.dispatch(this.owner, this._nowDragging);
                    this._isDragging = this._nowDragging;
                }

                if (this.isDown === true && this._nowUp !== null && this._isDown.id === this._nowUp.id) {
                    this._onUp.dispatch(this.owner, this._nowUp);

                    //dispatch drag event
                    if (this.isDragging === true && this._isDragging.id == this._nowUp.id) {
                        this._isDragging = null;
                        this._onDragStopped.dispatch(this.owner, this._nowUp);
                    }

                    this._isDown = null;
                    this._isUp = true;
                }
            };

            /**
            * Evaluates where and what the mouse cursor is doing in relation to this box. Needs a little bit more love.
            * @method _evaluateMousePointer
            * @param pointer {MouseCursor}
            * @private
            */
            Input.prototype._evaluateMousePointer = function (pointer) {
                if (Kiwi.Geom.Intersect.circleToRectangle(pointer.circle, this._box.worldHitbox).result) {
                    if (this._dragEnabled && this.isDragging === false) {
                        this._distance.x = pointer.x - this._box.worldHitbox.left;
                        this._distance.y = pointer.y - this._box.worldHitbox.top;
                    }

                    //  Has it just moved inside?
                    if (this.withinBounds === false) {
                        this._nowEntered = pointer;
                        this._withinBounds = pointer;
                        this._outsideBounds = false;
                        this._justEntered = true;
                    }
                } else {
                    //  It's outside the bounds now, was it previously in?
                    if (this.withinBounds === true && this.isDragging === false) {
                        this._nowLeft = pointer;
                        this._withinBounds = null;
                        this._outsideBounds = true;
                    }
                }

                //  Input is down (click/touch)
                if (pointer.isDown === true) {
                    //if is was a mouse, did it just enter?
                    if (this._justEntered) {
                        this._isDown = pointer;
                        this._isUp = false;
                        this._tempDragDisabled = true;
                    }

                    //  Within bounds?
                    if (this.withinBounds === true && this.isDown === false && this._nowDown === null) {
                        this._nowDown = pointer;
                    }

                    if (this._dragEnabled === true && this.isDragging == false && this._tempDragDisabled === false) {
                        if (this.isDown == true) {
                            this._nowDragging = pointer;
                        }
                    }
                } else {
                    if (this._tempDragDisabled === true)
                        this._tempDragDisabled = false;

                    if (this.isDown === true) {
                        this._nowUp = pointer;
                    }
                }

                if (this._justEntered)
                    this._justEntered = false;
            };

            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {string} A string representation of this object.
            * @publics
            */
            Input.prototype.toString = function () {
                return '[{Input (x=' + this.withinBounds + ')}]';
            };

            /**
            * Destroys the input.
            * @method destory
            * @public
            */
            Input.prototype.destroy = function () {
                _super.prototype.destroy.call(this);

                this.enabled = false;
                delete this._box;
                delete this._isDown;
                delete this._isUp;
                delete this._isDragging;
                delete this._dragEnabled;
                if (this._onDown)
                    this._onDown.dispose();
                delete this._onDown;
                if (this._onDragStarted)
                    this._onDragStarted.dispose();
                delete this._onDragStarted;
                if (this._onUp)
                    this._onUp.dispose();
                delete this._onUp;
                if (this._onLeft)
                    this._onLeft.dispose();
                delete this._onLeft;
                if (this._onEntered)
                    this._onEntered.dispose();
                delete this._onEntered;
                if (this._onDragStopped)
                    this._onDragStopped.dispose();
                delete this._onDragStopped;
                delete this._dragDistance;
            };
            return Input;
        })(Kiwi.Component);
        Components.Input = Input;
    })(Kiwi.Components || (Kiwi.Components = {}));
    var Components = Kiwi.Components;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Components
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Components) {
        /**
        * The Sound Component is a class to assist with the creation and management of multiple pieces of audio that may exist on a single Entity. This class is NOT needed when dealing with audio but is instead provided to assist in dealing with audio.
        *
        * @class Sound
        * @extends Component
        * @namespace Kiwi.Components
        * @constructor
        * @param parent {Any} Who the sound component belongs to.
        * @return {Sound}
        */
        var Sound = (function (_super) {
            __extends(Sound, _super);
            function Sound(parent) {
                _super.call(this, parent, 'Sound');

                this._audio = [];
            }
            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Sound.prototype.objType = function () {
                return 'Sound';
            };

            /**
            * Creates a new audio segment on this component.
            *
            * @method addSound
            * @param name {string} The name for this audio file. This is how you will access the audio from this component and so it should be unique.
            * @param key {string} The piece of audio that you want to use.
            * @param [volume=1] {number} The volume that the audio should be set to.
            * @param [loop=false] {boolean} If the audio should keep play again when it finishes playing.
            * @return {Audio}
            * @public
            */
            Sound.prototype.addSound = function (name, key, volume, loop) {
                if (typeof volume === "undefined") { volume = 1; }
                if (typeof loop === "undefined") { loop = false; }
                if (this._validate(name) == true)
                    return;

                var audio = this.game.audio.add(key, volume, loop);
                this._audio[name] = audio;

                return audio;
            };

            /**
            * Removes the audio sementment with the name you have given.
            *
            * @method removeSound
            * @param name {string} The piece of audio you would like to remove.
            * @public
            */
            Sound.prototype.removeSound = function (name) {
                if (this._validate(name) == false)
                    return;

                this._audio[name].stop();
                this._audio[name].destroy();
                delete this._audio[name];
            };

            /**
            * Returns the Audio object for the sound that you pass.
            *
            * @method getSound
            * @param name {string} The piece of audio you would like to grab.
            * @return {Audio}
            * @public
            */
            Sound.prototype.getSound = function (name) {
                if (this._validate(name) == false)
                    return;

                return this._audio[name];
            };

            /*
            * This method is used to check to see if an audio segment with the name that is specified is on this component.
            *
            * @method _validate
            * @param name {string} The name of the audio segment you want to check exists.
            * @return {boolean}
            * @private
            */
            Sound.prototype._validate = function (name) {
                if (this._audio[name] === undefined) {
                    return false;
                } else {
                    return true;
                }
            };

            /**
            * Plays the audio that you specify.
            *
            * @method play
            * @param name {string} The name of the audio file you would like to play.
            * @public
            */
            Sound.prototype.play = function (name) {
                if (this._validate(name) == false)
                    return;

                this._audio[name].play();
            };

            /**
            * Stops the audio that you specify from playing.
            *
            * @method play
            * @param name {string} Name of the audio file you would like to stop.
            * @public
            */
            Sound.prototype.stop = function (name) {
                if (this._validate(name) == false)
                    return;

                this._audio[name].stop();
            };

            /**
            * Pauses the audio that you specify.
            *
            * @method play
            * @param name {string} The name of the audio you would like to pause.
            * @public
            */
            Sound.prototype.pause = function (name) {
                if (this._validate(name) == false)
                    return;

                this._audio[name].pause();
            };

            /**
            * Resumes the audio that you specify. Note: Audio can only resume if it was paused initially.
            *
            * @method play
            * @param name {string} The name of the audio you would like to resume.
            * @public
            */
            Sound.prototype.resume = function (name) {
                if (this._validate(name) == false)
                    return;

                this._audio[name].resume();
            };

            /**
            * Destroys this AudioComponent and all of the Audio objects it has.
            * @method destroy
            * @public
            */
            Sound.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                for (var key in this._audio) {
                    this._audio[key].stop();
                    this._audio[key].destroy();
                    delete this._audio[key];
                }
                delete this._audio;
            };
            return Sound;
        })(Kiwi.Component);
        Components.Sound = Sound;
    })(Kiwi.Components || (Kiwi.Components = {}));
    var Components = Kiwi.Components;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Components
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Components) {
        /**
        * Arcade Physics is an Optional Component that can be used when you are wanting to do basic physics collisions.
        * These have been ported from Flixel, so most function operate identically to the original flixel functions, though some
        * have been split into multiple functions. Generally where functions originally accepted
        * either groups or gameobjects within the same argument, the ported functions one or the other.
        * http://www.flixel.org/
        * http://www.adamatomic.com/
        *
        * @class ArcadePhysics
        * @constructor
        * @namespace Kiwi.Components
        * @param entity {Entity} The entity that this ArcadePhysics should be used on.
        * @param box {Box} The box component that holds the hitbox that should be used when resolving and calculating collisions.
        * @return {ArcadePhysics}
        * @extends Component
        *
        * @author Adam 'Atomic' Saltsman, Flixel
        *
        */
        var ArcadePhysics = (function (_super) {
            __extends(ArcadePhysics, _super);
            function ArcadePhysics(entity, box) {
                _super.call(this, entity, 'ArcadePhysics');
                /**
                * A function that is to execute when this object overlaps with another.
                * @property _callbackFunction
                * @type Function
                * @default null
                * @private
                */
                this._callbackFunction = null;
                /**
                * The context that the callback method should have when it executes.
                * @property _callbackContext
                * @type Any
                * @private
                */
                this._callbackContext = null;

                this.parent = entity;
                this.box = box;
                this.transform = this.parent.transform;

                this.last = new Kiwi.Geom.Point(this.transform.worldX, this.transform.worldY);
                this.mass = 1.0;
                this.elasticity = 0.0;

                this.immovable = false;
                this.moves = true;

                this.touching = ArcadePhysics.NONE;
                this.wasTouching = ArcadePhysics.NONE;
                this.allowCollisions = ArcadePhysics.ANY;

                this.velocity = new Kiwi.Geom.Point();
                this.acceleration = new Kiwi.Geom.Point();
                this.drag = new Kiwi.Geom.Point();
                this.maxVelocity = new Kiwi.Geom.Point(10000, 10000);

                this.angularVelocity = 0;
                this.angularAcceleration = 0;
                this.angularDrag = 0;
                this.maxAngular = 10000;
            }
            /**
            * Returns a boolean indicating whether the or not the object is currently colliding on a particular side that is passed.
            * Use the collision constants (like LEFT, FLOOR, e.t.c) when passing sides.
            * @method touching
            * @param value [number] The collision constant of the side you want to check against.
            * @return boolean
            * @public
            */
            ArcadePhysics.prototype.isTouching = function (value) {
                return (this.touching & value) == value;
            };

            /**
            * Whether the object should collide with other objects or not.
            * For more control over what directions the object will collide from, use collision constants (like LEFT, FLOOR, etc)
            * and set the value of allowCollisions directly.
            * @method solid
            * @param [value] {boolean} If left empty, this will then just toggle between ANY and NONE.
            * @return boolean
            * @public
            */
            ArcadePhysics.prototype.solid = function (value) {
                if (value !== undefined) {
                    if (value)
                        this.allowCollisions = ArcadePhysics.ANY;
                    else
                        this.allowCollisions = ArcadePhysics.NONE;
                }

                return (this.allowCollisions & ArcadePhysics.ANY) > ArcadePhysics.NONE;
            };

            /**
            * Sets up a callback function that will run when this object overlaps with another.
            *
            * @method setCallback
            * @param callbackFunction {Function}
            * @param callbackContext {Any}
            * @public
            */
            ArcadePhysics.prototype.setCallback = function (callbackFunction, callbackContext) {
                this._callbackFunction = callbackFunction;
                this._callbackContext = callbackContext;
            };

            /*
            *---------------
            * Seperation Code
            *---------------
            */
            /**
            * A static method for seperating two normal GameObjects on both the X and Y Axis's.
            * Both objects need to have both an ArcadePhysics Component and a Box component in order for the separate process to succeed.
            * This method is not recommended to be directly used but instead use a 'collide/overlaps' method instead.
            *
            * @method seperate
            * @static
            * @param object1 {Entity} The first GameObject you would like to seperate.
            * @param object2 {Entity} The second GameObject you would like to seperate from the first.
            * @return {boolean}
            * @public
            */
            ArcadePhysics.separate = function (object1, object2) {
                var separatedX = this.separateX(object1, object2);
                var separatedY = this.separateY(object1, object2);
                return separatedX || separatedY;
            };

            /**
            * Separates two passed GameObjects on the x-axis.
            * Both objects need to have both an ArcadePhysics Component and a Box component in order for the separate process to succeed.
            * This method is not recommended to be directly used but instead use a 'collide/overlaps' method instead.
            *
            * @method seperateX
            * @param object1 {Entity} The first GameObject.
            * @param object2 {Entity} The second GameObject.
            * @return {boolean} Whether the objects in fact touched and were separated along the X axis.
            * @static
            * @public
            */
            ArcadePhysics.separateX = function (object1, object2) {
                //Get the Physics Components.
                var phys1 = object1.components.getComponent("ArcadePhysics");
                var phys2 = object2.components.getComponent("ArcadePhysics");

                //Can they even be sseparatated? two immovable objects
                if (phys1.immovable && phys2.immovable)
                    return false;

                //First, get the two object deltas
                var overlap = 0;
                var obj1delta = phys1.transform.worldX - phys1.last.x;
                var obj2delta = phys2.transform.worldX - phys2.last.x;

                //Are they the same?
                if (obj1delta == obj2delta)
                    return false;

                //Check if the X hulls actually overlap
                var obj1deltaAbs = (obj1delta > 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs = (obj2delta > 0) ? obj2delta : -obj2delta;

                //Get the world hitboxes.
                var box1 = phys1.box.worldHitbox;
                var box2 = phys2.box.worldHitbox;

                //Where they are now using previous y axis's.
                var obj1rect = new Kiwi.Geom.Rectangle(box1.x - ((obj1delta > 0) ? obj1delta : 0), phys1.last.y + phys1.box.hitboxOffset.y, box1.width + ((obj1delta > 0) ? obj1delta : -obj1delta), box1.height);
                var obj2rect = new Kiwi.Geom.Rectangle(box2.x - ((obj2delta > 0) ? obj2delta : 0), phys2.last.y + phys2.box.hitboxOffset.y, box2.width + ((obj2delta > 0) ? obj2delta : -obj2delta), box2.height);

                //Could also use Kiwi.Geom.Intersect.rectangleToRectangle here...
                if ((obj1rect.x + obj1rect.width > obj2rect.x) && (obj1rect.x < obj2rect.x + obj2rect.width) && (obj1rect.y + obj1rect.height > obj2rect.y) && (obj1rect.y < obj2rect.y + obj2rect.height)) {
                    var maxOverlap = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;

                    if (obj1delta > obj2delta) {
                        overlap = box1.x + box1.width - box2.x;
                        if ((overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.RIGHT) || !(phys2.allowCollisions & ArcadePhysics.LEFT)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.RIGHT;
                            phys2.touching |= ArcadePhysics.LEFT;
                        }
                    } else {
                        overlap = box1.x - box2.width - box2.x;
                        if ((-overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.LEFT) || !(phys2.allowCollisions & ArcadePhysics.RIGHT)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.LEFT;
                            phys2.touching |= ArcadePhysics.RIGHT;
                        }
                    }
                }

                if (overlap != 0) {
                    //Get the average velocity
                    var obj1v = phys1.velocity.x;
                    var obj2v = phys2.velocity.x;

                    if (!phys1.immovable && !phys2.immovable) {
                        overlap *= 0.5;
                        phys1.transform.x = phys1.transform.x - overlap;
                        phys2.transform.x = phys2.transform.x + overlap;

                        var obj1velocity = Math.sqrt((obj2v * obj2v * phys2.mass) / phys1.mass) * ((obj2v > 0) ? 1 : -1);
                        var obj2velocity = Math.sqrt((obj1v * obj1v * phys1.mass) / phys2.mass) * ((obj1v > 0) ? 1 : -1);
                        var average = (obj1velocity + obj2velocity) * 0.5;
                        obj1velocity -= average;
                        obj2velocity -= average;
                        phys1.velocity.x = average + obj1velocity * phys1.elasticity;
                        phys2.velocity.x = average + obj2velocity * phys2.elasticity;
                    } else if (!phys1.immovable) {
                        phys1.transform.x = phys1.transform.x - overlap;
                        phys1.velocity.x = obj2v - obj1v * phys1.elasticity;
                    } else if (!phys2.immovable) {
                        phys2.transform.x = phys2.transform.x + overlap;
                        phys2.velocity.x = obj1v - obj2v * phys2.elasticity;
                    }
                    return true;
                }

                return false;
            };

            /**
            * Separated two GameObject on the y-axis. This method is executed from the 'separate' method.
            * Both objects need to have both an ArcadePhysics Component and a Box component in order for the separate process to succeed.
            * This method is not recommended to be directly used but instead use a 'collide/overlaps' method instead.
            *
            * @method seperateY
            * @param object1 {Entity} The first GameObject.
            * @param object2 {Entity} The second GameObject.
            * @return {boolean} Whether the objects in fact touched and were separated along the Y axis.
            * @static
            * @public
            */
            ArcadePhysics.separateY = function (object1, object2) {
                //Get the Arcade Physics Components
                var phys1 = object1.components.getComponent("ArcadePhysics");
                var phys2 = object2.components.getComponent("ArcadePhysics");

                //Can't separate two immovable objects
                if (phys1.immovable && phys2.immovable)
                    return false;

                var overlap = 0;
                var obj1delta = phys1.transform.worldY - phys1.last.y;
                var obj2delta = phys2.transform.worldY - phys2.last.y;

                //Do the deltas match?
                if (obj1delta == obj2delta)
                    return false;

                //Absolute Deltas
                var obj1deltaAbs = (obj1delta > 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs = (obj2delta > 0) ? obj2delta : -obj2delta;

                //Hitboxes
                var box1 = phys1.box.worldHitbox;
                var box2 = phys2.box.worldHitbox;

                //Rectangles
                var obj1rect = new Kiwi.Geom.Rectangle(box1.x, box1.y - ((obj1delta > 0) ? obj1delta : 0), box1.width, box1.height + obj1deltaAbs);
                var obj2rect = new Kiwi.Geom.Rectangle(box2.x, box2.y - ((obj2delta > 0) ? obj2delta : 0), box2.width, box2.height + obj2deltaAbs);

                //Check for overlap
                if ((obj1rect.x + obj1rect.width > obj2rect.x) && (obj1rect.x < obj2rect.x + obj2rect.width) && (obj1rect.y + obj1rect.height > obj2rect.y) && (obj1rect.y < obj2rect.y + obj2rect.height)) {
                    var maxOverlap = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;

                    if (obj1delta > obj2delta) {
                        overlap = box1.y + box1.height - box2.y;
                        if ((overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.DOWN) || !(phys2.allowCollisions & ArcadePhysics.UP)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.DOWN;
                            phys2.touching |= ArcadePhysics.UP;
                        }
                    } else {
                        overlap = box1.y - box2.height - box2.y;
                        if ((-overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.UP) || !(phys2.allowCollisions & ArcadePhysics.DOWN)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.UP;
                            phys2.touching |= ArcadePhysics.DOWN;
                        }
                    }

                    //Then adjust their positions and velocities accordingly (if there was any overlap)
                    if (overlap != 0) {
                        var obj1v = phys1.velocity.y;
                        var obj2v = phys2.velocity.y;

                        if (!phys1.immovable && !phys2.immovable) {
                            overlap *= 0.5;

                            phys1.transform.y = phys1.transform.y - overlap;
                            phys2.transform.y = phys2.transform.y + overlap;

                            var obj1velocity = Math.sqrt((obj2v * obj2v * phys2.mass) / phys1.mass) * ((obj2v > 0) ? 1 : -1);
                            var obj2velocity = Math.sqrt((obj1v * obj1v * phys1.mass) / phys2.mass) * ((obj1v > 0) ? 1 : -1);
                            var average = (obj1velocity + obj2velocity) * 0.5;

                            obj1velocity -= average;
                            obj2velocity -= average;

                            phys1.velocity.y = average + obj1velocity * phys1.elasticity;
                            phys2.velocity.y = average + obj2velocity * phys2.elasticity;
                        } else if (!phys1.immovable) {
                            phys1.transform.y = phys1.transform.y - overlap;
                            phys1.velocity.y = obj2v - obj1v * phys1.elasticity;

                            //This is special case code that handles cases like horizontal moving platforms you can ride
                            if (object2.active && phys2.moves && (obj1delta > obj2delta))
                                phys1.transform.x = phys1.transform.worldX + object2.transform.worldX - phys2.last.x;
                        } else if (!phys2.immovable) {
                            phys2.transform.y = phys2.transform.y + overlap;
                            phys2.velocity.y = obj1v - obj2v * phys2.elasticity;

                            //This is special case code that handles cases like horizontal moving platforms you can ride
                            if (object1.active && phys1.moves && (obj1delta < obj2delta))
                                phys2.transform.x = phys2.transform.worldX + object1.transform.worldX - phys1.last.x;
                        }

                        return true;
                    }
                }

                return false;
            };

            /*
            *---------------
            * Seperation of Tiles Methods
            *---------------
            */
            /**
            * Separates a GameObject from a series of passed Tiles that lie on a TileMapLayer.
            * The gameobject needs to have a Box Component and an ArcadePhysics Component.
            * This method is not recommended to be directly used but instead use the 'overlapsTiles' method instead.
            *
            * @method separateTiles
            * @param object {Entity} The GameObject you are wanting to separate from a tile.
            * @param layer {TileMapLayer} The TileMapLayer that the tiles belong on.
            * @param tiles {Object[]}
            * @return {Boolean} If any separation occured.
            * @public
            * @static
            */
            ArcadePhysics.separateTiles = function (object, layer, tiles) {
                //Physics Component Found?
                if (object.components.hasComponent("ArcadePhysics") == false)
                    return false;

                //Immovable?
                if (object.components.getComponent("ArcadePhysics").immovable)
                    return false;

                var sepX = false;
                var sepY = false;

                for (var i = 0; i < tiles.length; i++) {
                    var tile = tiles[i];

                    if (!sepX)
                        sepX = this.separateTilesX(object, layer, tile);
                    if (!sepY)
                        sepY = this.separateTilesY(object, layer, tile);
                }

                return sepX || sepY;
            };

            /**
            * Separates a GameObjects from an Array of Tiles on the x-axis.
            * @method separateTilesX
            * @param object {Entity} The GameObject you are wanting to separate from a tile.
            * @param layer {TileMapLayer} The TileMapLayer that the tiles belong on.
            * @param tile {Object}.
            * @return {Boolean} If any separation occured.
            * @public
            * @static
            */
            ArcadePhysics.separateTilesX = function (object, layer, tile) {
                //Get Physics
                var phys1 = object.components.getComponent("ArcadePhysics");
                var phys2 = layer.components.getComponent("ArcadePhysics");

                //First, get the two object deltas
                var obj1delta = phys1.transform.worldX - phys1.last.x;
                var obj2delta = phys2.transform.worldX - phys2.last.x;

                //If they moved the same amount.
                if (obj1delta == obj2delta)
                    return false;

                //Absolute Delta and Overlap
                var obj1deltaAbs = (obj1delta > 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs = (obj2delta > 0) ? obj2delta : -obj2delta;
                var overlap = 0;
                var maxOverlap = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;

                //Quick References
                var box1 = phys1.box.worldHitbox;
                var tileTypes = layer.tilemap.tileTypes;
                var tData = layer.tileData;

                //Box of the GameObject
                var x = phys2.transform.worldX + tile.x;
                var obj1rect = new Kiwi.Geom.Rectangle(box1.x - ((obj1delta > 0) ? obj1delta : 0), phys1.last.y + phys1.box.hitboxOffset.y, box1.width + ((obj1delta > 0) ? obj1delta : -obj1delta), box1.height);
                var obj2rect = new Kiwi.Geom.Rectangle(x - ((obj2delta > 0) ? obj2delta : 0), phys2.last.y + tile.y, layer.tileWidth + ((obj2delta > 0) ? obj2delta : -obj2delta), layer.tileHeight);

                //Check to see if they overlap
                if ((obj1rect.x + obj1rect.width > obj2rect.x) && (obj1rect.x < obj2rect.x + obj2rect.width) && (obj1rect.y + obj1rect.height > obj2rect.y) && (obj1rect.y < obj2rect.y + obj2rect.height)) {
                    //Which way the delta is going
                    if (obj1delta > obj2delta) {
                        overlap = box1.x + box1.width - x;
                        if ((overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.RIGHT) || !(tileTypes[tData[tile.index]].allowCollisions & ArcadePhysics.LEFT)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.RIGHT;
                        }
                    } else {
                        overlap = box1.x - layer.tileWidth - x;
                        if ((-overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.LEFT) || !(tileTypes[tData[tile.index]].allowCollisions & ArcadePhysics.RIGHT)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.LEFT;
                        }
                    }

                    //Resolve the Collision
                    if (overlap != 0) {
                        var obj1v = phys1.velocity.x;
                        var obj2v = phys2.velocity.x;

                        phys1.transform.x = phys1.transform.x - overlap;
                        phys1.velocity.x = obj2v - obj1v * phys1.elasticity;

                        return true;
                    }
                }

                return false;
            };

            /**
            * Separates a GameObjects from an Array of Tiles on the y-axis.
            * @method separateTilesY
            * @param object {Entity} The GameObject you are wanting to separate from a tile.
            * @param layer {TileMapLayer} The TileMapLayer that the tiles belong on.
            * @param tiles {Object[]} The tiles which are overlapping with the GameObject.
            * @return {Boolean} If any separation occured.
            * @public
            * @static
            */
            ArcadePhysics.separateTilesY = function (object, layer, tile) {
                //Get the physics.
                var phys1 = object.components.getComponent("ArcadePhysics");
                var phys2 = layer.components.getComponent("ArcadePhysics");

                //First, get the two object deltas
                var obj1delta = phys1.transform.worldY - phys1.last.y;
                var obj2delta = phys2.transform.worldY - phys2.last.y;

                //Have they moved the same amount?
                if (obj1delta == obj2delta)
                    return false;

                //Absolute Delta and Max Overlap
                var obj1deltaAbs = (obj1delta > 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs = (obj2delta > 0) ? obj2delta : -obj2delta;
                var overlap = 0;
                var maxOverlap = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;

                var box1 = phys1.box.worldHitbox;
                var tileTypes = layer.tilemap.tileTypes;
                var tData = layer.tileData;
                var y = layer.transform.worldY + tile.y;

                //Rectangles
                var obj1rect = new Kiwi.Geom.Rectangle(box1.x, box1.y - ((obj1delta > 0) ? obj1delta : 0), box1.width, box1.height + obj1deltaAbs);
                var obj2rect = new Kiwi.Geom.Rectangle(phys2.transform.worldX + tile.x, y - ((obj2delta > 0) ? obj2delta : 0), layer.tileWidth, layer.tileHeight + obj2deltaAbs);

                //Check if they overlap
                if ((obj1rect.x + obj1rect.width > obj2rect.x) && (obj1rect.x < obj2rect.x + obj2rect.width) && (obj1rect.y + obj1rect.height > obj2rect.y) && (obj1rect.y < obj2rect.y + obj2rect.height)) {
                    if (obj1delta > obj2delta) {
                        overlap = box1.y + box1.height - y;
                        if ((overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.DOWN) || !(tileTypes[tData[tile.index]].allowCollisions & ArcadePhysics.UP)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.DOWN;
                        }
                    } else {
                        overlap = box1.y - layer.tileHeight - y;
                        if ((-overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.UP) || !(tileTypes[tData[tile.index]].allowCollisions & ArcadePhysics.DOWN)) {
                            overlap = 0;
                        } else {
                            phys1.touching |= ArcadePhysics.UP;
                        }
                    }

                    //Resolve the Collision
                    if (overlap != 0) {
                        var obj1v = phys1.velocity.y;
                        var obj2v = phys2.velocity.y;

                        phys1.transform.y = phys1.transform.y - overlap;
                        phys1.velocity.y = obj2v - obj1v * phys1.elasticity;

                        return true;
                    }
                }

                return false;
            };

            /*
            *---------------
            * Instance Functions
            *---------------
            */
            /**
            * A method to check to see if any Tiles with in this parent TileMapLayer overlaps with a GameObject passed.
            * If seperateObjects is true it will seperate the two entities based on their bounding box.
            * ONLY works if parent of the ArcadePhysics component which is calling this method is a TileMapLayer.
            * Note: The GameObject passed must contain a box component and only if you want to separate the two objects must is ALSO contain an ArcadePhysics component.
            *
            * @method overlapsTile
            * @param gameObject {Entity} The GameObject you would like to separate with this one.
            * @param [separateObjects=false] {Boolean} If you want the GameObject to be separated from any tile it collides with.
            * @param [collisionType=ANY] {Number} If you want the GameObject to only check for collisions from a particular side of tiles. ANY by default.
            * @return {Boolean} If any gameobject overlapped.
            * @public
            */
            ArcadePhysics.prototype.overlapsTiles = function (gameObject, separateObjects, collisionType) {
                if (typeof separateObjects === "undefined") { separateObjects = false; }
                if (typeof collisionType === "undefined") { collisionType = Kiwi.Components.ArcadePhysics.ANY; }
                //Are we a tilemaplayer?
                if (this.parent.childType() !== Kiwi.TILE_LAYER)
                    return false;

                var tiles = this.parent.getOverlappingTiles(gameObject, collisionType);

                if (tiles.length > 0) {
                    if (separateObjects)
                        ArcadePhysics.separateTiles(gameObject, this.parent, tiles);

                    return true;
                } else {
                    return false;
                }
            };

            /**
            * A method to check to see if the parent of this physics component overlaps with another Kiwi.Entity.
            * If seperateObjects is true it will seperate the two entities based on their bounding box.
            * Note: The GameObject passed must contain a box component and only if you want to separate the two objects must is ALSO contain an ArcadePhysics component.
            * Also: Not to be used for separation from tiles.
            *
            * @method overlaps
            * @param gameObject {Entity}
            * @param [seperateObjects=false] {boolean}
            * @return {boolean}
            * @public
            */
            ArcadePhysics.prototype.overlaps = function (gameObject, separateObjects) {
                if (typeof separateObjects === "undefined") { separateObjects = false; }
                if (gameObject.components.hasComponent('Box') == false)
                    return;

                var box = gameObject.components.getComponent('Box');

                var result = (box.worldHitbox.x + box.worldHitbox.width > this.box.worldHitbox.x) && (box.worldHitbox.x < this.box.worldHitbox.x + this.box.worldHitbox.width) && (box.worldHitbox.y + box.worldHitbox.height > this.box.worldHitbox.y) && (box.worldHitbox.y < this.box.worldHitbox.y + this.box.worldHitbox.height);

                if (result) {
                    if (separateObjects)
                        ArcadePhysics.separate(this.owner, gameObject);

                    if (this._callbackFunction !== null && this._callbackContext !== null) {
                        this._callbackFunction.call(this._callbackContext, this.owner, gameObject);
                    }
                }

                return result;
            };

            /**
            * A method to check to see if the parent of this physics component overlaps with another individual in a Kiwi Group.
            *
            * @method overlapsGroup
            * @param group {Group}
            * @param [seperateObjects=false] {boolean}
            * @return { boolean }
            * @public
            */
            ArcadePhysics.prototype.overlapsGroup = function (group, separateObjects) {
                if (typeof separateObjects === "undefined") { separateObjects = false; }
                var results = false;

                for (var i = 0; i < group.members.length; i++) {
                    if (group.members[i].childType() === Kiwi.GROUP) {
                        //recursively check overlap
                        this.overlapsGroup(group.members[i], separateObjects);
                    } else {
                        //otherwise its an entity
                        if (this.overlaps(group.members[i], separateObjects)) {
                            if (this._callbackContext !== null && this._callbackFunction !== null)
                                this._callbackFunction.call(this._callbackContext, this.owner, group.members[i]);
                            results = true;
                        }
                    }
                }

                return results;
            };

            /**
            * A method to check to see if the parent of this physics component overlaps with a Entity that is held in an array.
            * @method overlapsArray
            * @param array {Array} The array of GameObjects you want to check.
            * @param [separateObjects=false] {boolean} If when the objects collide you want them to seperate outwards.
            * @return {boolean} If a collision was detected or not.
            * @public
            */
            ArcadePhysics.prototype.overlapsArray = function (array, separateObjects) {
                if (typeof separateObjects === "undefined") { separateObjects = false; }
                var results = false;

                for (var i = 0; i < array.length; i++) {
                    if (typeof array[i].childType !== "undefined") {
                        if (array[i].childType() == Kiwi.GROUP) {
                            this.overlapsGroup(array[i], separateObjects);
                        } else {
                            if (this.overlaps(array[i], separateObjects)) {
                                this._callbackFunction.call(this._callbackContext, this.owner, array[i]);
                                results = true;
                            }
                        }
                    }
                }

                return results;
            };

            /*
            *-------------
            * Motion Methods
            *-------------
            */
            /**
            * Computes the velocity based on the parameters passed.
            * @method computeVelocity
            * @static
            * @param velocity {number}
            * @param [acceleration=0] {number}
            * @param [drag=0] {number}
            * @param [max=10000] {number}
            * @return {Number} The new velocity
            * @public
            */
            ArcadePhysics.computeVelocity = function (velocity, acceleration, drag, max) {
                if (typeof acceleration === "undefined") { acceleration = 0; }
                if (typeof drag === "undefined") { drag = 0; }
                if (typeof max === "undefined") { max = 10000; }
                if (acceleration != 0)
                    velocity += acceleration * ArcadePhysics.updateInterval;
                else if (drag != 0) {
                    drag = drag * ArcadePhysics.updateInterval;
                    if (velocity - drag > 0)
                        velocity = velocity - drag;
                    else if (velocity + drag < 0)
                        velocity += drag;
                    else
                        velocity = 0;
                }
                if ((velocity != 0) && (max != 10000)) {
                    if (velocity > max)
                        velocity = max;
                    else if (velocity < -max)
                        velocity = -max;
                }
                return velocity;
            };

            /**
            * Updates the position of this object. Automatically called if the 'moves' parameter is true.
            * @method updateMotion
            * @public
            */
            ArcadePhysics.prototype.updateMotion = function () {
                var delta;
                var velocityDelta;

                //Update the motion calculated from rotation.
                velocityDelta = (ArcadePhysics.computeVelocity(this.angularVelocity, this.angularAcceleration, this.angularDrag, this.maxAngular) - this.angularVelocity) / 2;
                this.angularVelocity += velocityDelta;
                this.transform.rotation += this.angularVelocity * ArcadePhysics.updateInterval;
                this.angularVelocity += velocityDelta;

                //Update the motion on the x-axis.
                velocityDelta = (ArcadePhysics.computeVelocity(this.velocity.x, this.acceleration.x, this.drag.x, this.maxVelocity.x) - this.velocity.x) / 2;
                this.velocity.x += velocityDelta;
                delta = this.velocity.x * ArcadePhysics.updateInterval;
                this.velocity.x += velocityDelta;
                this.transform.x = this.transform.x + delta;

                //Update the motion on the y-axis.
                velocityDelta = (ArcadePhysics.computeVelocity(this.velocity.y, this.acceleration.y, this.drag.y, this.maxVelocity.y) - this.velocity.y) / 2;
                this.velocity.y += velocityDelta;
                delta = this.velocity.y * ArcadePhysics.updateInterval;
                this.velocity.y += velocityDelta;
                this.transform.y = this.transform.y + delta;
            };

            /**
            * The Update loop of the physics component
            * @method update
            * @public
            */
            ArcadePhysics.prototype.update = function () {
                //Flixel preupdate
                this.last.x = this.transform.worldX;
                this.last.y = this.transform.worldY;

                //Flixel postupdate
                if (this.moves)
                    this.updateMotion();

                this.wasTouching = this.touching;
                this.touching = ArcadePhysics.NONE;
            };

            /**
            * Removes all properties that refer to other objects or outside of this class in order to flag this object for garbage collection.
            * @method destroy
            * @public
            */
            ArcadePhysics.prototype.destroy = function () {
                _super.prototype.destroy.call(this);

                delete this.transform;
                delete this.owner;
                delete this._callbackContext;
                delete this._callbackFunction;
            };

            /**
            * The type of object that this is.
            * @method objType
            * @return {string}
            * @public
            */
            ArcadePhysics.prototype.objType = function () {
                return "ArcadePhysics";
            };

            /*
            *----------------
            * Static Functions
            *----------------
            */
            /*
            *----------------
            * Collide Functions - Maps to Overlaps
            *----------------
            */
            /**
            * A Static method to check to see if two objects collide or not. Returns a boolean indicating whether they overlaped or not.
            *
            * @method collide
            * @static
            * @public
            * @param gameObject1 {Kiwi.GameObjects.Entity} The first game object.
            * @param gameObject2 {Kiwi.GameObjects.Entity} The second game object.
            * @param [seperate=true] {boolean} If the two gameobjects should seperated when they collide.
            * @return {boolean}
            */
            ArcadePhysics.collide = function (gameObject1, gameObject2, seperate) {
                if (typeof seperate === "undefined") { seperate = true; }
                return ArcadePhysics.overlaps(gameObject1, gameObject2, seperate);
            };

            /**
            * A Static method to check to see if a single entity collides with a group of entities. Returns a boolean indicating whether they overlaped or not.
            *
            * @method collideGroup
            * @static
            * @public
            * @param gameObject {Kiwi.GameObjects.Entity}
            * @param group {Any} This could be either an Array of GameObjects or a Group containing members.
            * @param [seperate=true] {boolean}
            * @return {boolean}
            * @public
            */
            ArcadePhysics.collideGroup = function (gameObject, group, seperate) {
                if (typeof seperate === "undefined") { seperate = true; }
                return ArcadePhysics.overlapsObjectGroup(gameObject, group, seperate);
            };

            /**
            * A Static method to check to see if a group of entities overlap with another group of entities. Returns a boolean indicating whether they overlaped or not.
            *
            * @method collideGroupGroup
            * @static
            * @public
            * @param group1 {Any} This can either be an array or a Group.
            * @param group2 {Any} Also could either be an array or a Group.
            * @param [seperate=true] {boolean}
            * @return {boolean}
            */
            ArcadePhysics.collideGroupGroup = function (group1, group2, seperate) {
                if (typeof seperate === "undefined") { seperate = true; }
                return ArcadePhysics.overlapsGroupGroup(group1, group2, seperate);
            };

            /*
            *-------------
            * Overlap Static Method - Use's the Arcade Physics of one of the gameobjects passed.
            *-------------
            */
            /**
            * A Static method to that checks to see if two objects overlap. Returns a boolean indicating whether they did or not.
            *
            * @method overlaps
            * @static
            * @public
            * @param gameObject1 {Kiwi.GameObjects.Entity}
            * @param gameObject2 {Kiwi.GameObjects.Entity}
            * @param [separateObjects=true] {boolean}
            * @return {boolean}
            */
            ArcadePhysics.overlaps = function (gameObject1, gameObject2, separateObjects) {
                if (typeof separateObjects === "undefined") { separateObjects = true; }
                var obj1Physics = gameObject1.components.getComponent("ArcadePhysics");
                return obj1Physics.overlaps(gameObject2, separateObjects);
            };

            /**
            * A Static method to that checks to see if a single object overlaps with a group of entities. Returns a boolean indicating whether they did or not.
            *
            * @method overlapsObjectGroup
            * @static
            * @param gameObject {Entity}
            * @param group {Group}
            * @param [seperateObjects=true] {boolean} If they overlap should the seperate or not
            * @return {boolean}
            * @public
            */
            ArcadePhysics.overlapsObjectGroup = function (gameObject, group, separateObjects) {
                if (typeof separateObjects === "undefined") { separateObjects = true; }
                var objPhysics = gameObject.components.getComponent("ArcadePhysics");
                return objPhysics.overlapsGroup(group, separateObjects);
            };

            /**
            * A Static method that checks to see if any objects in a group overlap with objects in another group.
            *
            * @method overlaps
            * @static
            * @param group1 {Group} The first
            * @param group2 {Any}
            * @param [seperate=true] {boolean} If they overlap should the seperate or not
            * @return {boolean}
            * @public
            */
            ArcadePhysics.overlapsGroupGroup = function (group1, group2, separateObjects) {
                if (typeof separateObjects === "undefined") { separateObjects = true; }
                var result = false;

                var members = group1.members;
                var i = 0;

                while (i < group1.members.length) {
                    if (members[i].childType() == Kiwi.GROUP) {
                        if (ArcadePhysics.overlapsGroupGroup(members[i++], group2, separateObjects))
                            result = true;
                    } else {
                        if (ArcadePhysics.overlapsObjectGroup(members[i++], group2, separateObjects))
                            result = true;
                    }
                }

                return result;
            };

            /**
            * A Statuc method that checks to see if any objects from an Array collide with a Kiwi Group members.
            *
            * @method overlapsArrayGroup
            * @param array {Array} An array you want to check collide.
            * @param group {Group} A group of objects you want to check overlaps.
            * @param [seperateObjects=true] {Boolean} If when a collision is found the objects should seperate out.
            * @return {Boolean}
            * @static
            */
            ArcadePhysics.overlapsArrayGroup = function (array, group, separateObjects) {
                if (typeof separateObjects === "undefined") { separateObjects = true; }
                var result = false;

                for (var i = 0; i < array.length; i++) {
                    if (typeof array[i].childType !== "undefined") {
                        if (array[i].childType() === Kiwi.GROUP) {
                            if (ArcadePhysics.overlapsGroupGroup(array[i], group, separateObjects))
                                result = true;
                        } else {
                            if (ArcadePhysics.overlapsObjectGroup(array[i], group, separateObjects))
                                result = true;
                        }
                    }
                }

                return result;
            };

            ArcadePhysics.updateInterval = 1 / 10;

            ArcadePhysics.LEFT = 0x0001;

            ArcadePhysics.RIGHT = 0x0010;

            ArcadePhysics.UP = 0x0100;

            ArcadePhysics.DOWN = 0x1000;

            ArcadePhysics.NONE = 0;

            ArcadePhysics.CEILING = ArcadePhysics.UP;

            ArcadePhysics.FLOOR = ArcadePhysics.DOWN;

            ArcadePhysics.WALL = ArcadePhysics.LEFT | ArcadePhysics.RIGHT;

            ArcadePhysics.ANY = ArcadePhysics.LEFT | ArcadePhysics.RIGHT | ArcadePhysics.UP | ArcadePhysics.DOWN;

            ArcadePhysics.OVERLAP_BIAS = 4;
            return ArcadePhysics;
        })(Kiwi.Component);
        Components.ArcadePhysics = ArcadePhysics;
    })(Kiwi.Components || (Kiwi.Components = {}));
    var Components = Kiwi.Components;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Files
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Files) {
        /**
        * Used for the loading of files and game assets. This usually happens when a State is at the 'loading' stage (executing the 'preload' method).
        *
        * @class Loader
        * @namespace Kiwi.Files
        * @constructor
        * @param game {Game} The game that this loader belongs to.
        * @return {Loader} This Object
        *
        */
        var Loader = (function () {
            function Loader(game) {
                /**
                * If a real byte value calculation will be made prior to the load (much smoother progress bar but costs HEAD calls x total file count)
                * @property _calculateBytes
                * @type boolean
                * @default true
                * @private
                */
                this._calculateBytes = true;
                /**
                * Total number of files to be loaded
                * @property _fileTotal
                * @type Number
                * @private
                */
                this._fileTotal = 0;
                /**
                * The most recently loaded file (out of the total)
                * @property _currentFile
                * @type Number
                * @private
                */
                this._currentFile = 0;
                /**
                * Total file size (in bytes) of all files to be loaded - only set if calculateBytes is true
                * @property _bytesTotal
                * @type Number
                * @private
                */
                this._bytesTotal = 0;
                /**
                * Total number of bytes loaded so far (out of _bytesTotal)
                * @property _bytesLoaded
                * @type Number
                * @private
                */
                this._bytesLoaded = 0;
                /**
                * Total number of bytes loaded from last completed file
                * @property _bytesCurrent
                * @type Number
                * @private
                */
                this._bytesCurrent = 0;
                /**
                * When using the tag loader we don't have a byte total, just a X of files total - this holds the percentage each file from that total is worth
                * @property _fileChunk
                * @type Number
                * @private
                */
                this._fileChunk = 0;
                /**
                * The total % of the current queue that has been loaded
                * @property _percentLoaded
                * @type Number
                * @private
                */
                this._percentLoaded = 0;
                /**
                * Everything in the queue loaded?
                * @property _complete
                * @type boolean
                * @private
                */
                this._complete = false;
                this._game = game;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Loader.prototype.objType = function () {
                return "Loader";
            };

            /**
            * The boot method is executed when the DOM has successfully loaded and we can now start the game.
            * @method boot
            * @public
            */
            Loader.prototype.boot = function () {
                this._fileList = [];
                this._loadList = [];
            };

            /**
            * Initialise the properities that are needed on this loader.
            * @method init
            * @param [progress=null] {Any} Progress callback method.
            * @param [complete=null] {Any} Complete callback method.
            * @param [calculateBytes=false] {boolean}
            * @public
            */
            Loader.prototype.init = function (progress, complete, calculateBytes) {
                if (typeof progress === "undefined") { progress = null; }
                if (typeof complete === "undefined") { complete = null; }
                if (typeof calculateBytes === "undefined") { calculateBytes = false; }
                this._fileList.length = 0;
                this._loadList.length = 0;

                this._calculateBytes = calculateBytes;
                this._complete = false;

                if (progress !== null) {
                    this._onProgressCallback = progress;
                }

                if (complete !== null) {
                    this._onCompleteCallback = complete;
                }
            };

            /**
            * Creates a new file for an image and adds a the file to loading queue.
            * @method addImage
            * @param key {String} The key for the file.
            * @param url {String} The url of the image to load.
            * @param [width] {number} The width of the cell on the image to use once the image is loaded.
            * @param [height] {number} The height of the cell on the image to use once the image is loaded.
            * @param [offsetX] {number} An offset on the x axis of the cell.
            * @param [offsetY] {number} An offset of the y axis of the cell.
            * @param [storeAsGlobal=true] {boolean} If the image should be stored globally or not.
            * @public
            */
            Loader.prototype.addImage = function (key, url, width, height, offsetX, offsetY, storeAsGlobal) {
                if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
                var file = new Kiwi.Files.File(this._game, Kiwi.Files.File.IMAGE, url, key, true, storeAsGlobal);
                file.metadata = { width: width, height: height, offsetX: offsetX, offsetY: offsetY };

                this._fileList.push(file);
            };

            /**
            * Creates a new file for a spritesheet and adds the file to the loading queue.
            * @method addSpriteSheet
            * @param key {String} The key for the file.
            * @param url {String} The url of the image to load.
            * @param frameWidth {number} The width of a single cell in the spritesheet.
            * @param frameHeight {number} The height of a single cell in the spritesheet.
            * @param [numCells] {number} The number of cells that are in this spritesheet.
            * @param [rows] {number} The number of cells that are in a row.
            * @param [cols] {number} The number of cells that are in a column.
            * @param [sheetOffsetX] {number} The offset of the whole spritesheet on the x axis.
            * @param [sheetOffsetY] {number} The offset of the whole spritesheet on the y axis.
            * @param [cellOffsetX] {number} The spacing between each cell on the x axis.
            * @param [cellOffsetY] {number} The spacing between each cell on the y axis.
            * @param [storeAsGlobal=true] {boolean}
            * @public
            */
            Loader.prototype.addSpriteSheet = function (key, url, frameWidth, frameHeight, numCells, rows, cols, sheetOffsetX, sheetOffsetY, cellOffsetX, cellOffsetY, storeAsGlobal) {
                if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
                var file = new Kiwi.Files.File(this._game, Kiwi.Files.File.SPRITE_SHEET, url, key, true, storeAsGlobal);

                file.metadata = { frameWidth: frameWidth, frameHeight: frameHeight, numCells: numCells, rows: rows, cols: cols, sheetOffsetX: sheetOffsetX, sheetOffsetY: sheetOffsetY, cellOffsetX: cellOffsetX, cellOffsetY: cellOffsetY };

                this._fileList.push(file);
            };

            /**
            * Creates new file's for loading a texture atlas and adds those files to the loading queue.
            * @method addTextureAtlas
            * @param key {String} The key for the image file.
            * @param imageUrl {String} The url of the image to load.
            * @param jsonID {String} A key for the JSON file.
            * @param jsonURL {String} The url of the json file to load.
            * @param [storeAsGlobal=true] {Boolean} If hte files should be stored globally or not.
            * @public
            */
            Loader.prototype.addTextureAtlas = function (key, imageURL, jsonID, jsonURL, storeAsGlobal) {
                if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
                var imageFile = new Kiwi.Files.File(this._game, Kiwi.Files.File.TEXTURE_ATLAS, imageURL, key, true, storeAsGlobal);
                var jsonFile = new Kiwi.Files.File(this._game, Kiwi.Files.File.JSON, jsonURL, jsonID, true, storeAsGlobal);

                imageFile.metadata = { jsonID: jsonID };
                jsonFile.metadata = { imageID: key };

                this._fileList.push(imageFile, jsonFile);
            };

            /**
            * Creates a new File to store a audio piece.
            * This method firstly checks to see if the AUDIO file being loaded is supported or not by the browser/device before adding it to the loading queue.
            * You can override this behaviour and tell the audio data to load even if not supported by setting the 'onlyIfSupported' boolean to false.
            *
            * @method addAudio
            * @param key {String} The key for the audio file.
            * @param url {String} The url of the audio to load.
            * @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
            * @param [onlyIfSupported=true] {Boolean} If the audio file should only be loaded if Kiwi detects that the audio file could be played. Set this to fa
            * @public
            */
            Loader.prototype.addAudio = function (key, url, storeAsGlobal, onlyIfSupported) {
                if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
                if (typeof onlyIfSupported === "undefined") { onlyIfSupported = true; }
                var file = new Kiwi.Files.File(this._game, Kiwi.Files.File.AUDIO, url, key, true, storeAsGlobal);
                var support = false;

                switch (file.fileExtension) {
                    case 'mp3':
                        support = Kiwi.DEVICE.mp3;
                        break;

                    case 'ogg':
                    case 'oga':
                        support = Kiwi.DEVICE.ogg;
                        break;

                    case 'm4a':
                        support = Kiwi.DEVICE.m4a;
                        break;

                    case 'wav':
                    case 'wave':
                        support = Kiwi.DEVICE.wav;
                        break;
                }

                if (support == true || onlyIfSupported == false) {
                    this._fileList.push(file);
                } else {
                    console.error('Audio Format not supported on this Device/Browser.');
                }
            };

            /**
            * Creates a new File to store JSON and adds it to the loading queue.
            * @method addJSON
            * @param key {String} The key for the file.
            * @param url {String} The url to the json file.
            * @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
            * @public
            */
            Loader.prototype.addJSON = function (key, url, storeAsGlobal) {
                if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
                this._fileList.push(new Kiwi.Files.File(this._game, Kiwi.Files.File.JSON, url, key, true, storeAsGlobal));
            };

            /**
            * Creates a new File to store XML and adds it to the loading queue.
            * @method addXML
            * @param key {String} The key for the file.
            * @param url {String} The url to the xml file.
            * @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
            * @public
            */
            Loader.prototype.addXML = function (key, url, storeAsGlobal) {
                if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
                this._fileList.push(new Kiwi.Files.File(this._game, Kiwi.Files.File.XML, url, key, true, storeAsGlobal));
            };

            /**
            * Creates a new File for a Binary file and adds it to the loading queue.
            * @method addBinaryFile
            * @param key {String} The key for the file.
            * @param url {String} The url to the Binary file.
            * @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
            * @public
            */
            Loader.prototype.addBinaryFile = function (key, url, storeAsGlobal) {
                if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
                this._fileList.push(new Kiwi.Files.File(this._game, Kiwi.Files.File.BINARY_DATA, url, key, true, storeAsGlobal));
            };

            /**
            * Creates a new File to store a text file and adds it to the loading queue.
            * @method addTextFile
            * @param key {String} The key for the file.
            * @param url {String} The url to the text file.
            * @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
            * @public
            */
            Loader.prototype.addTextFile = function (key, url, storeAsGlobal) {
                if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
                this._fileList.push(new Kiwi.Files.File(this._game, Kiwi.Files.File.TEXT_DATA, url, key, true, storeAsGlobal));
            };

            /**
            * Loops through all of the files that need to be loaded and start the load event on them.
            * @method startLoad
            * @public
            */
            Loader.prototype.startLoad = function () {
                if (this._fileList.length === 0) {
                    this._onCompleteCallback();
                } else {
                    this._onProgressCallback(0, 0, null);

                    this._fileTotal = this._fileList.length;
                    this._bytesLoaded = 0;
                    this._bytesTotal = 0;
                    this._bytesCurrent = 0;
                    this._currentFile = 0;
                    this._fileChunk = 0;
                    this._percentLoaded = 0;

                    if (this._calculateBytes === true) {
                        this.getNextFileSize();
                    } else {
                        this._fileChunk = Math.floor(100 / this._fileTotal);
                        this._loadList = this._fileList;

                        this.nextFile();
                    }
                }
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method getNextFileSize
            * @private
            */
            Loader.prototype.getNextFileSize = function () {
                var _this = this;
                if (this._fileList.length === 0) {
                    var tempFile = this._fileList.shift();

                    tempFile.getFileDetails(function (file) {
                        return _this.addToBytesTotal(file);
                    });
                } else {
                    this.nextFile();
                }
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method addToBytesTotal
            * @param file {File}
            * @private
            */
            Loader.prototype.addToBytesTotal = function (file) {
                this._bytesTotal += file.fileSize;

                this._loadList.push(file);

                this.getNextFileSize();
            };

            /**
            * Starts the loading of the next file in the list.
            * @method nextFile
            * @private
            */
            Loader.prototype.nextFile = function () {
                var _this = this;
                this._currentFile++;

                var tempFile = this._loadList.shift();

                tempFile.load(function (f) {
                    return _this.fileLoadComplete(f);
                }, function (f) {
                    return _this.fileLoadProgress(f);
                });
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method fileLoadProgress
            * @param file {File}
            * @private
            */
            Loader.prototype.fileLoadProgress = function (file) {
                if (this._calculateBytes === true) {
                    this._bytesCurrent = file.bytesLoaded;

                    if (this._onProgressCallback) {
                        //  Send: the percentage complete (overall), the bytes total (overall) and the file currently being loaded
                        this._onProgressCallback(this.getPercentLoaded(), this.getBytesLoaded(), file);
                    }
                }
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method fileLoadComplete
            * @param file {File}
            * @private
            */
            Loader.prototype.fileLoadComplete = function (file) {
                if (this._calculateBytes === true) {
                    this._bytesLoaded += file.bytesTotal;
                    this._bytesCurrent = 0;

                    if (this._onProgressCallback) {
                        //  Send: the percentage complete (overall), the bytes total (overall) and the file currently being loaded
                        this._onProgressCallback(this.getPercentLoaded(), this._bytesLoaded, file);
                    }
                } else {
                    if (this._onProgressCallback) {
                        //  Send: the percentage complete (overall)
                        this._onProgressCallback(this.getPercentLoaded(), 0, file);
                    }
                }

                if (this._loadList.length === 0) {
                    //  All files loaded
                    this._complete = true;
                    if (this._game.debug) {
                        console.log("All files have loaded");
                    }

                    if (this._onCompleteCallback) {
                        this._onCompleteCallback();
                    }
                } else {
                    this.nextFile();
                }
            };

            /**
            * Returns the total number of bytes that have been loaded so far.
            * @method getBytesLoaded
            * @return {Number}
            * @public
            */
            Loader.prototype.getBytesLoaded = function () {
                return this._bytesLoaded + this._bytesCurrent;
            };

            /**
            * Returns a percentage of the amount that has been loaded so far.
            * @method getPercentLoaded
            * @return {Number}
            * @public
            */
            Loader.prototype.getPercentLoaded = function () {
                if (this._calculateBytes === true) {
                    return Math.round((this.getBytesLoaded() / this._bytesTotal) * 100);
                } else {
                    return Math.round((this._currentFile / this._fileTotal) * 100);
                }
            };

            /**
            * If true (and xhr/blob is available) the loader will get the bytes total of each file in the queue to give a much more accurate progress report during load
            If false the loader will use the file number as the progress value, i.e. if there are 4 files in the queue progress will get called 4 times (25, 50, 75, 100)
            * @method calculateBytes
            * @param [value] {boolean}
            * @return {boolean}
            * @public
            */
            Loader.prototype.calculateBytes = function (value) {
                if (value) {
                    this._calculateBytes = value;
                }

                return this._calculateBytes;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method complete
            * @return {boolean}
            * @public
            */
            Loader.prototype.complete = function () {
                return this._complete;
            };
            return Loader;
        })();
        Files.Loader = Loader;
    })(Kiwi.Files || (Kiwi.Files = {}));
    var Files = Kiwi.Files;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Files
* @main Files
*/
var Kiwi;
(function (Kiwi) {
    (function (Files) {
        /**
        * Holds a reference to all of the data Files (json, xml, e.t.c) that are accessible on the State that this DataLibrary is on.
        *
        * @class DataLibrary
        * @namespace Kiwi.Files
        * @constructor
        * @param game {Game} The game that this DataLibrary belongs to.
        * @return {DataLibrary}
        *
        */
        var DataLibrary = (function () {
            function DataLibrary(game) {
                this._game = game;
                this.data = {};
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            DataLibrary.prototype.objType = function () {
                return "DataLibrary";
            };

            /**
            * Resets the Data Library and makes it ready for the next state.
            * @method clear
            * @public
            */
            DataLibrary.prototype.clear = function () {
                for (var prop in this.data) {
                    delete this.data[prop];
                }
            };

            /**
            * Adds a new data file to the DataLibrary.
            * @method add
            * @param dataFile {File}
            * @public
            */
            DataLibrary.prototype.add = function (dataFile) {
                switch (dataFile.dataType) {
                    case Kiwi.Files.File.JSON:
                    case Kiwi.Files.File.XML:
                    case Kiwi.Files.File.BINARY_DATA:
                    case Kiwi.Files.File.TEXT_DATA:
                        this.data[dataFile.key] = dataFile;
                        break;

                    default:
                        break;
                }
            };

            /**
            * Rebuild the library from a fileStore. Clears the library and repopulates it.
            * @method rebuild
            * @param {Kiwi.Files.FileStore} fileStore
            * @param {Kiwi.State} state
            * @public
            */
            DataLibrary.prototype.rebuild = function (fileStore, state) {
                this.clear();
                if (this._game.debug) {
                    console.log("Rebuilding Data Library");
                }

                var fileStoreKeys = fileStore.keys;
                for (var i = 0; i < fileStoreKeys.length; i++) {
                    var file = this._game.fileStore.getFile(fileStoreKeys[i]);
                    if (file.isData) {
                        if (this._game.debug) {
                            console.log("Adding Data: " + file.fileName);
                        }
                        ;
                        state.dataLibrary.add(file);
                    }
                }
            };
            return DataLibrary;
        })();
        Files.DataLibrary = DataLibrary;
    })(Kiwi.Files || (Kiwi.Files = {}));
    var Files = Kiwi.Files;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Files
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Files) {
        /**
        * Handles the loading of an external data file via a tag loader OR xhr + arraybuffer, and optionally saves to the file store.
        * Also can contain information about the file (like file size, last modified, e.t.c.) either after it has been loaded
        * OR if you use the 'getFileDetails' method and the properties will then be set.
        *
        * @class File
        * @namespace Kiwi.Files
        * @constructor
        * @param game {Game} The game that this file belongs to.
        * @param dataType {Number} The type of file that is being loaded. For this you can use the STATIC properties that are located on this class for quick code completion.
        * @param path {String} The location of the file that is to be loaded.
        * @param [name=''] {String} A name for the file. If no name is specified then the files name will be used.
        * @param [saveToFileStore=true] {Boolean} If the file should be saved on the file store or not.
        * @param [storeAsGlobal=true] {Boolean} If this file should be stored as a global file, or if it should be destroyed when this state gets switched out.
        * @return {File}
        *
        */
        var File = (function () {
            function File(game, dataType, path, name, saveToFileStore, storeAsGlobal) {
                if (typeof name === "undefined") { name = ''; }
                if (typeof saveToFileStore === "undefined") { saveToFileStore = true; }
                if (typeof storeAsGlobal === "undefined") { storeAsGlobal = true; }
                /**
                * The XMLHttpRequest object. This only has a value if the xhr method of load is being used, otherwise this is null.
                * @property _xhr
                * @type XMLHttpRequest
                * @private
                */
                this._xhr = null;
                /**
                * Used to determine if this file should be saved to the file store or not.
                * @property _saveToFileStore
                * @type boolean
                * @default true
                * @private
                */
                this._saveToFileStore = true;
                /**
                * If when loading the file in we have loaded the file in using a tag loader (older browsers) or we are using the an XHR loader + array buffer.
                * By default we use the tag loader and only used the second method if the browser supports it.
                * @property _useTagLoader
                * @type boolean
                * @default true
                * @private
                */
                this._useTagLoader = true;
                /**
                * The size of the file that was/is being loaded.
                * Only has a value when the file was loaded by the XHR method OR you request the file information before hand using 'getFileDetails'.
                * @property fileSize
                * @type Number
                * @default 0
                * @public
                */
                this.fileSize = 0;
                /**
                * The Entity Tag that is assigned to the file. O
                * Only has a value when either using the XHR loader OR when requesting the file details.
                * @property ETag
                * @type String
                * @public
                */
                this.ETag = '';
                /**
                * The last date/time that this file was last modified.
                * Only has a value when using the XHR method of loading OR when requesting the file details.
                * @property lastModified
                * @type String
                * @default ''
                * @public
                */
                this.lastModified = '';
                /**
                * The time at which the loading started. Only has a value when the XHR method of loading is in use.
                * @property timeStarted
                * @type Number
                * @default 0
                * @public
                */
                this.timeStarted = 0;
                /**
                * The time at which the load finished. Only has a value if loading the file was successful and when the XHR method of loading is in use.
                * @property timeFinished
                * @type Number
                * @default 0
                * @public
                */
                this.timeFinished = 0;
                /**
                * The duration or how long it took to load the file. In milliseconds.
                * @property duration
                * @type Number
                * @default 0
                * @public
                */
                this.duration = 0;
                /**
                * If the loading of the file failed or encountered an error.
                * @property hasError
                * @type boolean
                * @default false
                * @public
                */
                this.hasError = false;
                /**
                * If the loading was a success or not.
                * @property success
                * @type boolean
                * @public
                */
                this.success = false;
                /**
                * A method that is to be executed when this file has finished loading.
                * @property onCompleteCallback
                * @type Any
                * @default null
                * @public
                */
                this.onCompleteCallback = null;
                /**
                * A method that is to be executed while this file is loading.
                * @property onProgressCallback
                * @type Any
                * @default null
                * @public
                */
                this.onProgressCallback = null;
                /**
                * The time at which progress in loading the file was last occurred.
                * @property lastProgress
                * @type Number
                * @public
                */
                this.lastProgress = 0;
                /**
                * The amount of percent loaded the file is. This is out of 100.
                * @property percentLoaded
                * @type Number
                * @public
                */
                this.percentLoaded = 0;
                /*
                *-----------------------
                * XHR Loading
                *-----------------------
                */
                /**
                * The status of this file that is being loaded.
                * Only used/has a value when the file was/is being loaded by the XHR method.
                * @property status
                * @type Number
                * @default 0
                * @public
                */
                this.status = 0;
                /**
                * The status piece of text that the XHR returns.
                * @property statusText
                * @type String
                * @default ''
                * @public
                */
                this.statusText = '';
                /**
                * The number of bytes that have currently been loaded.
                * This can used to create progress bars but only has a value when using the XHR method of loading.
                * @property bytesLoaded
                * @type Number
                * @default 0
                * @public
                */
                this.bytesLoaded = 0;
                /**
                * The total number of bytes that the file consists off.
                * Only has a value when using the XHR method of loading.
                * @property bytesTotal
                * @type Number
                * @default 0
                * @public
                */
                this.bytesTotal = 0;
                /**
                * The ready state of the XHR loader whilst loading.
                * @property readyState
                * @type Number
                * @default 0
                * @public
                */
                this.readyState = 0;
                /**
                * The default number of milliseconds that the XHR should wait before timing out.
                * Set this to NULL if you want it to not timeout.
                * @property timeOutDelay
                * @type Number
                * @default 2000
                * @public
                */
                this.timeOutDelay = 4000;
                /**
                * If this file has timeout when it was loading.
                * @property hasTimedOut
                * @type boolean
                * @default false
                * @public
                */
                this.hasTimedOut = false;
                /**
                * If the file timed out or not.
                * @property timedOut
                * @type Number
                * @default 0
                * @public
                */
                this.timedOut = 0;
                /**
                * The number of attempts at loading there have currently been at loading the file.
                * This is only used with XHR methods of loading.
                * @property attemptCounter
                * @type Number
                * @public
                */
                this.attemptCounter = 0;
                /**
                * The maximum attempts at loading the file that there is allowed.
                * Only used with XHR methods of loading.
                * @property maxLoadAttempts
                * @type Number
                * @default 2
                * @public
                */
                this.maxLoadAttempts = 2;
                /*
                *--------------------
                * File Details - Head Information
                *--------------------
                */
                /**
                * The maximum number of load attempts when requesting the file details that will be preformed.
                * @property maxHeadLoadAttempts
                * @type number
                * @default 1
                * @public
                */
                this.maxHeadLoadAttempts = 1;
                this._game = game;

                this.dataType = dataType;

                this.fileURL = path;

                if (path.lastIndexOf('/') > -1) {
                    this.fileName = path.substr(path.lastIndexOf('/') + 1);
                    this.filePath = path.substr(0, path.lastIndexOf('/') + 1);
                } else {
                    this.filePath = '';
                    this.fileName = path;
                }

                //  Not safe if there is a query string after the file extension
                this.fileExtension = path.substr(path.lastIndexOf('.') + 1).toLowerCase();

                if (Kiwi.DEVICE.blob) {
                    this._useTagLoader = true;
                } else {
                    this._useTagLoader = true;
                }

                if (this.dataType === Kiwi.Files.File.AUDIO) {
                    if (this._game.audio.usingAudioTag === true) {
                        this._useTagLoader = true;
                    } else {
                        this._useTagLoader = false;
                    }
                }

                if (this.dataType === Kiwi.Files.File.JSON) {
                    this._useTagLoader = false;
                }

                this._saveToFileStore = saveToFileStore;
                this._fileStore = this._game.fileStore;

                // null state owner indicates global storage
                if (this._game.states.current && !storeAsGlobal) {
                    this.ownerState = this._game.states.current;
                } else {
                    this.ownerState = null;
                }

                if (this.key === '') {
                    this.key = this.fileName;
                } else {
                    this.key = name;
                }
            }
            /**
            * Returns the type of this object
            * @method objType
            * @return {String}
            * @public
            */
            File.prototype.objType = function () {
                return "File";
            };

            /**
            * Adds a new tag to this file.
            * @method addTag
            * @param tag {String} The tag that you would like to add
            * @public
            */
            File.prototype.addTag = function (tag) {
                if (this._tags.indexOf(tag) == -1) {
                    this._tags.push(tag);
                }
            };

            /**
            * Removes a tag from this file.
            * @method removeTag
            * @param tag {String} The tag that is to be removed.
            * @public
            */
            File.prototype.removeTag = function (tag) {
                var index = this._tags.indexOf(tag);
                if (index != -1) {
                    this._tags.splice(index, 1);
                }
            };

            /**
            * Checks to see if a tag that is passed exists on this file and returns a boolean that is used as a indication of the results. True means that the tag exists on this file.
            * @method hasTag
            * @param tag {String} The tag you are checking to see exists.
            * @return {Boolean} If the tag does exist on this file or not.
            * @public
            */
            File.prototype.hasTag = function (tag) {
                if (this._tags.indexOf(tag) == -1) {
                    return false;
                }
                return true;
            };

            Object.defineProperty(File.prototype, "isTexture", {
                /*
                *----------------
                * Type Identification
                *----------------
                */
                /**
                * An indication of if this file is texture. This is READ ONLY.
                * @property isTexture
                * @type boolean
                * @public
                */
                get: function () {
                    if (this.dataType === File.IMAGE || this.dataType === File.SPRITE_SHEET || this.dataType === File.TEXTURE_ATLAS) {
                        return true;
                    }
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(File.prototype, "isAudio", {
                /**
                * An indication of if this file is a piece of audio. This is READ ONLY.
                * @property isAudio
                * @type boolean
                * @public
                */
                get: function () {
                    if (this.dataType === File.AUDIO) {
                        return true;
                    }
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(File.prototype, "isData", {
                /**
                * An indication of if this file is data. This is READ ONLY.
                * @property isData
                * @type boolean
                * @public
                */
                get: function () {
                    if (this.dataType === File.XML || this.dataType === File.JSON || this.dataType === File.TEXT_DATA || this.dataType === File.BINARY_DATA) {
                        return true;
                    }
                    return false;
                },
                enumerable: true,
                configurable: true
            });

            /*
            *-----------------
            * General Loading
            *-----------------
            */
            /**
            * Starts the loading process for this file.
            * @method load
            * @param [onCompleteCallback=null] {Any} The callback method to execute when this file has loaded.
            * @param [onProgressCallback=null] {Any} The callback method to execute while this file is loading.
            * @param [customFileStore=null] {Any} A custom filestore that is file should be added to.
            * @param [maxLoadAttempts] {Number} The maximum amount of times to try and load this file.
            * @param [timeout] {Number} The timeout to use when loading the file. Overrides the default timeout if passed otherwise uses the default 2000 milliseconds.
            * @public
            */
            File.prototype.load = function (onCompleteCallback, onProgressCallback, customFileStore, maxLoadAttempts, timeout) {
                if (typeof onCompleteCallback === "undefined") { onCompleteCallback = null; }
                if (typeof onProgressCallback === "undefined") { onProgressCallback = null; }
                if (typeof customFileStore === "undefined") { customFileStore = null; }
                if (this._game.debug) {
                    console.log("Attempting to load: " + this.fileName);
                }

                this.onCompleteCallback = onCompleteCallback;
                this.onProgressCallback = onProgressCallback;

                if (maxLoadAttempts != undefined)
                    this.maxLoadAttempts = maxLoadAttempts;
                if (timeout != undefined)
                    this.timeOutDelay = timeout;

                //Should the file be saved in a custom file store?
                if (customFileStore !== null) {
                    this._fileStore = customFileStore;
                    this._saveToFileStore = true;
                }

                //Start the load.
                this.start();

                //Load using the appropriate
                if (this._useTagLoader === true) {
                    this.tagLoader();
                } else {
                    this.xhrLoader();
                }
            };

            /**
            * Is executed when this file starts loading.
            * Gets the time and initalised properties that are used across both loading methods.
            * @method start
            * @private
            */
            File.prototype.start = function () {
                this.timeStarted = Date.now();
                this.lastProgress = Date.now();
                this.percentLoaded = 0;
                this.attemptCounter = 0;
            };

            /**
            * Is executed when this file stops loading. Used across all loading methods.
            * @method stop
            * @private
            */
            File.prototype.stop = function () {
                this.percentLoaded = 100;
                this.timeFinished = Date.now();
                this.duration = this.timeFinished - this.timeStarted;
            };

            /*
            *-----------------
            * Tag Loader Methods
            *-----------------
            */
            /**
            * Handles the loading of the file when using the tag loader method.
            * Only supports the IMAGES and AUDIO files.
            * @method tagLoader
            * @private
            */
            File.prototype.tagLoader = function () {
                var _this = this;
                //Is the file a image?
                if (this.dataType === Kiwi.Files.File.IMAGE || this.dataType === Kiwi.Files.File.SPRITE_SHEET || this.dataType === Kiwi.Files.File.TEXTURE_ATLAS) {
                    this.data = new Image();
                    this.data.src = this.fileURL;
                    this.data.onload = function (event) {
                        return _this.tagLoaderOnLoad(event);
                    };
                    this.data.onerror = function (event) {
                        return _this.tagLoaderOnError(event);
                    }; //To be remade
                    this.data.onreadystatechange = function (event) {
                        return _this.tagLoaderOnReadyStateChange(event);
                    };
                    //Is the file a piece of audio?
                } else if (this.dataType === Kiwi.Files.File.AUDIO) {
                    //Create the audio Element
                    this.data = document.createElement('audio');
                    this.data.src = this.fileURL;
                    this.data.preload = 'auto';

                    //Is the audio currently locked?
                    //This would mainly be due to iOS waiting for a touch/mouse event to fire.
                    if (this._game.audio.locked) {
                        this.tagLoaderAudioLocked();
                    } else {
                        this.data.addEventListener('canplaythrough', function () {
                            return _this.tagLoaderProgressThrough(null);
                        }, false);

                        //If targetting Cocoon we can use the load method to force the audio loading.
                        if (this._game.deviceTargetOption == Kiwi.TARGET_COCOON) {
                            this.data.load();
                            //Otherwise we tell the browser to play the audio in 'mute' to force loading.
                        } else {
                            this.data.volume = 0;
                            this.data.play();
                        }
                    }
                }
            };

            /**
            * Is executed when the tag loader changes its ready state.
            * @method tagLoaderOnReadyStateChange
            * @param {Any} event
            * @private
            */
            File.prototype.tagLoaderOnReadyStateChange = function (event) {
            };

            /**
            * Is executed when the tag loader encounters a error that stops it from loading.
            * @method tagLoaderOnError
            * @param {Any} event
            * @private
            */
            File.prototype.tagLoaderOnError = function (event) {
                this.hasError = true;
                this.error = event;

                if (this.onCompleteCallback) {
                    this.onCompleteCallback(this);
                }
            };

            /**
            * Is executed when an audio file can play the whole way through with stopping to load.
            * @method tagLoaderProgressThrough
            * @param {Any} event
            * @private
            */
            File.prototype.tagLoaderProgressThrough = function (event) {
                var _this = this;
                //Has it not fully loaded yet?
                //Work arround as the tag will constantly fire.
                if (this.percentLoaded !== 100) {
                    if (this.dataType === Kiwi.Files.File.AUDIO) {
                        this.data.removeEventListener('canplaythrough', function () {
                            return _this.tagLoaderProgressThrough(null);
                        }); //Remove will not work due to the nameless function.

                        //Stop the audio and reset it to the default settings.
                        this.data.pause();
                        this.data.currentTime = 0;
                        this.data.volume = 1;
                    }

                    this.tagLoaderOnLoad(null);
                }
            };

            /**
            * Is executed when iOS (or another device) is being used and the audio is 'locked'.
            * 'Fakes' the loading and tells the rest of the game to carry on.
            * @method tagLoaderIOSLoad
            * @private
            */
            File.prototype.tagLoaderAudioLocked = function () {
                this.percentLoaded = 100;
                this.tagLoaderOnLoad(null);
            };

            /**
            * Is executed when the file has successfully loaded.
            * @method tagLoaderOnLoad
            * @param {Any} event
            * @private
            */
            File.prototype.tagLoaderOnLoad = function (event) {
                this.stop();

                //Image loaded successfully...bit of a assumtion but hey...its a tag loader.
                if (this._game.debug)
                    console.log('Successfully Loaded: ' + this.fileName);

                if (this._saveToFileStore === true) {
                    this._fileStore.addFile(this.key, this);
                }

                if (this.onCompleteCallback) {
                    this.onCompleteCallback(this);
                }
            };

            /**
            * Sets up a XHR loader based on the properties of this file.
            * @method xhrLoader
            * @private
            */
            File.prototype.xhrLoader = function () {
                var _this = this;
                this.attemptCounter++;

                //Open a request
                this._xhr = new XMLHttpRequest();
                this._xhr.open('GET', this.fileURL, true);
                if (this.timeOutDelay !== null)
                    this._xhr.timeout = this.timeOutDelay;
                this._xhr.responseType = 'arraybuffer';

                //Assignment of callbacks
                this._xhr.onloadstart = function (event) {
                    return _this.xhrOnLoadStart(event);
                };
                this._xhr.onprogress = function (event) {
                    return _this.xhrOnProgress(event);
                };
                this._xhr.ontimeout = function (event) {
                    return _this.xhrOnTimeout(event);
                };
                this._xhr.onabort = function (event) {
                    return _this.xhrOnAbort(event);
                };
                this._xhr.onload = function (event) {
                    return _this.xhrOnLoad(event);
                };
                this._xhr.onreadystatechange = function (event) {
                    return _this.xhrOnReadyStateChange(event);
                };

                //Go!
                this._xhr.send();
            };

            /**
            * Is executed when the XHR loader has changed its ready state.
            * @method xhrOnReadyStateChange
            * @param {Any} event
            * @private
            */
            File.prototype.xhrOnReadyStateChange = function (event) {
                this.readyState = event.target.readyState;

                if (this.readyState === 4) {
                    this.xhrOnLoad(event);
                }
            };

            /**
            * Is executed when the XHR loader starts to load the file.
            * @method xhrOnLoadStart
            * @param {Any} event
            * @private
            */
            File.prototype.xhrOnLoadStart = function (event) {
                this.timeStarted = event.timeStamp;
                this.lastProgress = event.timeStamp;
            };

            /**
            * Runs when the XHR loader aborts the load for some reason.
            * @method xhrOnAbort
            * @param {Any} event
            * @private
            */
            File.prototype.xhrOnAbort = function (event) {
                if (this._game.debug)
                    console.log(this.fileName + ' loading was aborted.');

                this.error = event;
            };

            /**
            * Runs when the XHR loader encounters a error.
            * @method xhrOnError
            * @param {Any} event
            * @private
            */
            File.prototype.xhrOnError = function (event) {
                if (this._game.debug)
                    console.log('Error during load: ' + this.fileName);

                this.error = event;
            };

            /**
            * Is executed when the xhr
            * @method xhrOnTimeout
            * @param {Any} event
            * @private
            */
            File.prototype.xhrOnTimeout = function (event) {
                if (this._game.debug)
                    console.log('Timed out: ' + this.fileName);

                this.hasTimedOut = true;
                this.timedOut = Date.now();
                this.error = event;
            };

            /**
            * Is execute whilst loading of the file is occuring. Updates the number of bytes that have been loaded and percentage loaded.
            * @method xhrOnProgress
            * @param {Any} event
            * @private
            */
            File.prototype.xhrOnProgress = function (event) {
                this.bytesLoaded = parseInt(event.loaded);
                this.bytesTotal = parseInt(event.totalSize);
                this.percentLoaded = Math.round((this.bytesLoaded / this.bytesTotal) * 100);

                if (this.onProgressCallback) {
                    this.onProgressCallback(this);
                }
            };

            /**
            * Once the file has finished downloading (or pulled from the browser cache) this onload event fires.
            * @method xhrOnLoad
            * @param {event} The XHR event
            * @private
            */
            File.prototype.xhrOnLoad = function (event) {
                //Stop re-processing of the file if it was already processed.
                //Received from the ready state.
                if (this.timeFinished > 0)
                    return;

                this.status = this._xhr.status;
                this.statusText = this._xhr.statusText;

                //Was the loading a success?
                if (this._xhr.status === 200) {
                    this.stop();
                    this.success = true;
                    this.hasError = false;

                    if (this._game.debug)
                        console.log('Successfully Loaded: ' + this.fileName);

                    //Get the head information of the file.
                    this.fileType = this._xhr.getResponseHeader('Content-Type');
                    this.bytesTotal = parseInt(this._xhr.getResponseHeader('Content-Length'));
                    this.lastModified = this._xhr.getResponseHeader('Last-Modified');
                    this.ETag = this._xhr.getResponseHeader('ETag');
                    this.buffer = this._xhr.response;

                    //Start processing of the file.
                    this.processFile();
                    //Failed to load.
                } else {
                    //Should we try to load the file again?
                    if (this.attemptCounter >= this.maxLoadAttempts) {
                        this.success = false;
                        this.hasError = true;

                        if (this._game.debug)
                            console.error(this.fileName + ' wasn\'t loaded.');

                        this.parseComplete();
                    } else {
                        if (this._game.debug)
                            console.log('Retrying to load: ' + this.fileName);

                        this.xhrLoader();
                    }
                }
            };

            /*
            *-----------------
            * Processing of the File (via XHR Loading Method)
            *-----------------
            */
            /**
            * Handles the processing of the files information when it was loaded via the xhr + arraybuffer method.
            * Is only executed when the loading was a success
            this._xhr.onload = (event) => this.xhrOnLoad(event);.
            * @method processFile
            * @private
            */
            File.prototype.processFile = function () {
                switch (this.dataType) {
                    case Kiwi.Files.File.IMAGE:
                    case Kiwi.Files.File.SPRITE_SHEET:
                    case Kiwi.Files.File.TEXTURE_ATLAS:
                        this.createBlob();
                        break;

                    case Kiwi.Files.File.JSON:
                        //Loop through each character of the dataview, which is slower than a whole array but avoids the size issue.
                        this.data = '';
                        var uintArray = new Uint8Array(this.buffer);
                        for (var i = 0; i < uintArray.length; i++) {
                            this.data += String.fromCharCode(uintArray[i]);
                        }
                        this.parseComplete();

                        break;

                    case Kiwi.Files.File.AUDIO:
                        //Are we using web audio? (Not needed really as audio tags use Tag Loader.
                        if (this._game.audio.usingWebAudio) {
                            this.data = {
                                raw: this._xhr.response,
                                decoded: false,
                                buffer: null
                            };

                            //Decode that Audio
                            var that = this;
                            this._game.audio.context.decodeAudioData(this.data.raw, function (buffer) {
                                if (buffer) {
                                    that.data.buffer = buffer;
                                    that.data.decoded = true;
                                    that.parseComplete();
                                }
                            });
                        }
                        break;

                    default:
                        this.parseComplete();
                }
            };

            /*
            *--------------------
            * Create Blob Functionality
            *--------------------
            */
            /**
            * Creates a new Binary Large Object for the data that was loaded through the XHR.
            * @method createBlob
            * @private
            */
            File.prototype.createBlob = function () {
                var _this = this;
                this.data = document.createElement('img');
                this.data.onload = function () {
                    return _this.revoke();
                };

                var imageType = '';

                if (this.fileExtension === 'jpg' || this.fileExtension === 'jpeg') {
                    imageType = 'image/jpeg';
                } else if (this.fileExtension === 'png') {
                    imageType = 'image/png';
                } else if (this.fileExtension === 'gif') {
                    imageType = 'image/gif';
                }

                //  Until they fix the TypeScript lib.d we have to use window array access
                //  Need to find a way to tell if this suports constuctor values like below, otherwise it just errors Chrome < 20 etc
                //if (typeof window['Blob'] !== 'undefined')
                //{
                var blob = new window['Blob']([this.buffer], { type: imageType });

                //}
                //else
                //{
                //var BlobBuilder = window['BlobBuilder'] || window['WebKitBlobBuilder'] || window['MozBlobBuilder'] || window['MSBlobBuilder'];
                //var builder = new BlobBuilder;
                //builder.append([this.buffer]); // needs appendABV check
                //var blob = builder.getBlob(imageType);
                //}
                if (window['URL']) {
                    this.data.src = window['URL'].createObjectURL(blob);
                } else if (window['webkitURL']) {
                    this.data.src = window['webkitURL'].createObjectURL(blob);
                }
            };

            /**
            * Revokes the object url that was added to the window when creating the image.
            * Also tells the File that the loading is now complete.
            * @method revoke
            * @private
            */
            File.prototype.revoke = function () {
                if (window['URL']) {
                    window['URL'].revokeObjectURL(this.data.src);
                } else if (window['webkitURL']) {
                    window['webkitURL'].revokeObjectURL(this.data.src);
                }

                this.parseComplete();
            };

            /**
            * Executed when this file has completed loading (this could be due to it failing or succeeding).
            * @method parseComplete
            * @private
            */
            File.prototype.parseComplete = function () {
                if (this._saveToFileStore === true) {
                    this._fileStore.addFile(this.key, this);
                }

                if (this.onCompleteCallback) {
                    this.onCompleteCallback(this);
                }
            };

            /**
            * Attempts to make the file send a XHR HEAD request to get information about the file that is going to be downloaded.
            * This is particularly useful when you are wanting to check how large a file is before loading all of the content.
            * @method getFileDetails
            * @param [callback=null] {function} The callback to send this FileInfo object to.
            * @param [maxLoadAttempts=1] {number} The maximum amount of load attempts. Only set this if it is different from the default.
            * @param [timeout=this.timeOutDelay] {number} The timeout delay. By default this is the same as the timeout delay property set on this file.
            * @private
            */
            File.prototype.getFileDetails = function (callback, maxLoadAttempts, timeout) {
                if (typeof callback === "undefined") { callback = null; }
                if (typeof timeout === "undefined") { timeout = this.timeOutDelay; }
                this.onCompleteCallback = callback;
                if (this.maxHeadLoadAttempts !== undefined)
                    this.maxHeadLoadAttempts = maxLoadAttempts;

                //Start the XHR Request for the HEAD information. Reset the attempt counter.
                this.attemptCounter = 0;
                this.sendXHRHeadRequest(timeout);
            };

            /**
            * Sends a XHR request for the HEAD information of this file.
            * Useful as it can will contain the information about the file before loading the actual file.
            * @method sendXHRHeadRequest
            * @param timeout {Number} The timeout delay.
            * @private
            */
            File.prototype.sendXHRHeadRequest = function (timeout) {
                var _this = this;
                this.attemptCounter++;

                this._xhr = new XMLHttpRequest();
                this._xhr.open('HEAD', this.fileURL, false);
                this._xhr.onload = function (event) {
                    return _this.getXHRResponseHeaders(event);
                };
                this._xhr.ontimeout = function (event) {
                    return _this.xhrHeadOnTimeout(event);
                };
                this._xhr.onerror = function (event) {
                    return _this.xhrHeadOnError(event);
                };
                if (this.timeOutDelay !== null)
                    this._xhr.timeout = timeout;
                this._xhr.send();
            };

            /**
            * Is executed when the XHR head request timed out.
            * @method xhrHeadOnTimeout
            * @param event {Any}
            * @private
            */
            File.prototype.xhrHeadOnTimeout = function (event) {
                this.hasTimedOut = true;
                this.timedOut = Date.now();
                this.error = event;
                //The onload will fire after, thus trying again automatically.
            };

            /**
            * Is executed when this XHR head request has a error.
            * @method xhrHeadOnError
            * @param event {Any} The event containing the reason why this event failed.
            * @private
            */
            File.prototype.xhrHeadOnError = function (event) {
                this.hasError = true;
                this.error = event;
                this.status = this._xhr.status;
                this.statusText = this._xhr.statusText;
                //The onload will fire after, thus trying again automatically.
            };

            /**
            * Process the response headers received.
            * @method getResponseHeaders
            * @param event {Any} The XHR event
            * @private
            */
            File.prototype.getXHRResponseHeaders = function (event) {
                this.status = this._xhr.status;
                this.statusText = this._xhr.statusText;

                if (this._xhr.status === 200) {
                    //Get the file information...
                    this.fileType = this._xhr.getResponseHeader('Content-Type');
                    this.fileSize = parseInt(this._xhr.getResponseHeader('Content-Length'));
                    this.lastModified = this._xhr.getResponseHeader('Last-Modified');
                    this.ETag = this._xhr.getResponseHeader('ETag');

                    //Complete the request
                    this.completeXHRHeadRequest(true);
                } else {
                    this.completeXHRHeadRequest(false);
                }
            };

            /**
            * Used to finialise the XHR Head Request (used with get File Details).
            * When passed an outcome this method will see if it can 'try again' otherwise it will just finish the attempt.
            * @method completeXHRHeadRequest
            * @param outcome {Boolean} If the outcome was a success or not.
            * @private
            */
            File.prototype.completeXHRHeadRequest = function (outcome) {
                //If the outcome was not good and we can try again then do it!
                if (outcome == false && this.attemptCounter < this.maxLoadAttempts) {
                    this.sendXHRHeadRequest(this.timeOutDelay);
                    return;
                }

                //Execute the on complete callback.
                if (this.onCompleteCallback) {
                    this.attemptCounter = 0;
                    this.onCompleteCallback(this);
                }
            };

            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {string} a string representation of the instance.
            * @public
            */
            File.prototype.toString = function () {
                return "[{File (fileURL=" + this.fileURL + " fileName=" + this.fileName + " dataType=" + this.dataType + " fileSize=" + this.fileSize + " success=" + this.success + " status=" + this.status + ")}]";
            };
            File.IMAGE = 0;

            File.SPRITE_SHEET = 1;

            File.TEXTURE_ATLAS = 2;

            File.AUDIO = 3;

            File.JSON = 4;

            File.XML = 5;

            File.BINARY_DATA = 6;

            File.TEXT_DATA = 7;
            return File;
        })();
        Files.File = File;
    })(Kiwi.Files || (Kiwi.Files = {}));
    var Files = Kiwi.Files;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Files
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Files) {
        /**
        * Holds all of the Files (regardless of the file type) that have been loaded throughout a game/are accessable at a particular point in time. Contains methods for dealing with files. Note: Each time the state is switched the file store will remove all references to files that have not been flagged as global.
        *
        * @class FileStore
        * @namespace Kiwi.Files
        * @constructor
        * @param game {Game} The game that this FileStore belongs to.
        * @return {FilesStore}
        *
        */
        var FileStore = (function () {
            function FileStore(game) {
                /**
                * The number of files that are on the file store.
                * @property _size
                * @type Number
                * @default 0
                * @private
                */
                this._size = 0;
                this._game = game;
                this._files = {};
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            FileStore.prototype.objType = function () {
                return "FileStore";
            };

            /**
            * The boot method is executed when the DOM elements needed for this game are ready and thus the game can 'boot'.
            * @method boot
            * @public
            */
            FileStore.prototype.boot = function () {
            };

            /**
            * Returns a particular file by the key that you specify.
            * @method getFile
            * @param key {String} The key of the file that you to get.
            * @return {File}
            * @public
            */
            FileStore.prototype.getFile = function (key) {
                return this._files[key];
            };

            /**
            * Returns an object full of files that have a Tag that is associated with it.
            * @method getFilesByTag
            * @param tag {String}
            * @return {Object} All of the files with that tag.
            * @public
            */
            FileStore.prototype.getFilesByTag = function (tag) {
                var obj = {};
                for (var file in this._files) {
                    if (this._files[file].hasTag(tag)) {
                        obj[file] = this._files[file];
                    }
                }
                return obj;
            };

            /**
            * Removes all of the files by a tag that is specified.
            * @method removeFilesByTag
            * @param tag {String}
            * @return {Number} The number of files that were removed.
            * @public
            */
            FileStore.prototype.removeFilesByTag = function (tag) {
                var numberFiles = 0;
                for (var file in this._files) {
                    if (this._files[file].hasTag(tag)) {
                        this.removeFile(file);
                        numberFiles++;
                    }
                }
                return numberFiles;
            };

            Object.defineProperty(FileStore.prototype, "keys", {
                /**
                * Returns all of the keys for every file that exist on this FileStore as an array.
                * @property keys
                * @type String[]
                * @public
                */
                get: function () {
                    var keys = new Array();
                    for (var key in this._files) {
                        keys.push(key);
                    }

                    return keys;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns the number of files that are on this FileStore.
            * @method size
            * @return {Number}
            * @public
            */
            FileStore.prototype.size = function () {
                return this._size;
            };

            /**
            * Adds a File with a key to the FileStore. If the key that you specify already exists then this method will return false otherwise it should return true if it was added.
            * @method addFile
            * @param key {String} A unique key that this file should be accessed by.
            * @param value {File} The file that you would like to save on the FileStore.
            * @return {Boolean} If the file was added or not
            * @public
            */
            FileStore.prototype.addFile = function (key, value) {
                if (!this._files[key]) {
                    this._files[key] = value;
                    this._size++;
                    return true;
                }

                return false;
            };

            /**
            * Checks to see if a key that you pass is already being used for another file. Returns true if that key is already in used, false if it isn't.
            * @method exists
            * @param key {String} The key that you are checking.
            * @return boolean
            * @public
            */
            FileStore.prototype.exists = function (key) {
                if (this._files[key]) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Removes files on the FileStore that are associated with a particular state.
            * @method removeStateFiles
            * @param state {State}
            * @public
            */
            FileStore.prototype.removeStateFiles = function (state) {
                for (var file in this._files) {
                    if (this._files[file].ownerState === state) {
                        this.removeFile(file);
                    }
                }
            };

            /**
            * Removes a file by the key that is passed. Returns a boolean indicating if a file was removed or not.
            * Note: Only returns false if that file did not exist in the first place.
            * @method removeFile
            * @param key {String} The key of the file you want to remove.
            * @return {Boolean}
            * @public
            */
            FileStore.prototype.removeFile = function (key) {
                if (this._files[key]) {
                    this._files[key] = null;
                    delete this._files[key];
                    return true;
                }

                return false;
            };
            return FileStore;
        })();
        Files.FileStore = FileStore;
    })(Kiwi.Files || (Kiwi.Files = {}));
    var Files = Kiwi.Files;
})(Kiwi || (Kiwi = {}));
/**
* Kiwi - System
* @module Kiwi
* @submodule System
* @main System
*/
var Kiwi;
(function (Kiwi) {
    (function (System) {
        /**
        * DOM Boot and Ready functions (based on those used by jQuery)
        *
        * @class Bootstrap
        * @namespace Kiwi.System
        *
        */
        var Bootstrap = (function () {
            function Bootstrap() {
                /**
                *
                * @property isReady
                * @type boolean
                * @public
                */
                this.isReady = false;
                /**
                * The parent div in which the layers and input live
                * @property container
                * @type HTMLDivElement
                * @public
                */
                this.container = null;
                /**
                * This div sits on-top of all layers and captures user input
                * @property input
                * @type HTMLDivElement
                * @public
                */
                this.input = null;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Bootstrap.prototype.objType = function () {
                return "Bootstrap";
            };

            /**
            * Called at the start of the game to check to see if the DOM is ready before we do anything requiring it
            * @method boot
            * @param {String} domParent
            * @param {Any} [callback=null]
            * @param {boolean} [createContainer=true]
            * @public
            */
            Bootstrap.prototype.boot = function (domParent, callback, createContainer) {
                if (typeof callback === "undefined") { callback = null; }
                if (typeof createContainer === "undefined") { createContainer = true; }
                var _this = this;
                this._callback = callback;
                this._domParent = domParent;

                // if this is true a div will be created in browser
                this._createContainer = createContainer;

                // wait until DOM is loaded and call ready
                if (document.readyState === 'complete' || document.readyState === 'interactive') {
                    this.ready();
                } else {
                    document.addEventListener('DOMContentLoaded', function () {
                        return _this.ready();
                    }, false);
                    window.addEventListener('load', function () {
                        return _this.ready();
                    }, false);
                }
            };

            /**
            * If the DOM is ready it fires our callback, otherwise sets a short timeout to try again
            * @method ready
            * @public
            */
            Bootstrap.prototype.ready = function () {
                var _this = this;
                if (this.isReady === true) {
                    return;
                }

                if (!document.body) {
                    window.setTimeout(function () {
                        return _this.ready();
                    }, 13);
                } else {
                    //document.removeEventListener('DOMContentLoaded', () => this.ready(), false);
                    this.isReady = true;

                    if (this._createContainer === true) {
                        //  No domParent was given so we create our own container for the game with a unique ID
                        if (this._domParent === '') {
                            this.container = document.createElement('div');
                            this._setupContainer('KiwiGame' + Date.now().toString());
                            document.body.appendChild(this.container);
                        } else {
                            //  Does the container exist?
                            if (document.getElementById(this._domParent)) {
                                this.container = document.getElementById(this._domParent);
                                this._setupContainer();
                            } else {
                                this.container = document.createElement('div');
                                this._setupContainer(this._domParent);
                                document.body.appendChild(this.container);
                            }
                        }
                    }

                    if (this._callback !== null) {
                        this._callback();
                    }
                }
            };

            /**
            *
            * @method _setupContainer
            * @param {String} id
            * @private
            */
            Bootstrap.prototype._setupContainer = function (id) {
                if (typeof id === "undefined") { id = ''; }
                if (id) {
                    this.container.id = id;
                }

                this.container.style.width = Kiwi.Stage.DEFAULT_WIDTH + 'px';
                this.container.style.height = Kiwi.Stage.DEFAULT_HEIGHT + 'px';
                this.container.style.position = 'relative';
                this.container.style.overflow = 'hidden';
            };
            return Bootstrap;
        })();
        System.Bootstrap = Bootstrap;
    })(Kiwi.System || (Kiwi.System = {}));
    var System = Kiwi.System;
})(Kiwi || (Kiwi = {}));
/**
* Kiwi - System
* @module Kiwi
* @submodule System
*
*/
var Kiwi;
(function (Kiwi) {
    (function (System) {
        /**
        * Gets the x/y coordinate offset of any given valid DOM Element from the top/left position of the browser
        * Based on jQuery offset https://github.com/jquery/jquery/blob/master/src/offset.js
        *
        * @class Browser
        * @constructor
        * @namespace Kiwi.System
        * @param {Game} game
        * @return {StateMananger} This Object
        *
        */
        var Browser = (function () {
            function Browser(game) {
                this._game = game;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Browser.prototype.objType = function () {
                return "Browser";
            };

            /**
            * The DOM is ready, so if we have a current state pending we can init it now
            * @method boot
            */
            Browser.prototype.boot = function () {
                //this._game.stage.offset = this.getOffsetPoint(this._game.stage.container);
            };

            /**
            *
            * @method getOffsetPoint
            * @param {Any} element
            * @param {Point} output
            * @return {Point}
            * @public
            */
            Browser.prototype.getOffsetPoint = function (element, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.Point; }
                var box = element.getBoundingClientRect();

                var clientTop = element.clientTop || document.body.clientTop || 0;
                var clientLeft = element.clientLeft || document.body.clientLeft || 0;
                var scrollTop = window.pageYOffset || element.scrollTop || document.body.scrollTop;
                var scrollLeft = window.pageXOffset || element.scrollLeft || document.body.scrollLeft;

                return output.setTo(box.left + scrollLeft - clientLeft, box.top + scrollTop - clientTop);
            };
            return Browser;
        })();
        System.Browser = Browser;
    })(Kiwi.System || (Kiwi.System = {}));
    var System = Kiwi.System;
})(Kiwi || (Kiwi = {}));
/**
* Kiwi - System
* @module Kiwi
* @submodule System
*/
var Kiwi;
(function (Kiwi) {
    (function (System) {
        /**
        * Detects device support capabilities. Using some elements from System.js by MrDoob and Modernizr
        * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/audio.js
        *
        * @class Device
        * @constructor
        * @namespace Kiwi.System
        *
        * @author mrdoob
        * @author Modernizr team
        *
        */
        var Device = (function () {
            function Device() {
                //  Operating System
                /**
                *
                * @property iOS
                * @type boolean
                * @public
                */
                this.iOS = false;
                /**
                *
                * @property android
                * @type boolean
                * @public
                */
                this.android = false;
                /**
                *
                * @property chromeOS
                * @type boolean
                * @public
                */
                this.chromeOS = false;
                /**
                *
                * @property linux
                * @type boolean
                * @public
                */
                this.linux = false;
                /**
                *
                * @property maxOS
                * @type boolean
                * @public
                */
                this.macOS = false;
                /**
                *
                * @property windows
                * @type boolean
                * @public
                */
                this.windows = false;
                //  Features
                /**
                *
                * @property canvas
                * @type boolean
                * @public
                */
                this.canvas = false;
                /**
                *
                * @property file
                * @type boolean
                * @public
                */
                this.file = false;
                /**
                *
                * @property fileSystem
                * @type boolean
                * @public
                */
                this.fileSystem = false;
                /**
                *
                * @property localStorage
                * @type boolean
                * @public
                */
                this.localStorage = false;
                /**
                *
                * @property webGL
                * @type boolean
                * @public
                */
                this.webGL = false;
                /**
                *
                * @property worker
                * @type boolean
                * @public
                */
                this.worker = false;
                /**
                *
                * @property blob
                * @type boolean
                * @public
                */
                this.blob = false;
                /**
                *
                * @property touch
                * @type boolean
                * @public
                */
                this.touch = false;
                /**
                *
                * @property css3D
                * @type boolean
                * @public
                */
                this.css3D = false;
                //  Browser
                /**
                *
                * @property arora
                * @type boolean
                * @public
                */
                this.arora = false;
                /**
                *
                * @property chrome
                * @type boolean
                * @public
                */
                this.chrome = false;
                /**
                *
                * @property epiphany
                * @type boolean
                * @public
                */
                this.epiphany = false;
                /**
                *
                * @property firefox
                * @type boolean
                * @public
                */
                this.firefox = false;
                /**
                *
                * @property ie
                * @type boolean
                * @public
                */
                this.ie = false;
                /**
                *
                * @property ieVersion
                * @type Number
                * @public
                */
                this.ieVersion = 0;
                /**
                *
                * @property mobileSafari
                * @type boolean
                * @public
                */
                this.mobileSafari = false;
                /**
                *
                * @property midori
                * @type boolean
                * @public
                */
                this.midori = false;
                /**
                *
                * @property opera
                * @type boolean
                * @public
                */
                this.opera = false;
                /**
                *
                * @property safari
                * @type boolean
                * @public
                */
                this.safari = false;
                /**
                *
                * @property webApp
                * @type boolean
                * @public
                */
                this.webApp = false;
                //  Audio
                /**
                *
                * @property audioData
                * @type boolean
                * @public
                */
                this.audioData = false;
                /**
                *
                * @property webaudio
                * @type boolean
                * @public
                */
                this.webaudio = false;
                /**
                *
                * @property ogg
                * @type boolean
                * @public
                */
                this.ogg = false;
                /**
                *
                * @property mp3
                * @type boolean
                * @public
                */
                this.mp3 = false;
                /**
                *
                * @property wav
                * @type boolean
                * @public
                */
                this.wav = false;
                /**
                *
                * @property m4a
                * @type boolean
                * @public
                */
                this.m4a = false;
                //  Device
                /**
                *
                * @property iPhone
                * @type boolean
                * @public
                */
                this.iPhone = false;
                /**
                *
                * @property iPhone4
                * @type boolean
                * @public
                */
                this.iPhone4 = false;
                /**
                *
                * @property iPad
                * @type boolean
                * @public
                */
                this.iPad = false;
                /**
                *
                * @property pixelRatio
                * @type Number
                * @public
                */
                this.pixelRatio = 0;
                this._checkAudio();
                this._checkBrowser();
                this._checkCSS3D();
                this._checkDevice();
                this._checkFeatures();
                this._checkOS();
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Device.prototype.objType = function () {
                return "Device";
            };

            /**
            *
            * @method _checkOS
            * @private
            */
            Device.prototype._checkOS = function () {
                var ua = navigator.userAgent;

                if (/Android/.test(ua)) {
                    this.android = true;
                } else if (/CrOS/.test(ua)) {
                    this.chromeOS = true;
                } else if (/iP[ao]d|iPhone/i.test(ua)) {
                    this.iOS = true;
                } else if (/Linux/.test(ua)) {
                    this.linux = true;
                } else if (/Mac OS/.test(ua)) {
                    this.macOS = true;
                } else if (/Windows/.test(ua)) {
                    this.windows = true;
                }
            };

            /**
            *
            * @method _checkFeatures
            * @private
            */
            Device.prototype._checkFeatures = function () {
                if (typeof window['Blob'] !== 'undefined')
                    this.blob = true;

                this.canvas = !!window['CanvasRenderingContext2D'];

                try  {
                    this.localStorage = !!localStorage.getItem;
                } catch (error) {
                    this.localStorage = false;
                }

                this.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];
                this.fileSystem = !!window['requestFileSystem'];
                this.webGL = !!window['WebGLRenderingContext'];
                this.worker = !!window['Worker'];

                if ('ontouchstart' in document.documentElement || window.navigator.msPointerEnabled) {
                    this.touch = true;
                }
            };

            /**
            *
            * @method _checkBrowser
            * @private
            */
            Device.prototype._checkBrowser = function () {
                var ua = navigator.userAgent;

                if (/Arora/.test(ua)) {
                    this.arora = true;
                } else if (/Chrome/.test(ua)) {
                    this.chrome = true;
                } else if (/Epiphany/.test(ua)) {
                    this.epiphany = true;
                } else if (/Firefox/.test(ua)) {
                    this.firefox = true;
                } else if (/Mobile Safari/.test(ua)) {
                    this.mobileSafari = true;
                } else if (/MSIE (\d+\.\d+);/.test(ua)) {
                    this.ie = true;
                    this.ieVersion = parseInt(RegExp.$1);
                } else if (/Midori/.test(ua)) {
                    this.midori = true;
                } else if (/Opera/.test(ua)) {
                    this.opera = true;
                } else if (/Safari/.test(ua)) {
                    this.safari = true;
                }

                // WebApp mode in iOS
                if (navigator['standalone']) {
                    this.webApp = true;
                }
            };

            /**
            *
            * @method _checkAudio
            * @private
            */
            Device.prototype._checkAudio = function () {
                this.audioData = !!(window['Audio']);
                this.webaudio = !!(window['webkitAudioContext'] || window['AudioContext']);

                var audioElement = document.createElement('audio');
                var result = false;

                try  {
                    if (result = !!audioElement.canPlayType) {
                        if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, '')) {
                            this.ogg = true;
                        }

                        if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, '')) {
                            this.mp3 = true;
                        }

                        // Mimetypes accepted:
                        //   developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
                        //   bit.ly/iphoneoscodecs
                        if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, '')) {
                            this.wav = true;
                        }

                        if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, '')) {
                            this.m4a = true;
                        }
                    }
                } catch (e) {
                }
            };

            /**
            *
            * @method _checkDevice
            * @private
            */
            Device.prototype._checkDevice = function () {
                this.pixelRatio = window['devicePixelRatio'] || 1;
                this.iPhone = navigator.userAgent.toLowerCase().indexOf('iphone') != -1;
                this.iPhone4 = (this.pixelRatio == 2 && this.iPhone);
                this.iPad = navigator.userAgent.toLowerCase().indexOf('ipad') != -1;
            };

            /**
            *
            * @method _checkCSS3D
            * @private
            */
            Device.prototype._checkCSS3D = function () {
                var el = document.createElement('p');
                var has3d;
                var transforms = {
                    'webkitTransform': '-webkit-transform',
                    'OTransform': '-o-transform',
                    'msTransform': '-ms-transform',
                    'MozTransform': '-moz-transform',
                    'transform': 'transform'
                };

                // Add it to the body to get the computed style.
                document.body.insertBefore(el, null);

                for (var t in transforms) {
                    if (el.style[t] !== undefined) {
                        el.style[t] = "translate3d(1px,1px,1px)";
                        has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
                    }
                }

                document.body.removeChild(el);

                this.css3D = (has3d !== undefined && has3d.length > 0 && has3d !== "none");
            };

            /**
            *
            * @method getAll
            * @return {String}
            * @public
            */
            Device.prototype.getAll = function () {
                var output = '';

                output = output.concat('Device\n');
                output = output.concat('iPhone : ' + this.iPhone + '\n');
                output = output.concat('iPhone4 : ' + this.iPhone4 + '\n');
                output = output.concat('iPad : ' + this.iPad + '\n');

                output = output.concat('\n');
                output = output.concat('Operating System\n');
                output = output.concat('iOS: ' + this.iOS + '\n');
                output = output.concat('Android: ' + this.android + '\n');
                output = output.concat('ChromeOS: ' + this.chromeOS + '\n');
                output = output.concat('Linux: ' + this.linux + '\n');
                output = output.concat('MacOS: ' + this.macOS + '\n');
                output = output.concat('Windows: ' + this.windows + '\n');

                output = output.concat('\n');
                output = output.concat('Browser\n');
                output = output.concat('Arora: ' + this.arora + '\n');
                output = output.concat('Chrome: ' + this.chrome + '\n');
                output = output.concat('Epiphany: ' + this.epiphany + '\n');
                output = output.concat('Firefox: ' + this.firefox + '\n');
                output = output.concat('Internet Explorer: ' + this.ie + ' (' + this.ieVersion + ')\n');
                output = output.concat('Mobile Safari: ' + this.mobileSafari + '\n');
                output = output.concat('Midori: ' + this.midori + '\n');
                output = output.concat('Opera: ' + this.opera + '\n');
                output = output.concat('Safari: ' + this.safari + '\n');

                output = output.concat('\n');
                output = output.concat('Features\n');
                output = output.concat('Blob: ' + this.blob + '\n');
                output = output.concat('Canvas: ' + this.canvas + '\n');
                output = output.concat('File: ' + this.file + '\n');
                output = output.concat('FileSystem: ' + this.fileSystem + '\n');
                output = output.concat('LocalStorage: ' + this.localStorage + '\n');
                output = output.concat('WebGL: ' + this.webGL + '\n');
                output = output.concat('Worker: ' + this.worker + '\n');
                output = output.concat('Touch: ' + this.touch + '\n');
                output = output.concat('CSS 3D: ' + this.css3D + '\n');

                output = output.concat('\n');
                output = output.concat('Audio\n');
                output = output.concat('Audio Data: ' + this.canvas + '\n');
                output = output.concat('Web Audio: ' + this.canvas + '\n');
                output = output.concat('Can play OGG: ' + this.canvas + '\n');
                output = output.concat('Can play MP3: ' + this.canvas + '\n');
                output = output.concat('Can play M4A: ' + this.canvas + '\n');
                output = output.concat('Can play WAV: ' + this.canvas + '\n');

                return output;
            };
            return Device;
        })();
        System.Device = Device;
    })(Kiwi.System || (Kiwi.System = {}));
    var System = Kiwi.System;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Textures
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Textures) {
        /**
        * A TextureAtlas is the base class that is created for each image that is loaded in through Kiwi. Each TextureAtlas contains a name (the same as the key that the user chose when loading the image in),the HTMLImageElement that it is for and a number of cells.
        *
        * @class TextureAtlas
        * @namespace Kiwi.Textures
        * @constructor
        * @param name {string} Name of the texture atlas. This is usually defined by the developer when loading the assets.
        * @param type {number} The type of texture atlas that this is. There are currently only three types.
        * @param cells {any} The cells that are within this image..
        * @param image {HTMLImageElement/HTMLCanvasElement} The image that the texture atlas is using.
        * @param [sequences] {Sequence[]} Any sequences of cells for this texture atlas. Used for animation.
        * @return {TextureAtlas}
        *
        */
        var TextureAtlas = (function () {
            function TextureAtlas(name, type, cells, image, sequences) {
                /**
                * Indicates that the image data has changed, and needs to be reuplaoded to the gpu in webGL mode.
                * @property dirty
                * @type boolean
                * @public
                */
                this.dirty = false;
                /**
                * The cell that is to be render at the start.
                * @property cellIndex
                * @type number
                * @default 0
                * @public
                */
                this.cellIndex = 0;
                this.name = name;
                this.cells = cells || new Array();
                this.sequences = sequences || new Array();
                this.image = image;
                this._type = type;
            }
            /**
            * The type of object that this texture atlas is.
            * @method objType
            * @return string
            * @public
            */
            TextureAtlas.prototype.objType = function () {
                return "TextureAtlas";
            };

            Object.defineProperty(TextureAtlas.prototype, "type", {
                /**
                * Will return to you this type of texture atlas. This is READ ONLY.
                * @type number
                * @public
                */
                get: function () {
                    return this._type;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Will populate this texture atlas with information based on a JSON file that was passed.
            *
            * @method readJSON
            * @param {any} atlasJSON
            * @public
            */
            TextureAtlas.prototype.readJSON = function (atlasJSON) {
                //populate from json
                var obj = JSON.parse(atlasJSON);
                this.name = obj.name;

                for (var i = 0; i < obj.cells.length; i++) {
                    this.cells.push(obj.cells[i]);

                    if (obj.cells[i].hitboxes === undefined) {
                        this.cells[i].hitboxes = new Array();
                        this.cells[i].hitboxes.push({ x: 0, y: 0, w: this.cells[i].w, h: this.cells[i].h });
                    }
                }

                if (obj.sequences) {
                    for (var i = 0; i < obj.sequences.length; i++) {
                        var seq = new Kiwi.Animations.Sequence(obj.sequences[i].name, obj.sequences[i].cells);

                        if (obj.sequences[i].speed !== undefined)
                            seq.speed = obj.sequences[i].speed;
                        if (obj.sequences[i].loop !== undefined)
                            seq.loop = obj.sequences[i].loop;

                        this.sequences.push(seq);
                    }
                }
            };
            TextureAtlas.SINGLE_IMAGE = 0;

            TextureAtlas.SPRITE_SHEET = 1;

            TextureAtlas.TEXTURE_ATLAS = 2;
            return TextureAtlas;
        })();
        Textures.TextureAtlas = TextureAtlas;
    })(Kiwi.Textures || (Kiwi.Textures = {}));
    var Textures = Kiwi.Textures;
})(Kiwi || (Kiwi = {}));
/**
* Contains Objects that are used when dealing specifically with Textures/Images. Majority of these classes are for Internal Kiwi use.
*
* @module Kiwi
* @submodule Textures
* @main Textures
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Textures) {
        /**
        * Holds a reference to all of the image files (jpg, png, e.t.c) that are accessible on the State this TextureLibrary is on.
        *
        * @class TextureLibrary
        * @namespace Kiwi.Textures
        * @constructor
        * @param game {Game} The game that this texture library belongs to.
        * @return {TextureLibrary}
        *
        */
        var TextureLibrary = (function () {
            function TextureLibrary(game) {
                this._game = game;
                this.textures = new Object();
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {string}
            * @public
            */
            TextureLibrary.prototype.objType = function () {
                return "TextureLibrary";
            };

            /**
            * Resets the texture library.
            * @method clear
            * @public
            */
            TextureLibrary.prototype.clear = function () {
                for (var prop in this.textures) {
                    delete this.textures[prop];
                }
            };

            /**
            * Adds a texture atlas to the library.
            * @method add
            * @param atlas {TextureAtlas}
            * @public
            */
            TextureLibrary.prototype.add = function (atlas) {
                this.textures[atlas.name] = atlas;

                if (this._game.renderOption === Kiwi.RENDERER_WEBGL) {
                    if (Kiwi.Utils.Common.base2Sizes.indexOf(atlas.image.width) == -1 || Kiwi.Utils.Common.base2Sizes.indexOf(atlas.image.height) == -1) {
                        console.log("Warning:Image is not of base2 size and may not render correctly.");
                    }
                    var renderManager = this._game.renderer;
                    renderManager.addTexture(this._game.stage.gl, atlas);
                }
            };

            /**
            * Adds a new image file to the texture library.
            * @method addFromFile
            * @param imageFile {File}
            * @public
            */
            TextureLibrary.prototype.addFromFile = function (imageFile) {
                if (this._game.renderOption === Kiwi.RENDERER_WEBGL && this._game.deviceTargetOption != Kiwi.TARGET_COCOON) {
                    imageFile = this._rebuildImage(imageFile);
                }

                switch (imageFile.dataType) {
                    case Kiwi.Files.File.SPRITE_SHEET:
                        this.textures[imageFile.key] = this._buildSpriteSheet(imageFile);
                        break;
                    case Kiwi.Files.File.IMAGE:
                        this.textures[imageFile.key] = this._buildImage(imageFile);
                        break;
                    case Kiwi.Files.File.TEXTURE_ATLAS:
                        this.textures[imageFile.key] = this._buildTextureAtlas(imageFile);
                        break;
                    default:
                        break;
                }
            };

            /**
            * Used to rebuild a Texture from the FileStore into a base2 size if it doesn't have it already.
            * @method _rebuildImage
            * @param imageFile {File} The image file that is to be rebuilt.
            * @return {File} The new image file.
            * @private
            */
            TextureLibrary.prototype._rebuildImage = function (imageFile) {
                //Check to see if it is base 2
                var newImg = Kiwi.Utils.Common.convertToBase2(imageFile.data);

                //Was it resized? We can check to see if the width/height has changed.
                if (imageFile.data.width !== newImg.width || imageFile.data.height !== newImg.height) {
                    if (imageFile.dataType === Kiwi.Files.File.SPRITE_SHEET) {
                        //If no rows were passed then calculate them now.
                        if (!imageFile.metadata.rows)
                            imageFile.metadata.rows = imageFile.data.height / imageFile.metadata.frameHeight;

                        //If no columns were passed then calculate them again.
                        if (!imageFile.metadata.cols)
                            imageFile.metadata.cols = imageFile.data.width / imageFile.metadata.frameWidth;
                    } else if (imageFile.dataType === Kiwi.Files.File.IMAGE) {
                        if (!imageFile.metadata.width)
                            imageFile.metadata.width = imageFile.data.width;

                        if (!imageFile.metadata.height)
                            imageFile.metadata.height = imageFile.data.height;
                    }

                    if (this._game.debug)
                        console.log(imageFile.fileName + ' has been rebuilt to be base2.');

                    //Assign the new image to the data
                    imageFile.data = newImg;
                }

                return imageFile;
            };

            /**
            * Used to build a new texture atlas based on the image file provided. Internal use only.
            * @method _buildTextureAtlas
            * @param imageFile {File} The image file that is to be used.
            * @return {TextureAtlas} The new texture atlas that is created.
            * @private
            */
            TextureLibrary.prototype._buildTextureAtlas = function (imageFile) {
                var atlas = new Kiwi.Textures.TextureAtlas(imageFile.key, Kiwi.Textures.TextureAtlas.TEXTURE_ATLAS, null, imageFile.data);
                var m = imageFile.metadata;

                var json = this._game.fileStore.getFile(m.jsonID).data;
                json.trim();

                atlas.readJSON(json);

                return atlas;
            };

            /**
            * Builds a spritesheet atlas from the an image file that is provided.
            * @method _buildSpriteSheet
            * @param imageFile {File} The image file that is to be used.
            * @return {SpriteSheet} The SpriteSheet that was just created.
            * @private
            */
            TextureLibrary.prototype._buildSpriteSheet = function (imageFile) {
                var m = imageFile.metadata;

                //BEWARE THE SWITCH TO CELLWIDTH AND FRAMEWIDTH
                var spriteSheet = new Kiwi.Textures.SpriteSheet(imageFile.key, imageFile.data, m.frameWidth, m.frameHeight, m.numCells, m.rows, m.cols, m.sheetOffsetX, m.sheetOffsetY, m.cellOffsetX, m.cellOffsetY);
                return spriteSheet;
            };

            /**
            * Builds a single image atlas from a image file that is provided.
            * @method _buildImage
            * @param imageFile {File} The image file that is to be used.
            * @return {SingleImage} The SingleImage that was created.
            * @private
            */
            TextureLibrary.prototype._buildImage = function (imageFile) {
                var m = imageFile.metadata;
                return new Kiwi.Textures.SingleImage(imageFile.key, imageFile.data, m.width, m.height, m.offsetX, m.offsetY);
            };

            /**
            * Rebuild the library from a fileStore. Clears the library and repopulates it.
            * @method rebuild
            * @param {Kiwi.Files.FileStore} fileStore
            * @param {Kiwi.State} state
            * @public
            */
            TextureLibrary.prototype.rebuild = function (fileStore, state) {
                this.clear();
                if (this._game.debug) {
                    console.log("Rebuilding Texture Library");
                }

                var fileStoreKeys = fileStore.keys;
                for (var i = 0; i < fileStoreKeys.length; i++) {
                    var file = this._game.fileStore.getFile(fileStoreKeys[i]);
                    if (file.isTexture) {
                        if (this._game.debug) {
                            console.log("Adding Texture: " + file.fileName);
                        }
                        ;
                        state.textureLibrary.addFromFile(file);
                    }
                }
            };
            return TextureLibrary;
        })();
        Textures.TextureLibrary = TextureLibrary;
    })(Kiwi.Textures || (Kiwi.Textures = {}));
    var Textures = Kiwi.Textures;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Textures
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Textures) {
        /**
        * A special type of TextureAtlas that is created when loading in images that are design to be SpriteSheets. A SpriteSheet will generally contain multiple cells and can also contain sequences which are then automatically added as Animations when this texture is used on a Sprite.
        *
        * @class SpriteSheet
        * @extends TextureAtlas
        * @namespace Kiwi.Textures
        * @constructor
        * @param name {string} The name of the spritesheet.
        * @param texture {HTMLImageElement/HTMLCanvasElement} The image that is being used for the spritesheet.
        * @param cellWidth {number} The width of a single cell.
        * @param cellHeight {number} The height of a single cell.
        * @param [numCells] {number} The number of cells in total.
        * @param [rows] {number} The number of cells that make up a row.
        * @param [cols] {number} The number of cells that make up a column.
        * @param [sheetOffsetX] {number} The offset of the whole sheet on the x axis. Useful if the image has a border you don't want to show.
        * @param [sheetOffsetY] {number} The offset of the whole sheet on the y axis. Useful if the image has a border you don't want to show.
        * @param [cellOffsetX] {number} An offset between cells on the x axis. Useful if there is a border between cells which is not to be shown.
        * @param [cellOffsetY] {number} An offset between cells on the y axis. Useful if there is a border between cells which is not to be shown.
        * @return {SpriteSheet}
        */
        var SpriteSheet = (function (_super) {
            __extends(SpriteSheet, _super);
            function SpriteSheet(name, texture, cellWidth, cellHeight, numCells, rows, cols, sheetOffsetX, sheetOffsetY, cellOffsetX, cellOffsetY) {
                this.cellWidth = cellWidth;
                this.cellHeight = cellHeight;

                this._cols = cols || texture.width / cellWidth;
                this._rows = rows || texture.height / cellHeight;
                this.numCells = numCells || this.cols * this.rows;

                this.sheetOffsetX = sheetOffsetX || 0;
                this.sheetOffsetY = sheetOffsetY || 0;

                this.cellOffsetX = cellOffsetX || 0;
                this.cellOffsetY = cellOffsetY || 0;

                _super.call(this, name, Kiwi.Textures.TextureAtlas.SPRITE_SHEET, this.generateAtlasCells(), texture, this.sequences);
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return string
            * @public
            */
            SpriteSheet.prototype.objType = function () {
                return "SpriteSheet";
            };

            Object.defineProperty(SpriteSheet.prototype, "rows", {
                /**
                * Get the number of rows.
                * @type number
                * @public
                */
                get: function () {
                    return this._rows;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(SpriteSheet.prototype, "cols", {
                /**
                * Get the number of columns.
                * @type number
                * @public
                */
                get: function () {
                    return this._cols;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Generates the atlas cells based on the information that was provided.
            *
            * @method generateAtlasCells
            * @return {Array}
            * @public
            */
            SpriteSheet.prototype.generateAtlasCells = function () {
                var cells = new Array();
                var cellNumeric = new Array();

                var dx = this.sheetOffsetX;
                var dy = this.sheetOffsetY;
                var i = 0;

                for (var y = 0; y < this.rows; y++) {
                    for (var x = 0; x < this.cols; x++) {
                        cells.push({
                            x: dx,
                            y: dy,
                            w: this.cellWidth,
                            h: this.cellHeight,
                            hitboxes: [
                                {
                                    x: 0,
                                    y: 0,
                                    w: this.cellWidth,
                                    h: this.cellHeight
                                }
                            ]
                        });

                        cellNumeric.push(i++);

                        dx += this.cellOffsetX + this.cellWidth;
                    }
                    dx = this.sheetOffsetX;
                    dy += this.cellOffsetY + this.cellHeight;
                }

                //generate default sequence
                this.sequences = new Array();
                this.sequences.push(new Kiwi.Animations.Sequence('default', cellNumeric));

                return cells;
            };
            return SpriteSheet;
        })(Kiwi.Textures.TextureAtlas);
        Textures.SpriteSheet = SpriteSheet;
    })(Kiwi.Textures || (Kiwi.Textures = {}));
    var Textures = Kiwi.Textures;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Textures
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Textures) {
        /**
        * A special type of TextureAtlas that is used when the user has loaded a single image. This type of TextureAtlas contains only one cell which is generally the whole width/height of the image and starts at the coordinates 0/0. A SingleImage has a space to store sequences but this will not be used.
        *
        * @class SingleImage
        * @extends TextureAtlas
        * @namespace Kiwi.Textures
        * @constructor
        * @param name {string} The name of the single image
        * @param image {HTMLImageElement/HTMLCanvasElement} the image that is being used.
        * @param [width] {number} the width of the image
        * @param [height] {number} the height of the image
        * @param [offsetX] {number} the offset of the image on the x axis. Useful if the image has a border that you don't want to show.
        * @param [offsetY] {number} the offset of the image of the y axis. Useful if the image has a border that you don't want to show.
        * @return {SingleImage}
        */
        var SingleImage = (function (_super) {
            __extends(SingleImage, _super);
            function SingleImage(name, image, width, height, offsetX, offsetY) {
                this.width = width || image.width;
                this.height = height || image.height;
                this.offsetX = offsetX || 0;
                this.offsetY = offsetY || 0;

                _super.call(this, name, Kiwi.Textures.TextureAtlas.SINGLE_IMAGE, this.generateAtlasCells(), image);
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return string
            * @public
            */
            SingleImage.prototype.objType = function () {
                return "SingleImage";
            };

            /**
            * This method generates the single image cell based off the information that was passed during instantion.
            * @method generateAtlasCells
            * @returns{ Array }
            * @public
            */
            SingleImage.prototype.generateAtlasCells = function () {
                return [{ x: this.offsetX, y: this.offsetY, w: this.width, h: this.height, hitboxes: [{ x: 0, y: 0, w: this.width, h: this.height }] }];
            };
            return SingleImage;
        })(Kiwi.Textures.TextureAtlas);
        Textures.SingleImage = SingleImage;
    })(Kiwi.Textures || (Kiwi.Textures = {}));
    var Textures = Kiwi.Textures;
})(Kiwi || (Kiwi = {}));
/**
* Contains various methods that can be used when you are wanting to ease a Tween.
*
* @module Tweens
* @submodule Easing
* @main Easing
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            (function (Easing) {
                /**
                *
                * @class Back
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Back = (function () {
                    function Back() {
                    }
                    /**
                    * The type of object this is.
                    * @method objType
                    * @return {String}
                    * @public
                    */
                    Back.prototype.objType = function () {
                        return "Back";
                    };

                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Back.In = function (k) {
                        var s = 1.70158;
                        return k * k * ((s + 1) * k - s);
                    };

                    /**
                    *
                    * @method Out
                    * @param {Any} k
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Back.Out = function (k) {
                        var s = 1.70158;
                        return --k * k * ((s + 1) * k + s) + 1;
                    };

                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Back.InOut = function (k) {
                        var s = 1.70158 * 1.525;
                        if ((k *= 2) < 1)
                            return 0.5 * (k * k * ((s + 1) * k - s));
                        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
                    };
                    return Back;
                })();
                Easing.Back = Back;
            })(Tweens.Easing || (Tweens.Easing = {}));
            var Easing = Tweens.Easing;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            (function (Easing) {
                /**
                *
                * @class Bounce
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Bounce = (function () {
                    function Bounce() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String}
                    * @public
                    */
                    Bounce.prototype.objType = function () {
                        return "Bounce";
                    };

                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Bounce.In = function (k) {
                        return 1 - Kiwi.Animations.Tweens.Easing.Bounce.Out(1 - k);
                    };

                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Bounce.Out = function (k) {
                        if (k < (1 / 2.75)) {
                            return 7.5625 * k * k;
                        } else if (k < (2 / 2.75)) {
                            return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
                        } else if (k < (2.5 / 2.75)) {
                            return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
                        } else {
                            return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
                        }
                    };

                    /**
                    *
                    * @method InOut
                    * @param {Any} k
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Bounce.InOut = function (k) {
                        if (k < 0.5)
                            return Kiwi.Animations.Tweens.Easing.Bounce.In(k * 2) * 0.5;
                        return Kiwi.Animations.Tweens.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
                    };
                    return Bounce;
                })();
                Easing.Bounce = Bounce;
            })(Tweens.Easing || (Tweens.Easing = {}));
            var Easing = Tweens.Easing;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            /**
            *
            * @module Tweens
            * @submodule Easing
            *
            */
            (function (Easing) {
                /**
                *
                *
                * @class Circular
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Circular = (function () {
                    function Circular() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String}
                    * @public
                    */
                    Circular.prototype.objType = function () {
                        return "Circular";
                    };

                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    */
                    Circular.In = function (k) {
                        return 1 - Math.sqrt(1 - k * k);
                    };

                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    */
                    Circular.Out = function (k) {
                        return Math.sqrt(1 - (--k * k));
                    };

                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    */
                    Circular.InOut = function (k) {
                        if ((k *= 2) < 1)
                            return -0.5 * (Math.sqrt(1 - k * k) - 1);
                        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
                    };
                    return Circular;
                })();
                Easing.Circular = Circular;
            })(Tweens.Easing || (Tweens.Easing = {}));
            var Easing = Tweens.Easing;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            (function (Easing) {
                /**
                *
                * @class Cubic
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Cubic = (function () {
                    function Cubic() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String}
                    * @public
                    */
                    Cubic.prototype.objType = function () {
                        return "Cubic";
                    };

                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Cubic.In = function (k) {
                        return k * k * k;
                    };

                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Cubic.Out = function (k) {
                        return --k * k * k + 1;
                    };

                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @static
                    * @public
                    */
                    Cubic.InOut = function (k) {
                        if ((k *= 2) < 1)
                            return 0.5 * k * k * k;
                        return 0.5 * ((k -= 2) * k * k + 2);
                    };
                    return Cubic;
                })();
                Easing.Cubic = Cubic;
            })(Tweens.Easing || (Tweens.Easing = {}));
            var Easing = Tweens.Easing;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            (function (Easing) {
                /**
                *
                *
                * @class Elastic
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Elastic = (function () {
                    function Elastic() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String}
                    * @public
                    */
                    Elastic.prototype.objType = function () {
                        return "Elastic";
                    };

                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Elastic.In = function (k) {
                        var s, a = 0.1, p = 0.4;
                        if (k === 0)
                            return 0;
                        if (k === 1)
                            return 1;
                        if (!a || a < 1) {
                            a = 1;
                            s = p / 4;
                        } else
                            s = p * Math.asin(1 / a) / (2 * Math.PI);
                        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                    };

                    /**
                    *
                    * @method Out
                    * @param {Any} k
                    * @static
                    * @public
                    */
                    Elastic.Out = function (k) {
                        var s, a = 0.1, p = 0.4;
                        if (k === 0)
                            return 0;
                        if (k === 1)
                            return 1;
                        if (!a || a < 1) {
                            a = 1;
                            s = p / 4;
                        } else
                            s = p * Math.asin(1 / a) / (2 * Math.PI);
                        return (a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
                    };

                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @static
                    * @public
                    */
                    Elastic.InOut = function (k) {
                        var s, a = 0.1, p = 0.4;
                        if (k === 0)
                            return 0;
                        if (k === 1)
                            return 1;
                        if (!a || a < 1) {
                            a = 1;
                            s = p / 4;
                        } else
                            s = p * Math.asin(1 / a) / (2 * Math.PI);
                        if ((k *= 2) < 1)
                            return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
                    };
                    return Elastic;
                })();
                Easing.Elastic = Elastic;
            })(Tweens.Easing || (Tweens.Easing = {}));
            var Easing = Tweens.Easing;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            (function (Easing) {
                /**
                *
                *
                * @class Exponential
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Exponential = (function () {
                    function Exponential() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String}
                    * @public
                    */
                    Exponential.prototype.objType = function () {
                        return "Exponential";
                    };

                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Exponential.In = function (k) {
                        return k === 0 ? 0 : Math.pow(1024, k - 1);
                    };

                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Exponential.Out = function (k) {
                        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
                    };

                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Exponential.InOut = function (k) {
                        if (k === 0)
                            return 0;
                        if (k === 1)
                            return 1;
                        if ((k *= 2) < 1)
                            return 0.5 * Math.pow(1024, k - 1);
                        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
                    };
                    return Exponential;
                })();
                Easing.Exponential = Exponential;
            })(Tweens.Easing || (Tweens.Easing = {}));
            var Easing = Tweens.Easing;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            (function (Easing) {
                /**
                *
                * @class Linear
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Linear = (function () {
                    function Linear() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String}
                    * @public
                    */
                    Linear.prototype.objType = function () {
                        return "Linear";
                    };

                    /**
                    *
                    * @method None
                    * @param {Any} k
                    * @return {Number}
                    * @static
                    */
                    Linear.None = function (k) {
                        return k;
                    };
                    return Linear;
                })();
                Easing.Linear = Linear;
            })(Tweens.Easing || (Tweens.Easing = {}));
            var Easing = Tweens.Easing;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            (function (Easing) {
                /**
                *
                *
                * @class Quadratic
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Quadratic = (function () {
                    function Quadratic() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String}
                    * @public
                    */
                    Quadratic.prototype.objType = function () {
                        return "Quadratic";
                    };

                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quadratic.In = function (k) {
                        return k * k;
                    };

                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quadratic.Out = function (k) {
                        return k * (2 - k);
                    };

                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quadratic.InOut = function (k) {
                        if ((k *= 2) < 1)
                            return 0.5 * k * k;
                        return -0.5 * (--k * (k - 2) - 1);
                    };
                    return Quadratic;
                })();
                Easing.Quadratic = Quadratic;
            })(Tweens.Easing || (Tweens.Easing = {}));
            var Easing = Tweens.Easing;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            (function (Easing) {
                /**
                *
                * @class Quartic
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Quartic = (function () {
                    function Quartic() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String}
                    * @public
                    */
                    Quartic.prototype.objType = function () {
                        return "Quartic";
                    };

                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Quartic.In = function (k) {
                        return k * k * k * k;
                    };

                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Quartic.Out = function (k) {
                        return 1 - (--k * k * k * k);
                    };

                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Quartic.InOut = function (k) {
                        if ((k *= 2) < 1)
                            return 0.5 * k * k * k * k;
                        return -0.5 * ((k -= 2) * k * k * k - 2);
                    };
                    return Quartic;
                })();
                Easing.Quartic = Quartic;
            })(Tweens.Easing || (Tweens.Easing = {}));
            var Easing = Tweens.Easing;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            (function (Easing) {
                /**
                *
                * @class Quintic
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Quintic = (function () {
                    function Quintic() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String}
                    * @public
                    */
                    Quintic.prototype.objType = function () {
                        return "Quintic";
                    };

                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quintic.In = function (k) {
                        return k * k * k * k * k;
                    };

                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quintic.Out = function (k) {
                        return --k * k * k * k * k + 1;
                    };

                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quintic.InOut = function (k) {
                        if ((k *= 2) < 1)
                            return 0.5 * k * k * k * k * k;
                        return 0.5 * ((k -= 2) * k * k * k * k + 2);
                    };
                    return Quintic;
                })();
                Easing.Quintic = Quintic;
            })(Tweens.Easing || (Tweens.Easing = {}));
            var Easing = Tweens.Easing;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            (function (Easing) {
                /**
                *
                * @class Sinusoidal
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Sinusoidal = (function () {
                    function Sinusoidal() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String}
                    * @public
                    */
                    Sinusoidal.prototype.objType = function () {
                        return "Sinusoidal";
                    };

                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Sinusoidal.In = function (k) {
                        return 1 - Math.cos(k * Math.PI / 2);
                    };

                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Sinusoidal.Out = function (k) {
                        return Math.sin(k * Math.PI / 2);
                    };

                    /**
                    *
                    * @method InOut
                    * @param {Any} k
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Sinusoidal.InOut = function (k) {
                        return 0.5 * (1 - Math.cos(Math.PI * k));
                    };
                    return Sinusoidal;
                })();
                Easing.Sinusoidal = Sinusoidal;
            })(Tweens.Easing || (Tweens.Easing = {}));
            var Easing = Tweens.Easing;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
* The section of Kiwi which holds the scripts that manage Tween's in Kiwi. The scripts in this section are based on Tween.js by sole and have been converted to TypeScript and integrated into Kiwi. https://github.com/sole/tween.js
*
* @module Animations
* @submodule Tweens
* @main Tweens
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        (function (Tweens) {
            /**
            * The TweenManager is automatically created on every game. This class is responsible for the creation and management of tweens for the game.
            *
            * Based on tween.js by sole. Converted to TypeScript and integrated into Kiwi.
            * https://github.com/sole/tween.js
            *
            * @class TweenManager
            * @namespace Kiwi.Animations.Tweens
            * @constructor
            * @param game {Game}
            * @return {TweenManager}
            *
            * @author     sole / http://soledadpenades.com
            * @author     mrdoob / http://mrdoob.com
            * @author     Robert Eisele / http://www.xarg.org
            * @author     Philippe / http://philippe.elsass.me
            * @author     Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
            * @author     Paul Lewis / http://www.aerotwist.com/
            * @author     lechecacharro
            * @author     Josh Faul / http://jocafa.com/
            * @author     egraether / http://egraether.com/
            *
            */
            var TweenManager = (function () {
                function TweenManager(game) {
                    this._game = game;
                    this._tweens = [];
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String}
                * @public
                */
                TweenManager.prototype.objType = function () {
                    return "TweenManager";
                };

                /**
                * Returns all of tweens that are on the manager.
                * @method getAll
                * @return Tween[]
                * @public
                */
                TweenManager.prototype.getAll = function () {
                    return this._tweens;
                };

                /**
                * Removes all of the tweens on the manager.
                * @method removeAll
                * @public
                */
                TweenManager.prototype.removeAll = function () {
                    this._tweens.length = 0;
                };

                /**
                * Creates a new Tween.
                * @method create
                * @param object {Any} The object that this tween is to apply.
                * @return {Tween} The tween that was created.
                * @public
                */
                TweenManager.prototype.create = function (object) {
                    return new Kiwi.Animations.Tween(object, this._game);
                };

                /**
                * Adds a tween to the manager.
                * @method add
                * @param tween {Tween} The tween that you want to add to the manager.
                * @return {Tween}
                * @public
                */
                TweenManager.prototype.add = function (tween) {
                    tween.setParent(this._game);

                    this._tweens.push(tween);

                    return tween;
                };

                /**
                * Removes a tween from this manager.
                * @method remove
                * @param tween {Tween} The tween that you would like to remove.
                * @return {Tween}
                * @public
                */
                TweenManager.prototype.remove = function (tween) {
                    var i = this._tweens.indexOf(tween);

                    if (i !== -1) {
                        this._tweens.splice(i, 1);
                    }
                };

                /**
                * The update loop.
                * @method update
                * @public
                */
                TweenManager.prototype.update = function () {
                    if (this._tweens.length === 0) {
                        return false;
                    }

                    //  See if we can merge the length into the while block
                    var i = 0;
                    var numTweens = this._tweens.length;

                    while (i < numTweens) {
                        if (this._tweens[i].update(this._game.time.now())) {
                            i++;
                        } else {
                            this._tweens.splice(i, 1);
                            numTweens--;
                        }
                    }

                    return true;
                };
                return TweenManager;
            })();
            Tweens.TweenManager = TweenManager;
        })(Animations.Tweens || (Animations.Tweens = {}));
        var Tweens = Animations.Tweens;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Animations
* @submodule Tweens
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        /**
        * Manages the tweening of properties/values on a single object. A Tween is the animation of a number between an initially value to and final value (that you specify).
        * Note: When using a Tween you need to make sure that the Tween has been added to a TweenManager. You can either do this by creating the Tween via the Manager or alternatively using the 'add' method on the TweenManager. Otherwise the tween will not work.
        *
        * Based on tween.js by sole. Converted to TypeScript and integrated into Kiwi.
        * https://github.com/sole/tween.js
        *
        * @class Tween
        * @constructor
        * @namespace Kiwi.Animations
        * @param object {Any} The object that this tween is taking affect on.
        * @param game {Game} The game that this tween is for.
        * @return {Tween} This tween.
        *
        * @author     sole / http://soledadpenades.com
        * @author     mrdoob / http://mrdoob.com
        * @author     Robert Eisele / http://www.xarg.org
        * @author     Philippe / http://philippe.elsass.me
        * @author     Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
        * @author     Paul Lewis / http://www.aerotwist.com/
        * @author     lechecacharro
        * @author     Josh Faul / http://jocafa.com/
        * @author     egraether / http://egraether.com/
        *
        */
        var Tween = (function () {
            function Tween(object, game) {
                if (typeof game === "undefined") { game = null; }
                /**
                * The game that this tween belongs to.
                * @property _game
                * @type Game
                * @private
                */
                this._game = null;
                /**
                * The manager that this tween belongs to.
                * @property _manager
                * @type Manager
                * @private
                */
                this._manager = null;
                /**
                * The object that this tween is affecting.
                * @property _object
                * @type Any
                * @private
                */
                this._object = null;
                /**
                * The starting values of the properties that the tween is animating.
                * @property _valuesStart
                * @type Object
                * @private
                */
                this._valuesStart = {};
                /**
                * The end values of the properties that the tween is animating.
                * @property _valuesEnd
                * @type Object
                * @private
                */
                this._valuesEnd = {};
                /**
                * The duration of the tween, in milliseconds.
                * @property _duration
                * @type Number
                * @private
                */
                this._duration = 1000;
                /**
                * The amount of time to delay the tween by. In Milliseconds.
                * @property _delayTime
                * @type Number
                * @private
                */
                this._delayTime = 0;
                /**
                * The time at which the tween started.
                * @property _startTime
                * @type Number
                * @private
                */
                this._startTime = null;
                /**
                * The easing function that is to be used while tweening.
                * @property _easingFunction
                * @type Function
                * @default Kiwi.Tweens.Easing.Linear.None
                * @private
                */
                this._easingFunction = Kiwi.Animations.Tweens.Easing.Linear.None;
                /**
                * [NEEDS DESCRIPTION]
                * @property _interpolationFunction
                * @type Function
                * @default Kiwi.Utils.Interpolation.Linear
                * @private
                */
                this._interpolationFunction = Kiwi.Utils.GameMath.linearInterpolation;
                /**
                * An array containing all of the tweens that are to be played when this one finishes.
                * @property _chainedTweens
                * @type Tween[]
                * @private
                */
                this._chainedTweens = [];
                /**
                * The method that is to be called when the tween starts playing.
                * @property _onStartCallback
                * @type Function
                * @default null
                * @private
                */
                this._onStartCallback = null;
                /**
                * The context that the _onStartCallback method is to be called in.
                * @property _onStartContext
                * @type Any
                * @default null
                * @private
                */
                this._onStartContext = null;
                /**
                * A boolean indicating if the starting callback has been called or not.
                * @property _onStartCallbackFired
                * @type boolean
                * @default false
                * @private
                */
                this._onStartCallbackFired = false;
                /**
                * A callback method that will be called each time the tween updates.
                * @property _onUpdateCallback
                * @type Function
                * @default null
                * @private
                */
                this._onUpdateCallback = null;
                /**
                * The context that the update callback has when called.
                * @property _onUpdateContext
                * @type any
                * @default null
                * @private
                */
                this._onUpdateContext = null;
                /**
                * A method to be called when the tween finish's tweening.
                * @property _onCompleteCallback
                * @type function
                * @default null
                * @private
                */
                this._onCompleteCallback = null;
                /*
                * A boolean indicating whether or not the _onCompleteCallback has been called.
                * Is reset each time you tell the tween to start.
                * @property _onCompleteCalled
                * @type boolean
                * @default false
                * @private
                */
                this._onCompleteCalled = false;
                /**
                * The context that the onCompleteCallback should have when called.
                * @property _onCompleteContext
                * @type any
                * @default null
                * @private
                */
                this._onCompleteContext = null;
                /**
                * An indication of whether or not this tween is currently running.
                * @property isRunning.
                * @type boolean
                * @default false
                * @public
                */
                this.isRunning = false;
                this._object = object;

                if (game !== null) {
                    this._game = game;
                    this._manager = this._game.tweens;
                }

                this.isRunning = false;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Tween.prototype.objType = function () {
                return "Tween";
            };

            /**
            * Sets up the various properties that define this tween.
            * The ending position/properties for this tween, how long the tween should go for, easing method to use and if should start right way.
            *
            * @method to
            * @param properties {Object} The ending location of the properties that you want to tween.
            * @param [duration=1000] {Number} The duration of the tween.
            * @param [ease=null] {Any} The easing method to be used. If not specifed then this will default to LINEAR.
            * @param [autoStart=false] {boolean} If the tween should start right away.
            * @return {Tween}
            * @public
            */
            Tween.prototype.to = function (properties, duration, ease, autoStart) {
                if (typeof duration === "undefined") { duration = 1000; }
                if (typeof ease === "undefined") { ease = null; }
                if (typeof autoStart === "undefined") { autoStart = false; }
                this._duration = duration;

                //  If properties isn't an object this will fail, sanity check it here somehow?
                this._valuesEnd = properties;

                if (ease !== null) {
                    this._easingFunction = ease;
                }

                if (autoStart === true) {
                    return this.start();
                } else {
                    return this;
                }
            };

            /**
            * Gets the initial values for the properties that it is to animate and starts the tween process.
            * @method start
            * @public
            */
            Tween.prototype.start = function () {
                if (this._game === null || this._object === null) {
                    return;
                }

                this.isRunning = true;

                this._manager.add(this);

                this._onStartCallbackFired = false;

                this._onCompleteCalled = false;

                this._startTime = this._game.time.now() + this._delayTime;

                for (var property in this._valuesEnd) {
                    // This prevents the interpolation of null values or of non-existing properties
                    if (this._object[property] === null || !(property in this._object)) {
                        continue;
                    }

                    // check if an Array was provided as property value
                    if (this._valuesEnd[property] instanceof Array) {
                        if (this._valuesEnd[property].length === 0) {
                            continue;
                        }

                        // create a local copy of the Array with the start value at the front
                        this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);
                    }

                    //  Check if property is a function
                    if (typeof this._object[property] === 'function') {
                        this._valuesStart[property] = this._object[property]();
                    } else {
                        this._valuesStart[property] = this._object[property];
                    }
                }

                return this;
            };

            /**
            * Stops the Tween from running and removes it from the manager.
            * @method stop
            * @public
            */
            Tween.prototype.stop = function () {
                if (this._manager !== null) {
                    this._manager.remove(this);
                }

                this.isRunning = false;

                return this;
            };

            /**
            * Sets the game and the manager of this tween.
            * @method setParent
            * @param {Game} value
            * @public
            */
            Tween.prototype.setParent = function (value) {
                this._game = value;
                this._manager = this._game.tweens;
            };

            /**
            * Sets the amount of delay that the tween is to have before it starts playing.
            * @method delay
            * @param amount {Number} The amount of time to delay the tween by.
            * @return {Tween}
            * @public
            */
            Tween.prototype.delay = function (amount) {
                this._delayTime = amount;
                return this;
            };

            /**
            * Sets the easing method that is to be used when animating this tween.
            * @method easing
            * @param easing {Function} The easing function to use.
            * @return {Tween}
            * @public
            */
            Tween.prototype.easing = function (easing) {
                this._easingFunction = easing;
                return this;
            };

            /**
            * [REQUIRES DESCRIPTION]
            * @method interpolation
            * @param {Any} interpolation
            * @return {Tween}
            * @public
            */
            Tween.prototype.interpolation = function (interpolation) {
                this._interpolationFunction = interpolation;

                return this;
            };

            /**
            * Adds another tween that should start playing once tween has completed.
            * @method chain
            * @param tween {Tween}
            * @return {Tween}
            * @public
            */
            Tween.prototype.chain = function (tween) {
                this._chainedTweens.push(tween);
                return this;
            };

            /**
            * Adds a function that is to be executed when the tween start playing.
            * @method onStart
            * @param callback {Function} The function that is to be executed on tween start.
            * @param context {any} The context that function is to have when called.
            * @return {Tween}
            * @public
            */
            Tween.prototype.onStart = function (callback, context) {
                this._onStartCallback = callback;
                this._onStartContext = context;
                return this;
            };

            /**
            * Adds a function that is to be executed when this tween updates while it is playing.
            * @method onUpdate
            * @param callback {Function} The method that is to be executed.
            * @param context {Any} The context the method is to have when called.
            * @public
            */
            Tween.prototype.onUpdate = function (callback, context) {
                this._onUpdateCallback = callback;
                this._onUpdateContext = context;
                return this;
            };

            /**
            * Defines a method that is to be called when this tween is finished.
            * @method onComplete
            * @param callback {Function} The method that is to be executed.
            * @param context {Any} The context the method is to have when called.
            * @public
            */
            Tween.prototype.onComplete = function (callback, context) {
                this._onCompleteCallback = callback;
                this._onCompleteContext = context;

                return this;
            };

            /**
            * The update loop is executed every frame whilst the tween is running.
            * @method update
            * @param time {Number}
            * @public
            */
            Tween.prototype.update = function (time) {
                if (time < this._startTime) {
                    return true;
                }

                if (this._onStartCallbackFired === false) {
                    if (this._onStartCallback !== null) {
                        this._onStartCallback.call(this._onStartContext, this._object);
                    }

                    this._onStartCallbackFired = true;
                }

                var elapsed = (time - this._startTime) / this._duration;
                elapsed = elapsed > 1 ? 1 : elapsed;

                var value = this._easingFunction(elapsed);

                for (var property in this._valuesStart) {
                    var start = this._valuesStart[property];
                    var end = this._valuesEnd[property];

                    //  Add checks for object, array, numeric up front
                    if (end instanceof Array) {
                        this._object[property] = this._interpolationFunction(end, value);
                    } else {
                        if (typeof this._object[property] === 'function') {
                            this._object[property](start + (end - start) * value);
                        } else {
                            this._object[property] = start + (end - start) * value;
                        }
                    }
                }

                if (this._onUpdateCallback !== null) {
                    this._onUpdateCallback.call(this._onUpdateContext, this._object, value);
                }

                if (elapsed == 1) {
                    this.isRunning = false;

                    if (this._onCompleteCallback !== null && this._onCompleteCalled == false) {
                        this._onCompleteCalled = true;
                        this._onCompleteCallback.call(this._onCompleteContext, this._object);
                    }

                    for (var i = 0; i < this._chainedTweens.length; i++) {
                        this._chainedTweens[i].start();
                    }

                    return false;
                }

                return true;
            };
            return Tween;
        })();
        Animations.Tween = Tween;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));

var Kiwi;
(function (Kiwi) {
    /**
    * Contains the classes which are related to the rendering of GameObjects.
    *
    * @module Kiwi
    * @submodule Renderers
    * @main
    */
    (function (Renderers) {
        /**
        *
        * @class CanvasRenderer
        * @extends IRenderer
        * @constructor
        * @namespace Kiwi.Renderers
        * @param game {Game} The game that this canvas renderer belongs to.
        * @return {CanvasRenderer}
        *
        */
        var CanvasRenderer = (function () {
            function CanvasRenderer(game) {
                this.numDrawCalls = 0;
                this._game = game;
            }
            /**
            * The boot method is executed when all of the DOM elements that are needed to play the game are ready.
            * @method boot
            * @public
            */
            CanvasRenderer.prototype.boot = function () {
            };

            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            CanvasRenderer.prototype.objType = function () {
                return "CanvasRenderer";
            };

            /**
            * This method recursively goes through a State's members and runs the render method of each member that is a Entity.
            * If it is a Group then this method recursively goes through that Groups members the process that happened to the State's members happens to the Group's members.
            *
            * @method _recurse
            * @param child {IChild} The child that is being checked.
            * @private
            */
            CanvasRenderer.prototype._recurse = function (child) {
                if (!child.willRender)
                    return;

                if (child.childType() === Kiwi.GROUP) {
                    for (var i = 0; i < child.members.length; i++) {
                        this._recurse(child.members[i]);
                    }
                } else {
                    this.numDrawCalls++;
                    child.render(this._currentCamera);
                }
            };

            //for gl compatibility - refactor me
            CanvasRenderer.prototype.requestRendererInstance = function (rendererID, params) {
                if (typeof params === "undefined") { params = null; }
                return null;
            };

            CanvasRenderer.prototype.requestSharedRenderer = function (rendererID, params) {
                if (typeof params === "undefined") { params = null; }
                return null;
            };

            CanvasRenderer.prototype.initState = function (state) {
            };

            CanvasRenderer.prototype.endState = function (state) {
            };

            /**
            * Renders all of the Elements that are on a particular camera.
            * @method render
            * @param camera {Camera}
            * @public
            */
            CanvasRenderer.prototype.render = function (camera) {
                this.numDrawCalls = 0;
                this._currentCamera = camera;
                var root = this._game.states.current.members;

                //clear
                this._game.stage.ctx.fillStyle = this._game.stage.color;

                this._game.stage.ctx.fillRect(0, 0, this._game.stage.canvas.width, this._game.stage.canvas.height);

                //apply camera transform
                var cm = camera.transform.getConcatenatedMatrix();
                var ct = camera.transform;

                this._game.stage.ctx.save();
                this._game.stage.ctx.setTransform(cm.a, cm.b, cm.c, cm.d, cm.tx + ct.rotPointX, cm.ty + ct.rotPointY);

                for (var i = 0; i < root.length; i++) {
                    this._recurse(root[i]);
                }
                this._game.stage.ctx.restore();
            };
            return CanvasRenderer;
        })();
        Renderers.CanvasRenderer = CanvasRenderer;
    })(Kiwi.Renderers || (Kiwi.Renderers = {}));
    var Renderers = Kiwi.Renderers;
})(Kiwi || (Kiwi = {}));

var Kiwi;
(function (Kiwi) {
    /**
    *
    *
    * @module Kiwi
    * @submodule Renderers
    * @main Renderers
    */
    (function (Renderers) {
        /**
        * Manages all rendering using WebGL. Requires the inclusion of gl-matrix.js / g-matrix.min.js -  https://github.com/toji/gl-matrix
        * Directly manages renderer objects, including factory methods for their creation.
        * Creates manager objects for shaders and textures.
        * Manages gl state at game initialisation, at state start and end, and per frame.
        * Runs the recursive scene graph rendering sequence every frame.
        * @class GLRenderManager
        * @extends IRenderer
        * @constructor
        * @param game {Game} The game that this renderer belongs to.
        * @return {GLRenderer}
        */
        var GLRenderManager = (function () {
            function GLRenderManager(game) {
                /**
                * The renderer object that is in use during a rendering batch.
                * @property _currentRenderer
                * @type Kiwi.Renderers.Renderer
                * @private
                */
                this._currentRenderer = null;
                /**
                * Tally of number of entities rendered per frame
                * @property _entityCount
                * @type number
                * @default 0
                * @private
                */
                this._entityCount = 0;
                /**
                * Tally of number of draw calls per frame
                * @property numDrawCalls
                * @type number
                * @default 0
                * @public
                */
                this.numDrawCalls = 0;
                /**
                * Maximum allowable sprites to render per frame
                * Note:Not currently used  - candidate for deletion
                * @property _maxItems
                * @type number
                * @default 1000
                * @private
                */
                this._maxItems = 1000;
                /**
                * The most recently bound texture atlas.
                * @property _currentTextureAtlas
                * @type TextureAtlas
                * @private
                */
                this._currentTextureAtlas = null;
                /**
                * An array of renderers. Shared renderers are used for batch rendering. Multiple gameobjects can use the same renderer
                * instance and add rendering info to a batch rather than rendering individually.
                * This means only one draw call is necessary to render a number of objects. The most common use of this is standard 2d sprite rendering,
                * and the TextureAtlasRenderer is added by default as a shared renderer. Sprites, StaticImages and Tilemaps (core gameobjects) can all use the
                * same renderer/shader combination and be drawn as part of the same batch.
                * Custom gameobjects can also choose to use a shared renderer, fo example in the case that a custom gameobject's rendering requirements matched the TextureAtlasRenderer
                * capabilities.
                *
                * @property _sharedRenderers
                * @type Array
                * @private
                */
                this._sharedRenderers = {};
                this._game = game;
                if (typeof mat4 === "undefined") {
                    throw "ERROR: gl-matrix.js is missing - you need to include this javascript to use webgl - https://github.com/toji/gl-matrix";
                }
            }
            /**
            * Initialises all WebGL rendering services
            * @method boot
            * @public
            */
            GLRenderManager.prototype.boot = function () {
                this._textureManager = new Kiwi.Renderers.GLTextureManager();
                this._shaderManager = new Kiwi.Shaders.ShaderManager();

                //this.filters = new Kiwi.Filters.GLFilterManager(this._game, this._shaderManager);
                this._init();
            };

            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            GLRenderManager.prototype.objType = function () {
                return "GLRenderManager";
            };

            GLRenderManager.prototype.addTexture = function (gl, atlas) {
                this._textureManager.uploadTexture(gl, atlas);
            };

            /**
            * Adds a renderer to the sharedRenderer array. The rendererID is a string that must match a renderer property of the Kiwi.Renderers object.
            * If a match is found and an instance does not already exist, then a renderer is instantiated and added to the array.
            * @method addSharedRenderer
            * @param {String} rendererID
            * @param {Object} params
            * @return {Boolean} success
            * @public
            */
            GLRenderManager.prototype.addSharedRenderer = function (rendererID, params) {
                if (typeof params === "undefined") { params = null; }
                //does renderer exist?
                if (Kiwi.Renderers[rendererID]) {
                    //already added?
                    if (!(rendererID in this._sharedRenderers)) {
                        this._sharedRenderers[rendererID] = new Kiwi.Renderers[rendererID](this._game.stage.gl, this._shaderManager, params);
                        return true;
                    }
                }
                return false;
            };

            /**
            * Requests a shared renderer. A game object that wants to use a shared renderer uses this method to obtain a reference to the shared renderer instance.
            * @method addSharedRenderer
            * @param {String} rendererID
            * @param {Object} params
            * @return {Kiwi.Renderers.Renderer} A shared renderer or null if none found.
            * @public
            */
            GLRenderManager.prototype.requestSharedRenderer = function (rendererID, params) {
                if (typeof params === "undefined") { params = null; }
                var renderer = this._sharedRenderers[rendererID];
                if (renderer) {
                    return renderer;
                } else {
                    if (this.addSharedRenderer(rendererID, params)) {
                        return this._sharedRenderers[rendererID];
                    } else {
                        console.log("no renderer called " + rendererID);
                    }
                }

                //failed request
                return null;
            };

            /**
            * Requests a new renderer instance. This factory method is the only way gameobjects should instantiate their own renderer.
            * The rendererID is a string that must match a renderer property of the Kiwi.Renderers object.
            * If a match is found then a renderer is instantiated and returned. Gameobjects which have rendering requirements that do not suit
            * batch rendering use this technique.
            * @method requestRendererInstance
            * @param {String} rendererID The name of the requested renderer
            * @param {Object} params
            * @return {Kiwi.Renderers.Renderer} A renderer or null if none found.
            * @public
            */
            GLRenderManager.prototype.requestRendererInstance = function (rendererID, params) {
                if (typeof params === "undefined") { params = null; }
                if (rendererID in Kiwi.Renderers) {
                    var renderer = new Kiwi.Renderers[rendererID](this._game.stage.gl, this._shaderManager, params);
                    return renderer;
                } else {
                    console.log("No renderer with id " + rendererID + " exists");
                }
                return null;
            };

            /*
            public get filtersEnabled(): boolean {
            return this._filtersEnabled;
            }
            
            public set filtersEnabled(val: boolean) {
            this._filtersEnabled = val;
            }
            
            private _filtersEnabled: boolean = false;
            
            /**
            * Performs initialisation required for single game instance - happens once, at bootup
            * Sets global GL state.
            * Initialises managers for shaders and textures.
            * Instantiates the default shared renderer (TextureAtlasRenderer)
            * @method _init
            * @private
            */
            GLRenderManager.prototype._init = function () {
                console.log("Intialising WebGL");
                var gl = this._game.stage.gl;

                //init stage and viewport
                this._stageResolution = new Float32Array([this._game.stage.width, this._game.stage.height]);
                gl.viewport(0, 0, this._game.stage.width, this._game.stage.height);

                //set default gl state
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                //shader manager
                this._shaderManager.init(gl, "TextureAtlasShader");

                //camera matrix
                this.camMatrix = mat3.create();

                //stage res needs update on stage resize
                this._game.stage.onResize.add(function (width, height) {
                    this._stageResolution = new Float32Array([width, height]);
                    if (this.currentRenderer)
                        this._currentRenderer.updateStageResolution(gl, this._stageResolution);

                    //this.filters.updateFilterResolution(gl,width, height);
                    gl.viewport(0, 0, width, height);
                }, this);
                /* if (this.filtersEnabled && !this.filters.isEmpty) {
                this.filters.enableFrameBuffers(gl);
                }*/
            };

            /**
            * Performs initialisation required when switching to a different state. Called when a state has been switched to.
            * The textureManager is told to rebuild its cache of textures from the states textuer library.
            * @method initState
            * @public
            */
            GLRenderManager.prototype.initState = function (state) {
                this._textureManager.uploadTextureLibrary(this._game.stage.gl, state.textureLibrary);
            };

            /**
            * Performs cleanup required before switching to a different state. Called whwn a state is about to be switched from. The textureManager is told to empty its cache.
            * @method initState
            * @param state {Kiwi.State}
            * @public
            */
            GLRenderManager.prototype.endState = function (state) {
                this._textureManager.clearTextures(this._game.stage.gl);
                console.log("ending WebGL on State");
            };

            /**
            * Manages rendering of the scene graph - called once per frame.
            * Sets up per frame gl uniforms such as the view matrix and camera offset.
            * Clears the current renderer ready for a new batch.
            * Initiates recursive render of scene graph starting at the root.
            * @method render
            * @param camera {Camera}
            * @public
            */
            GLRenderManager.prototype.render = function (camera) {
                if (this._game.states.current.members.length == 0) {
                    console.log("nothing to render");
                    return;
                }

                var gl = this._game.stage.gl;

                //reset stats
                this.numDrawCalls = 0;
                this._textureManager.numTextureWrites = 0;
                this._entityCount = 0;

                //clear stage
                var col = this._game.stage.normalizedColor;
                gl.clearColor(col.r, col.b, col.g, col.a);
                gl.clear(gl.COLOR_BUFFER_BIT);

                //set cam matrix uniform
                var cm = camera.transform.getConcatenatedMatrix();
                var ct = camera.transform;

                var rotOffset = vec2.create();
                var scale = vec2.create();
                vec2.set(scale, ct.scaleX, ct.scaleY);
                vec2.set(rotOffset, ct.rotPointX - cm.tx, ct.rotPointY - cm.ty);

                mat3.identity(this.camMatrix);
                mat3.translate(this.camMatrix, this.camMatrix, rotOffset);
                mat3.rotate(this.camMatrix, this.camMatrix, ct.rotation);
                vec2.negate(rotOffset, rotOffset);
                mat3.translate(this.camMatrix, this.camMatrix, rotOffset);
                mat3.scale(this.camMatrix, this.camMatrix, scale);

                this.collateRenderSequence();
                this.collateBatches();
                this.renderBatches(gl, camera);
                /*if (this._filtersEnabled && !this.filters.isEmpty) {
                this.filters.applyFilters(gl);
                gl.useProgram(this._shaderManager.currentShader.shaderProgram);
                gl.bindTexture(gl.TEXTURE_2D, this._currentTextureAtlas.glTextureWrapper.texture);
                }*/
            };

            GLRenderManager.prototype.collateRenderSequence = function () {
                this._sequence = [];
                var root = this._game.states.current;
                this.collateChild(root);
            };

            GLRenderManager.prototype.collateChild = function (child) {
                if (child.childType() === Kiwi.GROUP) {
                    for (var i = 0; i < child.members.length; i++) {
                        this.collateChild(child.members[i]);
                    }
                } else {
                    var entity = child;
                    this._sequence.push({
                        entity: entity,
                        renderer: entity.glRenderer,
                        shader: entity.glRenderer.shaderPair,
                        isBatchRenderer: entity.glRenderer.isBatchRenderer,
                        texture: entity.atlas
                    });
                }
            };

            GLRenderManager.prototype.collateBatches = function () {
                var currentRenderer = null;
                var currentShader = null;
                var currentTexture = null;

                this._batches = [];
                var batchIndex;

                for (var i = 0; i < this._sequence.length; i++) {
                    if (!this._sequence[i].isBatchRenderer || this._sequence[i].renderer !== currentRenderer || this._sequence[i].shader !== currentShader || this._sequence[i].texture !== currentTexture) {
                        //create a new batch
                        var batchIndex = this._batches.push(new Array()) - 1;
                        currentRenderer = this._sequence[i].renderer;
                        currentShader = this._sequence[i].shader;
                        currentTexture = this._sequence[i].texture;
                    }
                    this._batches[batchIndex].push(this._sequence[i]);
                }
            };

            GLRenderManager.prototype.renderBatches = function (gl, camera) {
                for (var i = 0; i < this._batches.length; i++) {
                    var batch = this._batches[i];

                    //if first is batch then they all are
                    if (batch[0].isBatchRenderer) {
                        this.renderBatch(gl, batch, camera);
                    } else {
                        this.renderEntity(gl, batch[0].entity, camera);
                    }
                }
            };

            GLRenderManager.prototype.renderBatch = function (gl, batch, camera) {
                this.setupGLState(gl, batch[0].entity);
                this._currentRenderer.clear(gl, { camMatrix: this.camMatrix });
                for (var i = 0; i < batch.length; i++) {
                    batch[i].entity.renderGL(gl, camera);
                }
                this._currentRenderer.draw(gl);
            };

            GLRenderManager.prototype.renderEntity = function (gl, entity, camera) {
                this.setupGLState(gl, entity);
                entity.renderGL(gl, camera);
            };

            GLRenderManager.prototype.setupGLState = function (gl, entity) {
                if (entity.atlas !== this._currentTextureAtlas)
                    this._switchTexture(gl, entity);
                if (entity.glRenderer !== this._currentRenderer)
                    this._switchRenderer(gl, entity);
            };

            /**
            * Switch renderer to the one needed by the entity that needs rendering
            * @method _switchRenderer
            * @param gl {WebGLRenderingContext}
            * @param entity {Entity}
            * @private
            */
            GLRenderManager.prototype._switchRenderer = function (gl, entity) {
                if (this._currentRenderer)
                    this._currentRenderer.disable(gl);
                this._currentRenderer = entity.glRenderer;
                this._currentRenderer.enable(gl, { camMatrix: this.camMatrix, stageResolution: this._stageResolution, textureAtlas: this._currentTextureAtlas });
            };

            /**
            * Switch texture to the one needed by the entity that needs rendering
            * @method _switchTexture
            * @param gl {WebGLRenderingContext}
            * @param entity {Entity}
            * @private
            */
            GLRenderManager.prototype._switchTexture = function (gl, entity) {
                this._currentTextureAtlas = entity.atlas;
                if (this._currentRenderer)
                    this._currentRenderer.updateTextureSize(gl, new Float32Array([this._currentTextureAtlas.glTextureWrapper.image.width, this._currentTextureAtlas.glTextureWrapper.image.height]));
                this._textureManager.useTexture(gl, entity.atlas.glTextureWrapper);
            };
            return GLRenderManager;
        })();
        Renderers.GLRenderManager = GLRenderManager;
    })(Kiwi.Renderers || (Kiwi.Renderers = {}));
    var Renderers = Kiwi.Renderers;
})(Kiwi || (Kiwi = {}));
/**
* GLSL ES Shaders are used for WebGL rendering.
* ShaderPair objects encapsulate GLSL ES vertex and fragment shader programs.
*   ShaderPairs contain the GLSL code, provide an interface to uniforms and attributes, and have the ability to link and compile the shaders.
* The ShaderManager keeps track of each ShaderPair, and controls which one is bound for use at any particular time.
*   Only the ShaderManager can create ShaderPairs. When a renderer (see note on renderes below) requests a ShaderPair the ShaderManager will either
*       1) Return a reference to an already instantiated ShaderPair, and set the GL state to use the shader program or
*       2) Return a reference to a new ShaderPair, which will be linked and compiled and bound for use.
*   All ShaderPairs must be housed as properties of the Kiwi.Shaders object.
*
* Kiwi.Renderer objects use a ShaderPair to draw.
*   They must request a ShaderPair from the ShaderManager.
*   Many renderers may use the same ShaderPair.
*   Some renderers may at different times use multiple ShaderPairs (only one is possible at any given time)
*
* @module Kiwi
* @submodule Shaders
* @main Shaders
*/
var Kiwi;
(function (Kiwi) {
    (function (Shaders) {
        /**
        * Manages all WebGL Shaders. Maintains a list of ShaderPairs
        *
        * Provides an interface for using a specific ShaderPair, adding new ShaderPairs, and requesting a reference to a ShaderPair instance.
        * Renderes use shaderPairs to draw. Multiple renderers may use the same compiled shader program.
        * This Manager ensures only one compiled instance of each program is created
        * @class ShaderManager
        * @extends IRenderer
        * @constructor
        * @return {GLRenderer}
        */
        var ShaderManager = (function () {
            function ShaderManager() {
                /**
                * An object containing a set of properties each of which references a ShaderPair.
                * @property _shaderPairs
                * @type Object
                * @private
                */
                this._shaderPairs = {};
            }
            Object.defineProperty(ShaderManager.prototype, "currentShader", {
                /**
                * The shader program that is currently set to be used useing gl.useProgram.
                * @property currentShader
                * @type Array
                * @private
                */
                get: function () {
                    return this._currentShader;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Sets up a default shaderPair.
            * @method init
            * @param {WebGLRenderingContext} gl
            * @param {String} defaultShaderID
            * @public
            */
            ShaderManager.prototype.init = function (gl, defaultShaderID) {
                this._currentShader = this.requestShader(gl, defaultShaderID);
            };

            /**
            * Provides a reference to a ShaderPair. If the requested ShaderPair exists as a property on the _shaderPairs object it will be returned if already loaded,
            * otherwise it will be loaded, then returned.
            * If the request is not on the list, the Kiwi.Shaders object will  be checked for a property name that matches shaderID and a new ShaderPair
            * will be instantiated, loaded, and set for use.
            
            * @method init
            * @param {WebGLRenderingContext} gl
            * @param {String} shaderID
            * @return {ShaderPair} a ShaderPair instance - null on fail
            * @public
            */
            ShaderManager.prototype.requestShader = function (gl, shaderID, use) {
                if (typeof use === "undefined") { use = true; }
                var shader;

                //in list already?
                if (shaderID in this._shaderPairs) {
                    shader = this._shaderPairs[shaderID];
                    if (!shader.loaded) {
                        this._loadShader(gl, shader);
                    }
                    if (use)
                        this._useShader(gl, shader);
                    return shader;
                } else {
                    //not in list, does it exist?
                    if (this.shaderExists) {
                        shader = this._addShader(gl, shaderID);
                        this._loadShader(gl, shader);
                        if (use)
                            this._useShader(gl, shader);
                        return shader;
                    } else {
                        console.log("Shader " + shaderID + " does not exist");
                    }
                }

                //unsuccessful request
                return null;
            };

            /**
            * Tests to see if a ShaderPair property named ShaderID exists on Kiwi.Shaders. Can be used to test for the availability of specific shaders (for fallback)
            * @method shaderExists
            * @param {WebGLRenderingContext} gl
            * @param {String} shaderID
            * @return {Boolean} success
            * @public
            */
            ShaderManager.prototype.shaderExists = function (gl, shaderID) {
                return shaderID in Kiwi.Shaders;
            };

            /**
            * Creates a new instance of a ShaderPair and adds a reference to the _shaderPairs object
            * @method _addShader
            * @param {WebGLRenderingContext} gl
            * @param {String} shaderID
            * @return {ShaderPair}
            * @private
            */
            ShaderManager.prototype._addShader = function (gl, shaderID) {
                this._shaderPairs[shaderID] = new Kiwi.Shaders[shaderID]();
                return this._shaderPairs[shaderID];
            };

            /**
            * Tells a ShaderPair to load (compile and link)
            * @method _loadShader
            * @param {WebGLRenderingContext} gl
            * @param {ShaderPair} shader
            * @private
            */
            ShaderManager.prototype._loadShader = function (gl, shader) {
                shader.init(gl);
            };

            /**
            * Changes gl state so that the shaderProgram contined in a ShaderPir is bound for use
            * @method _useShader
            * @param {WebGLRenderingContext} gl
            * @param {ShaderPair} shader
            * @private
            */
            ShaderManager.prototype._useShader = function (gl, shader) {
                if (shader !== this._currentShader) {
                    this._currentShader = shader;
                }
                gl.useProgram(shader.shaderProgram);
            };
            return ShaderManager;
        })();
        Shaders.ShaderManager = ShaderManager;
    })(Kiwi.Shaders || (Kiwi.Shaders = {}));
    var Shaders = Kiwi.Shaders;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Renderers
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Renderers) {
        /**
        *
        * @class GLTexture
        * @constructor
        * @param gl {WebGLRenderingContext}
        * @param [_image] {HTMLImageElement}
        * @return {GLTexture}
        */
        var GLTextureWrapper = (function () {
            function GLTextureWrapper(gl, atlas, upload) {
                if (typeof upload === "undefined") { upload = false; }
                this._created = false;
                this._uploaded = false;
                this.textureAtlas = atlas;
                this.image = atlas.image;
                this._numBytes = this.image.width * this.image.height * 4;
                this.createTexture(gl);
                if (upload)
                    this.uploadTexture(gl);
            }
            Object.defineProperty(GLTextureWrapper.prototype, "numBytes", {
                get: function () {
                    return this._numBytes;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(GLTextureWrapper.prototype, "created", {
                get: function () {
                    return this._created;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(GLTextureWrapper.prototype, "uploaded", {
                get: function () {
                    return this._uploaded;
                },
                enumerable: true,
                configurable: true
            });

            //force : if true then other textures will be removed until there is room.
            GLTextureWrapper.prototype.createTexture = function (gl) {
                this.texture = gl.createTexture();
                this._created = true;
                return true;
            };

            GLTextureWrapper.prototype.uploadTexture = function (gl) {
                var success = false;
                if (!this.created) {
                    this.createTexture(gl);
                }

                if (this.uploaded) {
                    console.log("...not uploading:the image is already uploaded");
                } else {
                    gl.bindTexture(gl.TEXTURE_2D, this.texture);
                    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.bindTexture(gl.TEXTURE_2D, null);

                    //check gl error here
                    this._uploaded = true;
                    success = true;
                }

                return success;
            };

            GLTextureWrapper.prototype.refreshTexture = function (gl) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
            };

            GLTextureWrapper.prototype.deleteTexture = function (gl) {
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.deleteTexture(this.texture);
                this._uploaded = false;
                this._created = false;
                return true;
            };
            return GLTextureWrapper;
        })();
        Renderers.GLTextureWrapper = GLTextureWrapper;
    })(Kiwi.Renderers || (Kiwi.Renderers = {}));
    var Renderers = Kiwi.Renderers;
})(Kiwi || (Kiwi = {}));
/**
*
*
* @module Kiwi
* @submodule Renderers
* @main Renderers
*/
var Kiwi;
(function (Kiwi) {
    (function (Renderers) {
        /**
        * Manages GL Texture objects, including creation, uploading, destruction and memory management
        * @class GLTextureManager
        * @constructor
        * @return {GLTextureManager}
        */
        var GLTextureManager = (function () {
            function GLTextureManager() {
                /**
                * The number of textures uploads in the last frame
                * @property numTextureWrites
                * @type number
                * @public
                */
                this.numTextureWrites = 0;
                this._numTexturesUsed = 0;
                this._usedTextureMem = 0;
                this.maxTextureMem = GLTextureManager.DEFAULT_MAX_TEX_MEM_MB * 1024 * 1024;
                this._textureWrapperCache = new Array();
            }
            Object.defineProperty(GLTextureManager.prototype, "usedTextureMem", {
                get: function () {
                    return this._usedTextureMem;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(GLTextureManager.prototype, "numTexturesUsed", {
                get: function () {
                    return this._numTexturesUsed;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Adds a texture wrapper to the cache
            * @method _addTextureToCache
            * @param glTexture {GLTextureWrapper}
            * @private
            */
            GLTextureManager.prototype._addTextureToCache = function (glTexture) {
                this._textureWrapperCache.push(glTexture);
            };

            /**
            * Deletes a texture from memory and removes the wrapper from the cache
            * @method _deleteTexture
            * @param gl {WebGLRenderingContext}
            * @param idx {number}
            * @private
            */
            GLTextureManager.prototype._deleteTexture = function (gl, idx) {
                this._textureWrapperCache[idx].deleteTexture(gl);
                this._usedTextureMem -= this._textureWrapperCache[idx].numBytes;
                this._numTexturesUsed--;
            };

            /**
            * Uploads a texture to video memory
            * @method _uploadTexture
            * @param gl {WebGLRenderingContext}
            * @param glTextureWrapper {GLTextureWrapper}
            * @return boolean
            * @private
            */
            GLTextureManager.prototype._uploadTexture = function (gl, glTextureWrapper) {
                //only upload it if it fits
                if (glTextureWrapper.numBytes + this._usedTextureMem <= this.maxTextureMem) {
                    glTextureWrapper.uploadTexture(gl);
                    this._usedTextureMem += glTextureWrapper.numBytes;
                    this._numTexturesUsed++;

                    return true;
                }
                return false;
            };

            /**
            * Uploads a texture library to video memory
            * @method uploadTextureLibrary
            * @param gl {WebGLRenderingContext}
            * @param textureLibrary {Kiwi.Textures.TextureLibrary}
            * @public
            */
            GLTextureManager.prototype.uploadTextureLibrary = function (gl, textureLibrary) {
                this._textureWrapperCache = new Array();
                for (var tex in textureLibrary.textures) {
                    this.uploadTexture(gl, textureLibrary.textures[tex]);
                }
            };

            GLTextureManager.prototype.uploadTexture = function (gl, textureAtlas) {
                //create a glTexture
                var glTextureWrapper = new Kiwi.Renderers.GLTextureWrapper(gl, textureAtlas);

                //store a refence to it
                this._addTextureToCache(glTextureWrapper);

                //create reference on atlas to avoid lookups when switching
                textureAtlas.glTextureWrapper = glTextureWrapper;

                //only upload it if it fits
                if (!this._uploadTexture(gl, glTextureWrapper)) {
                    console.log("...skipped uploading texture due to allocated texture memory exceeded");
                }
            };

            /**
            * Removes all textures from video memory and clears the wrapper cache
            * @method clearTextures
            * @param gl {WebGLRenderingContext}
            * @public
            */
            GLTextureManager.prototype.clearTextures = function (gl) {
                for (var i = 0; i < this._textureWrapperCache.length; i++) {
                    //delete it from g mem
                    this._textureWrapperCache[i].deleteTexture(gl);

                    //kill the reference on the atlas
                    this._textureWrapperCache[i].textureAtlas.glTextureWrapper = null;
                }
                this._textureWrapperCache = new Array();
            };

            /**
            * Binds the texture ready for use, uploads it if it isn't already
            * @method useTexture
            * @param gl {WebGLRenderingContext}
            * @param glTextureWrapper {GLTextureWrappery}
            * @param textureSizeUniform {number}
            * @return boolean
            * @public
            */
            GLTextureManager.prototype.useTexture = function (gl, glTextureWrapper) {
                if (!glTextureWrapper.created || !glTextureWrapper.uploaded) {
                    if (!this._uploadTexture(gl, glTextureWrapper)) {
                        this._freeSpace(gl, glTextureWrapper.numBytes);
                        this._uploadTexture(gl, glTextureWrapper);
                    }
                    this.numTextureWrites++;
                }

                //use texture
                if (glTextureWrapper.created && glTextureWrapper.uploaded) {
                    gl.bindTexture(gl.TEXTURE_2D, glTextureWrapper.texture);

                    //gl.uniform2fv(textureSizeUniform, new Float32Array([glTextureWrapper.image.width, glTextureWrapper.image.height]));
                    return true;
                }

                return false;
            };

            /**
            * Attemps to free space for to uplaod a texture.
            * 1: Try and find texture that is same size to remove
            * 2: Find next smallest to remove (not yet implemented)
            * 3: Sequentially remove until there is room (not yet implemented)
            * @method _freeSpace
            * @param gl {WebGLRenderingContext}
            * @param numBytesToRemove {number}
            * @return boolean
            * @public
            */
            GLTextureManager.prototype._freeSpace = function (gl, numBytesToRemove) {
                // console.log("Attempting to free texture space");
                var nextSmallest = 99999999999;
                var nextSmalletIndex = -1;
                for (var i = 0; i < this._textureWrapperCache.length; i++) {
                    var numTextureBytes = this._textureWrapperCache[i].numBytes;
                    if (numTextureBytes === numBytesToRemove && this._textureWrapperCache[i].uploaded) {
                        //  console.log("..found one same size");
                        this._deleteTexture(gl, i);
                        return true;
                    } else if (numTextureBytes > numBytesToRemove && numTextureBytes < nextSmallest) {
                        nextSmallest = numTextureBytes;
                        nextSmalletIndex = i;
                    }
                }

                /*
                //have we found a larger one to remove
                if (nextSmalletIndex !== -1) {
                this.removeTextureAt(gl,nextSmalletIndex);
                return true;
                } else {
                //remove sequentially till there is enough space - is not optimal for space
                var numBytesRemoved: number = 0;
                var i = 0;
                
                do {
                this.removeTextureAt(gl,i);
                numBytesRemoved += this.textureWrapperCache[i].numBytes;
                i++
                } while (numBytesRemoved < numBytesToRemove);
                return true;
                
                
                }
                */
                return true;
            };
            GLTextureManager.DEFAULT_MAX_TEX_MEM_MB = 1024;
            return GLTextureManager;
        })();
        Renderers.GLTextureManager = GLTextureManager;
    })(Kiwi.Renderers || (Kiwi.Renderers = {}));
    var Renderers = Kiwi.Renderers;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Renderers
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Renderers) {
        /**
        *
        * @class GLArrayBuffer
        * @constructor
        * @namespace Kiwi.Renderers
        * @param gl {WebGLRenderingContext}
        * @param [_itemSize] {number}
        * @param [items] {number[]}
        * @param [init=true] {boolean}
        * @return {GLArrayBuffer}
        */
        var GLArrayBuffer = (function () {
            function GLArrayBuffer(gl, _itemSize, items, upload) {
                if (typeof upload === "undefined") { upload = true; }
                this._created = false;
                this._uploaded = false;
                this.items = items || GLArrayBuffer.squareVertices;
                this.itemSize = _itemSize || 2;
                this.numItems = this.items.length / this.itemSize;
                this.createBuffer(gl);
                if (upload) {
                    this.uploadBuffer(gl, this.items);
                }
            }
            Object.defineProperty(GLArrayBuffer.prototype, "created", {
                get: function () {
                    return this._created;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(GLArrayBuffer.prototype, "uploaded", {
                get: function () {
                    return this._uploaded;
                },
                enumerable: true,
                configurable: true
            });

            /**
            *
            * @method clear
            * @public
            */
            GLArrayBuffer.prototype.clear = function () {
                this.items = new Array();
            };

            /**
            *
            * @method init
            * @param gl {WebGLRenderingCotext}
            * @return {WebGLBuffer}
            * @public
            */
            GLArrayBuffer.prototype.createBuffer = function (gl) {
                this.buffer = gl.createBuffer();
                this._created = true;
                return true;
            };

            GLArrayBuffer.prototype.uploadBuffer = function (gl, items) {
                this.items = items;
                this.numItems = this.items.length / this.itemSize;
                var f32 = new Float32Array(this.items);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                gl.bufferData(gl.ARRAY_BUFFER, f32, gl.DYNAMIC_DRAW);
                this._uploaded = true;
                return true;
            };

            GLArrayBuffer.prototype.deleteBuffer = function (gl) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                gl.deleteBuffer(this.buffer);
                this.uploaded = false;
                this.created = false;
                return true;
            };

            GLArrayBuffer.squareVertices = [
                0, 0,
                100, 0,
                100, 100,
                0, 100
            ];

            GLArrayBuffer.squareUVs = [
                0, 0,
                .1, 0,
                .1, .1,
                0, .1
            ];

            GLArrayBuffer.squareCols = [
                1, 1, 1, 1
            ];
            return GLArrayBuffer;
        })();
        Renderers.GLArrayBuffer = GLArrayBuffer;
    })(Kiwi.Renderers || (Kiwi.Renderers = {}));
    var Renderers = Kiwi.Renderers;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Renderers
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Renderers) {
        /**
        *
        * @class GLElementArrayBuffer
        * @constructor
        * @namespace Kiwi.Renderers
        * @param gl {WebGLRenderingContent}
        * @param [_itemSize] {number}
        * @param [_indices] {number[]}
        * @param [init=true] {boolean}
        * @return {GLElementArrayBuffer}
        */
        var GLElementArrayBuffer = (function () {
            function GLElementArrayBuffer(gl, _itemSize, _indices, init) {
                if (typeof init === "undefined") { init = true; }
                this.indices = _indices || GLElementArrayBuffer.square;
                this.itemSize = _itemSize || 1;
                this.numItems = this.indices.length / this.itemSize;
                if (init) {
                    this.buffer = this.init(gl);
                }
            }
            /**
            *
            * @method clear
            * @public
            */
            GLElementArrayBuffer.prototype.clear = function () {
                this.indices = new Array();
            };

            /**
            *
            * @method init
            * @param gl {WebGLRenderingContext}
            * @return {WebGLBuffer}
            * @public
            */
            GLElementArrayBuffer.prototype.init = function (gl) {
                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), gl.STATIC_DRAW);

                return buffer;
            };

            /**
            *
            * @method refresh
            * @param gl {WebGLRenderingContext}
            * @param indices {number[]}
            * @return {WebGLBuffer}
            * @public
            */
            GLElementArrayBuffer.prototype.refresh = function (gl, indices) {
                this.numItems = this.indices.length / this.itemSize;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), gl.STATIC_DRAW);

                return this.buffer;
            };

            GLElementArrayBuffer.square = [
                0, 1, 2,
                0, 2, 3
            ];
            return GLElementArrayBuffer;
        })();
        Renderers.GLElementArrayBuffer = GLElementArrayBuffer;
    })(Kiwi.Renderers || (Kiwi.Renderers = {}));
    var Renderers = Kiwi.Renderers;
})(Kiwi || (Kiwi = {}));
var Kiwi;
(function (Kiwi) {
    (function (Renderers) {
        var Renderer = (function () {
            function Renderer(gl, shaderManager, isBatchRenderer) {
                if (typeof isBatchRenderer === "undefined") { isBatchRenderer = false; }
                this.loaded = false;
                this._isBatchRenderer = false;
                this.shaderManager = shaderManager;
                this._isBatchRenderer = isBatchRenderer;
                this.loaded = true;
            }
            /**
            
            * The stage resolution in pixels
            * @property _stageResolution
            * @type Float32Array
            * @public
            */
            //public init(gl: WebGLRenderingContext, params: any = null) {
            //    this.loaded = true;
            //}
            Renderer.prototype.enable = function (gl, params) {
                if (typeof params === "undefined") { params = null; }
            };

            Renderer.prototype.disable = function (gl) {
            };

            Renderer.prototype.clear = function (gl, params) {
            };
            Renderer.prototype.draw = function (gl) {
            };

            Renderer.prototype.updateStageResolution = function (gl, res) {
            };
            Renderer.prototype.updateTextureSize = function (gl, size) {
            };

            Object.defineProperty(Renderer.prototype, "isBatchRenderer", {
                get: function () {
                    return this._isBatchRenderer;
                },
                enumerable: true,
                configurable: true
            });
            Renderer.RENDERER_ID = "Renderer";
            return Renderer;
        })();
        Renderers.Renderer = Renderer;
    })(Kiwi.Renderers || (Kiwi.Renderers = {}));
    var Renderers = Kiwi.Renderers;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Renderers
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Renderers) {
        var TextureAtlasRenderer = (function (_super) {
            __extends(TextureAtlasRenderer, _super);
            function TextureAtlasRenderer(gl, shaderManager, params) {
                if (typeof params === "undefined") { params = null; }
                _super.call(this, gl, shaderManager, true);
                this._maxItems = 1000;

                this._vertexBuffer = new Kiwi.Renderers.GLArrayBuffer(gl, 5);

                //6 verts per quad
                this._indexBuffer = new Kiwi.Renderers.GLElementArrayBuffer(gl, 1, this._generateIndices(this._maxItems * 6));

                this.shaderPair = this.shaderManager.requestShader(gl, "TextureAtlasShader");
            }
            TextureAtlasRenderer.prototype.enable = function (gl, params) {
                if (typeof params === "undefined") { params = null; }
                this.shaderPair = this.shaderManager.requestShader(gl, "TextureAtlasShader");

                //Texture
                gl.uniform1i(this.shaderPair.uniforms.uSampler.location, 0);

                //Other uniforms
                gl.uniform2fv(this.shaderPair.uniforms.uResolution.location, params.stageResolution);
                gl.uniformMatrix3fv(this.shaderPair.uniforms.uCamMatrix.location, false, params.camMatrix);

                this.updateTextureSize(gl, new Float32Array([params.textureAtlas.glTextureWrapper.image.width, params.textureAtlas.glTextureWrapper.image.height]));
            };

            TextureAtlasRenderer.prototype.disable = function (gl) {
                gl.disableVertexAttribArray(this.shaderPair.attributes.aXYUV);
                gl.disableVertexAttribArray(this.shaderPair.attributes.aAlpha);
            };

            TextureAtlasRenderer.prototype.clear = function (gl, params) {
                this._vertexBuffer.clear();
                gl.uniformMatrix3fv(this.shaderPair.uniforms.uCamMatrix.location, false, params.camMatrix);
            };

            TextureAtlasRenderer.prototype.draw = function (gl) {
                this._vertexBuffer.uploadBuffer(gl, this._vertexBuffer.items);

                gl.enableVertexAttribArray(this.shaderPair.attributes.aXYUV);
                gl.vertexAttribPointer(this.shaderPair.attributes.aXYUV, 4, gl.FLOAT, false, 20, 0);

                gl.enableVertexAttribArray(this.shaderPair.attributes.aAlpha);
                gl.vertexAttribPointer(this.shaderPair.attributes.aAlpha, 1, gl.FLOAT, false, 20, 16);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer.buffer);
                gl.drawElements(gl.TRIANGLES, (this._vertexBuffer.items.length / 20) * 6, gl.UNSIGNED_SHORT, 0);
            };

            /**
            * Create prebaked indices for drawing quads
            * @method _generateIndices
            * @param numQuads {number}
            * @return number[]
            * @private
            */
            TextureAtlasRenderer.prototype._generateIndices = function (numQuads) {
                var quads = new Array();
                for (var i = 0; i < numQuads; i++) {
                    quads.push(i * 4 + 0, i * 4 + 1, i * 4 + 2, i * 4 + 0, i * 4 + 2, i * 4 + 3);
                }
                return quads;
            };

            TextureAtlasRenderer.prototype.updateStageResolution = function (gl, res) {
                gl.uniform2fv(this.shaderPair.uniforms.uResolution.location, res);
            };

            TextureAtlasRenderer.prototype.updateTextureSize = function (gl, size) {
                gl.uniform2fv(this.shaderPair.uniforms.uTextureSize.location, size);
            };

            /**
            * Collates all xy and uv coordinates into a buffer ready for upload to viceo memory
            * @method _collateVertexAttributeArrays
            * @param gl {WebGLRenderingContext}
            * @param entity {Entity}
            * @param camera {Camera}
            * @public
            */
            TextureAtlasRenderer.prototype.addToBatch = function (gl, entity, camera) {
                var t = entity.transform;
                var m = t.getConcatenatedMatrix();

                var cell = entity.atlas.cells[entity.cellIndex];

                var pt1 = new Kiwi.Geom.Point(0 - t.rotPointX, 0 - t.rotPointY);
                var pt2 = new Kiwi.Geom.Point(cell.w - t.rotPointX, 0 - t.rotPointY);
                var pt3 = new Kiwi.Geom.Point(cell.w - t.rotPointX, cell.h - t.rotPointY);
                var pt4 = new Kiwi.Geom.Point(0 - t.rotPointX, cell.h - t.rotPointY);

                pt1 = m.transformPoint(pt1);
                pt2 = m.transformPoint(pt2);
                pt3 = m.transformPoint(pt3);
                pt4 = m.transformPoint(pt4);

                this._vertexBuffer.items.push(pt1.x + t.rotPointX, pt1.y + t.rotPointY, cell.x, cell.y, entity.alpha, pt2.x + t.rotPointX, pt2.y + t.rotPointY, cell.x + cell.w, cell.y, entity.alpha, pt3.x + t.rotPointX, pt3.y + t.rotPointY, cell.x + cell.w, cell.y + cell.h, entity.alpha, pt4.x + t.rotPointX, pt4.y + t.rotPointY, cell.x, cell.y + cell.h, entity.alpha);
            };

            TextureAtlasRenderer.prototype.concatBatch = function (vertexItems) {
                this._vertexBuffer.items = this._vertexBuffer.items.concat(vertexItems);
            };
            TextureAtlasRenderer.RENDERER_ID = "TextureAtlasRenderer";
            return TextureAtlasRenderer;
        })(Kiwi.Renderers.Renderer);
        Renderers.TextureAtlasRenderer = TextureAtlasRenderer;
    })(Kiwi.Renderers || (Kiwi.Renderers = {}));
    var Renderers = Kiwi.Renderers;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Renderers
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Shaders) {
        /**
        *
        * @class GLShaders
        * @constructor
        * @param gl {WebGLRenderingContext}
        * @return {GLShaders}
        */
        var ShaderPair = (function () {
            function ShaderPair() {
                this.loaded = false;
            }
            ShaderPair.prototype.init = function (gl) {
                this.vertShader = this.compile(gl, this.vertSource.join("\n"), gl.VERTEX_SHADER);
                this.fragShader = this.compile(gl, this.fragSource.join("\n"), gl.FRAGMENT_SHADER);
                this.shaderProgram = this.attach(gl, this.vertShader, this.fragShader);
                this.loaded = true;
            };

            /**
            *
            * @method attach
            * @param gl {WebGLRenderingContext}
            * @param vertShader {WebGLShader}
            * @param fragShader {WebGLShader}
            * @return {WebGLProgram}
            * @public
            */
            ShaderPair.prototype.attach = function (gl, vertShader, fragShader) {
                var shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, fragShader);
                gl.attachShader(shaderProgram, vertShader);
                gl.linkProgram(shaderProgram);
                return shaderProgram;
            };

            /**
            *
            * @method compile
            * @param gl {WebGLRenderingContext}
            * @param src {string}
            * @param shaderType {number}
            * @return {WebGLShader}
            * @public
            */
            ShaderPair.prototype.compile = function (gl, src, shaderType) {
                var shader = gl.createShader(shaderType);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    return null;
                }
                return shader;
            };

            ShaderPair.prototype.setParam = function (uniformName, value) {
                this.uniforms[uniformName].value = value;
                this.uniforms[uniformName].dirty = true;
            };

            ShaderPair.prototype.applyUniforms = function (gl) {
                for (var u in this.uniforms) {
                    this.applyUniform(gl, u);
                }
            };

            ShaderPair.prototype.applyUniform = function (gl, name) {
                var u = this.uniforms[name];
                if (this.uniforms[name].dirty) {
                    console.log(name);
                    gl["uniform" + u.type](u.location, u.value);
                    this.uniforms[name].dirty = false;
                }
            };

            ShaderPair.prototype.initUniforms = function (gl) {
                for (var uniformName in this.uniforms) {
                    var uniform = this.uniforms[uniformName];
                    uniform.location = gl.getUniformLocation(this.shaderProgram, uniformName);
                    uniform.dirty = true;
                    uniform.value = null;
                }
            };
            ShaderPair.RENDERER_ID = "ShaderPair";
            return ShaderPair;
        })();
        Shaders.ShaderPair = ShaderPair;
    })(Kiwi.Shaders || (Kiwi.Shaders = {}));
    var Shaders = Kiwi.Shaders;
})(Kiwi || (Kiwi = {}));
/**
*
* @class GLShaders
* @constructor
* @param gl {WebGLRenderingContext}
* @return {GLShaders}
*/
var Kiwi;
(function (Kiwi) {
    (function (Shaders) {
        var TextureAtlasShader = (function (_super) {
            __extends(TextureAtlasShader, _super);
            function TextureAtlasShader() {
                _super.call(this);
                this.attributes = {
                    aXYUV: null,
                    aAlpha: null
                };
                this.uniforms = {
                    uCamMatrix: {
                        type: "mat3"
                    },
                    uResolution: {
                        type: "2fv"
                    },
                    uTextureSize: {
                        type: "2fv"
                    },
                    uSampler: {
                        type: "1i"
                    }
                };
                /**
                *
                * @property texture2DFrag
                * @type Array
                * @public
                */
                this.fragSource = [
                    "precision mediump float;",
                    "varying vec2 vTextureCoord;",
                    "varying float vAlpha;",
                    "uniform sampler2D uSampler;",
                    "void main(void) {",
                    "gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));",
                    "gl_FragColor.a *= vAlpha;",
                    "}"
                ];
                /**
                *
                * @property texture2DVert
                * @type Array
                * @public
                */
                this.vertSource = [
                    "attribute vec4 aXYUV;",
                    "attribute float aAlpha;",
                    "uniform mat3 uCamMatrix;",
                    "uniform vec2 uResolution;",
                    "uniform vec2 uTextureSize;",
                    "varying vec2 vTextureCoord;",
                    "varying float vAlpha;",
                    "void main(void) {",
                    "   vec2 pos = (uCamMatrix * vec3(aXYUV.xy,1)).xy; ",
                    "   gl_Position = vec4((pos / uResolution * 2.0 - 1.0) * vec2(1, -1), 0, 1);",
                    "   vTextureCoord = aXYUV.zw / uTextureSize;",
                    "   vAlpha = aAlpha;",
                    "}"
                ];
            }
            TextureAtlasShader.prototype.init = function (gl) {
                _super.prototype.init.call(this, gl);

                //attributes
                this.attributes.aXYUV = gl.getAttribLocation(this.shaderProgram, "aXYUV");
                this.attributes.aAlpha = gl.getAttribLocation(this.shaderProgram, "aAlpha");

                this.initUniforms(gl);
            };
            return TextureAtlasShader;
        })(Kiwi.Shaders.ShaderPair);
        Shaders.TextureAtlasShader = TextureAtlasShader;
    })(Kiwi.Shaders || (Kiwi.Shaders = {}));
    var Shaders = Kiwi.Shaders;
})(Kiwi || (Kiwi = {}));
/**
* Is the namespace in which all code that is used to create/provide an animation of various sorts are stored. These could range from animations that change the cell of a SpriteSheet that is displayed every few seconds (Animation/Sequence), to animations that change a numeric value on a object over a period time (Tweens).
*
* @module Kiwi
* @submodule Animations
* @main Animations
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        /**
        * An Animation contains information about a single animation that is held on a AnimationManager.
        * The information that is held is unique to this individual animation and will initially be the same as a Sequence,
        * but if you do ever modify the information held in this Animation the corresponding Sequence will not be updated.
        *
        * @class Animation
        * @namespace Kiwi.Animations
        * @constructor
        * @param name {string} The name of this anim.
        * @param sequences {Sequences} The sequence that this anim will be using to animate.
        * @param clock {Clock} A game clock that this anim will be using to keep record of the time between frames.
        * @param parent {AnimationManager} The animation manager that this animation belongs to.
        * @return {Anim}
        *
        */
        var Animation = (function () {
            function Animation(name, sequence, clock, parent) {
                /**
                * The current frame index that the animation is currently upto.
                * Note: A frame index is the index of a particular cell in the Sequence.
                * @property _frameIndex
                * @type number
                * @private
                */
                this._frameIndex = 0;
                /**
                * The starting time of the animation from when it was played. Internal use only.
                * @property _startTime
                * @type number
                * @private
                */
                this._startTime = null;
                /**
                * Indicates whether the animation is playing in reverse or not.
                * @property _reverse
                * @type boolean
                * @private
                */
                this._reverse = false;
                /**
                * If the animation is currently playing or not.
                * @property _isPlaying
                * @type boolean
                * @default false
                * @private
                */
                this._isPlaying = false;
                /**
                * A Kiwi.Signal that dispatches an event when the animation has stopped playing.
                * @property _onStop
                * @type Signal
                * @public
                */
                this._onStop = null;
                /**
                * A Kiwi.Signal that dispatches an event when the animation has started playing.
                * @property _onPlay
                * @type Kiwi.Signal
                * @public
                */
                this._onPlay = null;
                /**
                * A Kiwi.Signal that dispatches an event when the animation has updated/changed frameIndexs.
                * @property _onUpdate
                * @type Kiwi.Signal
                * @public
                */
                this._onUpdate = null;
                /**
                * A Kiwi.Signal that dispatches an event when the animation has come to the end of the animation and is going to play again.
                * @property _onLoop
                * @type Kiwi.Signal
                * @public
                */
                this._onLoop = null;
                this.name = name;
                this._sequence = sequence;
                this._speed = sequence.speed;
                this._loop = sequence.loop;
                this._clock = clock;
                this._parent = parent;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Animation.prototype.objType = function () {
                return 'Animation';
            };

            Object.defineProperty(Animation.prototype, "loop", {
                /**
                * If once the animation reaches the end, it should start again from the first cell in the sequence or not.
                * @property loop
                * @type boolean
                * @public
                */
                get: function () {
                    return this._loop;
                },
                set: function (value) {
                    this._loop = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Animation.prototype, "frameIndex", {
                /**
                * The current frame index that the animation is currently upto.
                * Note: A frame index is the index of a particular cell in the Sequence.
                * @property frameIndex
                * @type number
                * @public
                */
                get: function () {
                    return this._frameIndex;
                },
                set: function (val) {
                    if (this._validateFrame(val)) {
                        this._frameIndex = val;
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Animation.prototype, "currentCell", {
                /**
                * Returns the current cell that the animation is up to. This is READ ONLY.
                * @property currentCell
                * @type number
                * @public
                */
                get: function () {
                    return this._sequence.cells[this.frameIndex];
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Animation.prototype, "speed", {
                /**
                * How long the each cell should stay on screen for. In seconds.
                * @property speed
                * @type number
                * @public
                */
                get: function () {
                    return this._speed;
                },
                set: function (value) {
                    this._speed = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Animation.prototype, "reverse", {
                get: function () {
                    return this._reverse;
                },
                /**
                * Whether the animation is to be played in reverse.
                * @property reverse
                * @type boolean
                * @public
                */
                set: function (value) {
                    this._reverse = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Animation.prototype, "isPlaying", {
                /**
                * If the animation is currently playing or not.
                * @property isPlaying
                * @type boolean
                * @private
                */
                get: function () {
                    return this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Animation.prototype, "onStop", {
                get: function () {
                    if (this._onStop == null)
                        this._onStop = new Kiwi.Signal;
                    return this._onStop;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Animation.prototype, "onPlay", {
                get: function () {
                    if (this._onPlay == null)
                        this._onPlay = new Kiwi.Signal;
                    return this._onPlay;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Animation.prototype, "onUpdate", {
                get: function () {
                    if (this._onUpdate == null)
                        this._onUpdate = new Kiwi.Signal;
                    return this._onUpdate;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Animation.prototype, "onLoop", {
                get: function () {
                    if (this._onLoop == null)
                        this._onLoop = new Kiwi.Signal;
                    return this._onLoop;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * An Internal method used to start the animation.
            * @method _start
            * @param [index=null] {number} The index of the frame in the sequence that is to play. If left as null if just starts from where it left off.
            * @private
            */
            Animation.prototype._start = function (index) {
                if (typeof index === "undefined") { index = null; }
                if (index !== null) {
                    this.frameIndex = index;
                }

                this._isPlaying = true;
                this._startTime = this._clock.elapsed();
                this._tick = this._startTime + this._speed;
                if (this._onPlay !== null)
                    this._onPlay.dispatch();
            };

            /**
            * Plays the animation.
            * @method play
            * @public
            */
            Animation.prototype.play = function () {
                //if the animation is at the last frame then start it at the beginning
                if (this._frameIndex === this.length - 1)
                    this.frameIndex = 0;

                this.playAt(this._frameIndex);
            };

            /**
            * Plays the animation at a particular frame
            * @method playAt
            * @param index {number} The index of the cell in the sequence that the animation is to start at.
            * @public
            */
            Animation.prototype.playAt = function (index) {
                this._start(index);
            };

            /**
            * Pauses the current animation.
            * @method pause
            * @public
            */
            Animation.prototype.pause = function () {
                this.stop();
            };

            /**
            * Resumes the current animation after stopping.
            * @method resume
            * @public
            */
            Animation.prototype.resume = function () {
                if (this._startTime !== null) {
                    this._isPlaying = true;
                }
            };

            /**
            * Stops the current animation from playing.
            * @method stop
            * @public
            */
            Animation.prototype.stop = function () {
                if (this._isPlaying) {
                    this._isPlaying = false;
                    if (this._onStop !== null)
                        this._onStop.dispatch();
                }
            };

            /**
            * Makes the animation go to the next frame. If the animation is at the end it goes back to the start.
            * @method nextFrame
            * @public
            */
            Animation.prototype.nextFrame = function () {
                this._frameIndex++;
                if (this._frameIndex >= this.length)
                    this.frameIndex = 0;
            };

            /**
            * Makes the animation go to the previous frame. If the animation is at the first frame it goes to the end.
            * @method prevFrame
            * @public
            */
            Animation.prototype.prevFrame = function () {
                this._frameIndex--;
                if (this._frameIndex < 0)
                    this.frameIndex = this.length - 1;
            };

            /**
            * The update loop. Returns a boolean indicating whether the animation has gone to a new frame or not.
            * @method update
            * @public
            */
            Animation.prototype.update = function () {
                if (this._isPlaying) {
                    if (this._clock.elapsed() >= this._tick) {
                        this._tick = this._clock.elapsed() + this._speed;

                        //Would it be a valid frame?
                        if (this._validateFrame(this._frameIndex + ((this._reverse == true) ? -1 : 1))) {
                            this._frameIndex += (this._reverse == true) ? -1 : 1;
                            this._parent.updateCellIndex();
                            if (this._onUpdate !== null)
                                this._onUpdate.dispatch();
                        } else {
                            //Is it looping?
                            if (this._loop) {
                                if (this._reverse) {
                                    this._frameIndex = this.length - 1;
                                } else {
                                    this._frameIndex = 0;
                                }
                                this._parent.updateCellIndex();
                                if (this._onLoop !== null)
                                    this._onLoop.dispatch();
                                //Not Looping, stop animation.
                            } else {
                                //Execute the stop on the parent to allow the isPlaying boolean to remain consistent
                                this._parent.stop();
                            }
                        }
                    }
                }
            };

            /**
            * An internal method used to check to see if frame passed is valid or not
            * @method _validateFrame
            * @param frame {number} The index of the frame that is to be validated.
            * @private
            */
            Animation.prototype._validateFrame = function (frame) {
                return (frame < this.length && frame >= 0);
            };

            Object.defineProperty(Animation.prototype, "length", {
                /**
                * Returns the number of frames that in the animation. Thus the animations 'length'. Note this is READ ONLY.
                * @property length
                * @type number
                * @public
                */
                get: function () {
                    return this._sequence.cells.length;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Destroys the anim and all of the properties that exist on it.
            * @method destroy
            * @public
            */
            Animation.prototype.destroy = function () {
                this._isPlaying = false;
                delete this._clock;
                delete this._sequence;
                delete this._parent;
                if (this._onLoop)
                    this._onLoop.dispose();
                if (this._onStop)
                    this._onStop.dispose();
                if (this._onPlay)
                    this._onPlay.dispose();
                if (this._onUpdate)
                    this._onUpdate.dispose();
                delete this._onLoop;
                delete this._onStop;
                delete this._onPlay;
                delete this._onUpdate;
                delete this.frameIndex;
                delete this.loop;
                delete this._reverse;
                delete this._tick;
            };
            return Animation;
        })();
        Animations.Animation = Animation;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Animations
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Animations) {
        /**
        * A Sequence is a series of cells that are held on a SpriteSheet/TextureAtlas.
        * Sequences are generally used with the AnimationManager/Animation sections as a way to initially create Animations on GameObjects that use the same TextureAtlas.
        *
        * @class Sequence
        * @namespace Kiwi.Animations
        * @constructor
        * @param name {String} The name of this sequence. This is not unique.
        * @param cells {Number[]} The cells that are in this animation.
        * @param [speed=0.1] {Number} The time an animation should spend on each frame.
        * @param [loop=true] {boolean} If the sequence should play again if it was animating and the animation reaches the last frame.
        * @return {Sequence}
        *
        */
        var Sequence = (function () {
            function Sequence(name, cells, speed, loop) {
                if (typeof speed === "undefined") { speed = 0.1; }
                if (typeof loop === "undefined") { loop = true; }
                this.name = name;
                this.cells = cells;
                this.speed = speed;
                this.loop = loop;
            }
            return Sequence;
        })();
        Animations.Sequence = Sequence;
    })(Kiwi.Animations || (Kiwi.Animations = {}));
    var Animations = Kiwi.Animations;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Input) {
        /**
        * A compact object that holds the most important details about a Keyboard Event response.
        *
        * @class Key
        * @constructor
        * @namespace Kiwi.Input
        * @param manager {Keyboard} The keyboard manager that this key belongs to.
        * @param keycode {Number} The keycode that this key is.
        * @param [event] {KeyboardEvent} The keyboard event (if there was one) when this was created.
        * @return {Key} This object.
        *
        */
        var Key = (function () {
            function Key(manager, keycode, event) {
                /**
                * If the default action for this Key should be prevented or not.
                * For example. If your game use's the spacebar you would want its default action (which is to make the website scrolldown) prevented,
                * So you can set this to true.
                * @property preventDefault
                * @type Boolean
                * @default false
                * @public
                */
                this.preventDefault = false;
                /**
                * Indicated whether or not the key is currently down.
                * @property isDown
                * @type boolean
                * @default false
                * @public
                */
                this.isDown = false;
                /**
                * Indicates whether or not the key is currently up.
                * @property isUp
                * @type boolean
                * @default true
                * @public
                */
                this.isUp = true;
                /**
                * If the alt key was held at the time of the event happening.
                * @property altKey
                * @type boolean
                * @default false
                * @public
                */
                this.altKey = false;
                /**
                * If the ctrl key was held at the time of the event happening.
                * @property ctrlKey
                * @type boolean
                * @default false
                * @public
                */
                this.ctrlKey = false;
                /**
                * If the shift key was held at the time of the event happening.
                * @property shiftKey
                * @type boolean
                * @default false
                * @public
                */
                this.shiftKey = false;
                /**
                * The time that the key was pressed initially.
                * @property timeDown
                * @type Number
                * @default 0
                * @public
                */
                this.timeDown = 0;
                /**
                * The time at which the key was released.
                * @property timeUp
                * @type Number
                * @default 0
                * @public
                */
                this.timeUp = 0;
                /**
                * If this key is being 'held' down, this property will indicate the amount of times the 'onkeydown' event has fired.
                * This is reset each time the key is pressed.
                * @property repeats
                * @type Number
                * @default 0
                * @public
                */
                this.repeats = 0;
                this._manager = manager;
                this.game = this._manager.game;
                this.keyCode = keycode;

                if (event) {
                    this.update(event);
                }
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Key.prototype.objType = function () {
                return "Key";
            };

            Object.defineProperty(Key.prototype, "duration", {
                /**
                * The duration (in milliseconds) that the key has been down for.
                * This is property is READ ONLY.
                * @property duration
                * @type Number
                * @default 0
                * @public
                */
                get: function () {
                    //If the key is down when the dev is getting the duration, then update the duration.
                    if (this.isDown) {
                        this.timeDown = this.game.time.now();
                    }

                    return (this.timeDown < this.timeUp) ? 0 : this.timeDown - this.timeUp;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * The 'update' method fires when an event occur's. Updates the keys properties
            * @method update
            * @param event {KeyboardEvent}
            * @public
            */
            Key.prototype.update = function (event) {
                this.keyCode = event.keyCode;

                //Are we needing to prevent the default action?
                if (this.preventDefault)
                    event.preventDefault();

                if (event.type === 'keydown') {
                    this.altKey = event.altKey;
                    this.ctrlKey = event.ctrlKey;
                    this.shiftKey = event.shiftKey;

                    if (this.isDown === true) {
                        // Key was already held down, this must be a repeat rate based event
                        this.repeats++;
                        this.timeDown = this.game.time.now();
                    } else {
                        this.isDown = true;
                        this.isUp = false;
                        this.timeDown = this.game.time.now();
                        this.repeats = 0;
                    }
                } else if (event.type === 'keyup') {
                    this.isDown = false;
                    this.isUp = true;
                    this.timeUp = this.game.time.now();
                }
            };

            /**
            * Returns a boolean indicating whether or not this key was just pressed.
            * @method justPressed
            * @param [duration] {Number} The duration at which determines if a key was just pressed. Defaults to the managers just pressed rate.
            * @return {boolean}
            * @public
            */
            Key.prototype.justPressed = function (duration) {
                if (typeof duration === "undefined") { duration = this._manager.justPressedRate; }
                if (this.isDown === true && (this.timeDown + duration) > this.game.time.now()) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Returns a boolean indicating whether or not this key was just released.
            * @method justReleased
            * @param [duration] {Number} The duration at which determines if a key was just released. Defaults to the managers just pressed rate.
            * @return {boolean}
            * @public
            */
            Key.prototype.justReleased = function (duration) {
                if (typeof duration === "undefined") { duration = this._manager.justReleasedRate; }
                if (this.isUp === true && (this.timeUp + duration) > this.game.time.now()) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Resets all of the properties on the Key to their default values.
            * @method reset
            * @public
            */
            Key.prototype.reset = function () {
                this.isDown = false;
                this.isUp = true;
                this.timeUp = 0;
                this.timeDown = 0;
                this.repeats = 0;
                this.altKey = false;
                this.shiftKey = false;
                this.ctrlKey = false;
            };
            return Key;
        })();
        Input.Key = Key;
    })(Kiwi.Input || (Kiwi.Input = {}));
    var Input = Kiwi.Input;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Input) {
        /**
        * Handles and Manages the dispatching of keyboard events. When the user press's a button a new Key object is created.
        *
        * @class Keyboard
        * @constructor
        * @namespace Kiwi.Input
        * @param game {Game}
        * @return {Keyboard} This object.
        *
        */
        var Keyboard = (function () {
            function Keyboard(game) {
                /**
                * Contains a reference to each Key object when they are either added to this Keyboard manager (by the developer), or when an event fires with that keycode.
                * @property _keys
                * @type Key[]
                * @private
                */
                this._keys = [];
                /**
                * The time in milliseconds which determines if a key was just pressed or not.
                * @property justPressedRate
                * @type Number
                * @default 200
                * @public
                */
                this.justPressedRate = 200;
                /**
                * The time in milliseconds which determines if a key was just released or not.
                * @property justReleasedRate
                * @type Number
                * @default 200
                * @public
                */
                this.justReleasedRate = 200;
                this.game = game;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Keyboard.prototype.objType = function () {
                return "Keyboard";
            };

            Object.defineProperty(Keyboard.prototype, "keys", {
                /**
                * Returns all of the Key objects that currently exist. This is READ ONLY.
                * @property keys
                * @type Keys[]
                * @public
                */
                get: function () {
                    return this._keys;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Is executed when the DOMElements that are need to get the game going are loaded and thus the game can 'boot'
            * @method boot
            * @public
            */
            Keyboard.prototype.boot = function () {
                this.onKeyUp = new Kiwi.Signal;
                this.onKeyDown = new Kiwi.Signal;
                this.onKeyDownOnce = new Kiwi.Signal;
                this.start();
            };

            /**
            * The update loop that is executed every frame.
            * @method update
            * @public
            */
            Keyboard.prototype.update = function () {
            };

            /**
            * Adds the event listeners to the browser to listen for key events.
            * @method start
            * @public
            */
            Keyboard.prototype.start = function () {
                var _this = this;
                if (this.game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    //this._domElement.addEventListener('keydown', (event:KeyboardEvent) => this.onKeyDown(event), false);
                    //this._domElement.addEventListener('keyup', (event:KeyboardEvent) => this.onKeyUp(event), false);
                    document.body.addEventListener('keydown', function (event) {
                        return _this._keyPressed(event);
                    }, false);
                    document.body.addEventListener('keyup', function (event) {
                        return _this._keyReleased(event);
                    }, false);
                }
            };

            /**
            * Removes the event listeners and so effectively 'stops' all keyboard events.
            * @method stop
            * @public
            */
            Keyboard.prototype.stop = function () {
                var _this = this;
                if (this.game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    //this._domElement.removeEventListener('keydown', (event:KeyboardEvent) => this.onKeyDown(event), false);
                    //this._domElement.removeEventListener('keyup', (event:KeyboardEvent) => this.onKeyUp(event), false);
                    document.body.removeEventListener('keydown', function (event) {
                        return _this._keyPressed(event);
                    }, false);
                    document.body.removeEventListener('keyup', function (event) {
                        return _this._keyReleased(event);
                    }, false);
                }
            };

            /**
            * Is executed when a key is pressed/is down. This then either creates a new Key (if one does not currently exist) for that keycode,
            * or it updates the key that was pressed (if one does exist).
            * @method onKeyDown
            * @param {KeyboardEvent} event.
            * @private
            */
            Keyboard.prototype._keyPressed = function (event) {
                if (this._keys[event.keyCode]) {
                    this._keys[event.keyCode].update(event);
                } else {
                    this._keys[event.keyCode] = new Kiwi.Input.Key(this, event.keyCode, event);
                }

                if (this._keys[event.keyCode].repeats == 0)
                    this.onKeyDownOnce.dispatch(event.keyCode, this._keys[event.keyCode]);

                this.onKeyDown.dispatch(event.keyCode, this._keys[event.keyCode]);
            };

            /**
            * Is executed when a key is release/is now up. This then either creates a new Key (if one does not currently exist) for that keycode,
            * or it updates the key that was released (if one does exist).
            * @method onKeyUp
            * @param {KeyboardEvent} event.
            * @private
            */
            Keyboard.prototype._keyReleased = function (event) {
                if (this._keys[event.keyCode]) {
                    this._keys[event.keyCode].update(event);
                } else {
                    this._keys[event.keyCode] = new Kiwi.Input.Key(this, event.keyCode, event);
                }
                this.onKeyUp.dispatch(event.keyCode, this._keys[event.keyCode]);
            };

            /**
            * Creates a new Key object for a keycode that is specified.
            * Not strictly needed (as one will be created once an event occurs on that keycode) but can be good for setting the game up
            * and choosing whether to prevent that keys any default action.
            * @method addKey
            * @param keycode {Number} The keycode of the key that you want to add.
            * @param [preventDefault=false] {Boolean} If the default action for that key should be prevented or not when an event fires.
            * @return {Key}
            * @public
            */
            Keyboard.prototype.addKey = function (keycode, preventDefault) {
                if (typeof preventDefault === "undefined") { preventDefault = false; }
                var key = new Kiwi.Input.Key(this, keycode);
                key.preventDefault = preventDefault;

                return this._keys[keycode] = key;
            };

            /**
            * Returns a boolean indicating if a key (that you pass via a keycode) was just pressed or not.
            * @method justPressed
            * @param keycode {Number} The keycode of the key that you would like to check against.
            * @param [duration=this.justPressedRate] {Number} The duration at which determines if a key was 'just' pressed or not. If not specified defaults to the justPressedRate
            * @public
            */
            Keyboard.prototype.justPressed = function (keycode, duration) {
                if (typeof duration === "undefined") { duration = this.justPressedRate; }
                if (this._keys[keycode]) {
                    return this._keys[keycode].justPressed(duration);
                }

                return false;
            };

            /**
            * Returns a boolean indicating if a key (that you pass via a keycode) was just released or not.
            * @method justReleased
            * @param keycode {Number} The keycode of the key that you would like to check against.
            * @param [duration=this.justReleasedRate] {Number} The duration at which determines if a key was 'just' released or not. If not specified defaults to the justReleasedRate
            * @public
            */
            Keyboard.prototype.justReleased = function (keycode, duration) {
                if (typeof duration === "undefined") { duration = this.justReleasedRate; }
                if (this._keys[keycode]) {
                    return this._keys[keycode].justReleased(duration);
                }

                return false;
            };

            /**
            * Returns a boolean indicating whether a key (that you pass via its keycode) is down or not.
            * @method isDown
            * @param keycode {Number} The keycode of the key that you are checking.
            * @return {boolean}
            * @public
            */
            Keyboard.prototype.isDown = function (keycode) {
                if (this._keys[keycode]) {
                    return this._keys[keycode].isDown;
                } else {
                    return false;
                }
            };

            /**
            * Returns a boolean indicating whether a key (that you pass via its keycode) is up or not.
            * @method isUp
            * @param keycode {Number} The keycode of the key that you are checking.
            * @return {boolean}
            * @public
            */
            Keyboard.prototype.isUp = function (keycode) {
                if (this._keys[keycode]) {
                    return this._keys[keycode].isUp;
                } else {
                    return false;
                }
            };

            /**
            * Executes the reset method on every Key that currently exists.
            * @method reset
            * @public
            */
            Keyboard.prototype.reset = function () {
                for (var index in this._keys) {
                    this._keys[index].reset();
                }
            };
            return Keyboard;
        })();
        Input.Keyboard = Keyboard;
    })(Kiwi.Input || (Kiwi.Input = {}));
    var Input = Kiwi.Input;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Input) {
        /**
        * A Static class which has a property associated with all all of the character codes on a typical keyboard. While you don't need this class for your game to work, it is quite handy to use as it can speed up the development process.
        *
        * @class Keycodes
        * @namespace Kiwi.Input
        * @static
        */
        var Keycodes = (function () {
            function Keycodes() {
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {string}
            * @public
            */
            Keycodes.prototype.objType = function () {
                return "Keycodes";
            };

            Keycodes.A = "A".charCodeAt(0);

            Keycodes.B = "B".charCodeAt(0);

            Keycodes.C = "C".charCodeAt(0);

            Keycodes.D = "D".charCodeAt(0);

            Keycodes.E = "E".charCodeAt(0);

            Keycodes.F = "F".charCodeAt(0);

            Keycodes.G = "G".charCodeAt(0);

            Keycodes.H = "H".charCodeAt(0);

            Keycodes.I = "I".charCodeAt(0);

            Keycodes.J = "J".charCodeAt(0);

            Keycodes.K = "K".charCodeAt(0);

            Keycodes.L = "L".charCodeAt(0);

            Keycodes.M = "M".charCodeAt(0);

            Keycodes.N = "N".charCodeAt(0);

            Keycodes.O = "O".charCodeAt(0);

            Keycodes.P = "P".charCodeAt(0);

            Keycodes.Q = "Q".charCodeAt(0);

            Keycodes.R = "R".charCodeAt(0);

            Keycodes.S = "S".charCodeAt(0);

            Keycodes.T = "T".charCodeAt(0);

            Keycodes.U = "U".charCodeAt(0);

            Keycodes.V = "V".charCodeAt(0);

            Keycodes.W = "W".charCodeAt(0);

            Keycodes.X = "X".charCodeAt(0);

            Keycodes.Y = "Y".charCodeAt(0);

            Keycodes.Z = "Z".charCodeAt(0);

            Keycodes.ZERO = "0".charCodeAt(0);

            Keycodes.ONE = "1".charCodeAt(0);

            Keycodes.TWO = "2".charCodeAt(0);

            Keycodes.THREE = "3".charCodeAt(0);

            Keycodes.FOUR = "4".charCodeAt(0);

            Keycodes.FIVE = "5".charCodeAt(0);

            Keycodes.SIX = "6".charCodeAt(0);

            Keycodes.SEVEN = "7".charCodeAt(0);

            Keycodes.EIGHT = "8".charCodeAt(0);

            Keycodes.NINE = "9".charCodeAt(0);

            Keycodes.NUMPAD_0 = 96;

            Keycodes.NUMPAD_1 = 97;

            Keycodes.NUMPAD_2 = 98;

            Keycodes.NUMPAD_3 = 99;

            Keycodes.NUMPAD_4 = 100;

            Keycodes.NUMPAD_5 = 101;

            Keycodes.NUMPAD_6 = 102;

            Keycodes.NUMPAD_7 = 103;

            Keycodes.NUMPAD_8 = 104;

            Keycodes.NUMPAD_9 = 105;

            Keycodes.NUMPAD_MULTIPLY = 106;

            Keycodes.NUMPAD_ADD = 107;

            Keycodes.NUMPAD_ENTER = 108;

            Keycodes.NUMPAD_SUBTRACT = 109;

            Keycodes.NUMPAD_DECIMAL = 110;

            Keycodes.NUMPAD_DIVIDE = 111;

            Keycodes.F1 = 112;

            Keycodes.F2 = 113;

            Keycodes.F3 = 114;

            Keycodes.F4 = 115;

            Keycodes.F5 = 116;

            Keycodes.F6 = 117;

            Keycodes.F7 = 118;

            Keycodes.F8 = 119;

            Keycodes.F9 = 120;

            Keycodes.F10 = 121;

            Keycodes.F11 = 122;

            Keycodes.F12 = 123;

            Keycodes.F13 = 124;

            Keycodes.F14 = 125;

            Keycodes.F15 = 126;

            Keycodes.COLON = 186;

            Keycodes.EQUALS = 187;

            Keycodes.UNDERSCORE = 189;

            Keycodes.QUESTION_MARK = 191;

            Keycodes.TILDE = 192;

            Keycodes.OPEN_BRACKET = 219;

            Keycodes.BACKWARD_SLASH = 220;

            Keycodes.CLOSED_BRACKET = 221;

            Keycodes.QUOTES = 222;

            Keycodes.BACKSPACE = 8;

            Keycodes.TAB = 9;

            Keycodes.CLEAR = 12;

            Keycodes.ENTER = 13;

            Keycodes.SHIFT = 16;

            Keycodes.CONTROL = 17;

            Keycodes.ALT = 18;

            Keycodes.CAPS_LOCK = 20;

            Keycodes.ESC = 27;

            Keycodes.SPACEBAR = 32;

            Keycodes.PAGE_UP = 33;

            Keycodes.PAGE_DOWN = 34;

            Keycodes.END = 35;

            Keycodes.HOME = 36;

            Keycodes.LEFT = 37;

            Keycodes.UP = 38;

            Keycodes.RIGHT = 39;

            Keycodes.DOWN = 40;

            Keycodes.INSERT = 45;

            Keycodes.DELETE = 46;

            Keycodes.HELP = 47;

            Keycodes.NUM_LOCK = 144;
            return Keycodes;
        })();
        Input.Keycodes = Keycodes;
    })(Kiwi.Input || (Kiwi.Input = {}));
    var Input = Kiwi.Input;
})(Kiwi || (Kiwi = {}));
/**
* Section that contains the code related to handling user interaction with a game.
*
* @module Kiwi
* @submodule Input
* @main Input
*/
var Kiwi;
(function (Kiwi) {
    (function (Input) {
        /**
        * Handles the initialization and management of the various ways a user can interact with the device/game, whether this is through a Keyboard and Mouse or by a Touch. Also contains some of the general callbacks that are 'global' between both Desktop and Mobile based devices.
        *
        * @class InputManager
        * @constructor
        * @namespace Kiwi.Input
        * @param game {Game} The game that this object belongs to.
        * @return {InputManager} This object.
        *
        */
        var InputManager = (function () {
            function InputManager(game) {
                this.game = game;
            }
            /**
            * The type of object this is.
            * @method objType
            * @return String
            * @public
            */
            InputManager.prototype.objType = function () {
                return "InputManager";
            };

            Object.defineProperty(InputManager.prototype, "pointers", {
                /**
                * Returns all of the pointers that can be used on the Input Manager. This is READ only.
                * @property pointer
                * @type Pointer[]
                * @public
                */
                get: function () {
                    return this._pointers;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * This method is executed when the DOM has loaded and the manager is ready to load.
            * @method boot
            * @public
            */
            InputManager.prototype.boot = function () {
                this._pointers = [];

                this.mouse = new Kiwi.Input.Mouse(this.game);
                this.mouse.boot();

                this.keyboard = new Kiwi.Input.Keyboard(this.game);
                this.keyboard.boot();

                if (Kiwi.DEVICE.touch === true) {
                    this.touch = new Kiwi.Input.Touch(this.game);
                    this.touch.boot();
                    this.touch.touchDown.add(this._onDownEvent, this);
                    this.touch.touchUp.add(this._onUpEvent, this);
                    this._pointers = this.touch.fingers;
                } else {
                    this.mouse.onDown.add(this._onDownEvent, this);
                    this.mouse.onUp.add(this._onUpEvent, this);
                    this._pointers.push(this.mouse.cursor);
                }

                this.isDown = false;
                this.position = new Kiwi.Geom.Point();

                this.onDown = new Kiwi.Signal();
                this.onUp = new Kiwi.Signal();
            };

            /**
            * A private method that gets dispatched when either the mouse or touch manager dispatches a down event
            * @method _onDownEvent
            * @param x {Number} The x coordinate of the pointer
            * @param y {Number} The y coordinate of the pointer
            * @param timeDown {Number} The time that the pointer has been down for.
            * @param timeUp {Number} The Time that the pointer has been up form
            * @param duration {Number}
            * @param pointer {Pointer} The pointer that was used.
            * @private
            */
            InputManager.prototype._onDownEvent = function (x, y, timeDown, timeUp, duration, pointer) {
                this.onDown.dispatch(x, y, timeDown, timeUp, duration, pointer);
            };

            /**
            * A private method that gets dispatched when either the mouse or touch manager dispatches a up event
            * @method _onUpEvent
            * @param x {Number} The x coordinate of the pointer
            * @param y {Number} The y coordinate of the pointer
            * @param timeDown {Number} The time that the pointer has been down for.
            * @param timeUp {Number} The Time that the pointer has been up form
            * @param duration {Number}
            * @param pointer {Pointer} The pointer that was used.
            * @private
            */
            InputManager.prototype._onUpEvent = function (x, y, timeDown, timeUp, duration, pointer) {
                this.onUp.dispatch(x, y, timeDown, timeUp, duration, pointer);
            };

            Object.defineProperty(InputManager.prototype, "onPressed", {
                /*
                * An alias for the onPress signal that goes straight to the onDown.
                * @property onPressed
                * @type Signal
                * @public
                */
                get: function () {
                    return this.onDown;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(InputManager.prototype, "onReleased", {
                /**
                * An alias for the onRelease signal that goes straight to the onUp
                * @property onReleased
                * @type Signal
                * @public
                */
                get: function () {
                    return this.onUp;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * The update loop that gets executed every frame.
            * @method update
            * @public
            */
            InputManager.prototype.update = function () {
                this.mouse.update();
                this.keyboard.update();

                if (Kiwi.DEVICE.touch === true) {
                    this.touch.update();
                    this.position.setTo(this.touch.x, this.touch.y);
                    this.isDown = this.touch.isDown;
                } else {
                    this.position.setTo(this.mouse.x, this.mouse.y);
                    this.isDown = this.mouse.isDown;
                }
            };

            /**
            * Runs the reset method on the managers.
            * @method reset
            */
            InputManager.prototype.reset = function () {
                this.mouse.reset();
                this.keyboard.reset();

                if (Kiwi.DEVICE.touch === true) {
                    this.touch.reset();
                }
            };

            Object.defineProperty(InputManager.prototype, "x", {
                /**
                * Populated x coordinate based on the most recent click/touch event
                * @property x
                * @type Number
                * @public
                */
                get: function () {
                    return this.position.x;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(InputManager.prototype, "y", {
                /**
                * Populated y coordinate based on the most recent click/touch event
                * @property y
                * @type Number
                * @public
                */
                get: function () {
                    return this.position.y;
                },
                enumerable: true,
                configurable: true
            });
            return InputManager;
        })();
        Input.InputManager = InputManager;
    })(Kiwi.Input || (Kiwi.Input = {}));
    var Input = Kiwi.Input;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Input) {
        /**
        * Handles the dispatching/management of Mouse Events on a game. When this class is instantiated a MouseCursor object is also created (on this object) which holds the information that is unique to the mouse cursor, although majority of that information is still accessible inside this object.
        *
        * @class Mouse
        * @constructor
        * @namespace Kiwi.Input
        * @param game {Game} The game that this mouse manager belongs to.
        * @return {Mouse}
        *
        */
        var Mouse = (function () {
            function Mouse(game) {
                /**
                * The HTMLElement that is being used to apply the mouse events to.
                * @property _domElement
                * @type HTMLDivElement
                * @private
                */
                this._domElement = null;
                this._game = game;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Mouse.prototype.objType = function () {
                return "Mouse";
            };

            Object.defineProperty(Mouse.prototype, "cursor", {
                /**
                * Returns the MouseCursor that is being used on the stage. This is READ ONLY.
                * @property cursor
                * @type MouseCursor
                * @private
                */
                get: function () {
                    return this._cursor;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * This method is executed when the DOM has finished loading and thus the MouseManager can start listening for events.
            * @method boot
            * @public
            */
            Mouse.prototype.boot = function () {
                this._domElement = this._game.stage.container;

                this._cursor = new Kiwi.Input.MouseCursor(this._game);
                this._cursor.active = true;
                this._cursor.id = 1;

                this.onDown = new Kiwi.Signal();
                this.onUp = new Kiwi.Signal();
                this.onWheel = new Kiwi.Signal();

                this.start();
            };

            Object.defineProperty(Mouse.prototype, "isDown", {
                /**
                * Indicates whether or not the cursor is currently down. This is READ ONLY.
                * @property isDown
                * @type boolean
                * @default false
                * @public
                */
                get: function () {
                    return this._cursor.isDown;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mouse.prototype, "isUp", {
                /**
                * Indicates whether or not the cursor is currently up. This is READ ONLY.
                * @property isUp
                * @type boolean
                * @default true
                * @public
                */
                get: function () {
                    return this._cursor.isUp;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mouse.prototype, "duration", {
                /**
                * Gets the duration in Milliseconds that the mouse cursor has either been up or down for.
                * @property duration
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.duration;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mouse.prototype, "x", {
                /**
                * Gets the x coordinate of the mouse cursor.
                * @property x
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.x;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mouse.prototype, "y", {
                /**
                * Gets the y coordinate of the mouse cursor.
                * @property y
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.y;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mouse.prototype, "wheelDeltaX", {
                /**
                * Gets the wheelDeltaX coordinate of the mouse cursors wheel.
                * @property wheelDeltaX
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.wheelDeltaX;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mouse.prototype, "wheelDeltaY", {
                /**
                * Gets the wheelDeltaY coordinate of the mouse cursors wheel.
                * @property wheelDeltaY
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.wheelDeltaY;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mouse.prototype, "ctrlKey", {
                /**
                * Indicates if the ctrl key is down.
                * @property ctrlKey
                * @type boolean
                * @default false
                * @public
                */
                get: function () {
                    return this._cursor.ctrlKey;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mouse.prototype, "shiftKey", {
                /**
                * Indicates if the shift key is down.
                * @property shiftKey
                * @type boolean
                * @default false
                * @public
                */
                get: function () {
                    return this._cursor.shiftKey;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mouse.prototype, "altKey", {
                /**
                * Indicates if the alt key is down.
                * @property altKey
                * @type boolean
                * @default false
                * @public
                */
                get: function () {
                    return this._cursor.altKey;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Mouse.prototype, "button", {
                /**
                * Returns a number indicating the button that was used. This can be used with the STATIC button properties.
                * @property button
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.button;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * The update loop for the cursor.
            * @method update
            * @public
            */
            Mouse.prototype.update = function () {
                this._cursor.update();
            };

            /**
            * Start the mouse event listeners on the game. Automatically called by the boot.
            * @method start
            * @public
            */
            Mouse.prototype.start = function () {
                var _this = this;
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    if (Kiwi.DEVICE.ie && Kiwi.DEVICE.ieVersion < 9) {
                        this._domElement.attachEvent('onmousedown', function (event) {
                            return _this.onMouseDown(event);
                        });
                        this._domElement.attachEvent('onmousemove', function (event) {
                            return _this.onMouseMove(event);
                        });
                        this._domElement.attachEvent('onmouseup', function (event) {
                            return _this.onMouseUp(event);
                        });
                        this._domElement.attachEvent('onmousewheel', function (event) {
                            return _this.onMouseWheel(event);
                        });
                    } else {
                        this._domElement.addEventListener('mousedown', function (event) {
                            return _this.onMouseDown(event);
                        }, true);
                        this._domElement.addEventListener('mousemove', function (event) {
                            return _this.onMouseMove(event);
                        }, true);
                        this._domElement.addEventListener('mouseup', function (event) {
                            return _this.onMouseUp(event);
                        }, true);
                        this._domElement.addEventListener('mousewheel', function (event) {
                            return _this.onMouseWheel(event);
                        }, true);
                        this._domElement.addEventListener('DOMMouseScroll', function (event) {
                            return _this.onMouseWheel(event);
                        }, true);
                    }
                } else if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                    this._game.stage.canvas.addEventListener('mousedown', function (event) {
                        return _this.onMouseDown(event);
                    }, true);
                    this._game.stage.canvas.addEventListener('mousemove', function (event) {
                        return _this.onMouseMove(event);
                    }, true);
                    this._game.stage.canvas.addEventListener('mouseup', function (event) {
                        return _this.onMouseUp(event);
                    }, true);
                    this._game.stage.canvas.addEventListener('mousewheel', function (event) {
                        return _this.onMouseWheel(event);
                    }, true);
                    this._game.stage.canvas.addEventListener('DOMMouseScroll', function (event) {
                        return _this.onMouseWheel(event);
                    }, true);
                }
            };

            /**
            * Stops the mouse event listeners from working. Useful if you no longer want the mouse to 'work'/be listened to.
            * @method stop
            * @public
            */
            Mouse.prototype.stop = function () {
                var _this = this;
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    this._domElement.removeEventListener('mousedown', function (event) {
                        return _this.onMouseDown(event);
                    }, false);
                    this._domElement.removeEventListener('mousedown', this.onMouseDown, false);
                    this._domElement.removeEventListener('mousemove', this.onMouseMove, false);
                    this._domElement.removeEventListener('mouseup', this.onMouseUp, false);
                    this._domElement.removeEventListener('mousewheel', this.onMouseWheel, false);
                    this._domElement.removeEventListener('DOMMouseScroll', this.onMouseWheel, false);
                }
            };

            /**
            * Method that gets fired when the mouse is pressed on the stage.
            * @method onMouseDown
            * @param {MouseEvent} event.
            * @private
            */
            Mouse.prototype.onMouseDown = function (event) {
                this._cursor.start(event);
                this.onDown.dispatch(this._cursor.x, this._cursor.y, this._cursor.timeDown, this._cursor.timeUp, this.duration, this._cursor);
            };

            /**
            * Method that gets fired when the mouse moves anywhere on the stage.
            * @method onMouseMove
            * @param {MouseEvent} event.
            * @private
            */
            Mouse.prototype.onMouseMove = function (event) {
                this._cursor.move(event);
            };

            /**
            * Method that gets fired when the mouse is released on the stage.
            * @method onMouseUp
            * @param {MouseEvent} event.
            * @private
            */
            Mouse.prototype.onMouseUp = function (event) {
                this._cursor.stop(event);
                this.onUp.dispatch(this._cursor.x, this._cursor.y, this._cursor.timeDown, this._cursor.timeUp, this.duration, this._cursor);
            };

            /**
            * Method that gets fired when the mousewheel is moved.
            * @method onMouseWheel
            * @param {MouseEvent} event.
            * @private
            */
            Mouse.prototype.onMouseWheel = function (event) {
                this._cursor.wheel(event);
                this.onWheel.dispatch(this._cursor.wheelDeltaX, this._cursor.wheelDeltaY, this._cursor);
            };

            /**
            * Returns a boolean indicating if the mouse was 'justPressed' within a certain timeframe. The default timeframe is 200 milliseconds.
            * @method justPressed
            * @param [duration=200] {Number} The timeframe that it could have occured in.
            * @return {boolean}
            * @public
            */
            Mouse.prototype.justPressed = function (duration) {
                if (typeof duration === "undefined") { duration = this._cursor.justPressedRate; }
                return this._cursor.justPressed(duration);
            };

            /**
            * Returns a boolean indicating if the mouse was 'justReleased' within a certain timeframe. The default timeframe is 200 milliseconds.
            * @method justReleased
            * @param [duration=200] {Number} The timeframe that it could have occured in..
            * @return {boolean}
            * @public
            */
            Mouse.prototype.justReleased = function (duration) {
                if (typeof duration === "undefined") { duration = this._cursor.justReleasedRate; }
                return this._cursor.justReleased(duration);
            };

            /**
            * Runs the Reset method on the MouseCursor.
            * @method reset
            * @public
            */
            Mouse.prototype.reset = function () {
                this._cursor.reset();
            };
            Mouse.LEFT_BUTTON = 0;

            Mouse.MIDDLE_BUTTON = 1;

            Mouse.RIGHT_BUTTON = 2;
            return Mouse;
        })();
        Input.Mouse = Mouse;
    })(Kiwi.Input || (Kiwi.Input = {}));
    var Input = Kiwi.Input;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Input) {
        /**
        * Handles the dispatching and management of touch based events for the game. When the Touch manager is created TEN finger objects are created and used when the user interacts with the screen. Those finger are what you can use to create games that make the most out of multitouch events.
        *
        * @class Touch
        * @constructor
        * @namespace Kiwi.Input
        * @param game {Game} the game that this touch manager belongs to.
        * @return {Touch} This object.
        *
        */
        var Touch = (function () {
            function Touch(game) {
                /**
                * The dom element that these touch events are to take place on. This is usally set to be the stage/game container.
                * @property _domElement
                * @type HTMLElement
                * @default null
                * @private
                **/
                this._domElement = null;
                /**
                * A boolean that will roughly indicate if any finger is currently down.
                * @property isDown
                * @type boolean
                * @default false
                * @public
                */
                this.isDown = false;
                /**
                * If all the fingers are up.
                * @property isUp
                * @type boolean
                * @default true
                * @public
                */
                this.isUp = true;
                /**
                * The developer defined maximum number of touch events. By default this is set to 10 but this can be set to be lower.
                * @property _maxTouchEvents
                * @type number
                * @default 10
                * @private
                */
                this._maxPointers = 10;
                this._game = game;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return String
            * @public
            */
            Touch.prototype.objType = function () {
                return 'TouchManager';
            };

            Object.defineProperty(Touch.prototype, "fingers", {
                /**
                * Get the fingers that are being used.
                * @type Finger[]
                * @public
                */
                get: function () {
                    return this._fingers;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * An internal Kiwi method that runs when the DOM is loaded and the touch manager can now 'boot' up.
            * @method boot
            * @public
            */
            Touch.prototype.boot = function () {
                this._domElement = this._game.stage.container;

                this.finger1 = new Kiwi.Input.Finger(this._game);
                this.finger2 = new Kiwi.Input.Finger(this._game);
                this.finger3 = new Kiwi.Input.Finger(this._game);
                this.finger4 = new Kiwi.Input.Finger(this._game);
                this.finger5 = new Kiwi.Input.Finger(this._game);
                this.finger6 = new Kiwi.Input.Finger(this._game);
                this.finger7 = new Kiwi.Input.Finger(this._game);
                this.finger8 = new Kiwi.Input.Finger(this._game);
                this.finger9 = new Kiwi.Input.Finger(this._game);
                this.finger10 = new Kiwi.Input.Finger(this._game);

                this._fingers = [this.finger1, this.finger2, this.finger3, this.finger4, this.finger5, this.finger6, this.finger7, this.finger8, this.finger9, this.finger10];
                this.latestFinger = this.finger1;

                this.touchDown = new Kiwi.Signal();
                this.touchUp = new Kiwi.Signal();
                this.touchCancel = new Kiwi.Signal();

                this.start();
            };

            /**
            * Starts up the event listeners that are being used on the touch manager.
            * @method start
            * @public
            */
            Touch.prototype.start = function () {
                var _this = this;
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    this._domElement.addEventListener('touchstart', function (event) {
                        return _this.onTouchStart(event);
                    }, false);
                    this._domElement.addEventListener('touchmove', function (event) {
                        return _this.onTouchMove(event);
                    }, false);
                    this._domElement.addEventListener('touchend', function (event) {
                        return _this.onTouchEnd(event);
                    }, false);
                    this._domElement.addEventListener('touchenter', function (event) {
                        return _this.onTouchEnter(event);
                    }, false);
                    this._domElement.addEventListener('touchleave', function (event) {
                        return _this.onTouchLeave(event);
                    }, false);
                    this._domElement.addEventListener('touchcancel', function (event) {
                        return _this.onTouchCancel(event);
                    }, false);

                    document.addEventListener('touchmove', function (event) {
                        return _this.consumeTouchMove(event);
                    }, false);
                } else if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                    this._game.stage.canvas.addEventListener('touchstart', function (event) {
                        return _this.onTouchStart(event);
                    }, false);
                    this._game.stage.canvas.addEventListener('touchmove', function (event) {
                        return _this.onTouchMove(event);
                    }, false);
                    this._game.stage.canvas.addEventListener('touchend', function (event) {
                        return _this.onTouchEnd(event);
                    }, false);
                    this._game.stage.canvas.addEventListener('touchenter', function (event) {
                        return _this.onTouchEnter(event);
                    }, false);
                    this._game.stage.canvas.addEventListener('touchleave', function (event) {
                        return _this.onTouchLeave(event);
                    }, false);
                    this._game.stage.canvas.addEventListener('touchcancel', function (event) {
                        return _this.onTouchCancel(event);
                    }, false);
                }
            };

            /**
            * Prevent iOS bounce-back (doesn't work?)
            * @method consumeTouchMove
            * @param {Any} event
            * @public
            */
            Touch.prototype.consumeTouchMove = function (event) {
                event.preventDefault();
            };

            Object.defineProperty(Touch.prototype, "x", {
                /**
                * Gets the position of the latest finger on the x axis.
                * @type number
                * @public
                */
                get: function () {
                    return this.latestFinger.x;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Touch.prototype, "y", {
                /**
                * Gets the position of the latest finger on the y axis.
                * @type number
                * @public
                */
                get: function () {
                    return this.latestFinger.y;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Touch.prototype, "maximumPointers", {
                /**
                * Gets the maximum number of points of contact that are allowed on the game stage at one point.
                * @type number
                * @public
                */
                get: function () {
                    return this._maxPointers;
                },
                /**
                * Sets the maximum number of point of contact that are allowed on the game stage at one point.
                * The maximum number of points that are allowed is 10, and the minimum is 0.
                * @type number
                * @public
                */
                set: function (val) {
                    if (val < 0)
                        val = 1;
                    if (val > this._fingers.length)
                        val = this._fingers.length;

                    this._maxPointers = val;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * This method runs when the a touch start event is fired by the browser and then assigns the event to a pointer that is currently not active.
            * @method onTouchStart
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchStart = function (event) {
                for (var i = 0; i < event.changedTouches.length; i++) {
                    for (var f = 0; f < this._maxPointers; f++) {
                        if (this._fingers[f].active === false) {
                            this._fingers[f].start(event.changedTouches[i]);
                            this.latestFinger = this._fingers[f];

                            this.touchDown.dispatch(this._fingers[f].x, this._fingers[f].y, this._fingers[f].timeDown, this._fingers[f].timeUp, this._fingers[f].duration, this._fingers[f]);

                            this.isDown = true;
                            this.isUp = false;
                            break;
                        }
                    }
                }
            };

            /**
            * Doesn't appear to be supported by most browsers yet but if it was it would fire events when a touch is canceled.
            * @method onTouchCancel
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchCancel = function (event) {
                for (var i = 0; i < event.changedTouches.length; i++) {
                    for (var f = 0; f < this._fingers.length; f++) {
                        if (this._fingers[f].id === event.changedTouches[i].identifier) {
                            this._fingers[f].stop(event.changedTouches[i]);
                            this.touchCancel.dispatch(this._fingers[f].x, this._fingers[f].y, this._fingers[f].timeDown, this._fingers[f].timeUp, this._fingers[f].duration, this._fingers[f]);
                            break;
                        }
                    }
                }
            };

            /**
            * Doesn't appear to be supported by most browsers yet. But if it was would fire events when touch events enter an element.
            * @method onTouchEnter
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchEnter = function (event) {
                for (var i = 0; i < event.changedTouches.length; i++) {
                    for (var f = 0; f < this._maxPointers; f++) {
                        if (this._fingers[f].active === false) {
                            this._fingers[f].start(event.changedTouches[i]);
                            break;
                        }
                    }
                }
            };

            /**
            * Doesn't appear to be supported by most browsers yet. Would fire events when a 'finger' leaves an element.
            * Would be handly for when an finger 'leaves' the stage.
            * @method onTouchLeave
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchLeave = function (event) {
                for (var i = 0; i < event.changedTouches.length; i++) {
                    for (var f = 0; f < this._fingers.length; f++) {
                        if (this._fingers[f].id === event.changedTouches[i].identifier) {
                            this._fingers[f].leave(event.changedTouches[i]);
                            break;
                        }
                    }
                }
            };

            /**
            * When a touch pointer moves. This method updates the appropriate pointer.
            * @method onTouchMove
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchMove = function (event) {
                for (var i = 0; i < event.changedTouches.length; i++) {
                    for (var f = 0; f < this._fingers.length; f++) {
                        if (this._fingers[f].id === event.changedTouches[i].identifier) {
                            this._fingers[f].move(event.changedTouches[i]);
                            this.latestFinger = this._fingers[f];
                            break;
                        }
                    }
                }
            };

            /**
            * When a touch event gets released.
            * @method onTouchEnd
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchEnd = function (event) {
                for (var i = 0; i < event.changedTouches.length; i++) {
                    for (var f = 0; f < this._fingers.length; f++) {
                        if (this._fingers[f].id === event.changedTouches[i].identifier) {
                            this._fingers[f].stop(event.changedTouches[i]);
                            this.latestFinger = this._fingers[f];

                            this.touchUp.dispatch(this._fingers[f].x, this._fingers[f].y, this._fingers[f].timeDown, this._fingers[f].timeUp, this._fingers[f].duration, this._fingers[f]);

                            this.isDown = false;
                            this.isUp = true;
                            break;
                        }
                    }
                }

                for (var i = 0; i < this._fingers.length; i++) {
                    if (this._fingers[i].active) {
                        this.isDown = true;
                        this.isUp = false;
                    }
                }
            };

            /**
            * The update loop fro the touch manager.
            * @method update
            * @public
            */
            Touch.prototype.update = function () {
                if (this.isDown) {
                    for (var i = 0; i < this._fingers.length; i++) {
                        if (this._fingers[i].active) {
                            this._fingers[i].update();
                        }
                    }
                }
            };

            /**
            * This method removes all of the event listeners and thus 'stops' the touch manager.
            * @method stop
            * @public
            */
            Touch.prototype.stop = function () {
                var _this = this;
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    this._domElement.removeEventListener('touchstart', function (event) {
                        return _this.onTouchStart(event);
                    }, false);
                    this._domElement.removeEventListener('touchmove', function (event) {
                        return _this.onTouchMove(event);
                    }, false);
                    this._domElement.removeEventListener('touchend', function (event) {
                        return _this.onTouchEnd(event);
                    }, false);
                    this._domElement.removeEventListener('touchenter', function (event) {
                        return _this.onTouchEnter(event);
                    }, false);
                    this._domElement.removeEventListener('touchleave', function (event) {
                        return _this.onTouchLeave(event);
                    }, false);
                    this._domElement.removeEventListener('touchcancel', function (event) {
                        return _this.onTouchCancel(event);
                    }, false);
                } else if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                    this._game.stage.canvas.removeEventListener('touchstart', function (event) {
                        return _this.onTouchStart(event);
                    }, false);
                    this._game.stage.canvas.removeEventListener('touchmove', function (event) {
                        return _this.onTouchMove(event);
                    }, false);
                    this._game.stage.canvas.removeEventListener('touchend', function (event) {
                        return _this.onTouchEnd(event);
                    }, false);
                    this._game.stage.canvas.removeEventListener('touchenter', function (event) {
                        return _this.onTouchEnter(event);
                    }, false);
                    this._game.stage.canvas.removeEventListener('touchleave', function (event) {
                        return _this.onTouchLeave(event);
                    }, false);
                    this._game.stage.canvas.removeEventListener('touchcancel', function (event) {
                        return _this.onTouchCancel(event);
                    }, false);
                }
            };

            /**
            * Resets all of the fingers/pointers to their default states.
            * @method reset
            * @public
            */
            Touch.prototype.reset = function () {
                for (var i = 0; i < this._fingers.length; i++) {
                    this._fingers[i].reset();
                }
            };
            return Touch;
        })();
        Input.Touch = Touch;
    })(Kiwi.Input || (Kiwi.Input = {}));
    var Input = Kiwi.Input;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Input) {
        /**
        * Is a generic class that holds the properties/methods that are common across various different methods of inputs from the user, mainly between Touch and Mouse based events. This abstract class and such it is suppose to be extended from for individual implementations.
        *
        * @class Pointer
        * @constructor
        * @namespace Kiwi.Input
        * @param {Game} game
        * @return Pointer
        *
        */
        var Pointer = (function () {
            function Pointer(game) {
                /**
                * The horizontal coordinate of point relative to the game element
                * @property x
                * @type Number
                * @default -1
                * @public
                */
                this.x = -1;
                /**
                * The vertical coordinate of point relative to the game element
                * @property y
                * @type Number
                * @default -1
                * @public
                */
                this.y = -1;
                /**
                * The horizontal coordinate of point relative to the viewport in pixels, excluding any scroll offset
                * @property clientX
                * @type Number
                * @default -1
                * @public
                */
                this.clientX = -1;
                /**
                * The vertical coordinate of point relative to the viewport in pixels, excluding any scroll offset
                * @property clientY
                * @type Number
                * @default -1
                * @public
                */
                this.clientY = -1;
                /**
                * The horizontal coordinate of point relative to the viewport in pixels, including any scroll offset
                * @property pageX
                * @type Number
                * @default -1
                * @public
                */
                this.pageX = -1;
                /**
                * The vertical coordinate of point relative to the viewport in pixels, including any scroll offset
                * @property pageY
                * @type Number
                * @default -1
                * @public
                */
                this.pageY = -1;
                /**
                * The horizontal coordinate of point relative to the screen in pixels
                * @property screenX
                * @type Number
                * @default -1
                * @public
                */
                this.screenX = -1;
                /**
                * The vertical coordinate of point relative to the screen in pixels
                * @property screenY
                * @type Number
                * @default -1
                * @public
                */
                this.screenY = -1;
                /**
                * Indicates if this pointer is currently down.
                * @property isDown
                * @type boolean
                * @default false
                * @public
                */
                this.isDown = false;
                /**
                * Indicates if this pointer is currently up.
                * @property isUp
                * @default true
                * @type boolean
                * @public
                */
                this.isUp = true;
                /**
                * Indicates if this pointer is currently within the game.
                * @property withinGame
                * @type boolean
                * @default false
                * @public
                */
                this.withinGame = false;
                /**
                * Indicates if this pointer is active. Note a mouse is always 'active' where as a finger is only active when it is down.
                * @property active
                * @type boolean
                * @default false
                * @public
                */
                this.active = false;
                /**
                * Indicates the time that the pointer was pressed initially.
                * @property timeDown
                * @type number
                * @default 0
                * @public
                */
                this.timeDown = 0;
                /**
                * Indicates the time that the pointer was released initially.
                * @property timeUp
                * @type number
                * @default 0
                * @public
                */
                this.timeUp = 0;
                /**
                * The duration that the pointer has been down for in milliseconds.
                * @property duration
                * @type number
                * @default 0
                * @public
                */
                this.duration = 0;
                /**
                * The duration that the pointer has been down for in frames.
                * @property frameDuration
                * @type number
                * @default 0
                * @public
                */
                this.frameDuration = 0;
                /**
                * A time that is used to calculate if someone justPressed the pointer.
                * @property justPressedRate
                * @type number
                * @defeault 200
                * @public
                */
                this.justPressedRate = 200;
                /**
                * A time that is used to calculate if someone justReleased the pointer.
                * @property justReleasedRate
                * @type number
                * @default 200
                * @public
                */
                this.justReleasedRate = 200;
                this._game = game;
                this.point = new Kiwi.Geom.Point();
                this.circle = new Kiwi.Geom.Circle(0, 0, 1);
                this.startPoint = new Kiwi.Geom.Point();
                this.endPoint = new Kiwi.Geom.Point();
            }
            /**
            * The type of object this class is.
            * @method objType
            * @return {string}
            * @public
            */
            Pointer.prototype.objType = function () {
                return 'Pointer';
            };

            Object.defineProperty(Pointer.prototype, "game", {
                /**
                * Get the game that this pointer belongs to.
                * @type Game
                * @public
                */
                get: function () {
                    return this._game;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * The method that gets executed when the pointer presses/initially goes down on the screen.
            * From the event passed the coordinates are calculated.
            * @method start
            * @param {event} event
            * @public
            */
            Pointer.prototype.start = function (event) {
                this.move(event);
                this.startPoint.setTo(this.x, this.y);
                this.frameDuration = 0;
                this.withinGame = true;
                this.isDown = true;
                this.isUp = false;
                this.timeDown = this.game.time.now();
            };

            /**
            * The stop method is to be called when the pointer gets released initially.
            * @method stop
            * @param {event} event
            * @public
            */
            Pointer.prototype.stop = function (event) {
                this.withinGame = false;
                this.endPoint.setTo(this.x, this.y);
                this.isDown = false;
                this.isUp = true;

                this.timeUp = this.game.time.now();
                this.duration = this.timeUp - this.timeDown;
            };

            /**
            * Used to get the cooridnates of a pointer and inputs them to the correct properties.
            * @method move
            * @param {event} event
            * @public
            */
            Pointer.prototype.move = function (event) {
                this.clientX = event.clientX;
                this.clientY = event.clientY;

                this.pageX = event.pageX;
                this.pageY = event.pageY;

                this.screenX = event.screenX;
                this.screenY = event.screenY;

                this.x = (this.pageX - this.game.stage.offset.x) * this.game.stage.scale;
                this.y = (this.pageY - this.game.stage.offset.y) * this.game.stage.scale;

                this.point.setTo(this.x, this.y);
                this.circle.x = this.x;
                this.circle.y = this.y;

                this.duration = this.game.time.now() - this.timeDown;
            };

            /**
            * Indicates if the pointer was just pressed. This is based of the justPressedRate unless otherwise specifieds.
            * @method justPressed
            * @param {number} duration
            * @return boolean
            * @public
            */
            Pointer.prototype.justPressed = function (duration) {
                if (typeof duration === "undefined") { duration = this.justPressedRate; }
                if (this.isDown === true && (this.timeDown + duration) > this._game.time.now()) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Indicates if the pointer was just released. This is based of the justReleasedRate unless otherwise specified.
            * @method justReleased
            * @param {number} duration
            * @return boolean
            * @public
            */
            Pointer.prototype.justReleased = function (duration) {
                if (typeof duration === "undefined") { duration = this.justReleasedRate; }
                if (this.isUp === true && (this.timeUp + duration) > this._game.time.now()) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Resets the pointer properties to the default ones. Assumes that the pointer is no longer down.
            * @method reset
            * @public
            */
            Pointer.prototype.reset = function () {
                this.isDown = false;
                this.isUp = true;
                this.timeDown = 0;
                this.timeUp = 0;
                this.duration = 0;
                this.frameDuration = 0;
            };

            /**
            * The update loop for the pointer. Used only if down to update the duration.
            * @method update.
            * @public
            */
            Pointer.prototype.update = function () {
                if (this.isDown === true) {
                    this.frameDuration++;
                    this.duration = this._game.time.now() - this.timeDown;
                }
            };
            return Pointer;
        })();
        Input.Pointer = Pointer;
    })(Kiwi.Input || (Kiwi.Input = {}));
    var Input = Kiwi.Input;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Input) {
        /**
        * Holds the information about a Mouse Cursor. Such as the position of the cursor, the mouse wheels delta, the button that was used, e.t.c. Note: A mouse cursor is always active.
        *
        * @class MouseCursor
        * @namespace Kiwi.Input
        * @extends Pointer
        */
        var MouseCursor = (function (_super) {
            __extends(MouseCursor, _super);
            function MouseCursor() {
                _super.apply(this, arguments);
                /**
                * The offset of the mouse wheel on the X axis.
                * @property wheelDeltaX
                * @type number
                * @default 0
                * @public
                */
                this.wheelDeltaX = 0;
                /**
                * The offset of the mouse wheel on the Y axis.
                * @property wheelDeltaY
                * @type number
                * @default 0
                * @public
                */
                this.wheelDeltaY = 0;
            }
            /**
            * The type of object this class is.
            * @method objType
            * @return string
            * @public
            */
            MouseCursor.prototype.objType = function () {
                return 'MouseCursor';
            };

            /**
            * Gets executed when the mouse cursor gets initally pressed.
            * @method start
            * @param {event} event
            * @public
            */
            MouseCursor.prototype.start = function (event) {
                this.ctrlKey = event.ctrlKey;
                this.shiftKey = event.shiftKey;
                this.altKey = event.altKey;
                this.button - event.button;

                _super.prototype.start.call(this, event);
            };

            /**
            * Gets executed when the mouse cursor gets initally released.
            * @method stop
            * @param {event} event
            * @public
            */
            MouseCursor.prototype.stop = function (event) {
                this.move(event);
                _super.prototype.stop.call(this, event);
            };

            /**
            * When the mouse wheel event fires and the mouse's delta changes.
            * @method wheel
            * @param {event} event
            * @public
            */
            MouseCursor.prototype.wheel = function (event) {
                if (event['wheelDeltaX']) {
                    this.wheelDeltaX = event['wheelDeltaX'];
                } else {
                    this.wheelDeltaX = event.deltaX;
                }

                if (event['wheelDeltaY']) {
                    this.wheelDeltaY = event['wheelDeltaY'];
                } else {
                    this.wheelDeltaY = event.deltaY;
                }
            };
            return MouseCursor;
        })(Kiwi.Input.Pointer);
        Input.MouseCursor = MouseCursor;
    })(Kiwi.Input || (Kiwi.Input = {}));
    var Input = Kiwi.Input;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Input) {
        /**
        * Used with the Touch manager class, this object holds information about a single touch point/locaton (or you know a finger). By default a Finger has a diameter of 44 pixels (random average size of a finger) which can be used for collision/overlap detection. That value can be modified. Note: A Finger is only active whilst the user is 'pressing' down on stage.
        *
        * @class Finger
        * @extends Pointer
        * @namespace Kiwi.Input
        * @constructor
        * @param game {Game} The game that this finger belongs to.
        * @return Finger
        */
        var Finger = (function (_super) {
            __extends(Finger, _super);
            function Finger(game) {
                _super.call(this, game);
                this.circle.diameter = 44; //The diameter of your average finger!
            }
            /**
            * The type of object this is.
            * @method objType
            * @return string
            * @public
            */
            Finger.prototype.objType = function () {
                return 'Finger';
            };

            /**
            * @method start
            * @param {Any} event
            * @public
            */
            Finger.prototype.start = function (event) {
                this.id = event.identifier;
                this.active = true;
                _super.prototype.start.call(this, event);
            };

            /**
            * @method stop
            * @param event {Any}
            * @public
            */
            Finger.prototype.stop = function (event) {
                this.active = false;
                _super.prototype.stop.call(this, event);
            };

            /**
            * @method leave
            * @param event {Any}
            * @public
            */
            Finger.prototype.leave = function (event) {
                this.withinGame = false;
                this.move(event);
            };

            /**
            * @method reset
            * @public
            */
            Finger.prototype.reset = function () {
                this.active = false;
                _super.prototype.reset.call(this);
            };
            return Finger;
        })(Kiwi.Input.Pointer);
        Input.Finger = Finger;
    })(Kiwi.Input || (Kiwi.Input = {}));
    var Input = Kiwi.Input;
})(Kiwi || (Kiwi = {}));
/**
* Contains common classes whose applications deal with geometry or the collision of geometric shapes.
*
* @module Kiwi
* @submodule Geom
* @main
*/
var Kiwi;
(function (Kiwi) {
    (function (Geom) {
        /**
        * An object representation of an axis-aligned bounding box.
        *
        * @class AABB
        * @namespace Kiwi.Geom
        * @constructor
        * @param cx {Number}
        * @param cy {Number}
        * @param width {Number}
        * @param height {Number}
        * @return {AABB}
        */
        var AABB = (function () {
            function AABB(cx, cy, width, height) {
                /**
                *
                * @property cx
                * @type Number
                * @public
                */
                this.cx = 0;
                /**
                *
                * @property cy
                * @type Number
                * @public
                */
                this.cy = 0;
                /**
                * Half of the width.
                * @property halfWidth
                * @type Number
                * @public
                */
                this.halfWidth = 0;
                /**
                * Half of the height.
                * @property halfHeight
                * @type Number
                * @public
                */
                this.halfHeight = 0;
                this.cx = cx || 0;
                this.cy = cy || 0;
                this.halfWidth = width / 2 || 0;
                this.halfHeight = height / 2 || 0;
            }
            /**
            * Returns the type of this object
            * @method objType
            * @return {String} The type of this object
            * @public
            */
            AABB.prototype.objType = function () {
                return "AABB";
            };

            Object.defineProperty(AABB.prototype, "height", {
                /**
                * Returns the full height. This is read only.
                * @property height
                * @type number
                * @public
                */
                get: function () {
                    return this.halfHeight * 2;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AABB.prototype, "width", {
                /**
                * Returns the full width. This is read only.
                * @property width
                * @type number
                * @public
                */
                get: function () {
                    return this.halfWidth * 2;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Draws the object to a canvas
            * @method draw
            * @param ctx {CanvasRenderingContext2D} The context you want this drawn to.
            * @return {AABB}
            * @public
            */
            AABB.prototype.draw = function (ctx) {
                ctx.beginPath();
                ctx.moveTo(this.cx - this.halfWidth, this.cy);
                ctx.lineTo(this.cx + this.halfWidth, this.cy);
                ctx.moveTo(this.cx, this.cy - this.halfHeight);
                ctx.lineTo(this.cx, this.cy + this.halfHeight);
                ctx.stroke();
                return this;
            };

            /**
            * Sets the position of the object.
            * @method setPosition
            * @param cx {Number}
            * @param cy {Number}
            * @return {AABB}
            * @public
            */
            AABB.prototype.setPosition = function (cx, cy) {
                this.cx = cx;
                this.cy = cy;
                return this;
            };

            /**
            * Sets the position of the object by a point that you pass.
            * @method setPositionPoint
            * @param {Point} pos
            * @return {AABB}
            * @public
            */
            AABB.prototype.setPositionPoint = function (pos) {
                this.cx = pos.x;
                this.cy = pos.y;
                return this;
            };

            /**
            * Returns this object but as a new Rectangle.
            * @method toRect
            * @return {Rectangle}
            * @public
            */
            AABB.prototype.toRect = function () {
                return new Kiwi.Geom.Rectangle(this.cx - this.halfWidth, this.cy - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);
            };

            /**
            * Gives the dimension of this AABB from a rectangle's.
            * @method fromRect
            * @param {Rectangle} rect
            * @return {AABB}
            * @public
            */
            AABB.prototype.fromRect = function (rect) {
                this.halfWidth = rect.width / 2;
                this.halfHeight = rect.height / 2;
                this.cx = rect.x + this.halfWidth;
                this.cy = rect.y + this.halfHeight;
                return this;
            };
            return AABB;
        })();
        Geom.AABB = AABB;
    })(Kiwi.Geom || (Kiwi.Geom = {}));
    var Geom = Kiwi.Geom;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    (function (Geom) {
        /**
        * A Circle object is an area defined by its position,
        * as indicated by its center point (x,y) and diameter.
        *
        * @class Circle
        * @namespace Kiwi.Geom
        * @constructor
        * @param [x = 0] {Number} The x coordinate of the center of the circle.
        * @param [y = 0] {Number} The y coordinate of the center of the circle.
        * @param [diameter = 0] {number} The diameter of the circle.
        * @return {Circle} This circle object
        *
        */
        var Circle = (function () {
            function Circle(x, y, diameter) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof diameter === "undefined") { diameter = 0; }
                /**
                * The diameter of the circle
                * @property _diameter
                * @type Number
                * @default 0
                * @private
                */
                this._diameter = 0;
                /**
                * The radius of the circle
                * @property _radius
                * @type Number
                * @default 0
                * @private
                */
                this._radius = 0;
                /**
                * The x coordinate of the center of the circle
                * @property x
                * @type Number
                * @default 0
                * @public
                */
                this.x = 0;
                /**
                * The y coordinate of the center of the circle
                * @property y
                * @type Number
                * @default 0
                * @public
                */
                this.y = 0;
                this.setTo(x, y, diameter);
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String}
            * @public
            */
            Circle.prototype.objType = function () {
                return "Circle";
            };

            Object.defineProperty(Circle.prototype, "diameter", {
                get: function () {
                    return this._diameter;
                },
                /**
                * The diameter of the circle. The largest distance between any two points on the circle. The same as the radius * 2.
                * @property diameter
                * @type number
                * @public
                */
                set: function (value) {
                    if (value > 0) {
                        this._diameter = value;
                        this._radius = value * 0.5;
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Circle.prototype, "radius", {
                get: function () {
                    return this._radius;
                },
                /**
                * The radius of the circle. The length of a line extending from the center of the circle to any point on the circle itself. The same as half the diameter.
                * @property radius
                * @type number
                * @public
                */
                set: function (value) {
                    if (value > 0) {
                        this._radius = value;
                        this._diameter = value * 2;
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Circle.prototype, "circumference", {
                /**
                * The circumference of the circle. This is READ ONLY.
                * @property circumference
                * @type number
                * @public
                */
                get: function () {
                    return 2 * (Math.PI * this._radius);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Circle.prototype, "bottom", {
                get: function () {
                    return this.y + this._radius;
                },
                /**
                * The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.
                * @property bottom
                * @type number
                * @public
                */
                set: function (value) {
                    if (!isNaN(value)) {
                        if (value < this.y) {
                            this._radius = 0;
                            this._diameter = 0;
                        } else {
                            this.radius = value - this.y;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Circle.prototype, "left", {
                get: function () {
                    return this.x - this._radius;
                },
                /**
                * The x coordinate of the leftmost point of the circle. Changing the left property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
                * @property left
                * @type number
                * @public
                */
                set: function (value) {
                    if (!isNaN(value)) {
                        if (value < this.x) {
                            this.radius = this.x - value;
                        } else {
                            this._radius = 0;
                            this._diameter = 0;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Circle.prototype, "right", {
                get: function () {
                    return this.x + this._radius;
                },
                /**
                * The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
                * @property right
                * @type number
                * @public
                */
                set: function (value) {
                    if (value && !isNaN(value)) {
                        if (value > this.x) {
                            this.radius = value - this.x;
                        } else {
                            this._radius = 0;
                            this._diameter = 0;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Circle.prototype, "top", {
                get: function () {
                    return this.y - this._radius;
                },
                /**
                * The sum of the y minus the radius property. Changing the top property of a Circle object has no effect on the x and y properties, but does change the diameter.
                * @property top
                * @type number
                * @public
                */
                set: function (value) {
                    if (value && !isNaN(value)) {
                        if (value > this.y) {
                            this._radius = 0;
                            this._diameter = 0;
                        } else {
                            this.radius = this.y - value;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Circle.prototype, "area", {
                /**
                * Gets the area of this Circle. Note this is READ ONLY.
                * @property area
                * @type number
                * @public
                */
                get: function () {
                    if (this._radius > 0) {
                        return Math.PI * this._radius * this._radius;
                    } else {
                        return 0;
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Circle.prototype, "isEmpty", {
                /**
                * Determines whether or not this Circle object is empty. This is READ ONLY.
                * @method isEmpty
                * @return {boolean} A value of true if the Circle objects diameter is less than or equal to 0; otherwise false.
                * @public
                */
                get: function () {
                    if (this._diameter <= 0) {
                        return true;
                    }

                    return false;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns a new Circle object with the same values for the x, y, width, and height properties as the original Circle object.
            * @method clone
            * @param [output = Circle] {Circle} If given the values will be set into the object, otherwise a brand new Circle object will be created and returned.
            * @return {Circle}
            * @public
            */
            Circle.prototype.clone = function (output) {
                if (typeof output === "undefined") { output = new Circle; }
                return output.setTo(this.x, this.y, this._diameter);
            };

            /**
            * Copies all of circle data from the source Circle object into the calling Circle object.
            * @method copyFrom
            * @param source {Circle} The source circle object to copy from
            * @return {Circle} This circle object
            * @public
            */
            Circle.prototype.copyFrom = function (source) {
                return this.setTo(source.x, source.y, source.diameter);
            };

            /**
            * Copies all of circle data from this Circle object into the destination Circle object.
            * @method copyTo
            * @param circle {Circle} The destination circle object to copy in to
            * @return {Circle} The destination circle object
            * @public
            */
            Circle.prototype.copyTo = function (target) {
                return target.copyFrom(this);
            };

            /**
            * Returns the distance from the center of this Circle object to the given object (can be Circle, Point or anything with x/y values)
            * @method distanceTo
            * @param target {Any} The destination Point object.
            * @param [round=false] {boolean} Round the distance to the nearest integer (default false)
            * @return {Number} The distance between this Point object and the destination Point object.
            * @public
            */
            Circle.prototype.distanceTo = function (target, round) {
                if (typeof round === "undefined") { round = false; }
                var dx = this.x - target.x;
                var dy = this.y - target.y;

                if (round === true) {
                    return Math.round(Math.sqrt(dx * dx + dy * dy));
                } else {
                    return Math.sqrt(dx * dx + dy * dy);
                }
            };

            /**
            * Determines whether the object specified in the toCompare parameter is equal to this Circle object. This method compares the x, y and diameter properties of an object against the same properties of this Circle object.
            * @method equals
            * @param toCompare {Circle} The circle to compare to this Circle object.
            * @return {boolean} A value of true if the object has exactly the same values for the x, y and diameter properties as this Circle object; otherwise false.
            * @public
            */
            Circle.prototype.equals = function (toCompare) {
                if (this.x === toCompare.x && this.y === toCompare.y && this.diameter === toCompare.diameter) {
                    return true;
                }

                return false;
            };

            /**
            * Determines whether the Circle object specified in the toIntersect parameter intersects with this Circle object. This method checks the radius distances between the two Circle objects to see if they intersect.
            * @method intersects
            * @param toIntersect {Circle} The Circle object to compare against to see if it intersects with this Circle object.
            * @return {boolean} A value of true if the specified object intersects with this Circle object; otherwise false.
            * @public
            */
            Circle.prototype.intersects = function (toIntersect) {
                if (this.distanceTo(toIntersect, false) < (this._radius + toIntersect._radius)) {
                    return true;
                }

                return false;
            };

            /**
            * Returns a Point object containing the coordinates of a point on the circumference of this Circle based on the given angle.
            * @method circumferencePoint
            * @param angle {Number} The angle in radians (unless asDegrees is true) to return the point from.
            * @param [asDegress=false] {boolean} Is the given angle in radians (false) or degrees (true)?
            * @param [point=Point] {Point} An optional Point object to put the result in to. If none specified a new Point object will be created.
            * @return {Point} The Point object holding the result.
            * @public
            */
            Circle.prototype.circumferencePoint = function (angle, asDegrees, output) {
                if (typeof asDegrees === "undefined") { asDegrees = false; }
                if (typeof output === "undefined") { output = new Kiwi.Geom.Point; }
                if (asDegrees === true) {
                    angle = angle * (Math.PI / 180); // Radians to Degrees
                    //angle = angle * (180 / Math.PI); // Degrees to Radians
                }

                output.x = this.x + this._radius * Math.cos(angle);
                output.y = this.y + this._radius * Math.sin(angle);

                return output;
            };

            /**
            * Adjusts the location of the Circle object, as determined by its center coordinate, by the specified amounts.
            * @method offset
            * @param dx {Number} Moves the x value of the Circle object by this amount.
            * @param dy {Number} Moves the y value of the Circle object by this amount.
            * @return {Circle} This Circle object.
            * @public
            */
            Circle.prototype.offset = function (dx, dy) {
                if (!isNaN(dx) && !isNaN(dy)) {
                    this.x += dx;
                    this.y += dy;
                }

                return this;
            };

            /**
            * Adjusts the location of the Circle object using a Point object as a parameter. This method is similar to the Circle.offset() method, except that it takes a Point object as a parameter.
            * @method offsetPoint
            * @param {Point} point A Point object to use to offset this Circle object.
            * @return {Circle} This Circle object.
            * @public
            */
            Circle.prototype.offsetPoint = function (point) {
                return this.offset(point.x, point.y);
            };

            /**
            * Sets the members of Circle to the specified values.
            * @method setTo
            * @param x {Number} The x coordinate of the center of the circle.
            * @param y {Number} The y coordinate of the center of the circle.
            * @param diameter {Number} The diameter of the circle in pixels.
            * @return {Circle} This circle object
            * @public
            */
            Circle.prototype.setTo = function (x, y, diameter) {
                this.x = x;
                this.y = y;
                this._diameter = diameter;
                this._radius = diameter * 0.5;

                return this;
            };

            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {string} a string representation of the instance.
            * @public
            */
            Circle.prototype.toString = function () {
                return "[{Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]";
            };
            return Circle;
        })();
        Geom.Circle = Circle;
    })(Kiwi.Geom || (Kiwi.Geom = {}));
    var Geom = Kiwi.Geom;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    (function (Geom) {
        /**
        * Represents a halfline. The ray starts at the first point and extends infinitely in the direction of the second.
        *
        * @class Ray
        * @namespace Kiwi.Geom
        * @constructor
        * @param [x1 = 0] {Number} x1
        * @param [y1 = 0] {Number} y1
        * @param [x2 = 0] {Number} x2
        * @param [y2 = 0] {Number} y2
        * @return {Ray} This Object
        *
        */
        var Ray = (function () {
            function Ray(x1, y1, x2, y2) {
                if (typeof x1 === "undefined") { x1 = 0; }
                if (typeof y1 === "undefined") { y1 = 0; }
                if (typeof x2 === "undefined") { x2 = 0; }
                if (typeof y2 === "undefined") { y2 = 0; }
                /**
                * The x component of the initial point of the ray
                * @property x1
                * @type Number
                * @public
                */
                this.x1 = 0;
                /**
                * The y component of the initial point of the ray
                * @property y1
                * @type Number
                * @public
                */
                this.y1 = 0;
                /**
                * The x component of the direction point of the ray
                * @property x2
                * @type Number
                * @public
                */
                this.x2 = 0;
                /**
                * The y component of the direction point of the ray
                * @property y2
                * @type Number
                * @public
                */
                this.y2 = 0;
                this.setTo(x1, y1, x2, y2);
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String}
            * @public
            */
            Ray.prototype.objType = function () {
                return "Ray";
            };

            /**
            * Makes a copy of this Ray either as a new Ray object or,
            * makes a passed Ray a copy of this one.
            * @method clone
            * @param [output = Ray] {Ray}
            * @return {Ray}
            * @public
            */
            Ray.prototype.clone = function (output) {
                if (typeof output === "undefined") { output = new Ray; }
                return output.setTo(this.x1, this.y1, this.x2, this.y2);
            };

            /**
            * Makes this Ray the same as a passed Ray.
            * @method copyFrom
            * @param source {Ray}
            * @return {Ray}
            * @public
            */
            Ray.prototype.copyFrom = function (source) {
                return this.setTo(source.x1, source.y1, source.x2, source.y2);
            };

            /**
            * Makes a passed Ray the same as this Ray object.
            * @method copyTo
            * @param target {Ray}
            * @return {Ray}
            * @public
            */
            Ray.prototype.copyTo = function (target) {
                return target.copyFrom(this);
            };

            /**
            * Sets the origin and the direction of this Ray.
            * @method setTo
            * @param x1{Number}
            * @param y1{Number}
            * @param x2{Number}
            * @param y2{Number}
            * @return {Ray}
            * @public
            */
            Ray.prototype.setTo = function (x1, y1, x2, y2) {
                if (typeof x1 === "undefined") { x1 = 0; }
                if (typeof y1 === "undefined") { y1 = 0; }
                if (typeof x2 === "undefined") { x2 = 0; }
                if (typeof y2 === "undefined") { y2 = 0; }
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;

                return this;
            };

            Object.defineProperty(Ray.prototype, "angle", {
                /**
                * Get the angle of the ray.
                * @property angle
                * @return {Number}
                * @public
                */
                get: function () {
                    return Math.atan2(this.x2 - this.x1, this.y2 - this.y1);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Ray.prototype, "slope", {
                /**
                * Get the slope of the ray.
                * @property slope
                * @return {Number}
                * @public
                */
                get: function () {
                    return (this.y2 - this.y1) / (this.x2 - this.x1);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Ray.prototype, "yIntercept", {
                /**
                *
                * @method yIntercept
                * @property yIntercept
                * @return {Number}
                * @public
                */
                get: function () {
                    return (this.y1 - this.slope * this.x1);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Check if the Ray passes through a point.
            * @method isPointOnRay
            * @param {Number} x
            * @param {Number} y
            * @return {boolean}
            */
            Ray.prototype.isPointOnRay = function (x, y) {
                if ((x - this.x1) * (this.y2 - this.y1) === (this.x2 - this.x1) * (y - this.y1)) {
                    if (Math.atan2(y - this.y1, x - this.x1) == Math.atan2(this.y2 - this.y1, this.x2 - this.x1)) {
                        return true;
                    }
                }

                return false;
            };

            /**
            * Get a string representation of the ray.
            * @method toString
            * @return {String}
            */
            Ray.prototype.toString = function () {
                return "[{Ray (x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " y2=" + this.y2 + ")}]";
            };
            return Ray;
        })();
        Geom.Ray = Ray;
    })(Kiwi.Geom || (Kiwi.Geom = {}));
    var Geom = Kiwi.Geom;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    (function (Geom) {
        /**
        * Contains a collection of STATIC methods to help determine and return intersection between geometric objects.
        *
        * @class Intersect
        * @namespace Kiwi.Geom
        * @static
        */
        var Intersect = (function () {
            function Intersect() {
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String}
            * @public
            */
            Intersect.prototype.objType = function () {
                return "Intersect";
            };

            /**
            * -------------------------------------------------------------------------------------------
            * Distance
            * -------------------------------------------------------------------------------------------
            **/
            /**
            * Returns the distance between two sets of coordinates that you specify.
            * @method distance
            * @param x1 {Number} The x position of the first coordinate.
            * @param y1 {Number} The y position of the first coordinate.
            * @param x2 {Number} The x position of the second coordinate.
            * @param y2 {Number} The y position of the second coordinate.
            * @return {Number} The distance between the two points.
            * @public
            * @static
            **/
            Intersect.distance = function (x1, y1, x2, y2) {
                return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            };

            /**
            * Returns the distance squared between two sets of coordinates that you specify.
            * @method distanceSquared
            * @param x1 {Number} The x position of the first coordinate.
            * @param y1 {Number} The y position of the first coordinate.
            * @param x2 {Number} The x position of the second coordinate.
            * @param y2 {Number} The y position of the second coordinate.
            * @return {Number} The distance between the two points squared.
            * @public
            * @static
            */
            Intersect.distanceSquared = function (x1, y1, x2, y2) {
                return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            };

            /**
            * -------------------------------------------------------------------------------------------
            * Lines
            * -------------------------------------------------------------------------------------------
            **/
            /**
            * Check to see if any two Lines intersect at any point.
            * Both lines are treated as if they extend infintely through space.
            * @method lineToLine
            * @param line1 {Line} The first line object to check
            * @param line2 {Line} The second line object to check
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in. (One is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y
            * @public
            * @static
            */
            Intersect.lineToLine = function (line1, line2, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                var denom = (line1.x1 - line1.x2) * (line2.y1 - line2.y2) - (line1.y1 - line1.y2) * (line2.x1 - line2.x2);

                if (denom !== 0) {
                    output.result = true;
                    output.x = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (line2.x1 - line2.x2) - (line1.x1 - line1.x2) * (line2.x1 * line2.y2 - line2.y1 * line2.x2)) / denom;
                    output.y = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (line2.y1 - line2.y2) - (line1.y1 - line1.y2) * (line2.x1 * line2.y2 - line2.y1 * line2.x2)) / denom;
                }

                return output;
            };

            /**
            * Check to see if a Line and a Line Segment intersect at any point.
            * Note: The first line passed is treated as if it extends infinately though space,
            * The second is treated as if it only exists between its two points.
            * @method lineToLineSegment
            * @param line1 {Line} The first line to check. This is the one that will extend through space infinately.
            * @param seg {Line} The second line to check. This is the one that will only exist between its two coordinates.
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection.
            * @public
            * @static
            */
            Intersect.lineToLineSegment = function (line1, seg, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                var denom = (line1.x1 - line1.x2) * (seg.y1 - seg.y2) - (line1.y1 - line1.y2) * (seg.x1 - seg.x2);

                if (denom !== 0) {
                    output.x = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (seg.x1 - seg.x2) - (line1.x1 - line1.x2) * (seg.x1 * seg.y2 - seg.y1 * seg.x2)) / denom;
                    output.y = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (seg.y1 - seg.y2) - (line1.y1 - line1.y2) * (seg.x1 * seg.y2 - seg.y1 * seg.x2)) / denom;

                    var maxX = Math.max(seg.x1, seg.x2);
                    var minX = Math.min(seg.x1, seg.x2);
                    var maxY = Math.max(seg.y1, seg.y2);
                    var minY = Math.min(seg.y1, seg.y2);

                    //if (!(output.x <= maxX && output.x >= minX) || !(output.y <= maxY && output.y >= minY))
                    if ((output.x <= maxX && output.x >= minX) === true || (output.y <= maxY && output.y >= minY) === true) {
                        output.result = true;
                    }
                }

                return output;
            };

            /**
            * Checks to see if a Line that is passed, intersects at any point another Line that is made by passing a set of coordinates to this method.
            * Note: The first line will extend infinately through space.
            * And the second line will only exist between the two points passed.
            * @method lineToRawSegment
            * @param line {Line} The line object that extends infinatly through space.
            * @param x1 {number} The x coordinate of the first point in the second line.
            * @param y1 {number} The y coordinate of the first point in the second line.
            * @param x2 {number} The x coordinate of the second point in the second line.
            * @param y2 {number} The y coordinate of the second point in the second line.
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y
            * @static
            * @public
            */
            Intersect.lineToRawSegment = function (line, x1, y1, x2, y2, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                var denom = (line.x1 - line.x2) * (y1 - y2) - (line.y1 - line.y2) * (x1 - x2);

                if (denom !== 0) {
                    output.x = ((line.x1 * line.y2 - line.y1 * line.x2) * (x1 - x2) - (line.x1 - line.x2) * (x1 * y2 - y1 * x2)) / denom;
                    output.y = ((line.x1 * line.y2 - line.y1 * line.x2) * (y1 - y2) - (line.y1 - line.y2) * (x1 * y2 - y1 * x2)) / denom;

                    var maxX = Math.max(x1, x2);
                    var minX = Math.min(x1, x2);
                    var maxY = Math.max(y1, y2);
                    var minY = Math.min(y1, y2);

                    if ((output.x <= maxX && output.x >= minX) === true || (output.y <= maxY && output.y >= minY) === true) {
                        output.result = true;
                    }
                }

                return output;
            };

            /**
            * Checks to see if a Line and Ray object intersects at any point.
            * Note: The line in this case extends infinately through space.
            * @method lineToRay
            * @param line1 {Line} The Line object that extends infinatly through space.
            * @param ray {Ray} The Ray object that you want to check it against.
            * @param {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y
            * @public
            * @static
            */
            Intersect.lineToRay = function (line1, ray, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                var denom = (line1.x1 - line1.x2) * (ray.y1 - ray.y2) - (line1.y1 - line1.y2) * (ray.x1 - ray.x2);

                if (denom !== 0) {
                    output.x = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (ray.x1 - ray.x2) - (line1.x1 - line1.x2) * (ray.x1 * ray.y2 - ray.y1 * ray.x2)) / denom;
                    output.y = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (ray.y1 - ray.y2) - (line1.y1 - line1.y2) * (ray.x1 * ray.y2 - ray.y1 * ray.x2)) / denom;
                    output.result = true; // true unless either of the 2 following conditions are met

                    if (!(ray.x1 >= ray.x2) && output.x < ray.x1) {
                        output.result = false;
                    }

                    if (!(ray.y1 >= ray.y2) && output.y < ray.y1) {
                        output.result = false;
                    }
                }

                return output;
            };

            /**
            * Checks to see if a Line and a Circle intersect at any point.
            * Note: The line passed is assumed to extend infinately through space.
            * @method lineToCircle
            * @param line {Line} The Line object that you want to check it against.
            * @param circle {Circle} The Circle object to check.
            * @param [output=Intersect] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.lineToCircle = function (line, circle, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                //  Get a perpendicular line running to the center of the circle
                if (line.perp(circle.x, circle.y).length <= circle.radius) {
                    output.result = true;
                }

                return output;
            };

            /**
            * Check if the Line intersects with each side of a Rectangle.
            * Note: The Line is assumned to extend infinately through space.
            * @method lineToRectangle
            * @param line {Line} The Line object to check
            * @param rectangle {Rectangle} The Rectangle object to check
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.lineToRectangle = function (line, rect, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                //  Top of the Rectangle vs the Line
                Intersect.lineToRawSegment(line, rect.x, rect.y, rect.right, rect.y, output);

                if (output.result === true) {
                    return output;
                }

                //  Left of the Rectangle vs the Line
                Intersect.lineToRawSegment(line, rect.x, rect.y, rect.x, rect.bottom, output);

                if (output.result === true) {
                    return output;
                }

                //  Bottom of the Rectangle vs the Line
                Intersect.lineToRawSegment(line, rect.x, rect.bottom, rect.right, rect.bottom, output);

                if (output.result === true) {
                    return output;
                }

                //  Right of the Rectangle vs the Line
                Intersect.lineToRawSegment(line, rect.right, rect.y, rect.right, rect.bottom, output);

                return output;
            };

            /**
            * -------------------------------------------------------------------------------------------
            * Line Segment
            * -------------------------------------------------------------------------------------------
            **/
            /**
            * Checks to see if two Line Segments intersect at any point in space.
            * Note: Both lines are treated as if they only exist between their two line coordinates.
            * @method lineSegmentToLineSegment
            * @param line1 {Line} The first line object to check.
            * @param line2 {Line} The second line object to check.
            * @param [output=IntersectResult]{IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y.
            * @public
            * @static
            */
            Intersect.lineSegmentToLineSegment = function (line1, line2, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                Intersect.lineToLineSegment(line1, line2, output);

                if (output.result === true) {
                    if (!(output.x >= Math.min(line1.x1, line1.x2) && output.x <= Math.max(line1.x1, line1.x2) && output.y >= Math.min(line1.y1, line1.y2) && output.y <= Math.max(line1.y1, line1.y2))) {
                        output.result = false;
                    }
                }

                return output;
            };

            /**
            * Check if the Line Segment intersects with the Ray.
            * Note: The Line only exists between its two points.
            * @method lineSegmentToRay
            * @param line1 {Line} The Line object to check.
            * @param ray {Line} The Ray object to check.
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection in x/y
            * @public
            * @static
            */
            Intersect.lineSegmentToRay = function (line1, ray, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                Intersect.lineToRay(line1, ray, output);

                if (output.result === true) {
                    if (!(output.x >= Math.min(line1.x1, line1.x2) && output.x <= Math.max(line1.x1, line1.x2) && output.y >= Math.min(line1.y1, line1.y2) && output.y <= Math.max(line1.y1, line1.y2))) {
                        output.result = false;
                    }
                }

                return output;
            };

            /**
            * Check if the Line Segment intersects with the Circle.
            * Note the Line only exists between its point points.
            * @method lineSegmentToCircle
            * @param seg {Line} The Line object to check
            * @param circle {Circle} The Circle object to check
            * @param [ouput=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y
            * @public
            * @static
            */
            Intersect.lineSegmentToCircle = function (seg, circle, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                var perp = seg.perp(circle.x, circle.y);

                if (perp.length <= circle.radius) {
                    //  Line intersects circle - check if segment does
                    var maxX = Math.max(seg.x1, seg.x2);
                    var minX = Math.min(seg.x1, seg.x2);
                    var maxY = Math.max(seg.y1, seg.y2);
                    var minY = Math.min(seg.y1, seg.y2);

                    if ((perp.x2 <= maxX && perp.x2 >= minX) && (perp.y2 <= maxY && perp.y2 >= minY)) {
                        output.result = true;
                    } else {
                        //  Worst case - segment doesn't traverse center, so no perpendicular connection.
                        if (Intersect.circleContainsPoint(circle, { x: seg.x1, y: seg.y1 }) || Intersect.circleContainsPoint(circle, { x: seg.x2, y: seg.y2 })) {
                            output.result = true;
                        }
                    }
                }

                return output;
            };

            /**
            * Check if the Line Segment intersects with any side of a Rectangle.
            * Note: The Line only exists between its two points.
            * @method lineSegmentToCircle
            * @param seg {Line} The Line object to check.
            * @param rect {Rectangle} The Rectangle object to check.
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given).
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y.
            * @public
            * @static
            */
            Intersect.lineSegmentToRectangle = function (seg, rect, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                if (rect.contains(seg.x1, seg.y1) && rect.contains(seg.x2, seg.y2)) {
                    output.result = true;
                } else {
                    //  Top of the Rectangle vs the Line
                    Intersect.lineToRawSegment(seg, rect.x, rect.y, rect.right, rect.bottom, output);

                    if (output.result === true) {
                        return output;
                    }

                    //  Left of the Rectangle vs the Line
                    Intersect.lineToRawSegment(seg, rect.x, rect.y, rect.x, rect.bottom, output);

                    if (output.result === true) {
                        return output;
                    }

                    //  Bottom of the Rectangle vs the Line
                    Intersect.lineToRawSegment(seg, rect.x, rect.bottom, rect.right, rect.bottom, output);

                    if (output.result === true) {
                        return output;
                    }

                    //  Right of the Rectangle vs the Line
                    Intersect.lineToRawSegment(seg, rect.right, rect.y, rect.right, rect.bottom, output);

                    return output;
                }

                return output;
            };

            /**
            * -------------------------------------------------------------------------------------------
            * Ray
            * -------------------------------------------------------------------------------------------
            **/
            /**
            * Check to see if a Ray intersects at any point with a Rectangle.
            * @method rayToRectangle
            * @param ray {Ray} The Ray object to check.
            * @param rect {Rectangle} The Rectangle to check.
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.rayToRectangle = function (ray, rect, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                //  Currently just finds first intersection - might not be closest to ray pt1
                Intersect.lineToRectangle(ray, rect, output);

                return output;
            };

            /**
            * Check whether a Ray intersects a Line segment, returns the parametric value where the intersection occurs.
            * Note: The Line only exists between its two points.
            * @method rayToLineSegment
            * @static
            * @param rayx1 {Number} The origin point of the ray on the x axis.
            * @param rayy1 {Number} The origin point of the ray on the y axis.
            * @param rayx2 {Number} The direction of the ray on the x axis.
            * @param rayy2 {Number} The direction of the ray on the y axis.
            * @param linex1 {Number} The x of the first point of the line segment.
            * @param liney1 {Number} The y of the first point of the line segment.
            * @param linex2 {Number} The x of the second point of the line segment.
            * @param liney2 {Number} The y of the second point of the line segment.
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection stored in x
            * @public
            */
            Intersect.rayToLineSegment = function (rayx1, rayy1, rayx2, rayy2, linex1, liney1, linex2, liney2, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                var r, s, d;

                // Check lines are not parallel
                if ((rayy2 - rayy1) / (rayx2 - rayx1) != (liney2 - liney1) / (linex2 - linex1)) {
                    d = (((rayx2 - rayx1) * (liney2 - liney1)) - (rayy2 - rayy1) * (linex2 - linex1));

                    if (d != 0) {
                        r = (((rayy1 - liney1) * (linex2 - linex1)) - (rayx1 - linex1) * (liney2 - liney1)) / d;
                        s = (((rayy1 - liney1) * (rayx2 - rayx1)) - (rayx1 - linex1) * (rayy2 - rayy1)) / d;

                        if (r >= 0) {
                            if (s >= 0 && s <= 1) {
                                output.result = true;
                                output.x = rayx1 + r * (rayx2 - rayx1), rayy1 + r * (rayy2 - rayy1);
                            }
                        }
                    }
                }

                return output;
            };

            /**
            * -------------------------------------------------------------------------------------------
            * Circle
            * -------------------------------------------------------------------------------------------
            **/
            /**
            * Check if the two given Circle objects intersect at any point.
            * @method circleToCircle
            * @param circle1 {Circle} The first circle object to check.
            * @param circle2 {Circle} The second circle object to check.
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.circleToCircle = function (circle1, circle2, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                output.result = ((circle1.radius + circle2.radius) * (circle1.radius + circle2.radius)) >= Intersect.distanceSquared(circle1.x, circle1.y, circle2.x, circle2.y);

                return output;
            };

            /**
            * Check if a Circle and a Rectangle intersect with each other at any point.
            * @method circleToRectangle
            * @param circle {Circle} The circle object to check.
            * @param rect {Rectangle} The Rectangle object to check.
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.circleToRectangle = function (circle, rect, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                var inflatedRect = rect.clone();

                inflatedRect.inflate(circle.radius, circle.radius);

                output.result = inflatedRect.contains(circle.x, circle.y);

                return output;
            };

            /**
            * Check if the given Point is found within the given Circle.
            * @method circleContainsPoint
            * @param circle {Circle} The circle object to check
            * @param point {Point} The point object to check
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.circleContainsPoint = function (circle, point, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                output.result = circle.radius * circle.radius >= Intersect.distanceSquared(circle.x, circle.y, point.x, point.y);

                return output;
            };

            /**
            * -------------------------------------------------------------------------------------------
            * Rectangles
            * -------------------------------------------------------------------------------------------
            **/
            /**
            * Determines whether the specified point is contained within a given Rectangle object.
            * @method pointToRectangle
            * @param point {Point} The point object being checked.
            * @param rect {Rectangle} The rectangle object being checked.
            * @param [output=Intersect] {IntersectResult}  An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y/result
            * @public
            * @static
            */
            Intersect.pointToRectangle = function (point, rect, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                output.setTo(point.x, point.y);

                output.result = rect.containsPoint(point);

                return output;
            };

            /**
            * Check whether two axis aligned rectangles intersect. Return the intersecting rectangle dimensions if they do.
            * @method rectangleToRectangle
            * @param rect1 {Rectangle} The first Rectangle object.
            * @param rect2 {Rectangle} The second Rectangle object.
            * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
            * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y/width/height
            * @public
            * @static
            */
            Intersect.rectangleToRectangle = function (rect1, rect2, output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.IntersectResult; }
                var leftX = Math.max(rect1.x, rect2.x);
                var rightX = Math.min(rect1.right, rect2.right);
                var topY = Math.max(rect1.y, rect2.y);
                var bottomY = Math.min(rect1.bottom, rect2.bottom);

                output.setTo(leftX, topY, rightX - leftX, bottomY - topY, rightX - leftX, bottomY - topY);

                var cx = output.x + output.width * .5;
                var cy = output.y + output.height * .5;

                if ((cx > rect1.x && cx < rect1.right) && (cy > rect1.y && cy < rect1.bottom)) {
                    output.result = true;
                }

                return output;
            };
            return Intersect;
        })();
        Geom.Intersect = Intersect;
    })(Kiwi.Geom || (Kiwi.Geom = {}));
    var Geom = Kiwi.Geom;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    (function (Geom) {
        /**
        * A Lightweight object to hold the results of an Intersection.
        * Used in combination with the STATIC methods on the Intersect class.
        *
        * @class IntersectResult
        * @namespace Kiwi.Geom
        * @constructor
        */
        var IntersectResult = (function () {
            function IntersectResult() {
                /**
                * Holds the result of an Intersection between two geometric items.
                * TRUE means an Intersection did occur and FALSE means not.
                * @property result
                * @type boolean
                * @default false
                */
                this.result = false;
            }
            /**
            * The type of object this is.
            * @method objType
            * @return {String}
            * @public
            */
            IntersectResult.prototype.objType = function () {
                return "IntersectResult";
            };

            /**
            * Sets the coordinates of the points based on the parameters passed.
            * @method setTo
            * @param {Number} x1
            * @param {Number} y1
            * @param {Number} [x2=0]
            * @param {Number} [y2=0]
            * @param {Number} [width=0]
            * @param {Number} [height=0]
            */
            IntersectResult.prototype.setTo = function (x1, y1, x2, y2, width, height) {
                if (typeof x2 === "undefined") { x2 = 0; }
                if (typeof y2 === "undefined") { y2 = 0; }
                if (typeof width === "undefined") { width = 0; }
                if (typeof height === "undefined") { height = 0; }
                this.x = x1;
                this.y = y1;

                this.x1 = x1;
                this.y1 = y1;

                this.x2 = x2;
                this.y2 = y2;

                this.width = width;
                this.height = height;
            };
            return IntersectResult;
        })();
        Geom.IntersectResult = IntersectResult;
    })(Kiwi.Geom || (Kiwi.Geom = {}));
    var Geom = Kiwi.Geom;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    (function (Geom) {
        /**
        * A Kiwi Line object has two meanings depending on the situation you need.
        * Either an infinte line through space (this is the normal meaning of a Line)
        * OR it can be a Line Segment which just exists between the TWO points you specify.
        *
        * @class Line
        * @namespace Kiwi.Geom
        * @constructor
        * @param [x1 = 0] {Number} x1 x component of first point.
        * @param [y1 = 0]{Number} y1 y component of first point.
        * @param [x2 = 0]{Number} x2 x component of second point.
        * @param [y2 = 0]{Number} y2 y component of second point.
        * @return {Line} This Object
        *
        */
        var Line = (function () {
            function Line(x1, y1, x2, y2) {
                if (typeof x1 === "undefined") { x1 = 0; }
                if (typeof y1 === "undefined") { y1 = 0; }
                if (typeof x2 === "undefined") { x2 = 0; }
                if (typeof y2 === "undefined") { y2 = 0; }
                /**
                * X position of first point in your line.
                * @property x1
                * @type Number
                * @public
                */
                this.x1 = 0;
                /**
                * Y position of first point in your line.
                * @property y1
                * @type Number
                * @public
                */
                this.y1 = 0;
                /**
                * x component of second point.
                * @property x2
                * @type Number
                * @public
                */
                this.x2 = 0;
                /**
                * y component of second point.
                * @property y2
                * @type Number
                * @public
                */
                this.y2 = 0;
                this.setTo(x1, y1, x2, y2);
            }
            /**
            * Returns the type of this object
            * @method objType
            * @return {string} The type of this object
            * @public
            */
            Line.prototype.objType = function () {
                return "Line";
            };

            /**
            * Makes a clone of this Line.
            * The clone will either be a new Line Object,
            * Otherwise you can pass a existing Line Object that you want to be a clone of this one.
            * @method clone
            * @param [output = Line] {Line}
            * @return {Line}
            * @public
            */
            Line.prototype.clone = function (output) {
                if (typeof output === "undefined") { output = new Line; }
                return output.setTo(this.x1, this.y1, this.x2, this.y2);
            };

            /**
            * Make this Line a copy of another passed Line.
            * @method copyFrom
            * @param source {Line} source
            * @return {Line}
            * @public
            */
            Line.prototype.copyFrom = function (source) {
                return this.setTo(source.x1, source.y1, source.x2, source.y2);
            };

            /**
            * Make another passed Line a copy of this one.
            * @method copyTo
            * @param target {Line} target
            * @return {Line}
            * @public
            */
            Line.prototype.copyTo = function (target) {
                return target.copyFrom(this);
            };

            /**
            * Used to set all components on the line.
            * @method setTo
            * @param [x1 = 0]{Number} X component of first point.
            * @param [y1 = 0]{Number} Y component of first point.
            * @param [x2 = 0]{Number} X component of second point.
            * @param [y2 = 0]{Number} Y component of second point.
            * @return {Line}
            * @public
            */
            Line.prototype.setTo = function (x1, y1, x2, y2) {
                if (typeof x1 === "undefined") { x1 = 0; }
                if (typeof y1 === "undefined") { y1 = 0; }
                if (typeof x2 === "undefined") { x2 = 0; }
                if (typeof y2 === "undefined") { y2 = 0; }
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;

                return this;
            };

            Object.defineProperty(Line.prototype, "length", {
                /**
                * Get the length of the Line as a Line Segment.
                * @property length
                * @type number
                * @public
                */
                get: function () {
                    return Math.sqrt((this.x2 - this.x1) * (this.x2 - this.x1) + (this.y2 - this.y1) * (this.y2 - this.y1));
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Get the y of a point on the line for a given x.
            * @method getY
            * @param {Number} x
            * @return {Number}
            * @public
            */
            Line.prototype.getY = function (x) {
                if (this.x1 == this.x2)
                    return null;
                else
                    return this.slope * x + this.yIntercept;
            };

            Object.defineProperty(Line.prototype, "angle", {
                /**
                * Get the angle of the line.
                * @property angle
                * @return {Number}
                */
                get: function () {
                    return Math.atan2(this.x2 - this.x1, this.y2 - this.y1);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Line.prototype, "slope", {
                /**
                * Get the slope of the line (y/x).
                * @property slope
                * @return {Number}
                * @public
                */
                get: function () {
                    return (this.y2 - this.y1) / (this.x2 - this.x1);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Line.prototype, "perpSlope", {
                /**
                * Get the perpendicular slope of the line (x/y).
                * @propery perpSlope
                * @return {Number}
                * @public
                */
                get: function () {
                    return -((this.x2 - this.x1) / (this.y2 - this.y1));
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Line.prototype, "yIntercept", {
                /**
                * Get the y intercept for the line.
                * @property yIntercept
                * @return {Number}
                * @property
                */
                get: function () {
                    return (this.y1 - this.slope * this.x1);
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Check if a point is on the line.
            * @method isPointOnLine
            * @param x {Number}
            * @param y {Number}
            * @return {boolean}
            * @public
            */
            Line.prototype.isPointOnLine = function (x, y) {
                if ((x - this.x1) * (this.y2 - this.y1) === (this.x2 - this.x1) * (y - this.y1)) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Check if the point is both on the line and within the line segment.
            * @method isPointOnLineSegment
            * @param {Number} x
            * @param {Number} y
            * @return {boolean}
            * @public
            */
            Line.prototype.isPointOnLineSegment = function (x, y) {
                var xMin = Math.min(this.x1, this.x2);
                var xMax = Math.max(this.x1, this.x2);
                var yMin = Math.min(this.y1, this.y2);
                var yMax = Math.max(this.y1, this.y2);

                if (this.isPointOnLine(x, y) && (x >= xMin && x <= xMax) && (y >= yMin && y <= yMax)) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Check to see if this Line object intersects at any point with a passed Line.
            * Note: Both are treated as extending infinately through space.
            * @method intersectLineLine
            * @param line {Line} The line you want to check for a Intersection with.
            * @return {IntersectResult} The Intersect Result containing the collision information.
            * @public
            */
            Line.prototype.intersectLineLine = function (line) {
                return Kiwi.Geom.Intersect.lineToLine(this, line);
            };

            /**
            * Get a line perpendicular to the line passing through a given point.
            * @method perp
            * @param x {Number}
            * @param y {Number}
            * @param [output = Line] {Line}
            * @return {Line}
            * @public
            */
            Line.prototype.perp = function (x, y, output) {
                if (this.y1 === this.y2) {
                    if (output) {
                        output.setTo(x, y, x, this.y1);
                    } else {
                        return new Line(x, y, x, this.y1);
                    }
                }

                var yInt = (y - this.perpSlope * x);

                var pt = this.intersectLineLine({ x1: x, y1: y, x2: 0, y2: yInt });

                if (output) {
                    output.setTo(x, y, pt.x, pt.y);
                } else {
                    return new Line(x, y, pt.x, pt.y);
                }
            };

            /**
            * Get a string representation of the line.
            * @method toString
            * @return {String}
            * @public
            */
            Line.prototype.toString = function () {
                return "[{Line (x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " y2=" + this.y2 + ")}]";
            };
            return Line;
        })();
        Geom.Line = Line;
    })(Kiwi.Geom || (Kiwi.Geom = {}));
    var Geom = Kiwi.Geom;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    (function (Geom) {
        /**
        * Represents a 2d transformation matrix. This can be used to map points between different coordinate spaces. Matrices are used
        * by Transform objects to represent translation, scale and rotation transformations, and to determine where objects are in world space or camera space.
        * Objects such as entities and groups may be nested, and their associated transforms may represent how they are scaled, translated and rotated relative to a parent
        * transform.
        * By concatenating an object's transformatkion matrix with it's ancestors matrices, it is possible to determine the absolute position of the object in world space.
        * See http://en.wikipedia.org/wiki/Transformation_matrix#Examples_in_2D_graphics for an in depth discussion of 2d tranformation matrices.
        *
        * @class Matrix
        * @namespace Kiwi.Geom
        * @constructor
        * @param [a = 1] {Number}  position 0,0 of the matrix, affects scaling and rotation.
        * @param [b = 0] {Number}  position 0,1 of the matrix, affects scaling and rotation.
        * @param [c = 0] {Number}  position 1,0 of the matrix, affects scaling and rotation.
        * @param [d = 1] {Number}  position 1,1 of the matrix, affects scaling and rotation.
        * @param [tx = 0] {Number}  position 2,0 of the matrix, affects translation on x axis.
        * @param [ty = 0] {Number}  position 2,1 of the matrix, affects translation on y axis.
        * @return (Object) This object.
        *
        */
        var Matrix = (function () {
            function Matrix(a, b, c, d, tx, ty) {
                if (typeof a === "undefined") { a = 1; }
                if (typeof b === "undefined") { b = 0; }
                if (typeof c === "undefined") { c = 0; }
                if (typeof d === "undefined") { d = 1; }
                if (typeof tx === "undefined") { tx = 0; }
                if (typeof ty === "undefined") { ty = 0; }
                this.a = 1;
                this.b = 0;
                this.c = 0;
                this.d = 1;
                this.tx = 0;
                this.ty = 0;
                this.setTo(a, b, c, d, tx, ty);
            }
            Matrix.prototype.objType = function () {
                return "Matrix";
            };

            /**
            * Set all matrix values
            * @method setTo
            * @param [a = 1] {Number} position 0,0 of the matrix, affects scaling and rotation.
            * @param [b = 0] {Number} position 0,1 of the matrix, affects scaling and rotation.
            * @param [c = 0] {Number} position 1,0 of the matrix, affects scaling and rotation.
            * @param [d = 1] {Number} position 1,1 of the matrix, affects scaling and rotation.
            * @param [tx = 0] {Number} position 2,0 of the matrix, affects translation on x axis.
            * @param [ty = 0] {Number} position 2,1 of the matrix, affects translation on y axis.
            * @return (Object) This object.
            */
            Matrix.prototype.setTo = function (a, b, c, d, tx, ty) {
                if (typeof a === "undefined") { a = 1; }
                if (typeof b === "undefined") { b = 0; }
                if (typeof c === "undefined") { c = 0; }
                if (typeof d === "undefined") { d = 1; }
                if (typeof tx === "undefined") { tx = 0; }
                if (typeof ty === "undefined") { ty = 0; }
                this.a = a;
                this.b = b;
                this.c = c;
                this.d = d;
                this.tx = tx;
                this.ty = ty;

                return this;
            };

            /**
            * Set matrix values from transform values
            * @method setFromTransform
            * @Param tx {Number} tx. Translation on x axis.
            * @Param ty {Number} ty. Translation on y axis.
            * @Param scaleX {Number} scaleX. Scale on x axis.
            * @Param scaleY {Number} scaleY. Scale on y axis.
            * @Param rotation {Number} rotation.
            * @return {Object} This object.
            */
            Matrix.prototype.setFromTransform = function (tx, ty, scaleX, scaleY, rotation) {
                this.identity();
                var cos = Math.cos(rotation);
                var sin = Math.sin(rotation);

                this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, tx, ty);

                return this;
            };

            /**
            * Prepend values to this matrix, paramters supplied individually.
            * @method prepend
            * @param [a = 1]{Number} position 0,0 of the matrix, affects scaling and rotation.
            * @param [b = 0]{Number} position 0,1 of the matrix, affects scaling and rotation.
            * @param [c = 0]{Number} position 1,0 of the matrix, affects scaling and rotation.
            * @param [d = 0]{Number} position 1,1 of the matrix, affects scaling and rotation.
            * @param [tx = 0]{Number} position 2,0 of the matrix, affects translation on x axis.
            * @param [ty = 0]{Number} position 2,1 of the matrix, affects translation on y axis.
            * @return {Object} This object.
            */
            Matrix.prototype.prepend = function (a, b, c, d, tx, ty) {
                if (typeof a === "undefined") { a = 1; }
                if (typeof b === "undefined") { b = 0; }
                if (typeof c === "undefined") { c = 0; }
                if (typeof d === "undefined") { d = 1; }
                if (typeof tx === "undefined") { tx = 0; }
                if (typeof ty === "undefined") { ty = 0; }
                var tx1 = this.tx;
                var a1 = this.a;
                var c1 = this.c;

                this.a = a1 * a + this.b * c;
                this.b = a1 * b + this.b * d;
                this.c = c1 * a + this.d * c;
                this.d = c1 * b + this.d * d;

                this.tx = tx1 * a + this.ty * c + tx;
                this.ty = tx1 * b + this.ty * d + ty;
                return this;
            };

            /**
            * Prepend a matrix to this matrix.
            * @method prependMatrix
            * @param {Object} m. The matrix to prepend.
            * @return {Object} This object.
            */
            Matrix.prototype.prependMatrix = function (m) {
                var tx1 = this.tx;
                var a1 = this.a;
                var c1 = this.c;

                this.a = a1 * m.a + this.b * m.c;
                this.b = a1 * m.b + this.b * m.d;
                this.c = c1 * m.a + this.d * m.c;
                this.d = c1 * m.b + this.d * m.d;

                this.tx = tx1 * m.a + this.ty * m.c + m.tx;
                this.ty = tx1 * m.b + this.ty * m.d + m.ty;
                return this;
            };

            /**
            * Append values to this matrix, paramters supplied individually.
            * @method append
            * @param [a = 1]{Number} position 0,0 of the matrix, affects scaling and rotation.
            * @param [b = 0]{Number} position 0,1 of the matrix, affects scaling and rotation.
            * @param [c = 0]{Number} position 1,0 of the matrix, affects scaling and rotation.
            * @param [d = 1]{Number} position 1,1 of the matrix, affects scaling and rotation.
            * @param [tx = 0]{Number} position 2,0 of the matrix, affects translation on x axis.
            * @param [ty = 0]{Number} position 2,1 of the matrix, affects translation on y axis.
            * @return {Object} This object.
            */
            Matrix.prototype.append = function (a, b, c, d, tx, ty) {
                if (typeof a === "undefined") { a = 1; }
                if (typeof b === "undefined") { b = 0; }
                if (typeof c === "undefined") { c = 0; }
                if (typeof d === "undefined") { d = 1; }
                if (typeof tx === "undefined") { tx = 0; }
                if (typeof ty === "undefined") { ty = 0; }
                var a1 = this.a;
                var b1 = this.b;
                var c1 = this.c;
                var d1 = this.d;

                this.a = a * a1 + b * c1;
                this.b = a * b1 + b * d1;
                this.c = c * a1 + d * c1;
                this.d = c * b1 + d * d1;
                this.tx = tx * a1 + ty * c1 + this.tx;
                this.ty = tx * b1 + ty * d1 + this.ty;
                return this;
            };

            /**
            * Append a matrix to this matrix.
            * @method appendMatrix
            * @param m {Object} The matrix to append.
            * @return {Object} This object.
            */
            Matrix.prototype.appendMatrix = function (m) {
                var a1 = this.a;
                var b1 = this.b;
                var c1 = this.c;
                var d1 = this.d;

                this.a = m.a * a1 + m.b * c1;
                this.b = m.a * b1 + m.b * d1;
                this.c = m.c * a1 + m.d * c1;
                this.d = m.c * b1 + m.d * d1;
                this.tx = m.tx * a1 + m.ty * c1 + this.tx;
                this.ty = m.tx * b1 + m.ty * d1 + this.ty;
                return this;
            };

            /**
            * Set the tx and ty elements of the matrix
            * @method setPosition
            * @param x {Number} Translation on x axis.
            * @param y {Number} Translation on y axis.
            * @return  {Object} This object.
            */
            Matrix.prototype.setPosition = function (x, y) {
                this.tx = x;
                this.ty = y;
                return this;
            };

            /**
            * Set the tx and ty elements of the matrix from an object with x and y properties.
            * @method setPositionVector
            * @param p {Number} The object from which to copy the x and y properties from.
            * @return  {Object} This object.
            */
            Matrix.prototype.setPositionPoint = function (p) {
                this.tx = p.x;
                this.ty = p.y;
                return this;
            };

            /**
            * Get the x and y position of the matrix as an object with x and y properties
            * @method setPositionVector
            * @return {Object} An object constructed from a literal with x and y properties.
            */
            Matrix.prototype.getPosition = function (output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.Point; }
                return output.setTo(this.tx, this.ty);
            };

            /**
            * Set the matrix to the identity matrix - when appending or prepending this matrix to another there will be no change in the resulting matrix
            * @method identity
            * @return {Object} This object.
            */
            Matrix.prototype.identity = function () {
                this.a = 1;
                this.b = 0;
                this.c = 0;
                this.d = 1;
                this.tx = 0;
                this.ty = 0;
                return this;
            };

            /**
            * Rotate the matrix by "radians" degrees
            * @method rotate
            * @param radians{Number} radians.
            * @return {Object} This object.
            */
            Matrix.prototype.rotate = function (radians) {
                var cos = Math.cos(radians);
                var sin = Math.sin(radians);

                var a1 = this.a;
                var c1 = this.c;
                var tx1 = this.tx;

                this.a = a1 * cos - this.b * sin;
                this.b = a1 * sin + this.b * cos;
                this.c = c1 * cos - this.d * sin;
                this.d = c1 * sin + this.d * cos;
                this.tx = tx1 * cos - this.ty * sin;
                this.ty = tx1 * sin + this.ty * cos;
                return this;
            };

            /**
            * Translate the matrix
            * @method transalte
            * @Param tx {Number} tx. The amount to translate on the x axis.
            * @Param ty {Number} ty. The amount to translate on the y axis.
            * @return {Object} This object.
            */
            Matrix.prototype.translate = function (tx, ty) {
                this.tx += tx;
                this.ty += ty;
                return this;
            };

            /**
            * Scale the matrix
            * @method scale
            * @Param {Number} scaleX. The amount to scale on the x axis.
            * @Param {Number} scaleY. The amount to scale on the y axis.
            * @return {Object} This object.
            */
            Matrix.prototype.scale = function (scaleX, scaleY) {
                this.a *= scaleX;
                this.d *= scaleY;
                return this;
            };

            /**
            * Apply this matrix to a an object with x and y properties representing a point and return the transformed point.
            * @method transformPoint
            * @param pt {Object} The point to be translated.
            * @return {Object} The translated point.
            */
            Matrix.prototype.transformPoint = function (pt) {
                var x = pt.x;
                var y = pt.y;
                pt.x = this.a * x + this.c * y + this.tx;
                pt.y = this.b * x + this.d * y + this.ty;
                return pt;
            };

            /**
            * Invert this matrix so that it represents the opposite of it's orginal tranformaation.
            * @method transformPoint
            * @return {Object} This object.
            */
            Matrix.prototype.invert = function () {
                var a1 = this.a;
                var b1 = this.b;
                var c1 = this.c;
                var d1 = this.d;
                var tx1 = this.tx;
                var n = a1 * d1 - b1 * c1;

                this.a = d1 / n;
                this.b = -b1 / n;
                this.c = -c1 / n;
                this.d = a1 / n;
                this.tx = (c1 * this.ty - d1 * tx1) / n;
                this.ty = -(a1 * this.ty - b1 * tx1) / n;
                return this;
            };

            /**
            * Copy another matrix to this matrix.
            * @method copyFrom
            * @param m {Object} The matrixto be copied from.
            * @return {Object} This object.
            */
            Matrix.prototype.copyFrom = function (m) {
                this.a = m.a;
                this.b = m.b;
                this.c = m.c;
                this.d = m.d;
                this.tx = m.tx;
                this.ty = m.ty;

                return this;
            };

            /**
            * Copy this matrix to another matrix.
            * @method copyTo
            * @param m {Object} The matrix to copy to.
            * @return {Object} This object.
            */
            Matrix.prototype.copyTo = function (m) {
                m.a = this.a;
                m.b = this.b;
                m.c = this.c;
                m.d = this.d;
                m.tx = this.tx;
                m.ty = this.ty;
                return this;
            };

            /**
            * Clone this matrix
            * @method clone
            * @return {Object} The new clone of this matrix.
            */
            Matrix.prototype.clone = function () {
                return new Kiwi.Geom.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
            };

            Object.defineProperty(Matrix.prototype, "toString", {
                /**
                * Returns a string representation of this object.
                * @method toString
                * @return {string} a string representation of the instance.
                **/
                get: function () {
                    return "[{Matrix (a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + ")}]";
                },
                enumerable: true,
                configurable: true
            });
            return Matrix;
        })();
        Geom.Matrix = Matrix;
    })(Kiwi.Geom || (Kiwi.Geom = {}));
    var Geom = Kiwi.Geom;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    (function (Geom) {
        /**
        * Represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.
        *
        * @class Point
        * @constructor
        * @namespace Kiwi.Geom
        * @param x {Number} x One-liner. Default is ?.
        * @param y {Number} y One-liner. Default is ?.
        *
        */
        var Point = (function () {
            function Point(x, y) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                this.setTo(x, y);
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String}
            * @public
            */
            Point.prototype.objType = function () {
                return "Point";
            };

            /**
            * Converts a pair of polar coordinates to a Cartesian point coordinate and sets them on the point instance.
            * @method polar
            * @param length {Number}  The length coordinate of the polar pair.
            * @param angle {Number}  The angle, in radians, of the polar pair.
            * @return {Point} The new Cartesian Point object.
            * @public
            **/
            Point.prototype.polar = function (distance, angle) {
                this.x = distance * Math.cos(angle * Math.PI / 180);
                this.y = distance * Math.sin(angle * Math.PI / 180);
                return this;
            };

            /**
            * Adds the coordinates of another point to the coordinates of this point to create a new point.
            * @method add
            * @param toAdd {Point}  - The point to be added.
            * @param output {Point}
            * @return {Point} The new Point object.
            * @public
            **/
            Point.prototype.add = function (toAdd, output) {
                if (typeof output === "undefined") { output = new Point; }
                return output.setTo(this.x + toAdd.x, this.y + toAdd.y);
            };

            /**
            * Adds the given values to the coordinates of this point and returns it
            * @method addTo
            * @param x {Number} - The amount to add to the x value of the point
            * @param y {Number} - The amount to add to the x value of the point
            * @return {Point} This Point object.
            * @public
            **/
            Point.prototype.addTo = function (x, y) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                return this.setTo(this.x + x, this.y + y);
            };

            /**
            * Adds the given values to the coordinates of this point and returns it
            * @method subtractFrom
            * @param x {Number} - The amount to subtract from the x value of the point
            * @param y {Number} - The amount to subtract from the x value of the point
            * @return {Point} This Point object.
            * @public
            **/
            Point.prototype.subtractFrom = function (x, y) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                return this.setTo(this.x - x, this.y - y);
            };

            /**
            * Inverts the x and y values of this point
            * @method invert
            * @return {Point} This Point object.
            * @public
            **/
            Point.prototype.invert = function () {
                return this.setTo(this.y, this.x);
            };

            /**
            * Clamps this Point object to be between the given min and max
            * @method clamp
            * @param min {number} The minimum value to clamp this Point to
            * @param max {number} The maximum value to clamp this Point to
            * @return {Point} This Point object.
            * @public
            **/
            Point.prototype.clamp = function (min, max) {
                this.clampX(min, max);
                this.clampY(min, max);
                return this;
            };

            /**
            * Clamps the x value of this Point object to be between the given min and max
            * @method clampX
            * @param min {Number} The minimum value to clamp this Point to
            * @param max {Number} The maximum value to clamp this Point to
            * @return {Point} This Point object.
            * @public
            **/
            Point.prototype.clampX = function (min, max) {
                this.x = Math.max(Math.min(this.x, max), min);

                return this;
            };

            /**
            * Clamps the y value of this Point object to be between the given min and max
            * @method clampY
            * @param min {Number} The minimum value to clamp this Point to
            * @param max {Number} The maximum value to clamp this Point to
            * @return {Point} This Point object.
            * @public
            **/
            Point.prototype.clampY = function (min, max) {
                this.x = Math.max(Math.min(this.x, max), min);
                this.y = Math.max(Math.min(this.y, max), min);

                return this;
            };

            /**
            * Creates a copy of this Point.
            * @method clone
            * @param [output = Point]{Point} Optional Point object. If given the values will be set into this object, otherwise a brand new Point object will be created and returned.
            * @return {Point} The new Point object.
            * @public
            **/
            Point.prototype.clone = function (output) {
                if (typeof output === "undefined") { output = new Point; }
                return output.setTo(this.x, this.y);
            };

            /**
            * Copies the point data from the source Point object into this Point object.
            * @method copyFrom
            * @param source {Point} The point to copy from.
            * @return {Point} This Point object. Useful for chaining method calls.
            **/
            Point.prototype.copyFrom = function (source) {
                return this.setTo(source.x, source.y);
            };

            /**
            * Copies the point data from this Point object to the given target Point object.
            * @method copyTo
            * @param target {Point} target - The point to copy to.
            * @return {Point} The target Point object.
            **/
            Point.prototype.copyTo = function (target) {
                return target.setTo(this.x, this.y);
            };

            /**
            * Returns the distance from this Point object to the given Point object.
            * @method distanceTo
            * @param target {Point} The destination Point object.
            * @param round {boolean} Round the distance to the nearest integer (default false)
            * @return {Number} The distance between this Point object and the destination Point object.
            * @public
            **/
            /**
            * Get the angle from this Point object to given Point object.
            * @method angleTo
            * @param target {point} destination Point object.
            * @return {Number} angle to point
            * @public
            */
            Point.prototype.angleTo = function (target) {
                return Math.atan2(target.x - this.x, target.y - this.y);
            };

            /**
            * Get the angle from this Point object to given X,Y coordinates.
            * @method angleTo
            * @param x {number} x value.
            * @param y {number} y value.
            * @return {Number} angle to point.
            */
            Point.prototype.angleToXY = function (x, y) {
                return Math.atan2(x - this.x, y - this.y);
            };
            Point.prototype.distanceTo = function (target, round) {
                if (typeof round === "undefined") { round = false; }
                var dx = this.x - target.x;
                var dy = this.y - target.y;

                if (round === true) {
                    return Math.round(Math.sqrt(dx * dx + dy * dy));
                } else {
                    return Math.sqrt(dx * dx + dy * dy);
                }
            };

            /**
            * Returns the distance from this Point object to the given Point object.
            * @method distanceToXY
            * @param x {Number} x - The x value.
            * @param y {Number} y - The y value.
            * @param [round = Boolean] {boolean} round - Round the distance to the nearest integer (default false)
            * @return {Number} The distance between this Point object and the x/y values.
            * @public
            **/
            Point.prototype.distanceToXY = function (x, y, round) {
                if (typeof round === "undefined") { round = false; }
                var dx = this.x - x;
                var dy = this.y - y;

                if (round === true) {
                    return Math.round(Math.sqrt(dx * dx + dy * dy));
                } else {
                    return Math.sqrt(dx * dx + dy * dy);
                }
            };

            /**
            * Returns the distance between the two Point objects.
            * @method distanceBetween
            * @param pointA {Point} pointA - The first Point object.
            * @param pointB {Point} pointB - The second Point object.
            * @param [round = Boolean] {boolean} round - Round the distance to the nearest integer (default false)
            * @return {Number} The distance between the two Point objects.
            **/
            Point.distanceBetween = function (pointA, pointB, round) {
                if (typeof round === "undefined") { round = false; }
                var dx = pointA.x - pointB.x;
                var dy = pointA.y - pointB.y;

                if (round === true) {
                    return Math.round(Math.sqrt(dx * dx + dy * dy));
                } else {
                    return Math.sqrt(dx * dx + dy * dy);
                }
            };

            /**
            * Creates a new point with cartesian coordinates from a pair of polar coordinates
            * @method polar
            * @param length {Number} The length coordinate of the polar pair.
            * @param angle {Number} The angle, in radians, of the polar pair.
            * @return {Point} The new Cartesian Point object.
            **/
            Point.polar = function (length, angle) {
                return new Point(length * Math.cos(angle * Math.PI / 180), length * Math.sin(angle * Math.PI / 180));
            };

            /**
            * Returns true if the distance between this point and a target point is greater than or equal a specified distance.
            * This avoids using a costly square root operation
            * @method distanceCompare
            * @param target {Point} The Point object to use for comparison.
            * @param distance {Number} The distance to use for comparison.
            * @return {boolean} True if distance is >= specified distance.
            * @public
            **/
            Point.prototype.distanceCompare = function (target, distance) {
                if (this.distanceTo(target) >= distance) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Determines whether this Point object and the given point object are equal. They are equal if they have the same x and y values.
            * @method equals
            * @param point {Point} The point to compare against.
            * @return {boolean} A value of true if the object is equal to this Point object; false if it is not equal.
            * @public
            **/
            Point.prototype.equals = function (toCompare) {
                if (this.x === toCompare.x && this.y === toCompare.y) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Determines a point between two specified points. The parameter f determines where the new interpolated point is located relative to the two end points specified by parameters pt1 and pt2.
            * The closer the value of the parameter f is to 1.0, the closer the interpolated point is to the first point (parameter pt1). The closer the value of the parameter f is to 0, the closer the interpolated point is to the second point (parameter pt2).
            * @method interpolate
            * @param pointA{Point} The first Point object.
            * @param pointB {Point} The second Point object.
            * @param f {Number} The level of interpolation between the two points. Indicates where the new point will be, along the line between pt1 and pt2. If f=1, pt1 is returned; if f=0, pt2 is returned.
            * @return {Point} The new interpolated Point object.
            * @public
            **/
            Point.interpolate = function (pointA, pointB, f) {
                var xDiff = pointB.x - pointA.x;
                var yDiff = pointB.y - pointA.y;
                return new Point(pointB.x - xDiff * f, pointB.y - yDiff * f);
            };

            /**
            * Offsets the Point object by the specified amount. The value of dx is added to the original value of x to create the new x value.
            * The value of dy is added to the original value of y to create the new y value.
            * @method offset
            * @param dx {Number} The amount by which to offset the horizontal coordinate, x.
            * @param dy {Number} The amount by which to offset the vertical coordinate, y.
            * @return {Point} This Point object. Useful for chaining method calls.
            * @public
            **/
            Point.prototype.offset = function (dx, dy) {
                this.x += dx;
                this.y += dy;

                return this;
            };

            /**
            * Sets the x and y values of this Point object to the given coordinates.
            * @method setTo
            * @param x {Number} The horizontal position of this point.
            * @param y {Number} The vertical position of this point.
            * @return {Point} This Point object. Useful for chaining method calls.
            * @public
            **/
            Point.prototype.setTo = function (x, y) {
                this.x = x;
                this.y = y;

                return this;
            };

            /**
            * Subtracts the coordinates of another point from the coordinates of this point to create a new point.
            * @method subtract
            * @param point {Point} The point to be subtracted.
            * @param output {Point} Optional Point object. If given the values will be set into this object, otherwise a brand new Point object will be created and returned.
            * @return {Point} The new Point object.
            * @public
            **/
            Point.prototype.subtract = function (point, output) {
                if (typeof output === "undefined") { output = new Point; }
                return output.setTo(this.x - point.x, this.y - point.y);
            };

            Point.prototype.getCSS = function () {
                return this.x + 'px ' + this.y + 'px';
            };

            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {string} a string representation of the instance.
            * @public
            **/
            Point.prototype.toString = function () {
                return '[{Point (x=' + this.x + ' y=' + this.y + ')}]';
            };
            return Point;
        })();
        Geom.Point = Point;
    })(Kiwi.Geom || (Kiwi.Geom = {}));
    var Geom = Kiwi.Geom;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    (function (Geom) {
        /**
        * An area defined by its position, as indicated by its top-left corner (x,y) and width and height
        *
        * @class Rectangle
        * @namespace Kiwi.Geom
        * @constructor
        * @param [x = 0] {Number} The x coordinate of the top-left corner of the rectangle.
        * @param [y = 0] {Number} The y coordinate of the top-left corner of the rectangle.
        * @param [width = 0] {Number} width The width of the rectangle in pixels.
        * @param [height = 0] {Number} height The height of the rectangle in pixels.
        * @return {Rectangle} This rectangle object
        *
        */
        var Rectangle = (function () {
            /**
            * Creates a new Rectangle object with the top-left corner specified by the x and y parameters and with the specified width and height parameters. If you call this function without parameters, a rectangle with x, y, width, and height properties set to 0 is created.
            **/
            function Rectangle(x, y, width, height) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof width === "undefined") { width = 0; }
                if (typeof height === "undefined") { height = 0; }
                /**
                * The x coordinate of the top-left corner of the rectangle
                * @property x
                * @type Number
                * @public
                **/
                this.x = 0;
                /**
                * The y coordinate of the top-left corner of the rectangle
                * @property y
                * @type Number
                * @public
                **/
                this.y = 0;
                /**
                * The width of the rectangle in pixels
                * @property width
                * @type Number
                * @public
                **/
                this.width = 0;
                /**
                * The height of the rectangle in pixels
                * @property height
                * @type Number
                * @public
                **/
                this.height = 0;
                this.setTo(x, y, width, height);
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String}
            * @public
            */
            Rectangle.prototype.objType = function () {
                return "Rectangle";
            };


            Object.defineProperty(Rectangle.prototype, "bottom", {
                get: function () {
                    return this.y + this.height;
                },
                /**
                * The sum of the y and height properties. Changing the bottom property of a Rectangle object has no effect on the x, y and width properties, but does change the height property.
                * @property bottom
                * @return {Number}
                * @public
                **/
                set: function (value) {
                    if (value) {
                        if (value < this.y) {
                            this.height = 0;
                        } else {
                            this.height = value;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "center", {
                /**
                * Returns a Point containing the location of the center of the Rectangle, relative to the top left edge
                * @property center
                * @return {Point}
                * @public
                **/
                get: function () {
                    var output = new Kiwi.Geom.Point();
                    return output.setTo(Math.round(this.width / 2), Math.round(this.height / 2));
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Rectangle.prototype, "bottomRight", {
                get: function () {
                    var output = new Kiwi.Geom.Point();
                    return output.setTo(this.right, this.bottom);
                },
                /**
                * Returns a Point containing the location of the Rectangle's bottom-right corner, determined by the values of the right and bottom properties.
                * @property bottomRight
                * @return {Point}
                * @public
                */
                set: function (value) {
                    if (value) {
                        this.right = value.x;
                        this.bottom = value.y;
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Rectangle.prototype, "left", {
                get: function () {
                    return this.x;
                },
                /**
                * The x coordinate of the top-left corner of the rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
                * @property left
                * @return {number}
                * @public
                */
                set: function (value) {
                    if (value) {
                        var diff = this.x - value;

                        if (this.width + diff < 0) {
                            this.width = 0;

                            this.x = value;
                        } else {
                            this.width += diff;

                            this.x = value;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Rectangle.prototype, "right", {
                get: function () {
                    return this.x + this.width;
                },
                /**
                * The sum of the x and width properties. Changing the right property of a Rectangle object has no effect on the x, y and height properties. However it does affect the width property.
                * @property right
                * @return {Number}
                * @public
                */
                set: function (value) {
                    if (value) {
                        if (value < this.x) {
                            this.width = 0;
                        } else {
                            this.width = value - this.x;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "size", {
                /**
                * The size of the Rectangle object, expressed as a Point object with the values of the width and height properties.
                * @property size
                * @return {Point} The size of the Rectangle object
                * @public
                */
                get: function () {
                    var output = new Kiwi.Geom.Point();
                    return output.setTo(this.width, this.height);
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "volume", {
                /**
                * The volume of the Rectangle object in pixels, derived from width * height
                * @property volume
                * @return {Number}
                * @return
                */
                get: function () {
                    return this.width * this.height;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Rectangle.prototype, "perimeter", {
                /**
                * The perimeter size of the Rectangle object in pixels. This is the sum of all 4 sides.
                * @property perimeter
                * @return {Number}
                * @public
                */
                get: function () {
                    return (this.width * 2) + (this.height * 2);
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Rectangle.prototype, "top", {
                get: function () {
                    return this.y;
                },
                /**
                * The y coordinate of the top-left corner of the rectangle. Changing the top property of a Rectangle object has no effect on the x and width properties. However it does affect the height property, whereas changing the y value does not affect the height property.
                * @method top
                * @return {Number}
                * @public
                */
                set: function (value) {
                    if (value) {
                        var diff = this.y - value;

                        if (this.height + diff < 0) {
                            this.height = 0;

                            this.y = value;
                        } else {
                            this.height += diff;

                            this.y = value;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Rectangle.prototype, "topLeft", {
                get: function () {
                    var output = new Kiwi.Geom.Point();
                    return output.setTo(this.x, this.y);
                },
                /**
                * The location of the Rectangle object's top-left corner, determined by the x and y coordinates of the point.
                * @property topLeft
                * @return {Point}
                * @public
                */
                set: function (value) {
                    if (value) {
                        this.x = value.x;
                        this.y = value.y;
                    }
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.
            * @method clone
            * @param [output = Rectangle] {Rectangle} Optional Rectangle object. If given the values will be set into the object, otherwise a brand new Rectangle object will be created and returned.
            * @return {Rectangle}
            * @public
            **/
            Rectangle.prototype.clone = function (output) {
                if (typeof output === "undefined") { output = new Rectangle; }
                return output.setTo(this.x, this.y, this.width, this.height);
            };

            /**
            * Determines whether the specified coordinates are contained within the region defined by this Rectangle object.
            * @method contains
            * @param {Number} x The x coordinate of the point to test.
            * @param {Number} y The y coordinate of the point to test.
            * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
            **/
            Rectangle.prototype.contains = function (x, y) {
                if (x >= this.x && x <= this.right && y >= this.y && y <= this.bottom) {
                    return true;
                }

                return false;
            };

            /**
            * Determines whether the specified point is contained within the rectangular region defined by this Rectangle object. This method is similar to the Rectangle.contains() method, except that it takes a Point object as a parameter.
            * @method containsPoint
            * @param {Point} point The point object being checked. Can be Kiwi.Geom.Point or any object with .x and .y values.
            * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
            **/
            Rectangle.prototype.containsPoint = function (point) {
                return this.contains(point.x, point.y);
            };

            /**
            * Determines whether the Rectangle object specified by the rect parameter is contained within this Rectangle object. A Rectangle object is said to contain another if the second Rectangle object falls entirely within the boundaries of the first.
            * @method containsRect
            * @param rect {Rectangle} The rectangle object being checked.
            * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
            * @public
            **/
            Rectangle.prototype.containsRect = function (rect) {
                //	If the given rect has a larger volume than this one then it can never contain it
                if (rect.volume > this.volume) {
                    return false;
                }

                if (rect.x >= this.x && rect.y >= this.y && rect.right <= this.right && rect.bottom <= this.bottom) {
                    return true;
                }

                return false;
            };

            /**
            * Copies all of rectangle data from the source Rectangle object into the calling Rectangle object.
            * @method copyFrom
            * @param source {Rectangle} The source rectangle object to copy from
            * @return {Rectangle} This rectangle object
            * @public
            **/
            Rectangle.prototype.copyFrom = function (source) {
                return this.setTo(source.x, source.y, source.width, source.height);
            };

            /**
            * Copies all the rectangle data from this Rectangle object into the destination Rectangle object.
            * @method copyTo
            * @param target {Rectangle} The destination rectangle object to copy in to
            * @return {Rectangle} The destination rectangle object
            * @public
            **/
            Rectangle.prototype.copyTo = function (target) {
                return target.copyFrom(this);
            };

            /**
            * Determines whether the object specified in the toCompare parameter is equal to this Rectangle object. This method compares the x, y, width, and height properties of an object against the same properties of this Rectangle object.
            * @method equals
            * @param  toCompare {Rectangle} toCompare The rectangle to compare to this Rectangle object.
            * @return {boolean} A value of true if the object has exactly the same values for the x, y, width, and height properties as this Rectangle object; otherwise false.
            * @public
            **/
            Rectangle.prototype.equals = function (toCompare) {
                if (this.x === toCompare.x && this.y === toCompare.y && this.width === toCompare.width && this.height === toCompare.height) {
                    return true;
                }

                return false;
            };

            /**
            * Increases the size of the Rectangle object by the specified amounts, in pixels. The center point of the Rectangle object stays the same, and its size increases to the left and right by the dx value, and to the top and the bottom by the dy value.
            * @method inflate
            * @param dx {Number} dx The amount to be added to the left side of this Rectangle.
            * @param dy {Number} dy The amount to be added to the bottom side of this Rectangle.
            * @return {Rectangle} This Rectangle object.
            * @public
            **/
            Rectangle.prototype.inflate = function (dx, dy) {
                if (!isNaN(dx) && !isNaN(dy)) {
                    this.x -= dx;
                    this.width += 2 * dx;

                    this.y -= dy;
                    this.height += 2 * dy;
                }

                return this;
            };

            /**
            * Increases the size of the Rectangle object. This method is similar to the Rectangle.inflate() method except it takes a Point object as a parameter.
            * @method inflatePoint
            * @param point {Point} The x property of this Point object is used to increase the horizontal dimension of the Rectangle object. The y property is used to increase the vertical dimension of the Rectangle object.
            * @return {Rectangle} This Rectangle object.
            * @public
            **/
            Rectangle.prototype.inflatePoint = function (point) {
                return this.inflate(point.x, point.y);
            };

            /**
            * If the Rectangle object specified in the toIntersect parameter intersects with this Rectangle object, returns the area of intersection as a Rectangle object. If the rectangles do not intersect, this method returns an empty Rectangle object with its properties set to 0.
            * @method intersection
            * @param toIntersect {Rectangle} The Rectangle object to compare against to see if it intersects with this Rectangle object.
            * @param output {Rectangle} Optional Rectangle object. If given the intersection values will be set into this object, otherwise a brand new Rectangle object will be created and returned.
            * @return {Rectangle} A Rectangle object that equals the area of intersection. If the rectangles do not intersect, this method returns an empty Rectangle object; that is, a rectangle with its x, y, width, and height properties set to 0.
            **/
            Rectangle.prototype.intersection = function (toIntersect, output) {
                if (typeof output === "undefined") { output = new Rectangle; }
                if (this.intersects(toIntersect) === true) {
                    output.x = Math.max(toIntersect.x, this.x);
                    output.y = Math.max(toIntersect.y, this.y);
                    output.width = Math.min(toIntersect.right, this.right) - output.x;
                    output.height = Math.min(toIntersect.bottom, this.bottom) - output.y;
                }

                return output;
            };

            /**
            * Determines whether the object specified in the toIntersect parameter intersects with this Rectangle object. This method checks the x, y, width, and height properties of the specified Rectangle object to see if it intersects with this Rectangle object.
            * @method intersects
            * @param toIntersect {Rectangle} The Rectangle object to compare against to see if it intersects with this Rectangle object.
            * @return {boolean} A value of true if the specified object intersects with this Rectangle object; otherwise false.
            * @public
            **/
            Rectangle.prototype.intersects = function (toIntersect) {
                if (toIntersect.x > this.right - 1) {
                    return false;
                }

                if (toIntersect.right - 1 < this.x) {
                    return false;
                }

                if (toIntersect.bottom - 1 < this.y) {
                    return false;
                }

                if (toIntersect.y > this.bottom - 1) {
                    return false;
                }

                return true;
            };

            /**
            * Checks for overlaps between this Rectangle and the given Rectangle. Returns an object with boolean values for each check.
            * @method overlap
            * @param rect {Rectangle}
            * @return {Object} An object containing the overlapping details between the two Rectangles
            * @todo Move to an IntersectResult? Do not want to be generating all of these values each time this is called
            * @public
            **/
            Rectangle.prototype.overlap = function (rect) {
                var result = { top: false, bottom: false, left: false, right: false, contains: false, contained: false };
                var interRect = this.intersection(rect);

                if (interRect.isEmpty)
                    return result;
                if (this.containsRect(rect))
                    result.contains = true;
                if (rect.containsRect(this))
                    result.contained = true;
                if (this.top < rect.top)
                    result.top = true;
                if (this.bottom > rect.bottom)
                    result.bottom = true;
                if (this.left < rect.left)
                    result.left = true;
                if (this.right > rect.right)
                    result.right = true;

                return result;
            };

            /**
            * Determines whether or not this Rectangle object is empty.
            * @method isEmpty
            * @return {boolean} A value of true if the Rectangle object's width or height is less than or equal to 0; otherwise false.
            * @public
            **/
            Rectangle.prototype.isEmpty = function () {
                if (this.width < 1 || this.height < 1) {
                    return true;
                }

                return false;
            };

            /**
            * Adjusts the location of the Rectangle object, as determined by its top-left corner, by the specified amounts.
            * @method offset
            * @param dx {Number} Moves the x value of the Rectangle object by this amount.
            * @param dy {Number} Moves the y value of the Rectangle object by this amount.
            * @return {Rectangle} This Rectangle object.
            * @public
            **/
            Rectangle.prototype.offset = function (dx, dy) {
                if (!isNaN(dx) && !isNaN(dy)) {
                    this.x += dx;
                    this.y += dy;
                }

                return this;
            };

            /**
            * Adjusts the location of the Rectangle object using a Point object as a parameter. This method is similar to the Rectangle.offset() method, except that it takes a Point object as a parameter.
            * @method offsetPoint
            * @param point {Point} A Point object to use to offset this Rectangle object.
            * @return {Rectangle} This Rectangle object.
            **/
            Rectangle.prototype.offsetPoint = function (point) {
                return this.offset(point.x, point.y);
            };

            /**
            * Sets all of the Rectangle object's properties to 0. A Rectangle object is empty if its width or height is less than or equal to 0.
            * @method setEmpty
            * @return {Rectangle} This rectangle object
            **/
            Rectangle.prototype.setEmpty = function () {
                return this.setTo(0, 0, 0, 0);
            };

            /**
            * Sets the properties of Rectangle to the specified values.
            * @method setTo
            * @param x {Number} x The x coordinate of the top-left corner of the rectangle.
            * @param y {Number} y The y coordinate of the top-left corner of the rectangle.
            * @param width {Number} width The width of the rectangle in pixels.
            * @param height {Number} height The height of the rectangle in pixels.
            * @return {Rectangle} This rectangle object
            **/
            Rectangle.prototype.setTo = function (x, y, width, height) {
                if (!isNaN(x) && !isNaN(y) && !isNaN(width) && !isNaN(height)) {
                    this.x = x;
                    this.y = y;

                    if (width >= 0) {
                        this.width = width;
                    }

                    if (height >= 0) {
                        this.height = height;
                    }
                }

                return this;
            };

            /**
            * Adds two rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two rectangles.
            * @method union
            * @param toUnion{Rectangle} toUnion A Rectangle object to add to this Rectangle object.
            * @param [output = Rectangle] {Rectangle} output Optional Rectangle object. If given the new values will be set into this object, otherwise a brand new Rectangle object will be created and returned.
            * @return {Rectangle} A Rectangle object that is the union of the two rectangles.
            **/
            Rectangle.prototype.union = function (toUnion, output) {
                if (typeof output === "undefined") { output = new Rectangle; }
                return output.setTo(Math.min(toUnion.x, this.x), Math.min(toUnion.y, this.y), Math.max(toUnion.right, this.right), Math.max(toUnion.bottom, this.bottom));
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method scale
            * @param x {number}
            * @param y {number}
            * @param translation {Point}
            * @return {Rectangle}
            * @public
            **/
            Rectangle.prototype.scale = function (x, y, translation) {
                var trans = new Kiwi.Geom.Transform;
                trans.scaleX = x;
                trans.scaleY = y;
                trans.x = translation.x;
                trans.y = translation.y;

                var tl = this.topLeft;
                trans.transformPoint(tl);
                this.topLeft = tl;

                this.width *= x;
                this.height *= y;

                return this;
            };

            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {string} a string representation of the instance.
            **/
            Rectangle.prototype.toString = function () {
                return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " isEmpty=" + this.isEmpty() + ")}]";
            };
            return Rectangle;
        })();
        Geom.Rectangle = Rectangle;
    })(Kiwi.Geom || (Kiwi.Geom = {}));
    var Geom = Kiwi.Geom;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    (function (Geom) {
        /**
        * Represents position, scale, rotation and rotationPoint of an Entity.
        * - Values can be transformed with a 3x3 affine transformation matrix, which each transform is assigned.
        * - A tranform can be assigned a parent, which may in turn have it's own parent, thereby creating a tranform inheritence heirarchy
        * - A concatenated transformation matrix, representing the combined matrices of the transform and its ancestors.
        *
        * @class Transform
        * @namespace Kiwi.Geom
        * @constructor
        * @param x {Number} x. X position of the transform.
        * @param y {Number} y. Y position of the transform.
        * @param scaleX {Number} scaleX. X scaling of the transform.
        * @param scaleY {Number} scaleY. Y scaling of the transform.
        * @param rotation {Number} rotation. Rotation of the transform in radians.
        * @param rotX {Number} rotX. rotationPoint offset on X axis.
        * @param rotY {Number} rotY. rotationPoint offset on Y axis.
        * @return {Transform} This object.
        *
        */
        var Transform = (function () {
            function Transform(x, y, scaleX, scaleY, rotation, rotPointX, rotPointY) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof scaleX === "undefined") { scaleX = 1; }
                if (typeof scaleY === "undefined") { scaleY = 1; }
                if (typeof rotation === "undefined") { rotation = 0; }
                if (typeof rotPointX === "undefined") { rotPointX = 0; }
                if (typeof rotPointY === "undefined") { rotPointY = 0; }
                /**
                * X position of the transform
                * @property _x
                * @type Number
                * @private
                **/
                this._x = 0;
                /**
                * Y position of the transform
                * @property _y
                * @type Number
                * @private
                **/
                this._y = 0;
                /**
                * X scaleof the transform
                * @property _scaleX
                * @type Number
                * @private
                **/
                this._scaleX = 1;
                /**
                * Y scale of the transform
                * @property _scaleY
                * @type Number
                * @private
                **/
                this._scaleY = 1;
                /**
                * Rotation of the transform in radians.
                * @property _rotation
                * @type Number
                * @private
                **/
                this._rotation = 0;
                /**
                * Rotation offset on X axis.
                * @property _rotPointX
                * @type Number
                * @private
                **/
                this._rotPointX = 0;
                /**
                * Rotation offset on Y axis.
                * @property _rotY
                * @type Number
                * @private
                **/
                this._rotPointY = 0;
                this.setTransform(x, y, scaleX, scaleY, rotation, rotPointX, rotPointY);

                this._matrix = new Kiwi.Geom.Matrix();

                this._matrix.setFromTransform(this._x, this._y, this._scaleX, this._scaleY, this._rotation);

                this._cachedConcatenatedMatrix = this.getConcatenatedMatrix();
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String}
            * @public
            */
            Transform.prototype.objType = function () {
                return "Transform";
            };

            Object.defineProperty(Transform.prototype, "x", {
                get: function () {
                    return this._x;
                },
                /**
                * Return the X value of the transform.
                * @property x
                * @type Number
                * @return {Number} The X value of the transform.
                */
                set: function (value) {
                    this._x = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Transform.prototype, "y", {
                get: function () {
                    return this._y;
                },
                /**
                * Return the Y value of the transform.
                * @property y
                * @type Number
                * @return {Number} The Y value of the transform.
                * @public
                */
                set: function (value) {
                    this._y = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Transform.prototype, "scaleX", {
                get: function () {
                    return this._scaleX;
                },
                /**
                * Return the X scale value of the transform.
                * @property scaleX
                * @type Number
                * @return {Number} The X value of the transform.
                * @public
                */
                set: function (value) {
                    this._scaleX = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Transform.prototype, "scaleY", {
                get: function () {
                    return this._scaleY;
                },
                /**
                * Return the Y scale value of the transform.
                * @property scaleY
                * @type Number
                * @return {Number} The Y value of the transform.
                * @public
                */
                set: function (value) {
                    this._scaleY = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Transform.prototype, "rotation", {
                get: function () {
                    return this._rotation;
                },
                /**
                * Return the rotation value of the transform in radians.
                * @property rotation
                * @return {Number} The rotation value of the transform.
                * @public
                */
                set: function (value) {
                    this._rotation = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Transform.prototype, "rotPointX", {
                get: function () {
                    return this._rotPointX;
                },
                /**
                * Return the Rotation value from the x axis.
                * @property rotPointX
                * @return {Number} The registration value from the x axis.
                * @public
                */
                set: function (value) {
                    this._rotPointX = value;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Transform.prototype, "rotPointY", {
                get: function () {
                    return this._rotPointY;
                },
                /**
                * Return the rotation value from the y axis.
                * @public rotY
                * @return {Number} The rotation value from the y axis.
                * @public
                */
                set: function (value) {
                    this._rotPointY = value;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Transform.prototype, "matrix", {
                /**
                * Return the Matrix being used by this Transform
                * @property matrix
                * @return {Matrix} The Matrix being used by this Transform
                */
                get: function () {
                    return this._matrix;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Transform.prototype, "worldX", {
                /**
                * Return the x of this transform translated to world space.
                * @property worldX
                * @return {Number} x coordinate in world space
                * @public
                */
                get: function () {
                    return this.getConcatenatedMatrix().tx;
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Transform.prototype, "worldY", {
                /**
                * Return the y of this transform translated to world space.
                * @property worldY
                * @return {Number} y coordinate in world space
                * @public
                */
                get: function () {
                    return this.getConcatenatedMatrix().ty;
                },
                enumerable: true,
                configurable: true
            });


            Object.defineProperty(Transform.prototype, "parent", {
                get: function () {
                    return this._parent;
                },
                /**
                * Return the parent Transform, if any.
                * @property parent
                * @return {Transform} The parent Transform, or null.
                * @public
                */
                set: function (value) {
                    if (!this.checkAncestor(value)) {
                        this._parent = value;
                    }
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Set the X and Y values of the transform.
            * @method setPosition
            * @param x {Number} x.
            * @param y {Number} y.
            * @return {Transform} This object.
            * @public
            */
            Transform.prototype.setPosition = function (x, y) {
                this._x = x;
                this._y = y;

                //this.owner.dirty = true;
                return this;
            };

            /**
            * Set the X and Y values of the transform from a point.
            * @method setPositionPoint
            * @param point {Kiwi.Geom.Point} point.
            * @return {Transform} This object.
            * @public
            */
            Transform.prototype.setPositionFromPoint = function (point) {
                this._x = point.x;
                this._y = point.y;

                //this.owner.dirty = true;
                return this;
            };

            /**
            * Translate the X and Y value of the transform by point components.
            * @method translatePositionFromPoint
            * @param point {Point} point.
            * @return {Transform} This object.
            */
            Transform.prototype.translatePositionFromPoint = function (point) {
                this._x += point.x;
                this._y += point.y;

                //this.owner.dirty = true;
                return this;
            };

            /**
            * Return a Point representing the X and Y values of the transform. If none is given a new Point objected will be created.
            * @method getPostionPoint
            * @return {Kiwi.Geom.Point} A point representing the X and Y values of the transform.
            * @public
            */
            Transform.prototype.getPositionPoint = function (output) {
                if (typeof output === "undefined") { output = new Kiwi.Geom.Point; }
                return output.setTo(this._x, this._y);
            };

            Object.defineProperty(Transform.prototype, "scale", {
                /**
                * Set the X and Y scale value of the transform.
                * @method scale
                * @param value {Number}
                * @return {Transform} This object.
                * @public
                */
                set: function (value) {
                    this._scaleX = value;
                    this._scaleY = value;
                    //this.owner.dirty = true;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Set the core properties of the transform
            * @method setTransform
            * @param x {Number} x. X position of the transform.
            * @param y {Number} y. Y position of the transform.
            * @param scaleX {Number} scaleX. X scaling of the transform.
            * @param scaleY {Number} scaleY. Y scaling of the transform.
            * @param rotation {Number} rotation. Rotation of the transform in radians.
            * @param rotX{Number} rotX. Rotation offset on X axis.
            * @param rotY{Number} rotY. Rotation offset on Y axis.
            * @return {Transform} This object.
            * @public
            */
            Transform.prototype.setTransform = function (x, y, scaleX, scaleY, rotation, rotPointX, rotPointY) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                if (typeof scaleX === "undefined") { scaleX = 1; }
                if (typeof scaleY === "undefined") { scaleY = 1; }
                if (typeof rotation === "undefined") { rotation = 0; }
                if (typeof rotPointX === "undefined") { rotPointX = 0; }
                if (typeof rotPointY === "undefined") { rotPointY = 0; }
                this._x = x;
                this._y = y;
                this._scaleX = scaleX;
                this._scaleY = scaleY;
                this._rotation = rotation;
                this._rotPointX = rotPointX;
                this._rotPointY = rotPointY;

                //if (this.owner)
                //{
                //    this.owner.dirty = true;
                //}
                return this;
            };

            /**
            * Return the parent matrix of the transform. If there is no parent then null is returned.
            * @method getParentMatrix
            * @return {Matrix} The parent transform matrix.
            * @public
            */
            Transform.prototype.getParentMatrix = function () {
                if (this._parent) {
                    return this._parent.getConcatenatedMatrix();
                }

                return null;
            };

            /**
            * Return the transformation matrix that concatenates this transform with all ancestor transforms.
            * If there is no parent then this will return a matrix the same as this transforms matrix.
            * @method getConcatenatedMatrix
            * @return {Matrix} The concatenated matrix.
            * @public
            */
            Transform.prototype.getConcatenatedMatrix = function () {
                this._matrix.setFromTransform(this._x, this._y, this._scaleX, this._scaleY, this._rotation);

                var parentMatrix = this.getParentMatrix();

                if (parentMatrix) {
                    var matrix = this._matrix.clone();
                    matrix.prependMatrix(parentMatrix);
                    this._cachedConcatenatedMatrix.copyFrom(matrix);
                    return matrix;
                }

                return this._matrix;
            };

            /**
            * Return the x of this transform translated to a camera space
            * @method getCameraX
            * @param camera {Object} the camera
            * @return {Number} x coordinate in the camera space
            
            public getCameraX ( camera:Camera ):number
            {
            var mat = this.getConcatenatedMatrix();
            mat.prependMatrix(camera.transform.getConcatenatedMatrix());
            return mat.tx;
            }
            
            /**
            * Return the y of this transform translated to a camera space
            * @method getCameraY
            * @param camera {Object} the camera
            * @return {Number} y coordinate in the camera space
            
            public getCameraY ( camera:Camera ):number
            {
            var mat = this.getConcatenatedMatrix();
            mat.prependMatrix(camera.transform.getConcatenatedMatrix());
            return mat.ty;
            }
            */
            /**
            * [Requires Description]
            * @method transformPoint
            * @param point {Point} point
            * @return {Point}
            * @public
            **/
            Transform.prototype.transformPoint = function (point) {
                var mat = this.getConcatenatedMatrix();

                return mat.transformPoint(point);
            };

            /**
            * Copy another transforms data to this transform. A clone of the source matrix is created for the matrix property.
            * @method copyFrom
            * @param transform {Transform} transform. The tranform to be copied from.
            * @return {Transform} This object.
            * @public
            */
            Transform.prototype.copyFrom = function (source) {
                this.setTransform(source.x, source.y, source.scaleX, source.scaleY, source.rotation, source.rotPointX, source.rotPointY);

                this.parent = source.parent;

                //this.owner = source.owner;
                this._matrix = source.matrix.clone();

                return this;
            };

            /**
            * Copy this transforms data to the destination Transform. A clone of this transforms matrix is created in the destination Transform Matrix.
            * @method copyTo
            * @param destination {Transform} The tranform to copy to.
            * @return {Transform} This object.
            * @public
            */
            Transform.prototype.copyTo = function (destination) {
                destination.copyFrom(this);

                return this;
            };

            /**
            * Return a clone of this transform.
            * @method clone
            * @param output {Transform} A Transform to copy the clone in to. If none is given a new Transform object will be made.
            * @return {Transform} A clone of this object.
            * @public
            */
            Transform.prototype.clone = function (output) {
                if (typeof output === "undefined") { output = new Transform(); }
                output.copyFrom(this);

                return output;
            };

            /**
            * Recursively check that a transform does not appear as its own ancestor
            * @method checkAncestor
            * @param transform{Transform} The Transform to check.
            * @return {boolean} Returns true if the given transform is the same as this or an ancestor, otherwise false.
            * @public
            */
            Transform.prototype.checkAncestor = function (transform) {
                /*if (transform === this)
                {
                return true
                }
                
                if (transform.parent !== null)
                {
                return (this.checkAncestor(transform._parent))
                }*/
                return false;
            };

            Object.defineProperty(Transform.prototype, "toString", {
                /**
                * Return a string represention of this object.
                * @method toString
                * @return {string} A string represention of this object.
                * @public
                */
                get: function () {
                    return "[{Transform (x=" + this._x + " y=" + this._y + " scaleX=" + this._scaleX + " scaleY=" + this._scaleY + " rotation=" + this._rotation + " regX=" + this._rotPointX + " regY=" + this.rotPointY + " matrix=" + this._matrix + ")}]";
                },
                enumerable: true,
                configurable: true
            });
            return Transform;
        })();
        Geom.Transform = Transform;
    })(Kiwi.Geom || (Kiwi.Geom = {}));
    var Geom = Kiwi.Geom;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    (function (Geom) {
        /**
        * A two dimensional vector object for storing and manipulating x and y vector components.
        *
        * @class Vector2
        * @namespace Kiwi.Geom
        * @constructor
        * @param {Number} x The x component of the vector.
        * @param {Number} y The y component of the vector.
        * @return {Vector2}
        */
        var Vector2 = (function () {
            function Vector2(x, y) {
                if (typeof x === "undefined") { x = 0; }
                if (typeof y === "undefined") { y = 0; }
                this.setTo(x, y);
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String}
            * @public
            */
            Vector2.prototype.objType = function () {
                return "Vector2";
            };

            /**
            * Generate a Vector2 from an angle
            * @method fromAngle
            * @param angle {Number} The angle to generate the Vector2 from.
            * @static
            * @return {Vector2} A new Vector2.
            */
            Vector2.fromAngle = function (angle) {
                return new Vector2(Math.cos(angle), Math.sin(angle));
            };

            /**
            * Generate a random Vector2 within a given radius.
            * @method randomRadius
            * @param radius {Number} The size of the radius to use.
            * @static
            * @return {Vector2} A new Vector2.
            * @public
            */
            Vector2.randomRadius = function (radius) {
                return new Vector2(Math.random() * 2 - 1, Math.random() * 2 - 1).multiplyScalar(radius);
            };

            /**
            * Generate a Vector2 from a point.
            * @method fromPoint
            * @param point {Point} point.
            * @static
            * @return {Vector2} A new Vector2.
            * @public
            */
            Vector2.fromPoint = function (point) {
                return new Vector2(point.x, point.y);
            };

            /**
            * Add each component of another Vector2 to this vectors components.
            * @method add
            * @param {Vector2} Vector2 to add.
            * @return {Vector2} A new Vector2 containing the product.
            */
            Vector2.prototype.add = function (vector2) {
                return new Vector2(this.x + vector2.x, this.y + vector2.y);
            };

            /**
            * Add only the x component of another Vector2 to this vector.
            * @method addX
            * @param vector2 {Vector2} Vector2 to add.
            * @return {Vector2} A new Vector2 containing the result.
            * @public
            */
            Vector2.prototype.addX = function (vector2) {
                return new Vector2(this.x + vector2.x, this.y);
            };

            /**
            * Add only the y component of another Vector2 to this vector.
            * @method addY
            * @param vector2 {Vector2} Vector2 to add.
            * @return {Vector2} A new Vector2 containing the result.
            */
            Vector2.prototype.addY = function (vector2) {
                return new Vector2(this.x, this.y + vector2.y);
            };

            /**
            * Subtract each component of another Vector2 from this vectors components.
            * @method subtract
            * @param vector2 {Vector2} Vector2 to subtract.
            * @return {Vector2} A new Vector2 containing the result.
            * @public
            */
            Vector2.prototype.subtract = function (vector2) {
                return new Kiwi.Geom.Vector2(this.x - vector2.x, this.y - vector2.y);
            };

            /**
            * Multiply each component of another Vector2 with this vectors components.
            * @method multiply
            * @param vector2 {Vector2} Vector2 to multiply.
            * @return {Vector2} A new Vector2 containing the result.
            * @public
            */
            Vector2.prototype.multiply = function (vector2) {
                return new Kiwi.Geom.Vector2(this.x * vector2.x, this.y * vector2.y);
            };

            /**
            * Multiply each component of this vector with a scalar number.
            * @method multiplyScalar
            * @param scalar {Number} Scalar to multiply.
            * @return {Vector2} A new Vector2 containing the result.
            * @public
            */
            Vector2.prototype.multiplyScalar = function (scalar) {
                return new Kiwi.Geom.Vector2(this.x * scalar, this.y * scalar);
            };

            /**
            * Calculate the dot product if a Vector2 with this Vector2.
            * @method dot
            * @param vector2{Vector2} Vector2 to dot with this Vector2.
            * @return {Number} Result of dot product.
            * @public
            */
            Vector2.prototype.dot = function (vector2) {
                return this.x * vector2.x + this.y * vector2.y;
            };

            /**
            * Calculate the square length of this Vector2 (Distance from the origin).
            * @method lenSqr
            * @return {Number} The square length.
            * @public
            */
            Vector2.prototype.lenSqr = function () {
                return this.x * this.x + this.y * this.y;
            };

            /**
            * Calculate the length of this Vector2 (Distance from the origin).
            * @method len
            * @return {Number} The length.
            * @public
            */
            Vector2.prototype.len = function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            };

            /**
            * Calculate a normalised unit Vector2 from this Vector2.
            * @method unit
            * @return {Vector2} a new Unit Length Vector2.
            * @public
            */
            Vector2.prototype.unit = function () {
                var invLen = 1.0 / this.len();
                return this.multiplyScalar(invLen);
            };

            /**
            * Reduce each component of the Vector to the closest lower round value.
            * @method floor
            * @return {Vector2} a rounded down Vector2.
            * @public
            */
            Vector2.prototype.floor = function () {
                return new Vector2(Math.floor(this.x), Math.floor(this.y));
            };

            /**
            * Increase each component of the Vector to the closest upper round value.
            * @method ceil
            * @return {Vector2} a rounded up Vector2.
            * @public
            */
            Vector2.prototype.ceil = function () {
                return new Vector2(Math.ceil(this.x), Math.ceil(this.y));
            };

            /**
            * Round each component of the Vector to the closest round value.
            * @method round
            * @return {Vector2} a rounded Vector2.
            * @public
            */
            Vector2.prototype.round = function () {
                return new Vector2(Math.round(this.x), Math.round(this.y));
            };

            /**
            * Clamp the vector between a maximum and minimum Vector2 range component-wise.
            * @method clamp
            * @param min {Vector2} min. Minimum values for Vector2.
            * @param max {Vector2} max. Maximum values for Vector2.
            * @return {Vector2} a clamped Vector2.
            * @public
            */
            Vector2.prototype.clamp = function (min, max) {
                return new Vector2(Math.max(Math.min(this.x, max.x), min.x), Math.max(Math.min(this.y, max.y), min.y));
            };

            /**
            * Calculate a Vector2 perpendicular to this Vector2.
            * @method perp
            * @return {Vector2} the perpendicular Vector2.
            * @public
            */
            Vector2.prototype.perp = function () {
                return new Vector2(-this.y, this.x);
            };

            /**
            * Calculate a Vector2 opposite to this Vector2.
            * @method neg
            * @return {Vector2} the opposite Vector2.
            * @public
            */
            Vector2.prototype.neg = function () {
                return new Vector2(-this.x, -this.y);
            };

            /**
            * Check if two Vector2s from equal components.
            * @method equal
            * @param vector2 {Vector2} vector2. Vector2 to check against.
            * @return {boolean} returns true if equal.
            * @public
            */
            Vector2.prototype.equal = function (vector2) {
                return this.x === vector2.x && this.y === vector2.y;
            };

            /**
            * Get a Point object with the same components as this Vector2.
            * @method point
            * @return {Point} A new Point.
            * @public
            */
            Vector2.prototype.point = function () {
                return new Kiwi.Geom.Point(this.x, this.y);
            };

            /**
            * Set both components to zero.
            * @method clear
            * @return {Vector2} This object.
            * @public
            */
            Vector2.prototype.clear = function () {
                this.x = 0;
                this.y = 0;
                return this;
            };

            /**
            * Get a clone of this Vector2.
            * @method clone
            * @param vector2 {Vector2} vector2. A vector2 that will be cloned to. Optional.
            * @return {Vector2} Either a new cloned Vector2 or the output vector with cloned components.
            * @public
            */
            Vector2.prototype.clone = function (output) {
                if (output) {
                    return output.setTo(this.x, this.y);
                } else {
                    return new Vector2(this.x, this.y);
                }
            };

            /**
            * Copy components from another Vector2.
            * @method copyFrom
            * @param source {Vector2} A Vector2 to copy from.
            * @return {Vector2} This object.
            * @public
            */
            Vector2.prototype.copyFrom = function (source) {
                this.x = source.x;
                this.y = source.y;
                return this;
            };

            /**
            * Copy components to another Vector2.
            * @method copyTo
            * @param target {Vector2} A Vector2 to copy to.
            * @return {Vector2} The supplied Vector2.
            * @public
            */
            Vector2.prototype.copyTo = function (target) {
                target.x = this.x;
                target.y = this.y;
                return target;
            };

            /**
            * Set components on this Vector2.
            * @method setTo
            * @param x {Number} x component to set.
            * @param y {Number} y component to set.
            * @return {Vector2} This object.
            * @public
            */
            Vector2.prototype.setTo = function (x, y) {
                this.x = x;
                this.y = y;
                return this;
            };

            /**
            * Get a string representation of this object.
            * @method toString
            * @return {string} This object as a string.
            */
            Vector2.prototype.toString = function () {
                return '[{Vector2 (x=' + this.x + ' y=' + this.y + ')}]';
            };
            return Vector2;
        })();
        Geom.Vector2 = Vector2;
    })(Kiwi.Geom || (Kiwi.Geom = {}));
    var Geom = Kiwi.Geom;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule HUD
*
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        /**
        * A HUDDisplay is a container for which you can add/removes widget on, and is more used to manage the widgets that are being displayed on it.
        * A HUDDisplay is created through a games HUDManager and is NOT directly instantiated.
        * Each game can contain multiple HUDDisplay's and each HUDDisplay can contain multiple HUDWidgets.
        *
        * @class HUDDisplay
        * @namespace Kiwi.HUD
        * @constructor
        * @param game {Game} The game that this HUD Display belongs to.
        * @param name {string} The name of this display.
        * @return HUDDisplay
        */
        var HUDDisplay = (function () {
            function HUDDisplay(game, name) {
                this._game = game;
                this.name = name;
                this._manager = this._game.huds;
                this._device = this._game.deviceTargetOption;

                if (this._manager.supported) {
                    switch (this._device) {
                        case Kiwi.TARGET_BROWSER:
                            this.container = document.createElement("div");
                            this.container.id = "HUD-layer-" + game.rnd.uuid();
                            this.container.style.width = "100%";
                            this.container.style.height = "100%";
                            this.container.style.position = "absolute";
                            this._widgets = new Array();

                            break;
                    }

                    this.class = 'kiwi-display';
                }
            }
            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            HUDDisplay.prototype.objType = function () {
                return 'HUDDisplay';
            };

            /**
            * Adds a widget to the HUDDisplay. Returns a boolean as an indication of whether or not it was successful.
            *
            * @method addWidget
            * @param widget {HUDWidget}  The widget to be added to the Display
            * @return {Boolean} If it was successful or not.
            * @public
            */
            HUDDisplay.prototype.addWidget = function (widget) {
                if (this._manager.supported) {
                    this._widgets.push(widget);

                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.appendChild(widget.container);
                        return true;
                    }
                }
                return false;
            };

            /**
            * Removes a singular widget from the display. Returns a boolean as an indication of if anything happened or not.
            *
            * @method removeWidget
            * @param widget {HUDWidget} The widget to be removed.
            * @return {boolean} If it was successful or not.
            * @public
            */
            HUDDisplay.prototype.removeWidget = function (widget) {
                if (this._manager.supported) {
                    if (this.removeFromContainer(widget)) {
                        var i = this._widgets.indexOf(widget);

                        if (i !== -1) {
                            this._widgets.splice(i, 1);
                            return true;
                        }
                    }
                }
                return false;
            };

            /**
            * Removes all of the widgets on this display.
            * @method removeAllWidgets
            * @public
            */
            HUDDisplay.prototype.removeAllWidgets = function () {
                for (var i = 0; i < this._widgets.length; i++) {
                    this.removeFromContainer(this._widgets[i]);
                }

                this._widgets = [];
            };

            /**
            * Removes a widget from on the HUDDisplay.
            * @method removeFromContainer
            * @param widget {HUDWidget} The Widget to be removed.
            * @returns {boolean}
            */
            HUDDisplay.prototype.removeFromContainer = function (widget) {
                if (this._manager.supported) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        if (this.container.contains(widget.container)) {
                            this.container.removeChild(widget.container);
                            return true;
                        }
                    }
                }
                return false;
            };

            /**
            * Update loop
            * @method update
            * @public
            */
            HUDDisplay.prototype.update = function () {
                for (var i = 0; i < this._widgets.length; i++) {
                    this._widgets[i].update();
                }
            };

            /**
            * Shows displays the HUD Display on screen.
            * @method show
            * @public
            */
            HUDDisplay.prototype.show = function () {
                this.container.style.display = 'block';
            };

            /**
            * Hides the current HUD Display from the screen.
            * @method hide
            * @public
            */
            HUDDisplay.prototype.hide = function () {
                this.container.style.display = 'none';
            };

            Object.defineProperty(HUDDisplay.prototype, "class", {
                get: function () {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        return this.container.className;
                    }
                },
                /**
                * The class name that the container element that this HUDWidget current has.
                * @property class
                * @type {String}
                * @public
                */
                set: function (cssClass) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.className = cssClass;
                    }
                },
                enumerable: true,
                configurable: true
            });
            return HUDDisplay;
        })();
        HUD.HUDDisplay = HUDDisplay;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
* The HUD (Heads Up Display) is a section that handles the displayment of information that you always want visible to user.
* This section is managed differently to normal GameObjects, where the difference being that HUD items aren't added to a Canvas but are DOM elements instead. Since they DOM elements you can style these elements using a CSS sheet if you wish.
*
* @module Kiwi
* @submodule HUD
* @main HUD
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        /**
        * This class manages all of the various HUDDisplays that are currently used on this Managers game.
        * Using this class you can create/add and remove HUDDisplays from this game,
        * change the HUDDisplay that is currently being display (also known as the currentHUD) and show/hide the currentHUD.
        * Each HUDManager also has at least one HUDDisplay which is called the 'defaultHUD' you cannot remove,
        * but you can reassign the defaultHUD to be a different HUDDisplay if you want.
        *
        *
        * @class HUDManager
        * @namespace Kiwi.HUD
        * @constructor
        * @param game {Game} game
        * @return {HUDManager}
        */
        var HUDManager = (function () {
            function HUDManager(game) {
                this._game = game;
                this._device = this._game.deviceTargetOption;
            }
            Object.defineProperty(HUDManager.prototype, "supported", {
                /**
                * Returns the _supported property indicating whether HUD is supported or not.
                * @property supported
                * @type boolean
                * @public
                */
                get: function () {
                    return this._supported;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * The DOM is ready, so if the current state is pending we can boot up the HUD now.
            * @method boot
            * @public
            */
            HUDManager.prototype.boot = function () {
                if (this._device === Kiwi.TARGET_BROWSER) {
                    this._supported = true;

                    this._hudContainer = document.createElement("div");
                    this._hudContainer.id = "HUDContainer";
                    this._hudContainer.style.position = "absolute";
                    this._hudContainer.style.width = "100%";
                    this._hudContainer.style.height = "100%";
                    this._game.stage.container.appendChild(this._hudContainer);

                    this._huds = new Array();

                    this._defaultHUD = this.createHUD("defaultHUD");
                    this._currentHUD = this._defaultHUD;
                    this.setHUD(this._defaultHUD);
                } else {
                    this._supported = false;
                }
            };

            /**
            * Returns the type of object this is.
            * @method objType
            * @return {String}
            * @public
            */
            HUDManager.prototype.objType = function () {
                return "HUDManager";
            };

            Object.defineProperty(HUDManager.prototype, "defaultHUD", {
                get: function () {
                    return this._defaultHUD;
                },
                /**
                * The default HUDDisplay that is to be used.
                * The defaultHUD cannot be removed, and a game (that supports HUDS) will always contain the defaultHUD.
                *
                * @property defaultHUD
                * @type {HUDDisplay}
                * @public
                */
                set: function (value) {
                    if (this._currentHUD === this._defaultHUD) {
                        this._currentHUD = value;
                        this.setHUD(this._currentHUD);
                    }
                    this._defaultHUD = value;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Changes the currentHUD that is being displayed to one that is passed.
            * @method setHUD
            * @param hud {HUDDisplay} The HUD you want to display.
            * @public
            */
            HUDManager.prototype.setHUD = function (hud) {
                if (this.supported) {
                    this.hideHUD();
                    this._currentHUD = hud;
                    this.showHUD();
                }
            };

            /**
            * Shows the currentHUD (if nothing is passed) or shows a HUDDisplay that is passed.
            * @method showHUD
            * @param [hud=currentHUD] {HUDDisplay} The HUDDisplay you want to show. Defaults to the currentHUD if nothing is passed.
            * @public
            */
            HUDManager.prototype.showHUD = function (hud) {
                if (typeof hud === "undefined") { hud = this._currentHUD; }
                hud.show();
            };

            /**
            * Hides the currentHUD (if nothing is passed) or shows a HUDDisplay that is passed.
            * @method hideHUD
            * @param [hud=currentHUD] {HUDDisplay} The HUDDisplay you want to hude. Defaults to the currentHUD if nothing is passed.
            * @public
            */
            HUDManager.prototype.hideHUD = function (hud) {
                if (typeof hud === "undefined") { hud = this._currentHUD; }
                hud.hide();
            };

            /**
            * Creates a new HUDDisplay on this HUDManager.
            *
            * @method createHUD
            * @param name {string} Name of the new HUDDisplay that is being creates.
            * @param [switchTo=false] {boolean} Switch to the new HUD that was created. DE
            * @return {HUDDisplay} The HUDDisplay that was created.
            * @public
            */
            HUDManager.prototype.createHUD = function (name, switchTo) {
                if (typeof switchTo === "undefined") { switchTo = false; }
                if (this.supported) {
                    var hud = new Kiwi.HUD.HUDDisplay(this._game, name);
                    hud.hide();
                    this.addToContainer(hud);
                    this._huds.push(hud);

                    if (switchTo === true)
                        this.setHUD(hud);

                    return hud;
                }
            };

            /**
            * Removes a HUDDisplay off this manager. Returns a boolean indicating whether or not this method was a success.
            *
            * @method removeHUD
            * @param hud {HUDDisplay} The hud you want to remove.
            * @returns {boolean} If this method succeeded or not.
            * @public
            */
            HUDManager.prototype.removeHUD = function (hud) {
                if (this.supported) {
                    if (hud === this._defaultHUD) {
                        return false;
                    }

                    if (this._currentHUD === hud) {
                        this.setHUD(this._defaultHUD);
                    }

                    this.removeFromContainer(hud);

                    var i = this._huds.indexOf(hud);

                    if (i !== -1) {
                        this._huds.splice(i, 1);
                    }

                    return true;
                }
            };

            /**
            * Adds a HUDDisplays HTMLDivElement to this HUDManagers container element.
            * @method addToContainer
            * @param hud {HUDDisplay} The HUDDisplay that is to be added.
            * @private
            */
            HUDManager.prototype.addToContainer = function (hud) {
                if (this._device == Kiwi.TARGET_BROWSER) {
                    this._hudContainer.appendChild(hud.container);
                }
            };

            /**
            * Removes the hud that is passed from this HUD Manager. Checks to see if that hud has this container as a parent first.
            * @method removeFromContainer
            * @param hud {HUDDisplay} The hud to be removed
            * @private
            */
            HUDManager.prototype.removeFromContainer = function (hud) {
                if (this._device == Kiwi.TARGET_BROWSER) {
                    if (this._hudContainer.contains(hud.container)) {
                        this._hudContainer.removeChild(hud.container);
                    }
                }
            };

            /**
            * Game loop
            * @method update
            * @public
            */
            HUDManager.prototype.update = function () {
                if (this._supported) {
                    for (var i = 0; i < this._huds.length; i++) {
                        this._huds[i].update();
                    }
                }
            };
            return HUDManager;
        })();
        HUD.HUDManager = HUDManager;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule HUD
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        /**
        * The HUDWidget is an abstract class containing the fundamental properties and methods that every HUDWidget needs to have.
        * This class is designed to be extended from and thus objects should not directly instantiate it.
        *
        * @class HUDWidget
        * @namespace Kiwi.HUD
        * @constructor
        * @param game {Game}  The game that this HUDWidget belongs to.
        * @param name {string} Name of the type of HUDWidget.
        * @param x {number} The coordinates of this HUDWidget on the x-axis.
        * @param y {number} The coordinates of this HUDWidget on the y-axis.
        * @return {HUDWidget}
        */
        var HUDWidget = (function () {
            function HUDWidget(game, name, x, y) {
                this.name = name;
                this.game = game;
                this._manager = this.game.huds;
                this._device = this.game.deviceTargetOption;
                this.components = new Kiwi.ComponentManager(Kiwi.HUD_WIDGET, this);

                if (this._manager.supported) {
                    if (this._device === Kiwi.TARGET_BROWSER) {
                        this.container = document.createElement("div");
                        this.container.id = 'HUD-widget-' + this.game.rnd.uuid();
                        this.container.className = 'HUD-widget';
                        this.container.style.position = "absolute";
                    }

                    this.onCoordsUpdate = new Kiwi.Signal();
                    this.x = x;
                    this.y = y;
                }
            }
            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            HUDWidget.prototype.objType = function () {
                return 'HUDWidget';
            };

            Object.defineProperty(HUDWidget.prototype, "style", {
                /**
                * A quick way to reference the style object that exists on the container element of this widget.
                * @property style
                * @type any
                * @public
                */
                get: function () {
                    if (this._device === Kiwi.TARGET_BROWSER) {
                        return this.container.style;
                    }
                },
                set: function (val) {
                    if (this._device === Kiwi.TARGET_BROWSER) {
                        this.container.style = val;
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(HUDWidget.prototype, "x", {
                /**
                * Get the x coordinate of the widget
                * @property x
                * @type number
                * @public
                */
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._manager.supported) {
                        this._x = value;
                        if (this._device == Kiwi.TARGET_BROWSER)
                            this.container.style.left = this.x + "px";

                        this.onCoordsUpdate.dispatch(this.x, this.y);
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(HUDWidget.prototype, "y", {
                /**
                * Get the y coordinate of the widget
                * @property y
                * @type number
                * @public
                */
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._manager.supported) {
                        this._y = value;
                        if (this._device == Kiwi.TARGET_BROWSER)
                            this.container.style.top = this.y + "px";

                        this.onCoordsUpdate.dispatch(this.x, this.y);
                    }
                },
                enumerable: true,
                configurable: true
            });

            /**
            * This method is used to remove existing DOM elements and place them inside a HUDWidget's container element.
            * Useful so that when making HUD Widgets the developer can style HUDWidgets without having to create/write to much javascript.
            *
            * Can be used by itself but maybe more useful if you customise it to suit your own needs.
            * Currently doesn't have that great support.
            *
            * @method setTemplate
            * @param main {string} main - ID of an HTMLElement. This element should contain all of the elements you would like to place inside the HUDWidget.
            * @param [element] {string} element - ID of an HTMLElement that resides inside of the main param. This is the element that the HUDWidget can use to populate with information. E.g. Your score, health remaining, the icon, e.t.c.
            * @public
            */
            HUDWidget.prototype.setTemplate = function (main, element) {
                var paramsArr = [];
                for (var _i = 0; _i < (arguments.length - 2); _i++) {
                    paramsArr[_i] = arguments[_i + 2];
                }
                if (this._device == Kiwi.TARGET_BROWSER) {
                    var containerElement = document.getElementById(main);
                    if (containerElement === undefined) {
                        return;
                    }

                    if (element === undefined) {
                        var fieldElement = containerElement;
                    } else {
                        var fieldElement = document.getElementById(element);
                        if (fieldElement === undefined || containerElement.contains(fieldElement) === false) {
                            return;
                        }
                    }

                    this.tempElement = fieldElement;
                    this._tempContainer = containerElement;
                    this._tempParent = containerElement.parentElement;
                    this._tempParent.removeChild(containerElement);
                    this.container.appendChild(containerElement);
                }
            };

            /**
            * Used to remove any the template HTML from this HUDWidget.
            * Currently doesn't have that great support.
            *
            * @method removeTemplate
            * @public
            */
            HUDWidget.prototype.removeTemplate = function () {
                if (this._device == Kiwi.TARGET_BROWSER) {
                    if (this.tempElement !== undefined) {
                        this.container.removeChild(this._tempContainer);
                        this._tempParent.appendChild(this._tempContainer);
                        this.tempElement = null;
                        this._tempParent = null;
                        this._tempContainer = null;
                    }
                }
            };

            Object.defineProperty(HUDWidget.prototype, "class", {
                get: function () {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        return this.container.className;
                    }
                },
                /**
                * The class name/s that the container element that this HUDWidget current has.
                * @property class
                * @type {String}
                * @public
                */
                set: function (cssClass) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.className = cssClass;
                    }
                },
                enumerable: true,
                configurable: true
            });

            /**
            * The game update loop.
            * @method update
            * @public
            */
            HUDWidget.prototype.update = function () {
                this.components.update();
            };

            /**
            *
            * @method destroy
            * @public
            */
            HUDWidget.prototype.destroy = function () {
                delete this.game;
                delete this._manager;
                delete this._device;
                if (this.onCoordsUpdate)
                    this.onCoordsUpdate.dispose();
                delete this.onCoordsUpdate;
                //remove the elements....
            };
            return HUDWidget;
        })();
        HUD.HUDWidget = HUDWidget;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
* HUD Widgets are objects that are generally placed on to a HUD Display for displaying and managing information that the user would always need to see.
* An example of such information would be: the Health remaining, amount of ammo left, time they have left, e.t.c.
* And each one of those examples would have its own widget.
*
* @module HUD
* @submodule Widget
* @main Widget
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        (function (Widget) {
            /**
            * A Widget that is used for the displaying of text on the HUD.
            * Foreach TextField you can add some prefix/suffix text, which is more useful on classes extending this one.
            *
            * @class TextField
            * @extends HUDWidget
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Game} The game that this textfield belongs to.
            * @param text {string} The text on this textfield.
            * @param x {number} The x coordinates
            * @param y {number} The y coordinates
            * @return {TextField}
            */
            var TextField = (function (_super) {
                __extends(TextField, _super);
                function TextField(game, text, x, y) {
                    _super.call(this, game, "textField", x, y);
                    /**
                    * A string that is to be added in-front of the score. Can contain HTMLElements.
                    * @property _prefix
                    * @type string
                    * @default ''
                    * @private
                    */
                    this._prefix = '';
                    /**
                    * A string that is to be added after the score. Can contain HTMLElements.
                    * @property _suffix
                    * @type string
                    * @default ''
                    * @private
                    */
                    this._suffix = '';

                    this.class = 'kiwi-textfield-widget kiwi-widget';

                    if (this._manager.supported) {
                        if (this._device === Kiwi.TARGET_BROWSER) {
                            this._textField = this.container;
                            this._textField.innerHTML = text;
                        }
                    }
                }
                /**
                * Returns the type of object that this is.
                * @method objType
                * @return {String}
                * @public
                */
                TextField.prototype.objType = function () {
                    return 'TextFieldWidget';
                };

                /**
                * This method is used to remove existing DOM elements and place them inside a HUDWidget's container element.
                * Useful so that when making HUD Widgets the developer can style HUDWidgets without having to create/write to much javascript.
                *
                * Currently doesn't have great support.
                *
                * @method setTemplate
                * @param main {string} ID of an HTMLElement. This element should contain all of the elements you would like to place inside the HUDWidget.
                * @param icon {string} ID of an HTMLElement that resides inside of the main param. This is the element that the HUDWidget can use to populate with information. E.g. Your score, health remaining, the icon, e.t.c.
                * @public
                */
                TextField.prototype.setTemplate = function (main, field) {
                    if (this._device === Kiwi.TARGET_BROWSER) {
                        this._textField.innerText = '';
                        _super.prototype.setTemplate.call(this, main, field);

                        if (this.tempElement !== undefined) {
                            this._textField = this.tempElement;
                        }
                        this._textField.innerHTML = this._text;
                    }
                };

                /**
                * Used to remove any the template HTML from this HUDWidget.
                * Currently doesn't have great support.
                *
                * @method removeTemplate
                * @public
                */
                TextField.prototype.removeTemplate = function () {
                    if (this._device === Kiwi.TARGET_BROWSER) {
                        _super.prototype.removeTemplate.call(this);

                        if (this._device === Kiwi.TARGET_BROWSER) {
                            this._textField = this.container;
                            this._textField.innerHTML = this._text;
                        }
                    }
                };

                Object.defineProperty(TextField.prototype, "text", {
                    get: function () {
                        return this._text;
                    },
                    /**
                    * The text that is currently being displayed inside the textfield.
                    * @property text
                    * @type string
                    * @public
                    */
                    set: function (val) {
                        if (this._manager.supported) {
                            if (this._device === Kiwi.TARGET_BROWSER) {
                                if (this._prefix !== '')
                                    val = this._prefix + val;
                                if (this._suffix !== '')
                                    val += this._suffix;

                                this._text = val;
                                this._textField.innerHTML = this._text;
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(TextField.prototype, "suffix", {
                    get: function () {
                        return this._suffix;
                    },
                    /**
                    * A string that is to be added after the score. Can contain HTMLElements.
                    * @property _suffix
                    * @type string
                    * @default ''
                    * @public
                    */
                    set: function (val) {
                        this._suffix = val;
                        this._updateText();
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(TextField.prototype, "prefix", {
                    get: function () {
                        return this._prefix;
                    },
                    /**
                    * A string that is to be added in-front of the score. Can contain HTMLElements.
                    * @property _prefix
                    * @type string
                    * @default ''
                    * @public
                    */
                    set: function (val) {
                        this._prefix = val;
                        this._updateText();
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * This method is intended to be overriden by subclasses which functions update the text being displayed.
                * @method _updateText
                * @protected
                */
                TextField.prototype._updateText = function () {
                    //..your code here
                    this.text = this._text;
                };
                return TextField;
            })(Kiwi.HUD.HUDWidget);
            Widget.TextField = TextField;
        })(HUD.Widget || (HUD.Widget = {}));
        var Widget = HUD.Widget;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
* @module HUD
* @submodule Widget
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        (function (Widget) {
            /**
            * Used for displaying of information in a bar like of format. Example: Amount of health remaining for a character.
            * This class creates a 'innerbar' div inside of its main container which you can apply styles to.
            * You can control the minimum/maximum and current values of the bar through the Counter widget.
            *
            * @class Bar
            * @extends HUDWidget
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Game} The game that this bar belongs to.
            * @param current {number} The current value of the bar.
            * @param max {number} The maximum value that there can be.
            * @param x {number} The coordinates of this widget on the x-axis.
            * @param y {number} The cooridnates of this widget on the y-axis.
            * @param [width=120] {number} The width of the widget. Defaults to 120.
            * @param [height=20] {number} The height of the widget. Defaults to 20.
            * @param [color='#000'] {string} The default color of the inner bar. Defaults to #000 (black).
            * @return {Bar}
            */
            var Bar = (function (_super) {
                __extends(Bar, _super);
                function Bar(game, current, max, x, y, width, height, color) {
                    if (typeof width === "undefined") { width = 120; }
                    if (typeof height === "undefined") { height = 20; }
                    if (typeof color === "undefined") { color = '#000'; }
                    _super.call(this, game, "bar", x, y);
                    this._horizontal = true;
                    this.class = 'kiwi-bar-widget kiwi-widget';

                    if (this._manager.supported) {
                        if (this._device == Kiwi.TARGET_BROWSER) {
                            this._bar = document.createElement('div');
                            this._bar.className = 'kiwi-innerbar-widget';
                            this._bar.style.backgroundColor = color;
                            this.bar = this._bar;
                            this.container.appendChild(this.bar);
                        }

                        this.counter = this.components.add(new Kiwi.HUD.HUDComponents.Counter(this, current, max, 0));
                        this.counter.updated.add(this.updateCSS, this);

                        this.width = width;
                        this.height = height;

                        this._bar.style.height = '100%';
                        this._bar.style.width = '100%';

                        this.updateCSS();
                    }
                }
                /**
                * Returns the type of object that this is.
                * @method objType
                * @return {String}
                * @public
                */
                Bar.prototype.objType = function () {
                    return 'BarWidget';
                };

                Object.defineProperty(Bar.prototype, "width", {
                    /**
                    * The width of the container
                    * @property width
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this._width;
                    },
                    set: function (value) {
                        if (this._device == Kiwi.TARGET_BROWSER) {
                            this.container.style.width = value + "px";
                        }

                        this._width = value;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Bar.prototype, "height", {
                    /**
                    * The height of the container
                    * @property height
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this._height;
                    },
                    set: function (value) {
                        if (this._device == Kiwi.TARGET_BROWSER) {
                            this.container.style.height = value + "px";
                        }
                        this._height = value;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Bar.prototype, "horizontal", {
                    /**
                    * Used to set the bar to be horizontal or vertical by passing a boolean.
                    * @property horizontal
                    * @type boolean
                    * @public
                    */
                    get: function () {
                        return this._horizontal;
                    },
                    set: function (val) {
                        this._horizontal = val;
                        this.updateCSS();
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Bar.prototype, "vertical", {
                    /**
                    * Used to set the bar to be horizontal or vertical by passing a boolean.
                    * @property verticle
                    * @type boolean
                    * @public
                    */
                    get: function () {
                        return !this._horizontal;
                    },
                    set: function (val) {
                        this._horizontal = !val;
                        this.updateCSS();
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * This method is used to remove existing DOM elements and place them inside a HUDWidget's container element.
                * Useful so that when making HUD Widgets the developer can style HUDWidgets without having to create/write to much javascript.
                * Currently not supported.
                *
                * @method setTemplate
                * @param main {string} ID of an HTMLElement. This element should contain all of the elements you would like to place inside the HUDWidget.
                * @param innerbar {string} ID of an HTMLElement that resides inside of the main param. This is the element that the HUDWidget can use to populate with information. E.g. Your score, health remaining, the icon, e.t.c.
                * @public
                */
                Bar.prototype.setTemplate = function (main, innerbar) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        _super.prototype.setTemplate.call(this, main, innerbar);

                        if (this.tempElement !== undefined) {
                            this.bar = this.tempElement;
                        }
                    }
                };

                /**
                * Used to remove any the template HTML from this HUDWidget.
                * Current not supported.
                *
                * @method removeTemplate
                * @public
                */
                Bar.prototype.removeTemplate = function () {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        _super.prototype.removeTemplate.call(this);

                        this.bar = this._bar;
                        this.container.appendChild(this.bar);
                        this.updateCSS();
                    }
                };

                /**
                * Will be called when the range has been updated and thus you will want to preform the render of the bar here.
                * This should be overriden by subclasses so that you have your own custom bars.
                * @method updateCSS
                * @public
                */
                Bar.prototype.updateCSS = function () {
                    if (this.horizontal === true) {
                        this.bar.style.width = String(this.counter.currentPercent()) + '%';
                        this.bar.style.height = '100%';
                    } else {
                        this.bar.style.height = String(this.counter.currentPercent()) + '%';
                        this.bar.style.width = '100%';
                    }
                };
                return Bar;
            })(Kiwi.HUD.HUDWidget);
            Widget.Bar = Bar;
        })(HUD.Widget || (HUD.Widget = {}));
        var Widget = HUD.Widget;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
*
* @module HUD
* @submodule Widget
*
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        (function (Widget) {
            /**
            * Used to display a cell from a TextureAtlas in the HUD. This could be used for portraits of the character, e.t.c.
            * You can change the current cell that is being used in the TextureAtlas by modifing the cellIndex property.
            *
            * @class Icon
            * @extends HUDWidget
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Game} The game that this icon belongs to.
            * @param atlas {TextureAtlas} The image that you would like displayed.
            * @param x {number} The coordinate of the icon on the x-axis.
            * @param y {number The coordinate of the icon on the y-axis.
            * @return {Icon}
            */
            var Icon = (function (_super) {
                __extends(Icon, _super);
                function Icon(game, atlas, x, y) {
                    _super.call(this, game, 'Icon', x, y);
                    /**
                    * The cell inside the texture atlas that this icon is using
                    * @property _cellIndex
                    * @type number
                    * @default 0
                    * @private
                    */
                    this._cellIndex = 0;

                    this.class = 'kiwi-icon-widget kiwi-widget';
                    this.atlas = atlas;
                    this.icon = this.container;
                    this._applyCSS();
                }
                Object.defineProperty(Icon.prototype, "cellIndex", {
                    /**
                    * Gets the cell index that is being used.
                    * @property cellIndex
                    * @type number
                    * @default 0
                    * @public
                    */
                    get: function () {
                        return this._cellIndex;
                    },
                    set: function (value) {
                        this._cellIndex = value;
                        this.width = this.atlas.cells[this.cellIndex].w;
                        this.height = this.atlas.cells[this.cellIndex].h;
                        this._applyCSS();
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Icon.prototype, "width", {
                    /**
                    * Returns the width of the cell that is being used.
                    * @property width
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this.atlas.cells[this.cellIndex].w;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Icon.prototype, "height", {
                    /**
                    * Returns the height of the cell that is being used.
                    * @property height
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this.atlas.cells[this.cellIndex].h;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Removes the CSS from the Icon.
                * This can happen when setting/removing a template and is public to allow for overriding from subclasses.
                * @method _removeCSS
                * @protected
                */
                Icon.prototype._removeCSS = function () {
                    this.icon.style.width = '';
                    this.icon.style.height = '';
                    this.icon.style.backgroundImage = '';
                    this.icon.style.backgroundRepeat = '';
                    this.icon.style.backgroundSize = '';
                };

                /**
                * Applys the css to the HTMLElement that is to be affected.
                * @method _applyCSS
                * @protected
                */
                Icon.prototype._applyCSS = function () {
                    this.icon.style.width = this.width + "px";
                    this.icon.style.height = this.height + "px";
                    this.icon.style.backgroundSize = "100%";
                    this.icon.style.backgroundPositionX = -this.atlas.cells[this.cellIndex].x + "px";
                    this.icon.style.backgroundPositionY = -this.atlas.cells[this.cellIndex].y + "px";
                    this.icon.style.backgroundImage = 'url("' + this.atlas.image.src + '")';
                };

                /**
                * This method is used to remove existing DOM elements and place them inside a HUDWidget's container element.
                * Useful so that when making HUD Widgets the developer can style HUDWidgets without having to create/write to much javascript.
                * Currently not supported.
                *
                * @method setTemplate
                * @param main {string} main - ID of an HTMLElement. This element should contain all of the elements you would like to place inside the HUDWidget.
                * @param icon {string} icon - ID of an HTMLElement that resides inside of the main param. This is the element that the HUDWidget can use to populate with information. E.g. Your score, health remaining, the icon, e.t.c.
                * @public
                */
                Icon.prototype.setTemplate = function (main, icon) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this._removeCSS();

                        _super.prototype.setTemplate.call(this, main, icon);

                        if (this.tempElement !== undefined) {
                            this.icon = this.tempElement;
                        }

                        this._applyCSS();
                    }
                };

                /**
                * Used to remove any the template HTML from this HUDWidget.
                *
                * @method removeTemplate
                * @public
                */
                Icon.prototype.removeTemplate = function () {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        _super.prototype.removeTemplate.call(this);

                        this._removeCSS();
                        this.icon = this.container;
                        this._applyCSS();
                    }
                };
                return Icon;
            })(Kiwi.HUD.HUDWidget);
            Widget.Icon = Icon;
        })(HUD.Widget || (HUD.Widget = {}));
        var Widget = HUD.Widget;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
*
* @module HUD
* @submodule Widget
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        (function (Widget) {
            /**
            * The IconBar used to display a series of icons which represent a number of 'something' the user may have.
            * Example: If you had a shooter style game you might want to display the amount of 'ammo' left in the gun using a series of bullet icons. You could then use this IconBar to display that series.
            * The amount is based of a counter components current value, so you can set a maximum and minimum number of images to be displayed.
            *
            * @class IconBar
            * @extends HUDWidget
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Game} The game that this icon bar belongs to.
            * @param atlas {TextureAtlas} The texture atlas that the icons will have.
            * @param current {number} The current amount of icons in the bar.
            * @param max {number} The maximum number of icons.
            * @param x {number} The x coordinates of the first icon.
            * @param y {number} The y coordinates of the last icon.
            * @return {IconBar}
            */
            var IconBar = (function (_super) {
                __extends(IconBar, _super);
                function IconBar(game, atlas, current, max, x, y) {
                    _super.call(this, game, 'IconBar', x, y);
                    /**
                    * The amount of spacing you want between each icon in the bar. Defaults to 0.
                    * @property iconGap
                    * @type number
                    * @default 0
                    * @public
                    */
                    this.iconGap = 0;

                    this.class = 'kiwi-iconbar-widget kiwi-widget';
                    this.atlas = atlas;
                    this.width = this.atlas.cells[0].w;
                    this.height = this.atlas.cells[0].h;
                    this._horizontal = true;

                    this.counter = this.components.add(new Kiwi.HUD.HUDComponents.Counter(this, current, max, 0));
                    this.counter.updated.add(this._amountChanged, this);

                    this._icons = [];
                    this._amountChanged();
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String}
                * @public
                */
                IconBar.prototype.objType = function () {
                    return 'IconBarWidget';
                };

                /**
                * Gets called when the range has updated and then it updates the size of the bar.
                * @method _changeSize
                * @private
                */
                IconBar.prototype._amountChanged = function () {
                    //do we need to do something to the icons?!?
                    if (this.counter.max !== this._icons.length) {
                        if ((this.counter.max) > this._icons.length) {
                            //add more
                            var amount = (this.counter.max) - this._icons.length;
                            for (var i = 0; i < amount; i++) {
                                this._addIcon();
                            }
                        } else {
                            for (var i = this.counter.max; i < this._icons.length; i++) {
                                this._removeIcon(this._icons[i]);
                                this._icons[i].destroy();
                                this._icons.splice(i, 1);
                                i--;
                            }
                        }
                    }

                    for (var i = 0; i < this._icons.length; i++) {
                        if (i > (this.counter.current - 1)) {
                            this._icons[i].style.display = 'none';
                        } else {
                            this._icons[i].style.display = 'block';
                        }
                    }
                };

                /**
                * Creates a new Icon and adds it to this IconBar.
                * @method _addIcon
                * @private
                */
                IconBar.prototype._addIcon = function () {
                    if (this.horizontal) {
                        var i = new Kiwi.HUD.Widget.Icon(this.game, this.atlas, this.x + ((this.width + this.iconGap) * (this._icons.length - 1)), this.y);
                    } else {
                        var i = new Kiwi.HUD.Widget.Icon(this.game, this.atlas, this.x, ((this.height + this.iconGap) * (this._icons.length - 1)) + this.y);
                    }

                    this._icons.push(i);
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.appendChild(i.container);
                    }
                };

                /**
                * Removes a Icon from the container.
                * @method _removeIcon
                * @param icon {Icon} The icon that you want to remove
                * @private
                */
                IconBar.prototype._removeIcon = function (icon) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.removeChild(icon.container);
                    }
                };

                Object.defineProperty(IconBar.prototype, "horizontal", {
                    /**
                    * Used to set the bar to be horizontal or vertical by passing a boolean.
                    * @property horizontal
                    * @type boolean
                    * @default true
                    * @public
                    */
                    get: function () {
                        return this._horizontal;
                    },
                    set: function (val) {
                        this._horizontal = val;
                        this._amountChanged();
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(IconBar.prototype, "vertical", {
                    /**
                    * Used to set the bar to be horizontal or vertical by passing a boolean.
                    * @property vertical
                    * @type boolean
                    * @default false
                    * @public
                    */
                    get: function () {
                        return !this._horizontal;
                    },
                    set: function (val) {
                        this._horizontal = !val;
                        this._amountChanged();
                    },
                    enumerable: true,
                    configurable: true
                });
                return IconBar;
            })(Kiwi.HUD.HUDWidget);
            Widget.IconBar = IconBar;
        })(HUD.Widget || (HUD.Widget = {}));
        var Widget = HUD.Widget;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
* @module HUD
* @submodule Widget
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        (function (Widget) {
            /**
            * A subclass of textfield that is primarily used to keep track of a score.
            * The score can be accessed via the counter component.
            *
            * @class BasicScore
            * @extends TextField
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Game} The game that this BasicScore belongs to.
            * @param x {number} The cooridnates of the game on the x-axis.
            * @param y {number} The cooridnates of the game on the y-axis.
            * @param [initial=0] {number} The initial score to start off at.
            * @return {BasicScore}
            */
            var BasicScore = (function (_super) {
                __extends(BasicScore, _super);
                function BasicScore(game, x, y, initial) {
                    if (typeof initial === "undefined") { initial = 0; }
                    _super.call(this, game, "basicScore", x, y);
                    this.name = 'basicScore';
                    this.class = 'kiwi-basicscore-widget kiwi-widget';
                    this.counter = this.components.add(new Kiwi.HUD.HUDComponents.Counter(this, initial));
                    this.counter.updated.add(this._updateText, this);
                    this._updateText();
                }
                /**
                * Returns the type of object that this is.
                * @method objType
                * @return {String}
                * @public
                */
                BasicScore.prototype.objType = function () {
                    return 'BasicScoreWidget';
                };

                /**
                * Updates the text inside the textfield.
                * @method _updateText
                * @private
                */
                BasicScore.prototype._updateText = function () {
                    this.text = String(this.counter.current);
                };
                return BasicScore;
            })(Kiwi.HUD.Widget.TextField);
            Widget.BasicScore = BasicScore;
        })(HUD.Widget || (HUD.Widget = {}));
        var Widget = HUD.Widget;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
*
* @module HUD
* @submodule Widget
*
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        (function (Widget) {
            /**
            * A subclass of the TextField that has its own input component so that you can listen for mouse events on this widget.
            *
            * @class Button
            * @extends TextField
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {game} The game that this belongs to.
            * @param text {string} The text that you want to display inside the button.
            * @param x {number} The x-coordnates of this Widget.
            * @param y {number} The y-coordinates of this Widget.
            * @return {Button}
            */
            var Button = (function (_super) {
                __extends(Button, _super);
                function Button(game, text, x, y) {
                    _super.call(this, game, text, x, y);

                    this.name = 'button';
                    this.class = 'kiwi-button-widget kiwi-widget';

                    this.input = this.components.add(new Kiwi.HUD.HUDComponents.WidgetInput(this, this.container));
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String}
                * @public
                */
                Button.prototype.objType = function () {
                    return 'ButtonWidget';
                };
                return Button;
            })(Kiwi.HUD.Widget.TextField);
            Widget.Button = Button;
        })(HUD.Widget || (HUD.Widget = {}));
        var Widget = HUD.Widget;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
*
* @module HUD
* @submodule Widget
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        /*
        * TO DO---- SIGNALS/CALLBACKS
        */
        (function (Widget) {
            /**
            * A subclass of TextField which manages the displaying of a Time/Timer by creating a new clock on the Time Manager.
            * The time is managed by a Time Component which contains a format property that handles how the time should be formatted.
            *
            * @class Time
            * @extends TextField
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Game} The game that this object belongs to.
            * @param format {string} The format that you want the time to be displayed in. Leave it empty to display as normal.
            * @param x {number} The position of this text on the field.
            * @param y {number} The position of this text on the field.
            * @return {TextField}
            */
            var Time = (function (_super) {
                __extends(Time, _super);
                function Time(game, format, x, y) {
                    _super.call(this, game, 'time', x, y);
                    this.name = 'time';
                    this.class = 'kiwi-time-widget kiwi-widget';
                    this.time = this.components.add(new Kiwi.HUD.HUDComponents.Time(this, format));
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String}
                * @public
                */
                Time.prototype.objType = function () {
                    return 'TimeWidget';
                };

                /**
                * Pauses the clock where is stands. Calls the pause method on the clock.
                * @method pause
                * @public
                */
                Time.prototype.pause = function () {
                    this.time.pause();
                };

                /**
                * Stops the clock and thus the time. Calls the stop method of the clock.
                * @method stop
                * @public
                */
                Time.prototype.stop = function () {
                    this.time.stop();
                };

                /**
                * Starts the clock and thus the time.
                * @method start
                * @public
                */
                Time.prototype.start = function () {
                    this.time.start();
                };

                /**
                * Resumes the clock and thus the time.
                * @method resume
                * @public
                */
                Time.prototype.resume = function () {
                    this.time.resume();
                };

                /**
                * The update loop.
                * @method update
                * @public
                */
                Time.prototype.update = function () {
                    _super.prototype.update.call(this);

                    //update the time
                    if (this.time.isRunning) {
                        this.text = this.time.getTime();
                    }
                };
                return Time;
            })(Kiwi.HUD.Widget.TextField);
            Widget.Time = Time;
        })(HUD.Widget || (HUD.Widget = {}));
        var Widget = HUD.Widget;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
* @module HUD
* @submodule Widget
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        (function (Widget) {
            /**
            * A Widget for that is used for the management/displaying of a Menu.
            * This class is primarily used as a manager of MenuItems, so on this class you can create/add MenuItems
            * and styles that you want applyed to all MenuItems.
            *
            * @class Menu
            * @extends HUDWidget
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Game} The game that this Menu belongs to.
            * @param x {number} Its position on the x-axis.
            * @param y {number} Its position on the y -axis.
            * @return {Menu}
            */
            var Menu = (function (_super) {
                __extends(Menu, _super);
                function Menu(game, x, y) {
                    _super.call(this, game, 'menu', x, y);

                    this._menuItems = [];
                    this._styles = [];
                    this.class = 'kiwi-menu-widget kiwi-widget';
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {string}
                * @public
                */
                Menu.prototype.objType = function () {
                    return 'MenuWidget';
                };

                /**
                * Sets the style of all of the icons that will be on this menu.
                * @method setStyle
                * @param index {string}
                * @param value {string}
                * @public
                */
                Menu.prototype.setIconStyle = function (index, value) {
                    this._styles.push(({ 'index': index, 'value': value }));

                    for (var i = 0; i < this._menuItems.length; i++) {
                        this._menuItems[i].style[index] = value;
                    }
                };

                Object.defineProperty(Menu.prototype, "menuItems", {
                    /**
                    * Returns a list that contains all of the menu items (buttons) that are currently on this menu.
                    * Note: The array itself is READ ONLY but you can modify the objects contained inside of it.
                    * @property menuItems
                    * @type MenuItem[]
                    * @public
                    */
                    get: function () {
                        return this._menuItems;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Creates a new menu item and add's it to this menu.
                * @method createMenuItem
                * @param text {string} The text that you would like the menu item to have.
                * @param x {number} The x position of the menu item you are wanting to add.
                * @param y {number} The y position of the menu item you are wanting to add.
                * @return {MenuItem} The newly created MenuItem.
                * @public
                */
                Menu.prototype.createMenuItem = function (text, x, y) {
                    return this.addMenuItem(new Kiwi.HUD.Widget.MenuItem(this.game, text, x, y));
                };

                /**
                * Adds a MenuItem to this menu.
                * @method addMenuItem
                * @param item {MenuItem} The MenuItem that you would like to add to this menu.
                * @return {MenuItem}
                * @public
                */
                Menu.prototype.addMenuItem = function (item) {
                    this._menuItems.push(item);
                    item.menu = this;

                    for (var i = 0; i < this._styles.length; i++) {
                        item.style[this._styles[i].index] = this._styles[i].value;
                    }

                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.appendChild(item.container);
                    }

                    return item;
                };

                /**
                * Adds multiple MenuItems to this Menu.
                * @method addMenuItems
                * @param items {MenuItem[]} The array containing all of the menu items you want to add.
                * @public
                */
                Menu.prototype.addMenuItems = function (items) {
                    for (var i = 0; i < items.length; i++) {
                        this.addMenuItem(items[i]);
                    }
                };

                /**
                * Returns a MenuItem based on its corresponding numeric position that you pass in the array.
                * @method getMenuItem
                * @param val {Number}
                * @return {Kiwi.HUD.Widget.MenuItem}
                * @public
                */
                Menu.prototype.getMenuItem = function (val) {
                    return this._menuItems[val];
                };

                /**
                * Currently not supported or working.
                * @method setTemplate
                * @param main {string}
                * @param [sub] {string}
                * @public
                */
                Menu.prototype.setTemplate = function (main, sub) {
                    if (false) {
                        var mainElement = document.getElementById(main);
                        if (mainElement === undefined) {
                            return;
                        }

                        var subElements = mainElement.getElementsByTagName(sub);
                        if (subElements === undefined) {
                            return;
                        }

                        _super.prototype.setTemplate.call(this, main);
                        //do something with each item
                    }
                };

                /**
                * Currently not working.
                * @method removeTemplate
                * @public
                */
                Menu.prototype.removeTemplate = function () {
                };

                /**
                * The update loop.
                * @method update
                * @public
                */
                Menu.prototype.update = function () {
                    for (var i = 0; i < this._menuItems.length; i++) {
                        this._menuItems[i].update();
                    }
                    _super.prototype.update.call(this);
                };
                return Menu;
            })(Kiwi.HUD.HUDWidget);
            Widget.Menu = Menu;
        })(HUD.Widget || (HUD.Widget = {}));
        var Widget = HUD.Widget;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
* @module HUD
* @submodule Widget
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        (function (Widget) {
            /**
            * A MenuItem extends the Button Widget and is typically contained inside of a Menu Widget.
            * Since a MenuItem extends the Button Widget you can access the Input Component that it has to listen to mouse events.
            *
            * @class MenuItem
            * @extends HUDWidget
            * @namespace Kiwi.HUD.Widget
            * @contructor
            * @param game {Game} The game that this MenuItem belongs to.
            * @param text {string} The text that is to be inside the menuitem.
            * @param x {number} The position of this menu item on the x-axis.
            * @param y {number} The position of this menu item on the y-axis.
            * @return {Button}
            */
            var MenuItem = (function (_super) {
                __extends(MenuItem, _super);
                function MenuItem(game, text, x, y) {
                    _super.call(this, game, text, x, y);

                    this.name = 'menuItem';
                    this.class = 'kiwi-menuitem-widget kiwi-widget';
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {string}
                * @public
                */
                MenuItem.prototype.objType = function () {
                    return 'MenuItem';
                };
                return MenuItem;
            })(Kiwi.HUD.Widget.Button);
            Widget.MenuItem = MenuItem;
        })(HUD.Widget || (HUD.Widget = {}));
        var Widget = HUD.Widget;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
* HUDComponents are a space where components that are specific to HUDWidgets are kept. This are seperated from the normal Components section as the implementation of these are unique and only make sense when implemented on HUDWidgets, otherwise the concepts behind these are the same as normal Components.
*
* @module HUD
* @submodule HUDComponents
* @main HUDComponents
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        (function (HUDComponents) {
            /**
            * The Counter component handles a incrementation/decrementation of a singular numeric value.
            * You can also specifiy maximum/minimum values that the numeric value has be within but by default there is no max/min.
            *
            * @class Counter
            * @extends Component
            * @namespace Kiwi.HUD.HUDComponents
            * @constructor
            * @param owner {any} The object that this Component belongs to.
            * @param current {number} The current value.
            * @param [max=null] {number} The maximum value it can be. Default is null which means no maximum.
            * @param [min=null] {number} The minimum value that the current can be. Default is null which means no minium.
            * @return {number}
            */
            var Counter = (function (_super) {
                __extends(Counter, _super);
                function Counter(owner, current, max, min) {
                    if (typeof max === "undefined") { max = null; }
                    if (typeof min === "undefined") { min = null; }
                    _super.call(this, owner, "counter");

                    this._current = current;
                    this._max = max;
                    this._min = min;

                    //signals!!!
                    this.updated = new Kiwi.Signal();
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String}
                * @public
                */
                Counter.prototype.objType = function () {
                    return 'CounterComponent';
                };

                Object.defineProperty(Counter.prototype, "max", {
                    get: function () {
                        return this._max;
                    },
                    /**
                    * Set allows setting of the maximum value that the range can be in.
                    * Get returns the maximum value.
                    *
                    * @property max
                    * @type number
                    * @public
                    */
                    set: function (val) {
                        this._max = val;
                        this.updated.dispatch(this._current, this._max, this._min);
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Counter.prototype, "min", {
                    get: function () {
                        return this._min;
                    },
                    /**
                    * Set allows setting of the minimum value that the range can be in.
                    * Get returns the minimum value.
                    *
                    * @property min
                    * @type number
                    * @public
                    */
                    set: function (val) {
                        this._min = val;
                        this.updated.dispatch(this._current, this._max, this._min);
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Counter.prototype, "current", {
                    get: function () {
                        return this._current;
                    },
                    /**
                    * Set allows setting of the current value that the range can be in.
                    * The current value will only change if it is within the maximum/minimum values.
                    * Get returns the current value.
                    *
                    * @property current
                    * @type number
                    * @public
                    */
                    set: function (val) {
                        if (this._max !== null && val > this._max) {
                            this._current = this._max;
                        } else if (this._min !== null && val < this._min) {
                            this._current = this._min;
                        } else {
                            this._current = val;
                        }
                        this.updated.dispatch(this._current, this._max, this._min);
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Decreases the current value by the amount past.
                * If the new amount would be less than the minimun it goes to the min instead.
                *
                * @method decrease
                * @param [val=1] {number} The amount that you want to decrease the current value by. Default is 1.
                * @return {number}
                * @public
                */
                Counter.prototype.decrease = function (val) {
                    if (typeof val === "undefined") { val = 1; }
                    if (this._min === null || this._current > this._min) {
                        if (this._min !== null && this._current - val < this._min) {
                            this._current = this._min;
                        } else {
                            this._current -= val;
                        }
                        this.updated.dispatch(this._current, this._max, this._min);
                    }
                    return this._current;
                };

                /**
                * Increases the current value by the amount past.
                * If the new amount would be greater than the maximum it goes to the max instead.
                *
                * @method increase
                * @param [val=1] {number} The amount that you want to increase the current value by. Default is 1.
                * @return {number}
                * @public
                */
                Counter.prototype.increase = function (val) {
                    if (typeof val === "undefined") { val = 1; }
                    if (this._max === null || this._current < this._max) {
                        if (this._max !== null && this._current + val > this._max) {
                            this._current = this._max;
                        } else {
                            this._current += val;
                        }
                        this.updated.dispatch(this._current, this._max, this._min);
                    }
                    return this._current;
                };

                /**
                * @method currentPercent
                * @return {number}
                * @public
                */
                Counter.prototype.currentPercent = function () {
                    if (this.max !== null)
                        return ((this.current) / (this.max)) * 100;
                };
                return Counter;
            })(Kiwi.Component);
            HUDComponents.Counter = Counter;
        })(HUD.HUDComponents || (HUD.HUDComponents = {}));
        var HUDComponents = HUD.HUDComponents;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
*
* @module HUD
* @submodule HUDComponents
*
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        (function (HUDComponents) {
            /**
            * The WidgetInput Component handles the input events that you may want to listen to on a widget.
            * This Component is essentually another version of the normal Input Component but instead of for GameObjects this is for HUDWidgets.
            *
            * @class WidgetInput
            * @extends Component
            * @namespace Kiwi.HUD.HUDComponents
            * @constructor
            * @param owner {any} The object that this WidgetInput belongs to.
            * @param container {HTMLElement} The HTMLElement that the events will occur on/to.
            * @return {WidgetInput}
            */
            var WidgetInput = (function (_super) {
                __extends(WidgetInput, _super);
                function WidgetInput(owner, container) {
                    _super.call(this, owner, 'WidgetInput');
                    /**
                    * If the events are currently actively running or not.
                    * @property active
                    * @type boolean
                    * @private
                    */
                    this._active = false;
                    this._container = container;

                    //signals!!
                    this.onUp = new Kiwi.Signal;
                    this.onDown = new Kiwi.Signal;
                    this.onOver = new Kiwi.Signal;
                    this.onOut = new Kiwi.Signal;

                    this._addEvents();
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String}
                * @public
                */
                WidgetInput.prototype.objType = function () {
                    return 'WidgetInputComponent';
                };

                /**
                * Changes the HTMLElement that the events are occuring on to one passed.
                * Removes all of the current events from container before changing.
                * @method setElement
                * @param container {HTMLElement} The new element that the events are going to occur on.
                * @public
                */
                WidgetInput.prototype.setElement = function (container) {
                    this._removeEvents();
                    this._container = container;
                    this._addEvents();
                };

                /**
                * Creates new bindings and adds the events to the HTMLElement.
                * @method _addEvents
                * @private
                */
                WidgetInput.prototype._addEvents = function () {
                    if (!this._active) {
                        this._binds = [];
                        this._binds.push({ 'event': 'mouseup', 'function': this._up.bind(this) });
                        this._binds.push({ 'event': 'mousedown', 'function': this._down.bind(this) });
                        this._binds.push({ 'event': 'mouseover', 'function': this._over.bind(this) });
                        this._binds.push({ 'event': 'mouseout', 'function': this._out.bind(this) });

                        for (var i = 0; i < this._binds.length; i++) {
                            this._container.addEventListener(this._binds[i].event, this._binds[i].function, false);
                        }
                        this._active = true;
                    }
                };

                /**
                * Removes the events off of the current container.
                * @method _removeEvents
                * @private
                */
                WidgetInput.prototype._removeEvents = function () {
                    if (this._active) {
                        for (var i = 0; i < this._binds.length; i++) {
                            this._container.removeEventListener(this._binds[i].event, this._binds[i].function, false);
                        }
                        this._binds = [];
                        this._active = false;
                    }
                };

                /**
                * The method that is called when a mouseup event fires. The onUp Signal is called.
                * @method _up
                * @param evt {MouseEvent}
                * @private
                */
                WidgetInput.prototype._up = function (evt) {
                    this.onUp.dispatch(evt);
                };

                /**
                * The method that is called when a mousedown event fires. The onDown Signal is called.
                * @method _down
                * @param evt {MouseEvent}
                * @private
                */
                WidgetInput.prototype._down = function (evt) {
                    this.onDown.dispatch(evt);
                };

                /**
                * The method that is called when a mouseover event fires. The onOver Signal is called.
                * @method _over
                * @param evt {MouseEvent}
                * @private
                */
                WidgetInput.prototype._over = function (evt) {
                    this.onOver.dispatch(evt);
                };

                /**
                * The method that is called when a mouseout event fires. The onOut Signal is called.
                * @method _out
                * @param evt {MouseEvent}
                * @private
                */
                WidgetInput.prototype._out = function (evt) {
                    this.onOut.dispatch(evt);
                };
                return WidgetInput;
            })(Kiwi.Component);
            HUDComponents.WidgetInput = WidgetInput;
        })(HUD.HUDComponents || (HUD.HUDComponents = {}));
        var HUDComponents = HUD.HUDComponents;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
*
* @module HUD
* @submodule HUDComponents
*
*/
var Kiwi;
(function (Kiwi) {
    (function (HUD) {
        (function (HUDComponents) {
            /**
            * A Component to manage and display a Time in a particular format.
            * The Time Component creates a new clock on the Time Manager and it use's that clock to keep track of the time.
            * When you create a new Time Component you can specify a format that you want the time to display in, which is a string based on keywords.
            * Current supported keywords for the format are:
            *  's' = 'seconds'
            *  'm' = 'minutes'
            *  'ms' = milliseconds'
            *  'ss' = 'seconds with leading zero'
            *  'mm' = 'minutes with leading zero'
            *
            * @class Time
            * @extends Component
            * @namespace Kiwi.HUD.HUDComponents
            * @constructor
            * @param owner {any} The object that this component belongs to.
            * @param [format=''] {string} The format that the time is to be displayed in. Leave blank for the default time.
            * @return {Counter}
            */
            var Time = (function (_super) {
                __extends(Time, _super);
                function Time(owner, format) {
                    if (typeof format === "undefined") { format = ''; }
                    _super.call(this, owner, "time");
                    /**
                    * If the clock should 'count down' instead of up.
                    * @property countDown
                    * @type boolean
                    * @default false
                    * @public
                    */
                    this.countDown = false;
                    /**
                    * Used during the formatting stage of displaying the time.
                    * @property _displayString
                    * @type string
                    * @private
                    */
                    this._displayString = '';
                    /**
                    * The current time in seconds.
                    * @property _currentTime
                    * @type number
                    * @private
                    */
                    this._currentTime = 0;
                    /**
                    * The last time that the timer update. Used to calculate the time delta.
                    * @property _timeBefore
                    * @type number
                    * @private
                    */
                    this._timeBefore = 0;
                    /**
                    * The speed at which the time will increase/decrease by.
                    * Modify this property to make the time count down slower/faster.
                    * @property _speed
                    * @type number
                    * @default 1
                    * @private
                    */
                    this.speed = 1;

                    this.clock = this.game.time.addClock(name + '-clock', 1000);
                    this.format = format;
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String}
                * @public
                */
                Time.prototype.objType = function () {
                    return 'TimeComponent';
                };

                Object.defineProperty(Time.prototype, "isRunning", {
                    /**
                    * Indicates whether or not the clock is currently running or not, and thus whether or not the time is playing or not.
                    * @property isRunning
                    * @type boolean
                    * @public
                    */
                    get: function () {
                        return this.clock.isRunning();
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Pauses the clock where is stands. Calls the pause method on the clock.
                * @method pause
                * @public
                */
                Time.prototype.pause = function () {
                    this.clock.pause();
                };

                /**
                * Stops the clock and thus the time. Calls the stop method of the clock.
                * @method stop
                * @public
                */
                Time.prototype.stop = function () {
                    this.clock.stop();
                };

                /**
                * Starts the clock and thus the time.
                * @method start
                * @public
                */
                Time.prototype.start = function () {
                    this.clock.start();
                    this._timeBefore = this.clock.elapsed();
                };

                /**
                * Resumes the clock and thus the time.
                * @method resume
                * @public
                */
                Time.prototype.resume = function () {
                    this.clock.resume();
                };

                Object.defineProperty(Time.prototype, "format", {
                    get: function () {
                        return this._format;
                    },
                    /**
                    * The format that you want the time to be displayed in.
                    * @property format
                    * @type string
                    * @public
                    */
                    set: function (val) {
                        this._format = val;
                    },
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty(Time.prototype, "currentTime", {
                    /**
                    * The current time in seconds. This is READ ONLY.
                    * @property currentTime
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this._currentTime;
                    },
                    enumerable: true,
                    configurable: true
                });

                /**
                * Sets the current time of the timer.
                * @method setTime
                * @param milli {number} The number of milliseconds.
                * @param [sec=0] {number} The number of seconds to add.
                * @param [minutes=0] {number} The number of minutes to add.
                * @public
                */
                Time.prototype.setTime = function (milli, sec, minutes) {
                    if (typeof sec === "undefined") { sec = 0; }
                    if (typeof minutes === "undefined") { minutes = 0; }
                    this._currentTime = milli;
                    if (sec != 0)
                        this._currentTime += (sec * 1000);
                    if (minutes != 0)
                        this._currentTime += (minutes * 60 * 1000);
                };

                /**
                * Increases the current time by the amount passed.
                * @method addTime
                * @param milli {number} The number of milliseconds.
                * @param [sec=0] {number} The number of seconds to add.
                * @param [minutes=0] {number} The number of minutes to add.
                * @public
                */
                Time.prototype.addTime = function (milli, sec, minutes) {
                    if (typeof sec === "undefined") { sec = 0; }
                    if (typeof minutes === "undefined") { minutes = 0; }
                    this._currentTime += milli;
                    if (sec != 0)
                        this._currentTime += (sec * 1000);
                    if (minutes != 0)
                        this._currentTime += (minutes * 60 * 1000);
                };

                /**
                * Decreases the current time by the amount passed.
                * @method removeTime
                * @param milli {number} The number of milliseconds.
                * @param [sec=0] {number} The number of seconds to add.
                * @param [minutes=0] {number} The number of minutes to add.
                * @public
                */
                Time.prototype.removeTime = function (milli, sec, minutes) {
                    if (typeof sec === "undefined") { sec = 0; }
                    if (typeof minutes === "undefined") { minutes = 0; }
                    this._currentTime -= milli;
                    if (sec != 0)
                        this._currentTime -= (sec * 1000);
                    if (minutes != 0)
                        this._currentTime -= (minutes * 60 * 1000);
                };

                /**
                * Returns a string with the current time that this component is upto in the format that was passed.
                *
                * @method updateTime
                * @return string
                * @public
                */
                Time.prototype.getTime = function () {
                    if (this.countDown) {
                        this._currentTime -= (this.clock.elapsed() - this._timeBefore) * this.speed;
                    } else {
                        this._currentTime += (this.clock.elapsed() - this._timeBefore) * this.speed;
                    }
                    this._timeBefore = this.clock.elapsed();

                    //format time
                    if (this._format !== '') {
                        this._displayString = this._format;

                        //milliseconds
                        if (this._displayString.indexOf('ms') !== -1) {
                            var t = String(Math.floor(this._currentTime * 1000) % 1000);
                            this._displayString = this._displayString.replace('ms', t);
                        }

                        //seconds - leading
                        if (this._displayString.indexOf('ss') != -1) {
                            var t = String(Math.floor(this._currentTime) % 60);
                            if (t.length < 2)
                                t = '0' + t;
                            this._displayString = this._displayString.replace('ss', t);
                        }

                        //minutes - leading
                        if (this._displayString.indexOf('mm') !== -1) {
                            var t = String(Math.floor(this._currentTime / 60) % 60);
                            if (t.length < 2)
                                t = '0' + t;
                            this._displayString = this._displayString.replace('mm', t);
                        }

                        //minutes - no leading
                        if (this._displayString.indexOf('s') != -1) {
                            var t = String(Math.floor(this._currentTime) % 60);
                            this._displayString = this._displayString.replace('s', t);
                        }

                        //seconds - no leading
                        if (this._displayString.indexOf('m') !== -1) {
                            var t = String(Math.floor(this._currentTime / 60) % 60);
                            this._displayString = this._displayString.replace('m', t);
                        }

                        return this._displayString;
                    } else {
                        return String(this._currentTime.toFixed(2));
                    }
                };
                return Time;
            })(Kiwi.Component);
            HUDComponents.Time = Time;
        })(HUD.HUDComponents || (HUD.HUDComponents = {}));
        var HUDComponents = HUD.HUDComponents;
    })(Kiwi.HUD || (Kiwi.HUD = {}));
    var HUD = Kiwi.HUD;
})(Kiwi || (Kiwi = {}));
/**
* The namespace that holds all of the assets and functionality when dealing with Audio.
*
* @module Kiwi
* @submodule Sound
* @main Sound
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Sound) {
        /**
        * Manages the initialisation of assets necessary when dealing with audio in the game, either through Audio Tags or the Web Audio API. Also provides global sound controls that will be applyed to all Audio objects at the same time.
        *
        * @class AudioManager
        * @constructor
        * @namespace Kiwi.Sound
        * @param game {Game} The game that this audio manager belongs to.
        * @return {AudioManager}
        */
        var AudioManager = (function () {
            function AudioManager(game) {
                /**
                * If the current game has audio support or not.
                * @property noAudio
                * @type boolean
                * @public
                */
                this.noAudio = false;
                /**
                * If the game is currently using the Web Audio API for the sound.
                * @property usingWebAudio
                * @type boolean
                * @public
                */
                this.usingWebAudio = false;
                /**
                * If the game is using audio tags for the sound. This is the fallback if the web audio api is not supported.
                * @property usingAudioTag
                * @type boolean
                * @public
                */
                this.usingAudioTag = false;
                /**
                * Web Audio API ONLY - The audio context that is used for decoding audio, e.t.c.
                * @property context
                * @type any
                * @public
                */
                this.context = null;
                /**
                * Web Audio API ONLY - The master gain node through which all sounds play.
                * @property masterGain
                * @type any
                * @public
                */
                this.masterGain = null;
                this._unlockedSource = null;
                this._game = game;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            AudioManager.prototype.objType = function () {
                return "AudioManager";
            };

            Object.defineProperty(AudioManager.prototype, "locked", {
                /**
                * Returns a boolean indicating whether the device has been touched or not. READ ONLY.
                * @property locked
                * @type boolean
                * @public
                */
                get: function () {
                    return this._locked;
                },
                enumerable: true,
                configurable: true
            });

            /**
            * The boot method is executed when all of the DOM elements needed for the game are loaded and the game is ready to 'start' up.
            *
            * @method boot
            * @public
            */
            AudioManager.prototype.boot = function () {
                this._volume = 1;
                this._muted = false;
                this._sounds = [];

                //check to see if it is an iOS device and if it doesn't support webAudio
                if (Kiwi.DEVICE.iOS && Kiwi.DEVICE.webaudio == false) {
                    this.channels = 1;
                }

                //add mouse event here to 'unlock' the device.
                if (Kiwi.DEVICE.iOS && this._game.deviceTargetOption !== Kiwi.TARGET_COCOON) {
                    this._locked = true;
                    this._game.input.onUp.addOnce(this._unlocked, this);

                    console.log('Audio is currently Locked until at touch event.');
                } else {
                    this._locked = false;
                }

                this.usingWebAudio = true; //we hope for the best....
                this.usingAudioTag = false;

                if (!!window['AudioContext']) {
                    this.context = new window['AudioContext']();
                } else if (!!window['webkitAudioContext']) {
                    this.context = new window['webkitAudioContext']();
                } else if (!!window['Audio']) {
                    this.usingWebAudio = false;
                    this.usingAudioTag = true;
                } else {
                    this.usingWebAudio = false;
                    this.noAudio = true; //prepared for the worst :(
                }

                if (this.context !== null) {
                    if (this.context.createGain === undefined) {
                        this.masterGain = this.context.createGainNode();
                    } else {
                        this.masterGain = this.context.createGain();
                    }

                    this.masterGain.gain.value = 1;
                    this.masterGain.connect(this.context.destination);
                }
            };

            /**
            * Is executed when a mouse event is fired on the device. This is used to enabled playback of sounds on the current device if they were awaiting for a user event.
            * @method _unlocked
            * @private
            */
            AudioManager.prototype._unlocked = function () {
                console.log('Audio now Unlocked');

                if (this.usingAudioTag) {
                    this._locked = false;
                    for (var i = 0; i < this._sounds.length; i++) {
                        this._sounds[i].playable = true;
                    }
                } else {
                    // Create empty buffer and play it
                    var buffer = this.context.createBuffer(1, 1, 22050);
                    this._unlockedSource = this.context.createBufferSource();
                    this._unlockedSource.buffer = buffer;
                    this._unlockedSource.connect(this.context.destination);
                    this._unlockedSource.noteOn(0);
                }
            };


            Object.defineProperty(AudioManager.prototype, "mute", {
                get: function () {
                    return this._muted;
                },
                /**
                * Used to mute the audio on the device, or to check to see if the device is muted.
                *
                * @property mute
                * @type boolean
                * @default false
                * @public
                */
                set: function (value) {
                    if (value === true) {
                        if (this._muted)
                            return;
                        this._muted = true;

                        //mute the sounds
                        if (this.usingWebAudio) {
                            this._muteVolume = this.masterGain.gain.value;
                            this.masterGain.gain.value = 0;
                        } else if (this.usingAudioTag) {
                            for (var i = 0; i < this._sounds.length; i++) {
                                this._sounds[i].mute = true;
                            }
                        }
                    } else {
                        if (this._muted == false)
                            return;
                        this._muted = false;

                        if (this.usingWebAudio) {
                            this.masterGain.gain.value = this._muteVolume;
                        } else if (this.usingAudioTag) {
                            for (var i = 0; i < this._sounds.length; i++) {
                                this._sounds[i].mute = false;
                            }
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(AudioManager.prototype, "volume", {
                get: function () {
                    return this._volume;
                },
                /**
                * Global setting and getting of the volume. A number between 0 (silence) and 1 (full volume)
                *
                * @property volume
                * @type number
                * @default 1
                * @public
                */
                set: function (value) {
                    if (value !== undefined) {
                        value = Kiwi.Utils.GameMath.clamp(value, 1, 0);
                        this._volume = value;

                        if (this._muted) {
                            this._muteVolume = this._volume;
                        }

                        if (this.usingWebAudio) {
                            this.masterGain.gain.value = value;
                        } else if (this.usingAudioTag) {
                            for (var i = 0; i < this._sounds.length; i++) {
                                //for each sound tag to update.
                                this._sounds[i].volume = this._sounds[i].volume;
                            }
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Indicates whether or not an Audio Object is registered with this Audio Manager or not. More for Kiwi Internal use only.
            * @method isRegistered
            * @param sound {Audio} The Audio object you are checking for.
            * @return {Boolean} If the piece of audio is registered or not.
            * @public
            */
            AudioManager.prototype.isRegistered = function (sound) {
                if (this.noAudio)
                    return;

                if (this._sounds.indexOf(sound) !== -1) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Registers an Audio Object with this audio manager. Also assign's the audio piece a unique ID to identify it by. Internal Kiwi use only.
            * @method registerSound
            * @param sound {Audio} The audio piece you are wanting to register.
            * @return {Boolean } Indication of if the sound was successfully added or not.
            * @public
            */
            AudioManager.prototype.registerSound = function (sound) {
                if (this.isRegistered(sound) === false) {
                    sound.id = this._game.rnd.uuid();
                    this._sounds.push(sound);
                    return true;
                }
                return false;
            };

            /**
            * Used to create a new sound on the audio manager. Returns the newly created sound.
            *
            * @method add
            * @param key {string} The key for the audio file that is to be loaded from the AudioLibrary.
            * @param [volume=1] {number} The volume for the piece of audio.
            * @param [loop=false] {boolean} If the audio should keep repeat when it gets to the end.
            * @return {Audio}
            * @public
            */
            AudioManager.prototype.add = function (key, volume, loop) {
                if (typeof volume === "undefined") { volume = 1; }
                if (typeof loop === "undefined") { loop = false; }
                if (this.noAudio)
                    return;

                var sound = new Kiwi.Sound.Audio(this._game, key, volume, loop);
                return sound;
            };

            /**
            * Removes the passed sound from the audio manager. Needs testing.
            *
            * @method remove
            * @param sound {Audio} The audio file that you want to remove.
            * @public
            */
            AudioManager.prototype.remove = function (sound, destroy) {
                if (typeof destroy === "undefined") { destroy = true; }
                for (var i = 0; i < this._sounds.length; i++) {
                    if (sound.id == this._sounds[i].id) {
                        if (this.usingWebAudio)
                            this._sounds[i].gainNode.disconnect();
                        if (destroy == true)
                            this._sounds[i].destroy();
                        this._sounds.splice(i, 1, 0);
                        i--;
                    }
                }
            };

            /**
            * Plays all of the sounds listed in the audio manager.
            *
            * @method playAll
            * @public
            */
            AudioManager.prototype.playAll = function () {
                for (var i = 0; i < this._sounds.length; i++) {
                    if (this._sounds[i]) {
                        this._sounds[i].play();
                    }
                }
            };

            /**
            * Stops all of the sounds that are listed in the audio manager from playing.
            *
            * @method playAll
            * @public
            */
            AudioManager.prototype.stopAll = function () {
                for (var i = 0; i < this._sounds.length; i++) {
                    if (this._sounds[i]) {
                        this._sounds[i].stop();
                    }
                }
            };

            /**
            * Pauses all of the sounds listed in the audio manager.
            *
            * @method pauseAll
            * @public
            */
            AudioManager.prototype.pauseAll = function () {
                for (var i = 0; i < this._sounds.length; i++) {
                    if (this._sounds[i]) {
                        this._sounds[i].pause();
                    }
                }
            };

            /**
            * Resumes all of the sounds listed in the audio manager.
            *
            * @method resumeAll
            * @param [destroy=true] {boolean} If the audio objects should be destroyed when they are removed.
            * @public
            */
            AudioManager.prototype.resumeAll = function (destroy) {
                if (typeof destroy === "undefined") { destroy = true; }
                for (var i = 0; i < this._sounds.length; i++) {
                    if (this._sounds[i]) {
                        this._sounds[i].resume();
                    }
                }
            };

            /**
            * The update loop that is executed every frame.
            * @method update
            * @public
            */
            AudioManager.prototype.update = function () {
                if (this._locked) {
                    if (this.usingWebAudio && this._unlockedSource !== null) {
                        if ((this._unlockedSource.playbackState === this._unlockedSource.PLAYING_STATE || this._unlockedSource.playbackState === this._unlockedSource.FINISHED_STATE)) {
                            this._locked = false;
                            this._unlockedSource = null;
                            for (var i = 0; i < this._sounds.length; i++) {
                                this._sounds[i].playable = true;
                            }
                        }
                    }
                }

                if (!this.noAudio) {
                    for (var i = 0; i < this._sounds.length; i++) {
                        this._sounds[i].update();
                    }
                }
            };
            return AudioManager;
        })();
        Sound.AudioManager = AudioManager;
    })(Kiwi.Sound || (Kiwi.Sound = {}));
    var Sound = Kiwi.Sound;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Sound
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Sound) {
        /**
        * A Object that contains the functionality needed when wanting to play a single sound/sound file on a game.
        *
        * @class Audio
        * @constructor
        * @namespace Kiwi.Sound
        * @param game {Game} The game that this piece of audio belongs to.
        * @param key {string} The key to which which piece of audio should be loaded from the AudioLibrary.
        * @param volume {number} A number between 0 (silence) and 1 (loud).
        * @param loop {boolean} If the audio should loop when it is finished or just stop.
        * @return {Audio} This object
        *
        */
        var Audio = (function () {
            function Audio(game, key, volume, loop) {
                /**
                * A private indicator of whether this audio is currently muted or not.
                * @property _muted
                * @type boolean
                * @default false
                * @private
                */
                this._muted = false;
                /**
                * The total duration of the audio in seconds.
                * @property totalDuration
                * @type number
                * @public
                */
                this.totalDuration = 0;
                /**
                * Web Audio API ONLY - The audio buffer that is to be used when playing audio segments.
                * @property _buffer
                * @type any
                * @private
                */
                this._buffer = null;
                /**
                * Web Audio API ONLY - A boolean to indicate if the audio has been decoded or not yet. If not you will need to run the decode() method.
                * @property _decoded
                * @type boolean
                * @default false
                * @private
                */
                this._decoded = false;
                /**
                * An array of all of the markers that are on this piece of audio.
                * @property _markers
                * @type Array
                * @private
                */
                this._markers = [];
                /**
                * The current marker that is being used.
                * @property _currentMarker
                * @type String
                * @default 'default'
                * @private
                */
                this._currentMarker = 'default';
                this.ready = false;
                this._game = game;
                this._game.audio.registerSound(this);

                this._usingAudioTag = this._game.audio.usingAudioTag;
                this._usingWebAudio = this._game.audio.usingWebAudio;

                this._playable = (this._game.audio.locked == true) ? false : true;

                this.duration = 0;
                this._volume = volume;
                this._muteVolume = volume;
                this._muted = this._game.audio.mute;
                this._loop = loop;
                this.key = key;

                //If audio isn't supported OR the file does not exist
                if (this._game.audio.noAudio || this._game.fileStore.exists(this.key) === false) {
                    if (this._game.debugOption)
                        console.log('Could not play Audio. Either the browser doesn\'t support audio or the Audio file was not found on the filestore');
                    return;
                }

                //Setup the Web AUDIO API Sound
                if (this._usingWebAudio) {
                    this._setAudio();

                    if (this.ready) {
                        this.context = this._game.audio.context;
                        this.masterGainNode = this._game.audio.masterGain;

                        //create our gain node
                        if (typeof this.context.createGain === 'undefined') {
                            this.gainNode = this.context.createGainNode();
                        } else {
                            this.gainNode = this.context.createGain();
                        }

                        //make sure the audio is decoded.
                        this._decode();

                        this.gainNode.gain.value = this.volume * this._game.audio.volume; //this may need to change.....
                        this.gainNode.connect(this.masterGainNode);
                    }
                    //Set-up the Audio Tag Sound
                } else if (this._usingAudioTag) {
                    if (this._playable === true) {
                        this._setAudio();

                        if (this.ready) {
                            this.totalDuration = this._sound.duration;
                            this._sound.volume = this.volume * this._game.audio.volume;

                            if (isNaN(this.totalDuration) || this.totalDuration == 0)
                                this._pending = true;
                        }
                    }
                }

                this.addMarker('default', 0, this.totalDuration, this._loop);
                this._currentMarker = 'default';

                //tonnes of signals to go here.
                this.onPlay = new Kiwi.Signal();
                this.onStop = new Kiwi.Signal();
                this.onPause = new Kiwi.Signal();
                this.onResume = new Kiwi.Signal();
                this.onLoop = new Kiwi.Signal();
                this.onMute = new Kiwi.Signal();
            }
            Object.defineProperty(Audio.prototype, "playable", {
                /**
                *
                * @property playable
                * @type boolean
                * @private
                */
                get: function () {
                    return this._playable;
                },
                set: function (val) {
                    if (this._playable !== true && val == true) {
                        this._playable = val;
                        this._setAudio();

                        if (this.ready && this._usingAudioTag) {
                            this.totalDuration = this._sound.duration;
                            this._sound.volume = this.volume * this._game.audio.volume;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Audio.prototype.objType = function () {
                return "Audio";
            };

            /**
            * Retrieves the audio data from the file store.
            * @method _setAudio
            * @private
            */
            Audio.prototype._setAudio = function () {
                this._file = this._game.fileStore.getFile(this.key);

                //Does the data actually exist?
                if (typeof this._file.data == "undefined")
                    return;

                //force the browser to play it at least for a little bit
                if (this._usingAudioTag) {
                    //clone the audio node
                    this._sound = this._file.data.cloneNode(true);
                    this._sound.play();
                    this._sound.pause();
                } else {
                    this._sound = this._file.data;
                }

                this.ready = true;
            };

            /**
            * Decodes the audio data to make it playable. By default the audio should already have been decoded when it was loaded.
            *
            * @method _decode
            * @private
            */
            Audio.prototype._decode = function () {
                //You only decode when using the web audio api, when the audio has loaded and if it hasn't been decoded already
                if (this.ready == false || this._usingAudioTag)
                    return;

                //has the
                if (this._file.data.decoded === true && this._file.data.buffer !== null) {
                    this._buffer = this._file.data.buffer;
                    this._decoded = true;
                    return;
                }

                var that = this;
                this.context.decodeAudioData(this._file.data.raw, function (buffer) {
                    that._buffer = buffer;
                    that._decoded = true;
                });
            };

            Object.defineProperty(Audio.prototype, "volume", {
                get: function () {
                    return this._volume;
                },
                /**
                * Used to control the current volume for this sound.
                *
                * @property volume
                * @type number
                * @public
                */
                set: function (val) {
                    if (this._game.audio.noAudio || this.ready === false)
                        return;

                    val = Kiwi.Utils.GameMath.clamp(val, 1, 0);

                    this._volume = val;

                    if (this._muted) {
                        this._muteVolume = this._volume;
                    }

                    if (this._playable) {
                        if (this._usingWebAudio) {
                            this.gainNode.gain.value = this._volume * this._game.audio.volume; //this may need to change....
                        } else if (this._usingAudioTag) {
                            this._sound.volume = this._volume * this._game.audio.volume;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Audio.prototype, "mute", {
                get: function () {
                    return this._muted;
                },
                /**
                * Allows you to mute the sound.
                *
                * @property mute
                * @type boolean
                * @public
                */
                set: function (val) {
                    if (this._game.audio.noAudio)
                        return;

                    if (val !== undefined && this._muted !== val) {
                        if (val === true) {
                            this._muteVolume = this._volume;
                            this.volume = 0;
                            this._muted = true;
                        } else {
                            this._muted = false;
                            this.volume = this._muteVolume;
                        }
                        this.onMute.dispatch(this._muted);
                    }
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Adds a new marker to the audio which will then allow for that section of audio to be played.
            *
            * @method addMarker
            * @param name {string} The name of the marker that you are adding.
            * @param start {number} The starting point of the audio. In seconds.
            * @param stop {number} The stopping point of the audio. In seconds.
            * @param [loop=false] {boolean} If the marker's pieve of audio should loop or not.
            * @public
            */
            Audio.prototype.addMarker = function (name, start, stop, loop) {
                if (typeof loop === "undefined") { loop = false; }
                this._markers[name] = { start: start, stop: stop, duration: stop - start, loop: loop };
            };

            /**
            * Removes a currently existing marker from this audio.
            *
            * @method removeMarker
            * @param name {String} name of the audio that you want to remove.
            * @public
            */
            Audio.prototype.removeMarker = function (name) {
                if (name === 'default')
                    return;

                if (this.isPlaying && this._currentMarker == name) {
                    this.stop();
                    this._currentMarker = 'default';
                }
                delete this._markers[name];
            };

            /**
            * Plays the current sound/audio from the start.
            *
            * @method play
            * @param [marker] {string} The marker that is to be played. If no marker is specified then it will play the current marker (which would be the whole audio piece if no marker was ever added).
            * @param [forceRestart=false] {boolean} Force the audio to stop and start again. Otherwise if the audio was already playing it would ignore the play.
            * @public
            */
            Audio.prototype.play = function (marker, forceRestart) {
                if (typeof marker === "undefined") { marker = this._currentMarker; }
                if (typeof forceRestart === "undefined") { forceRestart = false; }
                if (this.isPlaying && forceRestart == false || this._game.audio.noAudio)
                    return;

                if (forceRestart === true && this._pending === false)
                    this.stop();

                if (typeof this._markers[marker] == "undefined")
                    return;

                //If its the current marker that is playing and shouldn't force restart then stop
                if (this._currentMarker === marker && this.isPlaying && forceRestart == false)
                    return;

                this.paused = false;
                this._currentMarker = marker;
                this.duration = this._markers[this._currentMarker].duration * 1000;
                this._loop = this._markers[this._currentMarker].loop;

                if (this._playable === false) {
                    this._pending = true;
                    return;
                }

                if (this._usingWebAudio) {
                    if (this._decoded === true) {
                        if (this._buffer == null)
                            this._buffer = this._file.data.buffer;

                        this._sound = this.context.createBufferSource();
                        this._sound.buffer = this._buffer;
                        this._sound.connect(this.gainNode);
                        this.totalDuration = this._sound.buffer.duration;

                        if (this.duration == 0)
                            this.duration = this.totalDuration * 1000;

                        if (this._loop)
                            this._sound.loop = true;

                        //start
                        if (this._sound.start === undefined) {
                            this._sound.noteGrainOn(0, this._markers[this._currentMarker].start, this.duration / 1000);
                        } else {
                            this._sound.start(0, this._markers[this._currentMarker].start, this.duration / 1000);
                        }

                        this.isPlaying = true;
                        this._startTime = this._game.time.now();
                        this._currentTime = 0;
                        this._stopTime = this._startTime + this.duration;
                        this.onPlay.dispatch();
                    } else {
                        this._pending = true;
                        this._decode();
                    }
                } else if (this._usingAudioTag) {
                    if (this._sound && this._sound.readyState == 4 || this._game.deviceTargetOption == Kiwi.TARGET_COCOON) {
                        if (this.duration == 0 || isNaN(this.duration))
                            this.duration = this.totalDuration * 1000;

                        if (this._muted)
                            this._sound.volume = 0;
                        else
                            this._sound.volume = this._volume;

                        this._sound.currentTime = this._markers[this._currentMarker].start;
                        this._sound.play();
                        this.isPlaying = true;
                        this._startTime = this._game.time.now();
                        this._currentTime = 0;
                        this._stopTime = this._startTime + this.duration;

                        if (!this.paused)
                            this.onPlay.dispatch();
                    } else {
                        this._pending = true;
                    }
                }
            };

            /**
            * Stop the sound from playing.
            *
            * @method stop
            * @public
            */
            Audio.prototype.stop = function () {
                if (this.isPlaying && this._sound) {
                    if (this._usingWebAudio) {
                        if (this._sound.stop === undefined) {
                            this._sound.noteOff(0);
                        } else {
                            this._sound.stop(0);
                        }
                    } else if (this._usingAudioTag) {
                        this._sound.pause();
                        this._sound.currentTime = 0;
                    }

                    this.isPlaying = false;

                    if (this.paused == false)
                        this.onStop.dispatch();
                }
            };

            /**
            * Pauses the sound so that you can resume it from at point to paused it at.
            *
            * @method pause
            * @public
            */
            Audio.prototype.pause = function () {
                if (this.isPlaying) {
                    this.paused = true;
                    this.stop();
                    this.onPause.dispatch();
                }
            };

            /**
            * Plays the sound from when you paused the sound.
            *
            * @method resume
            * @public
            */
            Audio.prototype.resume = function () {
                if (this.paused && this.isPlaying == false) {
                    if (this._usingWebAudio) {
                        if (this._buffer == null)
                            this._buffer = this._file.data.buffer;

                        this._sound = this.context.createBufferSource();
                        this._sound.buffer = this._buffer;
                        this._sound.connect(this.gainNode);

                        if (this._sound.start === undefined) {
                            this._sound.noteGrainOn(0, this._markers[this._currentMarker].start + (this._currentTime / 1000), this.duration / 1000);
                        } else {
                            this._sound.start(0, this._markers[this._currentMarker].start + (this._currentTime / 1000), this.duration / 1000);
                        }
                    } else {
                        this._sound.currentTime = this._markers[this._currentMarker].start + this._currentTime / 1000;
                        this._sound.play();
                    }

                    this.paused = false;
                    this.isPlaying = true;
                    this.onResume.dispatch();
                }
            };

            /**
            * The update loop that gets executed every frame.
            * @method update
            * @public
            */
            Audio.prototype.update = function () {
                //Check to see that the audio is ready
                if (!this.ready)
                    return;

                //Is the audio ready to be played and was waiting?
                if (this._playable && this._pending) {
                    //Is it the using the Web Audio API (can tell otherwise the audio would not be decoding otherwise) and it is now ready to be played?
                    if (this._decoded === true || this._file.data && this._file.data.decoded) {
                        this._pending = false;
                        this.play();
                        //If we are using Audio tags and the audio is pending then that must be because we are waiting for the audio to load.
                        // Also the work around for CocoonJS
                    } else if (this._usingAudioTag && !isNaN(this._sound.duration) || this._game.deviceTargetOption == Kiwi.TARGET_COCOON && this._sound.duration !== 0) {
                        this.totalDuration = this._sound.duration;
                        this._markers['default'].duration = this.totalDuration;
                        this._pending = false; //again shouldn't need once audio tag loader works.

                        if (this.isPlaying && this._currentMarker == 'default')
                            this.duration = this.totalDuration;
                    }
                }

                //if the audio is playing
                if (this.isPlaying) {
                    this._currentTime = this._game.time.now() - this._startTime;

                    if (this._currentTime >= this.duration) {
                        if (this._usingWebAudio) {
                            if (this._loop) {
                                if (this._currentMarker == 'default') {
                                    this._currentTime = 0;
                                    this._startTime = this._game.time.now();
                                } else {
                                    this.play(this._currentMarker, true);
                                }

                                this.onLoop.dispatch();
                            } else {
                                this.stop();
                            }
                        } else if (this._usingAudioTag) {
                            if (this._loop) {
                                this.play(this._currentMarker, true);
                                this.onLoop.dispatch();
                            } else {
                                this.stop();
                            }
                        }
                    }
                }
            };

            /**
            * This method handles the destruction of all of the properties when this audio is not longer needed.
            * You call this method when you want this method to be removed on the next garbage collection cycle.
            *
            * @method destroy
            * @public
            */
            Audio.prototype.destroy = function () {
                if (this._game) {
                    this._game.audio.remove(this);
                }
                if (this.onLoop)
                    this.onLoop.dispose();
                if (this.onStop)
                    this.onStop.dispose();
                if (this.onPlay)
                    this.onPlay.dispose();
                if (this.onMute)
                    this.onMute.dispose();
                if (this.onPause)
                    this.onPause.dispose();
                if (this.onResume)
                    this.onResume.dispose();

                delete this.onLoop;
                delete this.onStop;
                delete this.onPause;
                delete this.onMute;
                delete this.onPlay;
                delete this.onResume;
                delete this._game;
                delete this._sound;
                delete this._currentTime;
                delete this._startTime;
                delete this._stopTime;
                delete this._pending;
                delete this.masterGainNode;
                delete this.gainNode;
                delete this.totalDuration;
                delete this.duration;
                delete this._file;
                delete this._buffer;
                delete this._decoded;
            };
            return Audio;
        })();
        Sound.Audio = Audio;
    })(Kiwi.Sound || (Kiwi.Sound = {}));
    var Sound = Kiwi.Sound;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Sound
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Sound) {
        /**
        * Holds a reference to all of the Audio Files (mp3, ogg, e.t.c) that are accessible on the State that this AudioLibrary is on.
        *
        * @class AudioLibrary
        * @constructor
        * @namespace Kiwi.Sound
        * @param game {Game} The game that this audio library is a member of.
        * @return {AudioLibrary}
        */
        var AudioLibrary = (function () {
            function AudioLibrary(game) {
                this._game = game;
                this.audio = {};
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            AudioLibrary.prototype.objType = function () {
                return "AudioLibrary";
            };

            /**
            * Resets the audio library.
            * @method clear
            * @public
            */
            AudioLibrary.prototype.clear = function () {
                for (var prop in this.audio) {
                    delete this.audio[prop];
                }
            };

            /**
            * Rebuild the library from a fileStore. Clears the library and repopulates it.
            * @method rebuild
            * @param {Kiwi.Files.FileStore} fileStore
            * @param {Kiwi.State} state
            * @public
            */
            AudioLibrary.prototype.rebuild = function (fileStore, state) {
                this.clear();
                if (this._game.debug) {
                    console.log("Rebuilding Audio Library");
                }

                var fileStoreKeys = fileStore.keys;
                for (var i = 0; i < fileStoreKeys.length; i++) {
                    var file = this._game.fileStore.getFile(fileStoreKeys[i]);
                    if (file.isAudio) {
                        if (this._game.debug) {
                            console.log("Adding Audio: " + file.fileName);
                        }
                        ;
                        state.audioLibrary.add(file);
                    }
                }
            };

            /**
            * Adds a new audio file to the audio library.
            * @method add
            * @param {File} audioFile
            * @public
            */
            AudioLibrary.prototype.add = function (audioFile) {
                switch (audioFile.dataType) {
                    case Kiwi.Files.File.AUDIO:
                        this.audio[audioFile.key] = audioFile;
                        break;

                    default:
                        break;
                }
            };
            return AudioLibrary;
        })();
        Sound.AudioLibrary = AudioLibrary;
    })(Kiwi.Sound || (Kiwi.Sound = {}));
    var Sound = Kiwi.Sound;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Time
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Time) {
        /**
        * The Clock class offers a way of tracking time within a game. When creating a new Clock you should NOT directly instantiate this class but instead use the addClock method on a ClockManager.
        * - The MasterClock is a property of the Kiwi.Time.Manager class and tracks real world time in milliseconds elapsed since the application started. This happens automatically and there is no need to do anything to set this up.
        * - An instance of a clock is used to track time in arbitrary units (milliseconds by default)
        * - A clock can be started, paused, unpaused and stopped. Once stopped, re-starting the clock again will reset it.
        * - Any number of timers can be attached to a clock. See the Kiwi.Time.Timer class for timer details.
        * - If the clock is paused, any timers attached to the clock will take this into account and not continue to fire events until the clock is unpaused.
        * (Note that this is not the same as pausing timers, which can be done manually and needs to be undone manually.)
        *
        * @class Clock
        * @namespace Kiwi.Time
        * @constructor
        * @param manager {ClockManager} The ClockManager that this clock belongs to. .
        * @param master {MasterClock} The MasterClock that it is getting the time in relation to.
        * @param name {String} The name of the clock.
        * @param [units=1000] {Number} The units that this clock is to operate in.
        * @return {Clock} This Clock object.
        *
        */
        var Clock = (function () {
            function Clock(manager, master, name, units) {
                if (typeof units === "undefined") { units = 1000; }
                /**
                * The time the clock was first started relative to the master clock.
                * @property _timeFirstStarted
                * @type Number
                * @default null
                * @private
                */
                this._timeFirstStarted = null;
                /**
                * The time the clock was most recently started relative to the master clock.
                * @property _timeLastStarted
                * @type Number
                * @default null
                * @private
                */
                this._timeLastStarted = null;
                /**
                * The time the clock was most recently stopped relative to the master clock.
                * @property _timeLastStopped
                * @type Number
                * @default null
                * @private
                */
                this._timeLastStopped = null;
                /**
                * The time the clock was most receently paused relative to the master clock.
                * @property _timeLastPaused
                * @private
                * @type Number
                * @default null
                * @private
                */
                this._timeLastPaused = null;
                /**
                * The time the clock was most recently unpaused relative to the master clock.
                * @property _timeLastUnpaused
                * @private
                * @type Number
                * @default null
                * @private
                */
                this._timeLastUnpaused = null;
                /**
                * The total number of milliseconds the clock has been paused since it was last started.
                * @property _totalPaused
                * @private
                * @type Number
                * @default 0
                * @private
                */
                this._totalPaused = 0;
                /**
                * Whether the clock is in a running state.
                * @property _isRunning
                * @type boolean
                * @default false
                * @private
                */
                this._isRunning = false;
                /**
                * Whether the clock is in a stopped state.
                * @property _isStopped
                * @type boolean
                * @default true
                * @private
                */
                this._isStopped = true;
                /**
                * Whether the clock is in a paused state.
                * @property _isPaused
                * @type boolean
                * @default false
                * @private
                */
                this._isPaused = false;
                /**
                * An internal reference to the state of the elapsed timer
                * @property _elapsedState
                * @type Number
                * @default 0
                * @private
                */
                this._elapsedState = 0;
                /**
                * The time manager that this clock belongs to.
                * @property manager
                * @type ClockManager
                * @public
                */
                this.manager = null;
                /**
                * The master clock.
                * @property master
                * @type MasterClock
                * @public
                */
                this.master = null;
                /**
                * Name of the clock
                * @property name
                * @type string
                * @public
                */
                this.name = null;
                /**
                * The number of milliseconds counted as one unit of time by the clock.
                * @property units
                * @type Number
                * @default 0
                * @public
                */
                this.units = 0;
                this.manager = manager;
                this.master = master;
                this.name = name;
                this.units = units;
                this.timers = [];

                if (this.units < 1) {
                    this.units = 1;
                }
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Clock.prototype.objType = function () {
                return "Clock";
            };

            /**
            * The number of clock units elapsed since the clock was first started.
            * @method elapsedSinceFirstStarted.
            * @return {Number} number of clock units.
            * @public
            */
            Clock.prototype.elapsedSinceFirstStarted = function () {
                return (this._timeLastStarted) ? (this.master.elapsed() - this._timeFirstStarted) / this.units : null;
            };

            /**
            * Get the most recent time the clock was started relative to the master clock.
            * @method started
            * @return {Number} milliseconds.
            * @public
            */
            Clock.prototype.started = function () {
                return this._timeLastStarted;
            };

            /**
            * The number of clock units elapsed since the clock was most recently started (not including time spent paused)
            * @method elapsed
            * @return {Number} number of clock units.
            * @public
            */
            Clock.prototype.elapsed = function () {
                if (this._elapsedState === 0) {
                    return (this._timeLastStarted) ? ((this.master.elapsed() - this._timeLastStarted) - this._totalPaused) / this.units : null;
                } else if (this._elapsedState === 1) {
                    return (this._timeLastPaused - this._timeLastStarted - this._totalPaused) / this.units;
                } else if (this._elapsedState === 2) {
                    //  Same as zero!
                    return (this._timeLastStarted) ? ((this.master.elapsed() - this._timeLastStarted) - this._totalPaused) / this.units : null;
                } else if (this._elapsedState === 3) {
                    return (this._timeLastStopped - this._timeLastStarted - this._totalPaused) / this.units;
                }
            };

            /**
            * The number of clock units elapsed since the clock was most recently stopped.
            * @method elapsedSinceLastStopped.
            * @return {Number} number of clock units.
            * @public
            */
            Clock.prototype.elapsedSinceLastStopped = function () {
                return (this._timeLastStarted) ? (this.master.elapsed() - this._timeLastStopped) / this.units : null;
            };

            /**
            * The number of clock units elapsed since the clock was most recently paused.
            * @method elapsedSinceLastPaused.
            * @return {Number} number of clock units.
            * @public
            */
            Clock.prototype.elapsedSinceLastPaused = function () {
                return (this._timeLastStarted) ? (this.master.elapsed() - this._timeLastPaused) / this.units : null;
            };

            /**
            * The number of clock units elapsed since the clock was most recently unpaused.
            * @method elapsedSinceLastUnpaused.
            * @return {Number} number of clock units.
            * @public
            */
            Clock.prototype.elapsedSinceLastUnpaused = function () {
                return (this._timeLastStarted) ? (this.master.elapsed() - this._timeLastUnpaused) / this.units : null;
            };

            /**
            * Check if the clock is currently running.
            * @method isRunning
            * @return {boolean} true if running.
            * @public
            */
            Clock.prototype.isRunning = function () {
                return this._isRunning;
            };

            /**
            * Check if the clock is in the stopped state.
            * @method isStopped
            * @return {boolean} true if stopped.
            * @public
            */
            Clock.prototype.isStopped = function () {
                return this._isStopped;
            };

            /**
            * Check if the clock is in the paused state.
            * @method isPaused
            * @return {boolean} true if paused.
            * @public
            */
            Clock.prototype.isPaused = function () {
                return this._isPaused;
            };

            /**
            * Add an existing Timer to the Clock.
            * @method addTimer
            * @param timer {Timer} The Timer object instance to be added to ths Clock.
            * @return {Clock} This Clock object.
            * @public
            */
            Clock.prototype.addTimer = function (timer) {
                this.timers.push(timer);

                return this;
            };

            /**
            * Creates a new Timer and adds it to this Clock.
            * @method createTimer
            * @param name {string} The name of the Timer (must be unique on this Clock).
            * @param [delay=1] {Number} The number of clock units to wait between firing events (default 1)
            * @param [repeatCount=0] {Number} The number of times to repeat this Timer (default 0)
            * @param [start=true] {Boolean} If the timer should start.
            * @return {Timer} The newly created Timer.
            * @public
            */
            Clock.prototype.createTimer = function (name, delay, repeatCount, start) {
                if (typeof delay === "undefined") { delay = 1; }
                if (typeof repeatCount === "undefined") { repeatCount = 0; }
                if (typeof start === "undefined") { start = true; }
                this.timers.push(new Kiwi.Time.Timer(name, this, delay, repeatCount));

                if (start === true) {
                    this.timers[this.timers.length - 1].start();
                }

                return this.timers[this.timers.length - 1];
            };

            /**
            * Remove a Timer from this Clock based on either the Timer object or its name.
            * @method removeTimer
            * @param [timer=null] {Timer} The Timer object you wish to remove. If you wish to delete by Timer Name set this to null.
            * @param [timerName=''] {string} The name of the Timer object to remove.
            * @return {boolean} True if the Timer was successfully removed, false if not.
            * @public
            */
            Clock.prototype.removeTimer = function (timer, timerName) {
                if (typeof timer === "undefined") { timer = null; }
                if (typeof timerName === "undefined") { timerName = ''; }
                //  Timer object given?
                if (timer !== null) {
                    if (this.timers[timer.name]) {
                        delete this.timers[timer.name];

                        return true;
                    } else {
                        return false;
                    }
                }

                if (timerName !== '') {
                    if (this.timers[timerName]) {
                        delete this.timers[timerName];

                        return true;
                    } else {
                        return false;
                    }
                }

                return false;
            };

            /**
            * Check if the Timer already exists on this Clock
            * @method checkExists
            * @param name {string} The name of the Timer.
            * @return {boolean} true if the Timer exists, false if not.
            * @public
            */
            Clock.prototype.checkExists = function (name) {
                if (this.timers[name]) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Stop all timers attached to the clock.
            * @method stopAllTimers
            * @return {Clock} This Clock object.
            * @public
            */
            Clock.prototype.stopAllTimers = function () {
                for (var i = 0; i < this.timers.length; i++) {
                    this.timers[i].stop();
                }

                return this;
            };

            /**
            * Convert a number to milliseconds based on clock units.
            * @method toMilliseconds.
            * @return {Number} milliseconds.
            * @public
            */
            Clock.prototype.convertToMilliseconds = function (time) {
                return time * this.units;
            };

            /**
            * Updates all Timers linked to this Clock.
            * @method update
            * @public
            */
            Clock.prototype.update = function () {
                for (var i = 0; i < this.timers.length; i++) {
                    this.timers[i].update();
                }
            };

            /**
            * Start the clock. This resets the clock and starts it running.
            * @method start
            * @return {Clock} This Clock object.
            * @public
            */
            Clock.prototype.start = function () {
                this._timeLastStarted = this.master.elapsed();
                this._totalPaused = 0;

                if (!this._timeFirstStarted) {
                    this._timeFirstStarted = this._timeLastStarted;
                }

                this._isRunning = true;
                this._isPaused = false;
                this._isStopped = false;

                this._elapsedState = 0;

                return this;
            };

            /**
            * Pause the clock. The clock can only be paused if it is already running.
            * @method pause
            * @return {Clock} This Clock object.
            * @public
            */
            Clock.prototype.pause = function () {
                if (this._isRunning === true) {
                    this._timeLastPaused = this.master.elapsed();
                    this._isRunning = false;
                    this._isPaused = true;
                    this._isStopped = false;

                    this._elapsedState = 1;
                }

                return this;
            };

            /**
            * Resume the clock. The clock can only be resumed if it is already paused.
            * @method resume
            * @return {Clock} This Clock object.
            * @public
            */
            Clock.prototype.resume = function () {
                if (this._isPaused === true) {
                    this._timeLastUnpaused = this.master.elapsed();
                    this._totalPaused += this._timeLastUnpaused - this._timeLastPaused;
                    this._isRunning = true;
                    this._isPaused = false;
                    this._isStopped = false;

                    this._elapsedState = 2;
                }

                return this;
            };

            /**
            * Stop the clock. Clock can only be stopped if it is already running or is paused.
            * @method stop
            * @return {Clock} This Clock object.
            * @public
            */
            Clock.prototype.stop = function () {
                if (this._isStopped === false) {
                    this._timeLastStopped = this.master.elapsed();

                    if (this._isPaused === true) {
                        this._totalPaused += this._timeLastStopped - this._timeLastPaused;
                    }

                    this._isRunning = false;
                    this._isPaused = false;
                    this._isStopped = true;

                    this._elapsedState = 3;
                }

                return this;
            };

            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {string} a string representation of the instance.
            * @public
            */
            Clock.prototype.toString = function () {
                return "[{Clock (name=" + this.name + " units=" + this.units + " running=" + this._isRunning + ")}]";
            };
            return Clock;
        })();
        Time.Clock = Clock;
    })(Kiwi.Time || (Kiwi.Time = {}));
    var Time = Kiwi.Time;
})(Kiwi || (Kiwi = {}));
/**
* Contains ways of tracking time within a game or application. Each game will have a ClockManager, MasterClock and a single Clock automatically generated for them upon game creation.
*
* @module Kiwi
* @submodule Time
* @main Time
*/
var Kiwi;
(function (Kiwi) {
    (function (Time) {
        /**
        * Handles the generation and tracking of Clocks and Time related applications for a single game.
        *
        * @class ClockManager
        * @namespace Kiwi.Time
        * @constructor
        * @param {Game} game.
        * @return {ClockManager} This Object.
        *
        */
        var ClockManager = (function () {
            function ClockManager(game) {
                /**
                * An array containing all of the clocks that exist on this manager.
                * @property _clocks
                * @type Clock[]
                * @private
                */
                this._clocks = [];
                this._game = game;
            }
            /**
            * The type of object this is.
            * @method objType
            * @return {String}
            * @public
            */
            ClockManager.prototype.objType = function () {
                return "ClockManager";
            };

            /**
            * When all of the DOM elements that the game requires have loaded successfully then this object will 'boot'.
            * @method boot
            * @public
            */
            ClockManager.prototype.boot = function () {
                this.master = new Kiwi.Time.MasterClock();

                this.clock = new Kiwi.Time.Clock(this, this.master, 'default', 1000);
                this.clock.start();
            };

            /**
            * Creates a Clock class for keeping time relative to the MasterClock.
            * @method addClock
            * @param name {string} The name of the Clock.
            * @param [units=1000] {Number} The number of milliseconds that make up one unit of time on this clock. Default 1000.
            * @return {Clock} A reference to the newly created Clock object.
            * @public
            */
            ClockManager.prototype.addClock = function (name, units) {
                if (typeof units === "undefined") { units = 1000; }
                this._clocks.push(new Kiwi.Time.Clock(this, this.master, name, units));

                return this._clocks[this._clocks.length - 1];
            };

            /**
            * Returns the Clock with the matching name. Throws and error if no Clock with that name exists
            * @method getClock
            * @param name {string} The name of the Clock to be returned.
            * @return {Clock} The clock which matches the name given.
            * @public
            */
            ClockManager.prototype.getClock = function (name) {
                for (var i = 0; i < this._clocks.length; i++) {
                    if (this._clocks[i].name === name) {
                        return this._clocks[i];
                    }
                }
            };

            /**
            * Is executed every frame and updates all of the clocks that exist on this manager, times.
            * @method update
            * @public
            */
            ClockManager.prototype.update = function () {
                this.master.update();
                this.clock.update();

                for (var i = 0; i < this._clocks.length; i++) {
                    this._clocks[i].update();
                }
            };

            /**
            * Returns the current time. Based on the master clock.
            * @method now
            * @return {Number}
            * @public
            */
            ClockManager.prototype.now = function () {
                return this.master.now;
            };

            /**
            * Returns the delta of the master clock.
            * @method delta
            * @return {Number}
            * @public
            */
            ClockManager.prototype.delta = function () {
                return this.master.delta;
            };
            return ClockManager;
        })();
        Time.ClockManager = ClockManager;
    })(Kiwi.Time || (Kiwi.Time = {}));
    var Time = Kiwi.Time;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Time
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Time) {
        /**
        * The MasterClock tracks time elapsed since the application started.
        * Each ClockManager has only one MasterClock which is automatically generated when the game initially booted.
        * You should not access it directly, use the Clock and Timer classes instead.
        *
        * @class MasterClock
        * @namespace Kiwi.Time
        * @constructor
        * @return {MasterClock} This Object.
        *
        */
        var MasterClock = (function () {
            function MasterClock() {
                /**
                * The current time. This is updated every frame but AFTER the delta is calculated.
                * @property time
                * @type Number
                * @public
                */
                this.time = 0;
                /**
                * The current time, this is straight from the Date.now() method and is updated every frame BEFORE the delta.
                * @property now
                * @type Number
                * @public
                */
                this.now = 0;
                /**
                * The time it takes for the time to update. Using this you can calculate the fps.
                * @property delta
                * @type Number
                * @public
                */
                this.delta = 0;
                this._started = Date.now();
                this.time = this._started;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            MasterClock.prototype.objType = function () {
                return "MasterClock";
            };

            /**
            * The time that has elapsed since the game started. In milliseconds.
            * @method elapsed
            * @return {Number}
            * @public
            */
            MasterClock.prototype.elapsed = function () {
                return this.now - this._started;
            };

            /**
            * The time that has elapsed since the game started but in seconds.
            * @method totalElapsedSeconds
            * @return {Number}
            * @public
            */
            MasterClock.prototype.totalElapsedSeconds = function () {
                return (this.now - this._started) * 0.001;
            };

            /**
            * The update loop that should be executed every frame. Used to update the time.
            * @method update
            * @public
            */
            MasterClock.prototype.update = function () {
                //  Not in < IE8 (fixed via polyfill)
                this.now = Date.now();

                this.delta = this.now - this.time;

                this.time = this.now;

                //  Lock the delta at 0.1 minimum to minimise fps tunneling
                if (this.delta > 0.1) {
                    this.delta = 0.1;
                }
                //  Apply time scaling
            };

            /**
            * Used to calculate the elapsed time from a point that is specified. This is returned in Milliseconds.
            * @method elapsedSince
            * @param since {Number} The point in time in which you would like to see how many milliseconds have passed. In milliseconds.
            * @return {Number}
            * @public
            */
            MasterClock.prototype.elapsedSince = function (since) {
                return this.now - since;
            };

            /**
            * Used to calculate the elapsed time from a point that is specified BUT this is in seconds.
            * @method elapsedSecondsSince
            * @param since {Number} The point in time in which you would like to see how many seconds have passed. In milliseconds.
            * @return {Number }
            * @public
            */
            MasterClock.prototype.elapsedSecondsSince = function (since) {
                return (this.now - since) * 0.001;
            };

            /**
            * Resets the MasterClocks time.
            * @method reset
            * @public
            */
            MasterClock.prototype.reset = function () {
                this._started = this.now;
            };
            return MasterClock;
        })();
        Time.MasterClock = MasterClock;
    })(Kiwi.Time || (Kiwi.Time = {}));
    var Time = Kiwi.Time;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Time
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Time) {
        /**
        * The Timer class hooks into a game Clock and allows you run code at a specified point in game time.
        * Use the start() method to start a timer. Add TimerEvents to set-up code to be run on the timer interval.
        * Timer objects can run once or repeat at specified intervals to execute code on a schedule.
        *
        * @class Timer
        * @namespace Kiwi.Time
        * @constructor
        * @param name {string} The name of the timer.
        * @param clock {Clock} The game clock instance this Timer is based on.
        * @param delay {Number} The number of clock units to wait between firing events.
        * @param [repeatCount=0] {Number} The number of times to repeat the timer before it is expired. If you don't want it to ever expire, set a value of -1.
        * @return {Timer} This object.
        *
        */
        var Timer = (function () {
            function Timer(name, clock, delay, repeatCount) {
                if (typeof repeatCount === "undefined") { repeatCount = 0; }
                /**
                * The number of times the timer has repeated so far.
                * @property _currentCount
                * @type Number
                * @default 0
                * @private
                */
                this._currentCount = 0;
                /**
                * A collection of the TimerEvents associated with TimerEvent.TIMER_START
                * @property _startEvents
                * @type TimerEvent[]
                * @private
                */
                this._startEvents = null;
                /**
                * A collection of the TimerEvents associated with TimerEvent.TIMER_COUNT
                * @property _countEvents
                * @private
                * @type TimerEvent[]
                */
                this._countEvents = null;
                /**
                * A collection of the TimerEvents associated with TimerEvent.TIMER_STOP
                * @property _stopEvents
                * @private
                * @type TimerEvent[]
                */
                this._stopEvents = null;
                /**
                * The clock which this timer bases its timing on.
                * @property _clock
                * @type Clock
                * @private
                */
                this._clock = null;
                /**
                * The time the last repeat occurred in clock units.
                * @property _timeLastCount
                * @type Number
                * @private
                */
                this._timeLastCount = null;
                /**
                * Whether the timer is in a running state.
                * @property _isRunning
                * @type boolean
                * @default false
                * @private
                */
                this._isRunning = false;
                /**
                * Whether the timer is in a stopped state.
                * @property _isStopped
                * @type boolean
                * @default true
                * @private
                */
                this._isStopped = true;
                /**
                * Whether the timer is in a paused state.
                * @property _isPaused
                * @type boolean
                * @default false
                * @private
                */
                this._isPaused = false;
                /**
                * The name of the timer.
                * @property name
                * @type String
                * @default null
                * @public
                */
                this.name = null;
                /**
                * The delay, in game clock units, that the timer will wait before firing the event
                * @property delay
                * @type Number
                * @default 0
                * @public
                */
                this.delay = 0;
                /**
                * The number of times the timer will repeat before stopping.
                * @property repeatCount
                * @type Number
                * @default 0
                * @public
                */
                this.repeatCount = 0;
                this._clock = clock;

                this._startEvents = [];
                this._countEvents = [];
                this._stopEvents = [];

                this.name = name;
                this.delay = delay;
                this.repeatCount = repeatCount;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Timer.prototype.objType = function () {
                return "Timer";
            };

            /**
            * Get the number of times the timer has repeated.
            * @method getCurrentCount
            * @return {Number}
            * @public
            */
            Timer.prototype.currentCount = function () {
                return this._currentCount;
            };

            /**
            * The Timers current state. True if the Timer is running, otherwise false.
            * @method running
            * @return {boolean}
            * @public
            */
            Timer.prototype.isRunning = function () {
                return this._isRunning;
            };

            /**
            * Whether the timer is in a stopped state.
            * @method stopped
            * @return {boolean}
            * @public
            */
            Timer.prototype.isStopped = function () {
                return this._isStopped;
            };

            /**
            * Whether the timer is in a paused state.
            * @method paused
            * @return {boolean}
            * @public
            */
            Timer.prototype.isPaused = function () {
                return this._isPaused;
            };

            /**
            * Checks the list of TimerEvents added and processes them based on their type.
            * @method processEvents
            * @param type {Number} The type of events to dispatch
            * @private
            */
            Timer.prototype.processEvents = function (type) {
                if (type === Kiwi.Time.TimerEvent.TIMER_START) {
                    for (var i = 0; i < this._startEvents.length; i++) {
                        this._startEvents[i].run();
                    }
                } else if (type === Kiwi.Time.TimerEvent.TIMER_COUNT) {
                    for (var i = 0; i < this._countEvents.length; i++) {
                        this._countEvents[i].run();
                    }
                } else if (type === Kiwi.Time.TimerEvent.TIMER_STOP) {
                    for (var i = 0; i < this._stopEvents.length; i++) {
                        this._stopEvents[i].run();
                    }
                }
            };

            /**
            * Internal update loop called by the Clock that this Timer belongs to.
            * @method update
            * @public
            */
            Timer.prototype.update = function () {
                if (this._isRunning && this._clock.elapsed() - this._timeLastCount >= this.delay && this._isPaused === false) {
                    this._currentCount++;

                    this.processEvents(Kiwi.Time.TimerEvent.TIMER_COUNT);

                    this._timeLastCount = this._clock.elapsed() || 0;

                    if (this.repeatCount !== -1 && this._currentCount >= this.repeatCount) {
                        this.stop();
                    }
                }
            };

            /**
            * Start the Timer. This will reset the timer and start it. The timer can only be started if it is in a stopped state.
            * @method start
            * @return {Timer} this object.
            * @public
            */
            Timer.prototype.start = function () {
                if (this._isStopped === true) {
                    this._isRunning = true;
                    this._isPaused = false;
                    this._isStopped = false;

                    this._currentCount = 0;
                    this._timeLastCount = this._clock.elapsed() || 0;

                    this.processEvents(Kiwi.Time.TimerEvent.TIMER_START);
                }

                return this;
            };

            /**
            * Stop the Timer. Only possible when the timer is running or paused.
            * @method stop
            * @return {Timer} this object.
            * @public
            */
            Timer.prototype.stop = function () {
                if (this._isRunning === true || this._isPaused === true) {
                    this._isRunning = false;
                    this._isPaused = false;
                    this._isStopped = true;

                    this.processEvents(Kiwi.Time.TimerEvent.TIMER_STOP);
                }

                return this;
            };

            /**
            * Pause the Timer. Only possible when the timer is running.
            * @method pause
            * @return {Timer} this object.
            * @public
            */
            Timer.prototype.pause = function () {
                if (this._isRunning === true) {
                    this._isRunning = false;
                    this._isPaused = true;
                }

                return this;
            };

            /**
            * Resume the Timer. Only possible if the timer has been paused.
            * @method resume
            * @return {Timer} this object.
            * @public
            */
            Timer.prototype.resume = function () {
                if (this._isPaused === true) {
                    this._isRunning = true;
                    this._isPaused = false;
                }

                return this;
            };

            /**
            * Adds an existing TimerEvent object to this Timer.
            * @method addTimerEvent
            * @param {TimerEvent} A TimerEvent object
            * @return {TimerEvent} The TimerEvent object
            * @public
            */
            Timer.prototype.addTimerEvent = function (event) {
                if (event.type === Kiwi.Time.TimerEvent.TIMER_START) {
                    this._startEvents.push(event);
                } else if (event.type === Kiwi.Time.TimerEvent.TIMER_COUNT) {
                    this._countEvents.push(event);
                } else if (event.type === Kiwi.Time.TimerEvent.TIMER_STOP) {
                    this._stopEvents.push(event);
                }

                return event;
            };

            /**
            * Creates a new TimerEvent and adds it to this Timer
            * @method createTimerEvent
            * @param type {Number} The type of TimerEvent to create (TIMER_START, TIMER_COUNT or TIMER_STOP).
            * @param callback {Function} The function to call when the TimerEvent fires.
            * @param context {Function} The context in which the given function will run (usually 'this')
            * @return {TimerEvent} The newly created TimerEvent.
            * @public
            */
            Timer.prototype.createTimerEvent = function (type, callback, context) {
                if (type === Kiwi.Time.TimerEvent.TIMER_START) {
                    this._startEvents.push(new Kiwi.Time.TimerEvent(type, callback, context));
                    return this._startEvents[this._startEvents.length - 1];
                } else if (type === Kiwi.Time.TimerEvent.TIMER_COUNT) {
                    this._countEvents.push(new Kiwi.Time.TimerEvent(type, callback, context));
                    return this._countEvents[this._countEvents.length - 1];
                } else if (type === Kiwi.Time.TimerEvent.TIMER_STOP) {
                    this._stopEvents.push(new Kiwi.Time.TimerEvent(type, callback, context));
                    return this._stopEvents[this._stopEvents.length - 1];
                }

                return null;
            };

            /**
            * Removes a TimerEvent object from this Timer
            * @method removeTimerEvent
            * @param {TimerEvent} The TimerEvent to remove
            * @return {boolean} True if the event was removed, otherwise false.
            * @public
            */
            Timer.prototype.removeTimerEvent = function (event) {
                var removed = [];

                if (event.type === Kiwi.Time.TimerEvent.TIMER_START) {
                    removed = this._startEvents.splice(this._startEvents.indexOf(event), 1);
                } else if (event.type === Kiwi.Time.TimerEvent.TIMER_COUNT) {
                    removed = this._countEvents.splice(this._countEvents.indexOf(event), 1);
                } else if (event.type === Kiwi.Time.TimerEvent.TIMER_STOP) {
                    removed = this._stopEvents.splice(this._stopEvents.indexOf(event), 1);
                }

                if (removed.length === 1) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Removes all TimerEvent objects from this Timer
            * @method clear
            * @param type {Number} The type of TimerEvents to remove. Set to zero to remove them all.
            * @return {boolean} True if the event was removed, otherwise false.
            * @public
            */
            Timer.prototype.clear = function (type) {
                if (typeof type === "undefined") { type = 0; }
                if (type === 0) {
                    this._startEvents.length = 0;
                    this._countEvents.length = 0;
                    this._stopEvents.length = 0;
                } else if (type === Kiwi.Time.TimerEvent.TIMER_START) {
                    this._startEvents.length = 0;
                } else if (type === Kiwi.Time.TimerEvent.TIMER_COUNT) {
                    this._countEvents.length = 0;
                } else if (type === Kiwi.Time.TimerEvent.TIMER_STOP) {
                    this._stopEvents.length = 0;
                }
            };

            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {string} a string representation of the instance.
            * @public
            */
            Timer.prototype.toString = function () {
                return "[{Timer (name=" + this.name + " delay=" + this.delay + " repeatCount=" + this.repeatCount + " running=" + this._isRunning + ")}]";
            };
            return Timer;
        })();
        Time.Timer = Timer;
    })(Kiwi.Time || (Kiwi.Time = {}));
    var Time = Kiwi.Time;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Time
*
*/
var Kiwi;
(function (Kiwi) {
    (function (Time) {
        /**
        * A TimerEvent hooks into a Timer and is an object that is generated when you are wanting to executed a callback at a specific point in time.
        *
        * @class TimerEvent
        * @namespace Kiwi.Time
        * @constructor
        * @param type {Number} The type of TimerEvent that this is.
        * @param callback {Any} The method that is to be executed when the event occurs.
        * @param context {Any} The context that the callback is to be called in.
        * @return {TimerEvent} This Object.
        */
        var TimerEvent = (function () {
            function TimerEvent(type, callback, context) {
                /**
                * The callback to be called when this TimerEvent triggers
                * @property _callback
                * @type Function
                * @private
                */
                this._callback = null;
                /**
                * The type of TimerEvent
                * @property type
                * @type Function
                * @public
                */
                this.type = 0;
                this.type = type;
                this._callback = callback;
                this._callbackContext = context;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            TimerEvent.prototype.objType = function () {
                return "TimerEvent";
            };

            /**
            * Fires the callback associated with this TimerEvent
            * @method run
            * @public
            */
            TimerEvent.prototype.run = function () {
                if (this._callback) {
                    this._callback.apply(this._callbackContext);
                }
            };
            TimerEvent.TIMER_START = 1;

            TimerEvent.TIMER_COUNT = 2;

            TimerEvent.TIMER_STOP = 3;
            return TimerEvent;
        })();
        Time.TimerEvent = TimerEvent;
    })(Kiwi.Time || (Kiwi.Time = {}));
    var Time = Kiwi.Time;
})(Kiwi || (Kiwi = {}));
var Kiwi;
(function (Kiwi) {
    /**
    *
    * @module Kiwi
    * @submodule Utils
    */
    (function (Utils) {
        /**
        * Creates and the manages a Canvas DOMElement.
        *
        * @class Canvas
        * @namespace Kiwi.Utils
        * @constructor
        * @param width {Number} The width of the canvas.
        * @param height {Number} The height of the canvas.
        * @param [visible=true] {boolean} If the canvas is visible or not.
        * @param [offScreen=false] {boolean} If the canvas is designed to be offscreen or not.
        * @return {Canvas}
        *
        */
        var Canvas = (function () {
            function Canvas(width, height, visible, offScreen) {
                if (typeof visible === "undefined") { visible = true; }
                if (typeof offScreen === "undefined") { offScreen = false; }
                /**
                * The canvas DOM element.
                * @property domElement
                * @type HTMLCanvasElement
                * @public
                */
                this.domElement = null;
                /**
                * The 2D rendering context that is used to render anything to this canvas.
                * @property _context
                * @type CanvasRenderingContext2D
                * @public
                */
                this.context = null;
                /**
                * If the canvas element is visible or not.
                * @property _visible
                * @type boolean
                * @private
                */
                this._visible = true;
                /**
                * If the canvas is offscreen or not.
                * @property _offScreen
                * @type boolean
                * @private
                */
                this._offScreen = false;
                /**
                * The method to use when clearing the canvas.
                * @property _clearMode
                * @type Number
                * @private
                */
                this._clearMode = 1;
                /**
                * The background color to use clearing the canvas using a filled rectangle approach.
                * @property bgColor
                * @type String
                * @default 'rgb(0,0,0)'
                * @public
                */
                this.bgColor = 'rgb(0, 0, 0)';
                this.domElement = document.createElement('canvas');
                this.domElement.width = width;
                this.domElement.height = height;

                this._width = width;
                this._height = height;

                this.context = this.domElement.getContext('2d');

                this._offScreen = offScreen;
                this._visible = visible;

                if (visible === false) {
                    this.domElement.style.display = 'none';
                }
            }
            Object.defineProperty(Canvas.prototype, "width", {
                get: function () {
                    return this._width;
                },
                /**
                * The width of this canvas.
                * @property width
                * @type number
                * @public
                */
                set: function (value) {
                    this._width = value;
                    this._updatedSize();
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Canvas.prototype, "height", {
                get: function () {
                    return this._height;
                },
                /**
                * The height of this canvas.
                * @property height
                * @type number
                * @private
                */
                set: function (value) {
                    this._height = value;
                    this._updatedSize();
                },
                enumerable: true,
                configurable: true
            });

            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Canvas.prototype.objType = function () {
                return "Canvas";
            };

            /**
            * Updates the width/height on the canvas DOM element when either one of its sizes are updated.
            * @method _updatedSize
            * @private
            */
            Canvas.prototype._updatedSize = function () {
                this.domElement.width = this._width;
                this.domElement.height = this._height;
            };

            /**
            * Used to remove the canvas element completely along with this class. [NEEDS IMPLEMENTATION]
            * @method destroy
            * @public
            */
            Canvas.prototype.destroy = function () {
                if (this._offScreen === false) {
                    this.domElement.style.display = 'none';
                }
            };

            Object.defineProperty(Canvas.prototype, "visible", {
                get: function () {
                    return this._visible;
                },
                /**
                * If the canvas element is visible or not.
                * @property visible
                * @type boolean
                * @default true
                * @public
                */
                set: function (value) {
                    if (value !== null && value !== this._visible) {
                        this._visible = value;

                        if (value === true) {
                            this.domElement.style.display = 'block';
                        } else {
                            this.domElement.style.display = 'none';
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });

            Object.defineProperty(Canvas.prototype, "clearMode", {
                get: function () {
                    return this._clearMode;
                },
                /**
                * The clearmode the is to be used when clearing the canvas.
                * @property clearMode
                * @type Number
                * @default 1
                * @public
                */
                set: function (value) {
                    if (value !== null && value !== this._clearMode && value >= Kiwi.Utils.Canvas.CLEARMODE_NONE && value <= Kiwi.Utils.Canvas.CLEARMODE_FILLRECT_ALPHA) {
                        this._clearMode = value;
                    }
                },
                enumerable: true,
                configurable: true
            });

            /**
            * Clears the canvas using the method specified by the clearMode property.
            * @method clear
            * @public
            */
            Canvas.prototype.clear = function () {
                if (this._clearMode === Canvas.CLEARMODE_NONE) {
                    //  Do nothing
                } else if (this._clearMode === Canvas.CLEARMODE_CLEARRECT) {
                    //  Clear Rect
                    this.context.clearRect(0, 0, this.domElement.width, this.domElement.height);
                } else if (this._clearMode === Canvas.CLEARMODE_FILLRECT) {
                    //  Fill Rect Solid
                    this.context.fillStyle = this.bgColor;
                    this.context.fillRect(0, 0, this.domElement.width, this.domElement.height);
                } else if (this._clearMode === Canvas.CLEARMODE_FILLRECT_ALPHA) {
                    //  Clear Rect + Fill Rect (only use if bgColor contains alpha < 255)
                    this.context.clearRect(0, 0, this.domElement.width, this.domElement.height);
                    this.context.fillStyle = this.bgColor;
                    this.context.fillRect(0, 0, this.domElement.width, this.domElement.height);
                }
            };

            /**
            * Returns the canvas current image data as PNG.
            * @method saveAsPNG
            * @return String
            * @public
            */
            Canvas.prototype.saveAsPNG = function () {
                return this.domElement.toDataURL();
            };

            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {string} a string representation of the instance.
            * @public
            */
            Canvas.prototype.toString = function () {
                return '[{Canvas (width=' + this.width + ' height=' + this.height + ' visible=' + this.visible + ' offScreen=' + this._offScreen + ' clearMode=' + this.clearMode + ')}]';
            };
            Canvas.CLEARMODE_NONE = 0;

            Canvas.CLEARMODE_CLEARRECT = 1;

            Canvas.CLEARMODE_FILLRECT = 2;

            Canvas.CLEARMODE_FILLRECT_ALPHA = 3;
            return Canvas;
        })();
        Utils.Canvas = Canvas;
    })(Kiwi.Utils || (Kiwi.Utils = {}));
    var Utils = Kiwi.Utils;
})(Kiwi || (Kiwi = {}));
/**
* Utils is a space that holds a wide varity of useful methods.
*
* @module Kiwi
* @submodule Utils
* @main Utils
*/
var Kiwi;
(function (Kiwi) {
    (function (Utils) {
        /**
        * Methods to assist in working with Structs.
        * A lot of the functions in this class are Copyright 2012 Mauricio Santos and used with permission.
        * His work is licensed under the Apache License, Version 2.0 (the "License")
        *
        * @class Common
        * @namespace Kiwi.Utils
        * @static
        *
        * @author Mauricio Santos
        */
        var Common = (function () {
            function Common() {
            }
            /**
            * Default function to compare element order.
            * @method defaultCompare
            * @param {Any} a.
            * @param {Any} b.
            * @return {Number}
            * @static
            */
            Common.defaultCompare = function (a, b) {
                if (a < b) {
                    return -1;
                } else if (a === b) {
                    return 0;
                } else {
                    return 1;
                }
            };

            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            Common.prototype.objType = function () {
                return "Common";
            };

            /**
            * Default function to test equality.
            * @method defaultEquals
            * @param {Any} a
            * @param {Any} b
            * @return {boolean}
            * @static
            * @public
            */
            Common.defaultEquals = function (a, b) {
                return a === b;
            };

            /**
            * Default function to convert an object to a string.
            * @method defaultTostring
            * @param item {Any}
            * @return {Any}
            * @static
            * @public
            */
            Common.defaultTostring = function (item) {
                if (item === null) {
                    return 'KIWI_NULL';
                } else if (Kiwi.Utils.Common.isUndefined(item)) {
                    return 'KIWI_UNDEFINED';
                } else if (Kiwi.Utils.Common.isString(item)) {
                    return item;
                } else {
                    return item.toString();
                }
            };

            /**
            * Checks if the given argument is a function.
            * @method isFunction
            * @param {Any} func.
            * @return {boolean}
            * @static
            * @public
            */
            Common.isFunction = function (func) {
                return (typeof func) === 'function';
            };

            /**
            * Checks if the given value is numeric.
            * @method isNumeric
            * @param value {Any}
            * @return {Boolean}
            * @static
            * @public
            */
            Common.isNumeric = function (value) {
                return !isNaN(value);
            };

            /**
            * Checks if the given argument is undefined.
            * @method isUndefined
            * @param {Any} obj
            * @return {boolean}
            * @static
            * @public
            */
            Common.isUndefined = function (obj) {
                return (typeof obj) === 'undefined';
            };

            /**
            * Checks if the given argument is a string.
            * @method isString
            * @param {Any} obj
            * @return {boolean}
            * @static
            * @public
            */
            Common.isString = function (obj) {
                return Object.prototype.toString.call(obj) === '[object string]';
            };

            /**
            * Reverses a compare function.
            * @method reverseCompareFunction
            * @param {Any} compareFunction
            * @return {Number}
            * @static
            * @public
            */
            Common.reverseCompareFunction = function (compareFunction) {
                if (!Kiwi.Utils.Common.isFunction(compareFunction)) {
                    return function (a, b) {
                        if (a < b) {
                            return 1;
                        } else if (a === b) {
                            return 0;
                        } else {
                            return -1;
                        }
                    };
                } else {
                    return function (d, v) {
                        return compareFunction(d, v) * -1;
                    };
                }
            };

            /**
            * Returns an equal function given a compare function.
            * @method compareToEquals
            * @param {Any} compareFunction
            * @return {boolean}
            * @static
            * @public
            */
            Common.compareToEquals = function (compareFunction) {
                return function (a, b) {
                    return compareFunction(a, b) === 0;
                };
            };

            /**
            * Shuffles the contents of an array given into a random order.
            * @method shuffleArray
            * @param array {Any}
            * @return {Any} What you passed but the with the contents in a new order.
            * @static
            * @public
            */
            Common.shuffleArray = function (array) {
                for (var i = array.length - 1; i > 0; i--) {
                    var j = Math.floor(Math.random() * (i + 1));
                    var temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }

                return array;
            };

            /**
            * A method that checks to see if an Image or Canvas that is passed has base2 proportions.
            * If it doesn't the image is created on a Canvas and that Canvas is returned.
            * Used mainly when creating TextureAtlases for WebGL.
            * @method convertToBase2
            * @param imageFile {HTMLImageElement/HTMLCanvasElement} The image or canvas element that is to be converted into a base2size.
            * @return {HTMLImageElement/HTMLCanvasElement} The image that was passed (if it was already at base2 dimensions) or a new canvas element if it wasn't.
            * @static
            * @public
            */
            Common.convertToBase2 = function (image) {
                //Get the width/height
                var width = image.width;
                var height = image.height;

                //Check to see if the width is base2
                if (this.base2Sizes.indexOf(width) == -1) {
                    var i = 0;
                    while (width > this.base2Sizes[i])
                        i++;
                    width = this.base2Sizes[i];
                }

                //Check to see if the height is base2
                if (this.base2Sizes.indexOf(height) == -1) {
                    var i = 0;
                    while (height > this.base2Sizes[i])
                        i++;
                    height = this.base2Sizes[i];
                }

                //If either of them did not have a base2 size then create a canvas and create a new canvas.
                if (image.width !== width || image.height !== height) {
                    //Is it already a canvas?
                    var canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    canvas.getContext("2d").drawImage(image, 0, 0);

                    return canvas;
                }

                return image;
            };
            Common.base2Sizes = [2, 4, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
            return Common;
        })();
        Utils.Common = Common;
    })(Kiwi.Utils || (Kiwi.Utils = {}));
    var Utils = Kiwi.Utils;
})(Kiwi || (Kiwi = {}));
var Kiwi;
(function (Kiwi) {
    /**
    *
    * @module Kiwi
    * @submodule Utils
    */
    (function (Utils) {
        /**
        * Adds a set of extra Math functions and extends a few commonly used ones.
        * Includes some methods written by Dylan Engelman.
        *
        * @class GameMath
        * @namespace Kiwi.Utils
        * @static
        *
        * @author Richard Davey
        * @author Dylan Engelman
        */
        var GameMath = (function () {
            function GameMath() {
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            GameMath.prototype.objType = function () {
                return "GameMath";
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method computeMachineEpsilon
            * @return {Number}
            * @static
            * @public
            */
            GameMath.computeMachineEpsilon = function () {
                // Machine epsilon ala Eispack
                var fourThirds = 4.0 / 3.0;
                var third = fourThirds - 1.0;
                var one = third + third + third;
                return Math.abs(1.0 - one);
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method fuzzyEqual
            * @param a {number}
            * @param b {number}
            * @param [epsilon=0.0001] {number}
            * @return {boolean}
            * @static
            * @public
            */
            GameMath.fuzzyEqual = function (a, b, epsilon) {
                if (typeof epsilon === "undefined") { epsilon = 0.0001; }
                return Math.abs(a - b) < epsilon;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method fuzzyLessThan
            * @param a {number}
            * @param b {number}
            * @param [epsilon=0.0001] {number}
            * @return {boolean}
            * @static
            * @public
            */
            GameMath.fuzzyLessThan = function (a, b, epsilon) {
                if (typeof epsilon === "undefined") { epsilon = 0.0001; }
                return a < b + epsilon;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method fuzzyGreaterThan
            * @param a {number}
            * @param b {number}
            * @param [epsilon=0.0001] {number}
            * @return {boolean}
            * @static
            * @public
            */
            GameMath.fuzzyGreaterThan = function (a, b, epsilon) {
                if (typeof epsilon === "undefined") { epsilon = 0.0001; }
                return a > b - epsilon;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method fuzzyCeil
            * @param val {number}
            * @param [epsilon=0.0001] {number}
            * @return {Number}
            * @static
            * @public
            */
            GameMath.fuzzyCeil = function (val, epsilon) {
                if (typeof epsilon === "undefined") { epsilon = 0.0001; }
                return Math.ceil(val - epsilon);
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method fuzzyFloor
            * @param val {number}
            * @param [epsilion=0.0001] {number}
            * @return {Number}
            * @static
            * @public
            */
            GameMath.fuzzyFloor = function (val, epsilon) {
                if (typeof epsilon === "undefined") { epsilon = 0.0001; }
                return Math.floor(val + epsilon);
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method average
            * @param [args]* {Any[]}
            * @return {Number}
            * @static
            * @public
            */
            GameMath.average = function () {
                var args = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    args[_i] = arguments[_i + 0];
                }
                var avg = 0;

                for (var i = 0; i < args.length; i++) {
                    avg += args[i];
                }

                return avg / args.length;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method slam
            * @param value {number}
            * @param target {number}
            * @param [epsilon=0.0001] {number}
            * @return {Number}
            * @static
            * @public
            */
            GameMath.slam = function (value, target, epsilon) {
                if (typeof epsilon === "undefined") { epsilon = 0.0001; }
                return (Math.abs(value - target) < epsilon) ? target : value;
            };

            /**
            * Ratio of value to a range.
            * @method percentageMinMax
            * @param val {number}
            * @param max {number}
            * @param [min=0] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.percentageMinMax = function (val, max, min) {
                if (typeof min === "undefined") { min = 0; }
                val -= min;
                max -= min;

                if (!max)
                    return 0;
                else
                    return val / max;
            };

            /**
            * A value representing the sign of the value.
            * -1 for negative, +1 for positive, 0 if value is 0
            * @method sign
            * @param n {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.sign = function (n) {
                if (n)
                    return n / Math.abs(n);
                else
                    return 0;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method truncate
            * @param n {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.truncate = function (n) {
                return (n > 0) ? Math.floor(n) : Math.ceil(n);
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method shear
            * @param n {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.shear = function (n) {
                return n % 1;
            };

            /**
            * Wrap a value around a range, similar to modulus with a floating minimum
            * @method wrap
            * @param val {number}
            * @param max {number}
            * @param [min=0] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.wrap = function (val, max, min) {
                if (typeof min === "undefined") { min = 0; }
                val -= min;
                max -= min;
                if (max == 0)
                    return min;
                val %= max;
                val += min;
                while (val < min)
                    val += max;

                return val;
            };

            /**
            * Arithmetic version of wrap.
            * @method arithWrap
            * @param val {number}
            * @param max {number}
            * @param [min=0] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.arithWrap = function (value, max, min) {
                if (typeof min === "undefined") { min = 0; }
                max -= min;
                if (max == 0)
                    return min;
                return value - max * Math.floor((value - min) / max);
            };

            /**
            * Force a value within the boundaries of two values
            * If max < min, min is returned.
            * @method clamp
            * @param input {number}
            * @param max {number}
            * @param [min=0] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.clamp = function (input, max, min) {
                if (typeof min === "undefined") { min = 0; }
                return Math.max(min, Math.min(max, input));
            };

            /**
            * Snap a value to nearest grid slice, using rounding.
            * Example if you have an interval gap of 5 and a position of 12... you will snap to 10. Where as 14 will snap to 15
            *
            * @method snapTo
            * @param input {number} The value to snap
            * @param gap {number} The interval gap of the grid
            * @param [start=0] {number} Optional starting offset for gap
            * @return {number}
            * @static
            * @public
            */
            GameMath.snapTo = function (input, gap, start) {
                if (typeof start === "undefined") { start = 0; }
                if (gap == 0)
                    return input;

                input -= start;
                input = gap * Math.round(input / gap);
                return start + input;
            };

            /**
            * Snap a value to nearest grid slice, using floor.
            * Example if you have an interval gap of 5 and a position of 12... you will snap to 10. As will 14 snap to 10... but 16 will snap to 15
            *
            * @method snapToFloor
            * @param input {number} The value to snap
            * @param gap {number} The interval gap of the grid
            * @param [start=0] {number} Optional starting offset for gap
            * @return {number}
            * @static
            * @public
            */
            GameMath.snapToFloor = function (input, gap, start) {
                if (typeof start === "undefined") { start = 0; }
                if (gap == 0)
                    return input;

                input -= start;
                input = gap * Math.floor(input / gap);
                return start + input;
            };

            /**
            * Snap a value to nearest grid slice, using ceil.
            * Example if you have an interval gap of 5 and a position of 12... you will snap to 15. As will 14 will snap to 15... but 16 will snap to 20
            *
            * @method snapToCeil
            * @param input {number} The value to snap
            * @param gap {number} The interval gap of the grid
            * @param [start=0] {number} optional starting offset for gap
            * @return {number}
            * @static
            * @public
            */
            GameMath.snapToCeil = function (input, gap, start) {
                if (typeof start === "undefined") { start = 0; }
                if (gap == 0)
                    return input;

                input -= start;
                input = gap * Math.ceil(input / gap);
                return start + input;
            };

            /**
            * Snaps a value to the nearest value in an array.
            * @method snapToInArray
            * @param input {number}
            * @param arr {number[]}
            * @param [sort=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.snapToInArray = function (input, arr, sort) {
                if (typeof sort === "undefined") { sort = true; }
                if (sort)
                    arr.sort();
                if (input < arr[0])
                    return arr[0];

                var i = 1;

                while (arr[i] < input)
                    i++;

                var low = arr[i - 1];
                var high = (i < arr.length) ? arr[i] : Number.POSITIVE_INFINITY;

                return ((high - input) <= (input - low)) ? high : low;
            };

            /**
            * Round to some place comparative to a 'base', default is 10 for decimal place.
            * 'place' is represented by the power applied to 'base' to get that place
            *
            * @method roundTo
            * @param value {number} The value to round
            * @param [place=0] {number} The place to round to
            * @param [base=10] {number} The base to round in... default is 10 for decimal
            * @return {number}
            * @static
            * @public
            */
            GameMath.roundTo = function (value, place, base) {
                if (typeof place === "undefined") { place = 0; }
                if (typeof base === "undefined") { base = 10; }
                var p = Math.pow(base, -place);
                return Math.round(value * p) / p;
            };

            /*
            * E.g.
            *
            * 2000/7 ~= 285.714285714285714285714 ~= (bin)100011101.1011011011011011
            *
            * roundTo(2000/7,3) == 0
            * roundTo(2000/7,2) == 300
            * roundTo(2000/7,1) == 290
            * roundTo(2000/7,0) == 286
            * roundTo(2000/7,-1) == 285.7
            * roundTo(2000/7,-2) == 285.71
            * roundTo(2000/7,-3) == 285.714
            * roundTo(2000/7,-4) == 285.7143
            * roundTo(2000/7,-5) == 285.71429
            *
            * roundTo(2000/7,3,2)  == 288       -- 100100000
            * roundTo(2000/7,2,2)  == 284       -- 100011100
            * roundTo(2000/7,1,2)  == 286       -- 100011110
            * roundTo(2000/7,0,2)  == 286       -- 100011110
            * roundTo(2000/7,-1,2) == 285.5     -- 100011101.1
            * roundTo(2000/7,-2,2) == 285.75    -- 100011101.11
            * roundTo(2000/7,-3,2) == 285.75    -- 100011101.11
            * roundTo(2000/7,-4,2) == 285.6875  -- 100011101.1011
            * roundTo(2000/7,-5,2) == 285.71875 -- 100011101.10111
            *
            * Note what occurs when we round to the 3rd space (8ths place), 100100000, this is to be assumed
            * because we are rounding 100011.1011011011011011 which rounds up.
            */
            /**
            * [DESCRIPTION REQUIRED]
            * @method floorTo
            * @param value {number}
            * @param [place=0] {number}
            * @param [base=10] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.floorTo = function (value, place, base) {
                if (typeof place === "undefined") { place = 0; }
                if (typeof base === "undefined") { base = 10; }
                var p = Math.pow(base, -place);
                return Math.floor(value * p) / p;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method ceilTo
            * @param value {number}
            * @param [place=0] {number}
            * @param [base=10] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.ceilTo = function (value, place, base) {
                if (typeof place === "undefined") { place = 0; }
                if (typeof base === "undefined") { base = 10; }
                var p = Math.pow(base, -place);
                return Math.ceil(value * p) / p;
            };

            /**
            * A one dimensional linear interpolation of a value.
            * @method interpolateFloat
            * @param a {number}
            * @param b {number}
            * @param weight {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.interpolateFloat = function (a, b, weight) {
                return (b - a) * weight + a;
            };

            /**
            * Convert radians to degrees
            * @method radiansToDegrees
            * @param angle {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.radiansToDegrees = function (angle) {
                return angle * GameMath.RAD_TO_DEG;
            };

            /**
            * Convert degrees to radians
            * @method degreesToRadians
            * @param angle {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.degreesToRadians = function (angle) {
                return angle * GameMath.DEG_TO_RAD;
            };

            /**
            * Find the angle of a segment from (x1, y1) -> (x2, y2 )
            * @method angleBetween
            * @param x1 {number}
            * @param y1 {number}
            * @param x2 {number}
            * @param y2 {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.angleBetween = function (x1, y1, x2, y2) {
                return Math.atan2(y2 - y1, x2 - x1);
            };

            /**
            * Set an angle with in the bounds of -PI to PI
            * @method normalizeAngle
            * @param angle {number}
            * @param [radians=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.normalizeAngle = function (angle, radians) {
                if (typeof radians === "undefined") { radians = true; }
                var rd = (radians) ? GameMath.PI : 180;
                return GameMath.wrap(angle, rd, -rd);
            };

            /**
            * Closest angle between two angles from a1 to a2
            * absolute value the return for exact angle.
            * @method nearestAngleBetween
            * @param a1 {number}
            * @param a2 {number}
            * @param [radians=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.nearestAngleBetween = function (a1, a2, radians) {
                if (typeof radians === "undefined") { radians = true; }
                var rd = (radians) ? GameMath.PI : 180;

                a1 = GameMath.normalizeAngle(a1, radians);
                a2 = GameMath.normalizeAngle(a2, radians);

                if (a1 < -rd / 2 && a2 > rd / 2)
                    a1 += rd * 2;
                if (a2 < -rd / 2 && a1 > rd / 2)
                    a2 += rd * 2;

                return a2 - a1;
            };

            /**
            * Normalizes independent and then sets dep to the nearest value respective to independent.
            * For instance if dep=-170 and ind=170 then 190 will be returned as an alternative to -170
            * @method normalizeAngleToAnother
            * @param dep {number}
            * @param ind {number}
            * @param [radians=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.normalizeAngleToAnother = function (dep, ind, radians) {
                if (typeof radians === "undefined") { radians = true; }
                return ind + Kiwi.Utils.GameMath.nearestAngleBetween(ind, dep, radians);
            };

            /**
            * Normalize independent and dependent and then set dependent to an angle relative to 'after/clockwise' independent.
            * For instance dep=-170 and ind=170, then 190 will be reutrned as alternative to -170
            * @method normalizeAngleAfterAnother
            * @param dep {number}
            * @param ind {number}
            * @param [radians=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.normalizeAngleAfterAnother = function (dep, ind, radians) {
                if (typeof radians === "undefined") { radians = true; }
                dep = Kiwi.Utils.GameMath.normalizeAngle(dep - ind, radians);
                return ind + dep;
            };

            /**
            * Normalizes indendent and dependent and then sets dependent to an angle relative to 'before/counterclockwise' independent.
            * For instance dep = 190 and ind = 170, then -170 will be returned as an alternative to 190
            * @method normalizeAngleBeforeAnother
            * @param dep {number}
            * @param ind {number}
            * @param [radians=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.normalizeAngleBeforeAnother = function (dep, ind, radians) {
                if (typeof radians === "undefined") { radians = true; }
                dep = Kiwi.Utils.GameMath.normalizeAngle(ind - dep, radians);
                return ind - dep;
            };

            /**
            * Interpolate across the shortest arc between two angles.
            * @method interpolateAngles
            * @param a1 {number}
            * @param a2 {number}
            * @param weight {number}
            * @param [radians=true] {boolean}
            * @param [ease=null] {any}
            * @return {number}
            * @static
            * @public
            */
            GameMath.interpolateAngles = function (a1, a2, weight, radians, ease) {
                if (typeof radians === "undefined") { radians = true; }
                if (typeof ease === "undefined") { ease = null; }
                a1 = Kiwi.Utils.GameMath.normalizeAngle(a1, radians);
                a2 = Kiwi.Utils.GameMath.normalizeAngleToAnother(a2, a1, radians);

                return (typeof ease === 'function') ? ease(weight, a1, a2 - a1, 1) : Kiwi.Utils.GameMath.interpolateFloat(a1, a2, weight);
            };

            /**
            * Compute the logarithm of any value of any base.
            * A logarithm is the exponent that some constant (base) would have to be raised to
            * to be equal to value.
            * @method logBaseOf
            * @param value {number}
            * @param base {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.logBaseOf = function (value, base) {
                return Math.log(value) / Math.log(base);
            };

            /*
            * i.e.
            * 4 ^ x = 16
            * can be rewritten as to solve for x
            * logB4(16) = x
            * which with this function would be
            * LoDMath.logBaseOf(16,4)
            *
            * which would return 2, because 4^2 = 16
            */
            /**
            * Greatest Common Denominator using Euclid's algorithm.
            * @method GCD
            * @param m {number}
            * @param n {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.GCD = function (m, n) {
                var r;

                //make sure positive, GCD is always positive
                m = Math.abs(m);
                n = Math.abs(n);

                //m must be >= n
                if (m < n) {
                    r = m;
                    m = n;
                    n = r;
                }

                while (true) {
                    r = m % n;
                    if (!r)
                        return n;
                    m = n;
                    n = r;
                }

                return 1;
            };

            /**
            * Lowest Common Multiple
            * @method LCM
            * @param m {number}
            * @param n {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.LCM = function (m, n) {
                return (m * n) / Kiwi.Utils.GameMath.GCD(m, n);
            };

            /**
            * Factorial - N! Simple product series. By definition:
            * 0! == 1
            * @method factorial
            * @param value {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.factorial = function (value) {
                if (value == 0)
                    return 1;

                var res = value;

                while (--value) {
                    res *= value;
                }

                return res;
            };

            /**
            * Gamma function. Defined: gamma(N) == (N - 1)!
            * @method gammaFunction
            * @param value {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.gammaFunction = function (value) {
                return Kiwi.Utils.GameMath.factorial(value - 1);
            };

            /**
            * Falling factorial. Defined: (N)! / (N - x)!
            * Written subscript: (N)x OR (base)exp
            * @method fallingFactorial
            * @param base {number}
            * @param exp {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.fallingFactorial = function (base, exp) {
                return Kiwi.Utils.GameMath.factorial(base) / Kiwi.Utils.GameMath.factorial(base - exp);
            };

            /**
            * Rising factorial. Defined: (N + x - 1)! / (N - 1)!
            * Written superscript N^(x) OR base^(exp)
            * @method risingFactorial
            * @param base {number}
            * @param exp {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.risingFactorial = function (base, exp) {
                //expanded from gammaFunction for speed
                return Kiwi.Utils.GameMath.factorial(base + exp - 1) / Kiwi.Utils.GameMath.factorial(base - 1);
            };

            /**
            * Binomial coefficient.
            * @method binCoef
            * @param n {number}
            * @param k {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.binCoef = function (n, k) {
                return Kiwi.Utils.GameMath.fallingFactorial(n, k) / Kiwi.Utils.GameMath.factorial(k);
            };

            /*
            * defined: N! / (k!(N-k)!)
            * reduced: N! / (N-k)! == (N)k (fallingfactorial)
            * reduced: (N)k / k!
            */
            /**
            * Rising binomial coefficient.
            * As one can notice in the analysis of binCoef(...) that
            * binCoef is the (N)k divided by k!. Similarly rising binCoef
            * is merely N^(k) / k!
            * @method risingBinCoef
            * @param n {number}
            * @param k {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.risingBinCoef = function (n, k) {
                return Kiwi.Utils.GameMath.risingFactorial(n, k) / Kiwi.Utils.GameMath.factorial(k);
            };

            /**
            * Generate a random boolean result based on the chance value.
            * Returns true or false based on the chance value (default 50%). For example if you wanted a player to have a 30% chance
            * of getting a bonus, call chanceRoll(30) - true means the chance passed, false means it failed.
            *
            * @method changeRoll
            * @param [chance=50] {number} The chance of receiving the value. A number between 0 and 100 (effectively 0% to 100%)
            * @return {boolean} true if the roll passed, or false
            * @static
            * @public
            */
            GameMath.chanceRoll = function (chance) {
                if (typeof chance === "undefined") { chance = 50; }
                if (chance <= 0) {
                    return false;
                } else if (chance >= 100) {
                    return true;
                } else {
                    if (Math.random() * 100 >= chance) {
                        return false;
                    } else {
                        return true;
                    }
                }
            };

            /**
            * Adds the given amount to the value, but never lets the value go over the specified maximum.
            *
            * @method maxAdd
            * @param value {number} The value to add the amount to
            * @param amount {number} The amount to add to the value
            * @param max {number} The maximum the value is allowed to be
            * @return {number}
            * @static
            * @public
            */
            GameMath.maxAdd = function (value, amount, max) {
                value += amount;

                if (value > max) {
                    value = max;
                }

                return value;
            };

            /**
            * Subtracts the given amount from the value, but never lets the value go below the specified minimum.
            *
            * @method minSub
            * @param value {number} The base value
            * @param amount {number} The amount to subtract from the base value
            * @param min {number} The minimum the value is allowed to be
            * @return {number}
            * @static
            * @public
            */
            GameMath.minSub = function (value, amount, min) {
                value -= amount;

                if (value < min) {
                    value = min;
                }

                return value;
            };

            /**
            * Adds value to amount and ensures that the result always stays between 0 and max, by wrapping the value around.
            * Values must be positive integers, and are passed through Math.abs
            *
            * @method wrapValue
            * @param value {number} The value to add the amount to
            * @param amount {number} The amount to add to the value
            * @param max {number} The maximum the value is allowed to be
            * @return {number} The wrapped value
            * @static
            * @public
            */
            GameMath.wrapValue = function (value, amount, max) {
                var diff;

                value = Math.abs(value);
                amount = Math.abs(amount);
                max = Math.abs(max);

                diff = (value + amount) % max;

                return diff;
            };

            /**
            * Randomly returns either a 1 or -1
            * @method randomSign
            * @return {number} Either 1 or -1.
            * @static
            * @public
            */
            GameMath.randomSign = function () {
                return (Math.random() > 0.5) ? 1 : -1;
            };

            /**
            * Returns true if the number given is odd.
            * @method isOff
            * @param n {number} The number to check
            * @return {boolean} True if the given number is odd. False if the given number is even.
            * @static
            * @public
            */
            GameMath.isOdd = function (n) {
                if (n & 1) {
                    return true;
                } else {
                    return false;
                }
            };

            /**
            * Returns true if the number given is even.
            * @method isEvent
            * @param n {number} The number to check
            * @return {boolean} True if the given number is even. False if the given number is odd.
            * @static
            * @public
            */
            GameMath.isEven = function (n) {
                if (n & 1) {
                    return false;
                } else {
                    return true;
                }
            };

            /**
            * Keeps an angle value between -180 and +180.
            * Should be called whenever the angle is updated on the Sprite to stop it from going insane.
            * @method wrapAngle
            * @param angle {number} The angle value to check
            * @return {number} The new angle value, returns the same as the input angle if it was within bounds
            * @static
            * @public
            */
            GameMath.wrapAngle = function (angle) {
                var result = angle;

                //  Nothing needs to change
                if (angle >= -180 && angle <= 180) {
                    return angle;
                }

                //  Else normalise it to -180, 180
                result = (angle + 180) % 360;

                if (result < 0) {
                    result += 360;
                }

                return result - 180;
            };

            /**
            * Keeps an angle value between the given min and max values.
            * @method angleLimit
            * @param angle {number} The angle value to check. Must be between -180 and +180
            * @param min {number} The minimum angle that is allowed (must be -180 or greater)
            * @param max {number} The maximum angle that is allowed (must be 180 or less)
            * @return {number} The new angle value, returns the same as the input angle if it was within bounds
            * @static
            * @public
            */
            GameMath.angleLimit = function (angle, min, max) {
                var result = angle;

                if (angle > max) {
                    result = max;
                } else if (angle < min) {
                    result = min;
                }

                return result;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method linear
            * @param {Any} v
            * @param {Any} k
            * @return {number}
            * @static
            * @public
            */
            GameMath.linearInterpolation = function (v, k) {
                var m = v.length - 1;
                var f = m * k;
                var i = Math.floor(f);

                if (k < 0)
                    return Kiwi.Utils.GameMath.linear(v[0], v[1], f);
                if (k > 1)
                    return Kiwi.Utils.GameMath.linear(v[m], v[m - 1], m - f);

                return Kiwi.Utils.GameMath.linear(v[i], v[i + 1 > m ? m : i + 1], f - i);
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method Bezier
            * @param {Any} v
            * @param {Any} k
            * @return {number}
            * @static
            * @public
            */
            GameMath.bezierInterpolation = function (v, k) {
                var b = 0;
                var n = v.length - 1;

                for (var i = 0; i <= n; i++) {
                    b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Kiwi.Utils.GameMath.bernstein(n, i);
                }

                return b;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method CatmullRom
            * @param {Any} v
            * @param {Any} k
            * @return {number}
            * @static
            * @public
            */
            GameMath.catmullRomInterpolation = function (v, k) {
                var m = v.length - 1;
                var f = m * k;
                var i = Math.floor(f);

                if (v[0] === v[m]) {
                    if (k < 0)
                        i = Math.floor(f = m * (1 + k));

                    return Kiwi.Utils.GameMath.catmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
                } else {
                    if (k < 0)
                        return v[0] - (Kiwi.Utils.GameMath.catmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);

                    if (k > 1)
                        return v[m] - (Kiwi.Utils.GameMath.catmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);

                    return Kiwi.Utils.GameMath.catmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
                }
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method Linear
            * @param {Any} p0
            * @param {Any} p1
            * @param {Any} t
            * @return {number}
            * @static
            * @public
            */
            GameMath.linear = function (p0, p1, t) {
                return (p1 - p0) * t + p0;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method Bernstein
            * @param {Any} n
            * @param {Any} i
            * @return {number}
            * @static
            * @public
            */
            GameMath.bernstein = function (n, i) {
                return Kiwi.Utils.GameMath.factorial(n) / Kiwi.Utils.GameMath.factorial(i) / Kiwi.Utils.GameMath.factorial(n - i);
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method CatmullRom
            * @param {Any} p0
            * @param {Any} p1
            * @param {Any} p2
            * @param {Any} p3
            * @param {Any} t
            * @return {number}
            * @static
            * @public
            */
            GameMath.catmullRom = function (p0, p1, p2, p3, t) {
                var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;
                return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method difference
            * @param a {number}
            * @param b {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.difference = function (a, b) {
                return Math.abs(a - b);
            };
            GameMath.PI = 3.141592653589793;

            GameMath.PI_2 = 1.5707963267948965;

            GameMath.PI_4 = 0.7853981633974483;

            GameMath.PI_8 = 0.39269908169872413;

            GameMath.PI_16 = 0.19634954084936206;

            GameMath.TWO_PI = 6.283185307179586;

            GameMath.THREE_PI_2 = 4.7123889803846895;

            GameMath.E = 2.71828182845905;

            GameMath.LN10 = 2.302585092994046;

            GameMath.LN2 = 0.6931471805599453;

            GameMath.LOG10E = 0.4342944819032518;

            GameMath.LOG2E = 1.442695040888963387;

            GameMath.SQRT1_2 = 0.7071067811865476;

            GameMath.SQRT2 = 1.4142135623730951;

            GameMath.DEG_TO_RAD = 0.017453292519943294444444444444444;

            GameMath.RAD_TO_DEG = 57.295779513082325225835265587527;

            GameMath.B_16 = 65536;

            GameMath.B_31 = 2147483648;

            GameMath.B_32 = 4294967296;

            GameMath.B_48 = 281474976710656;

            GameMath.B_53 = 9007199254740992;

            GameMath.B_64 = 18446744073709551616;

            GameMath.ONE_THIRD = 0.333333333333333333333333333333333;

            GameMath.TWO_THIRDS = 0.666666666666666666666666666666666;

            GameMath.ONE_SIXTH = 0.166666666666666666666666666666666;

            GameMath.COS_PI_3 = 0.86602540378443864676372317075294;

            GameMath.SIN_2PI_3 = 0.03654595;

            GameMath.CIRCLE_ALPHA = 0.5522847498307933984022516322796;

            GameMath.ON = true;

            GameMath.OFF = false;

            GameMath.SHORT_EPSILON = 0.1;

            GameMath.PERC_EPSILON = 0.001;

            GameMath.EPSILON = 0.0001;

            GameMath.LONG_EPSILON = 0.00000001;
            return GameMath;
        })();
        Utils.GameMath = GameMath;
    })(Kiwi.Utils || (Kiwi.Utils = {}));
    var Utils = Kiwi.Utils;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Utils
*/
var Kiwi;
(function (Kiwi) {
    (function (Utils) {
        /**
        * Manages the creation of unique internal game IDs.
        * Based on Nonsense by Josh Faul https://github.com/jocafa/Nonsense
        * Random number generator from http://baagoe.org/en/wiki/Better_random_numbers_for_javascript
        *
        * @class RandomDataGenerator
        * @constructor
        * @namespace Kiwi.Utils
        * @param [seeds=[]] {String[]}
        * @return {RandomDataGenerator}
        *
        * @author Josh Faul
        */
        var RandomDataGenerator = (function () {
            function RandomDataGenerator(seeds) {
                if (typeof seeds === "undefined") { seeds = []; }
                /**
                * [DESCRIPTION REQUIRED]
                * @property c
                * @type Number
                * @default 1
                * @private
                */
                this.c = 1;
                /**
                * Used to contain various arrays of data that can be used when randomly generating blocks of text.
                * @property _data
                * @type Object
                * @private
                */
                this._data = {
                    lipsum: [
                        "lorem", "ipsum", "dolor", "sit", "amet", "consectetur",
                        "adipiscing", "elit", "nunc", "sagittis", "tortor", "ac", "mi",
                        "pretium", "sed", "convallis", "massa", "pulvinar", "curabitur",
                        "non", "turpis", "velit", "vitae", "rutrum", "odio", "aliquam",
                        "sapien", "orci", "tempor", "sed", "elementum", "sit", "amet",
                        "tincidunt", "sed", "risus", "etiam", "nec", "lacus", "id", "ante",
                        "hendrerit", "malesuada", "donec", "porttitor", "magna", "eget",
                        "libero", "pharetra", "sollicitudin", "aliquam", "mattis", "mattis",
                        "massa", "et", "porta", "morbi", "vitae", "magna", "augue",
                        "vestibulum", "at", "lectus", "sed", "tellus", "facilisis",
                        "tincidunt", "suspendisse", "eros", "magna", "consequat", "at",
                        "sollicitudin", "ac", "vestibulum", "vel", "dolor", "in", "egestas",
                        "lacus", "quis", "lacus", "placerat", "et", "molestie", "ipsum",
                        "scelerisque", "nullam", "sit", "amet", "tortor", "dui", "aenean",
                        "pulvinar", "odio", "nec", "placerat", "fringilla", "neque", "dolor"
                    ]
                };
                this.sow(seeds);
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String}
            * @public
            */
            RandomDataGenerator.prototype.objType = function () {
                return "RandomDataGenerator";
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method uint32
            * @return {Any}
            * @private
            */
            RandomDataGenerator.prototype.uint32 = function () {
                return this.rnd.apply(this) * 0x100000000;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method fract32
            * @return {Any}
            * @private
            */
            RandomDataGenerator.prototype.fract32 = function () {
                return this.rnd.apply(this) + (this.rnd.apply(this) * 0x200000 | 0) * 1.1102230246251565e-16;
            };

            // private random helper
            /**
            * [DESCRIPTION REQUIRED]
            * @method rnd
            * @return {Any}
            * @private
            */
            RandomDataGenerator.prototype.rnd = function () {
                var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10;

                this.c = t | 0;
                this.s0 = this.s1;
                this.s1 = this.s2;
                this.s2 = t - this.c;

                return this.s2;
            };

            /**
            * [DESCRIPTION REQUIRED]
            * @method hash
            * @param data {Any}
            * @private
            */
            RandomDataGenerator.prototype.hash = function (data) {
                var h, i, n;

                n = 0xefc8249d;

                data = data.toString();

                for (i = 0; i < data.length; i++) {
                    n += data.charCodeAt(i);
                    h = 0.02519603282416938 * n;
                    n = h >>> 0;
                    h -= n;
                    h *= n;
                    n = h >>> 0;
                    h -= n;
                    n += h * 0x100000000; // 2^32
                }

                return (n >>> 0) * 2.3283064365386963e-10;
            };

            /**
            * Reset the seed of the random data generator
            * @method sow
            * @param [seeds=[]] {String[]}
            * @public
            */
            RandomDataGenerator.prototype.sow = function (seeds) {
                if (typeof seeds === "undefined") { seeds = []; }
                this.s0 = this.hash(' ');
                this.s1 = this.hash(this.s0);
                this.s2 = this.hash(this.s1);

                var seed;

                for (var i = 0; seed = seeds[i++];) {
                    this.s0 -= this.hash(seed);
                    this.s0 += ~~(this.s0 < 0);

                    this.s1 -= this.hash(seed);
                    this.s1 += ~~(this.s1 < 0);

                    this.s2 -= this.hash(seed);
                    this.s2 += ~~(this.s2 < 0);
                }
            };

            /**
            * Returns a random integer between 0 and 2^32
            * @method integer
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.integer = function () {
                return this.uint32();
            };

            /**
            * Returns a random real number between 0 and 1
            * @method frac
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.frac = function () {
                return this.fract32();
            };

            /**
            * Returns a random real number between 0 and 2^32
            * @method real
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.real = function () {
                return this.uint32() + this.fract32();
            };

            /**
            * Returns a random integer between min and max
            * @method integerInRange
            * @param min {Number}
            * @param max {Number}
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.integerInRange = function (min, max) {
                return Math.floor(this.realInRange(min, max));
            };

            /**
            * Returns a random real number between min and max
            * @method realInRange
            * @param min {Number}
            * @param max {Number}
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.realInRange = function (min, max) {
                min = min || 0;
                max = max || 0;

                return this.frac() * (max - min) + min;
            };

            /**
            * Returns a random real number between -1 and 1
            * @method normal
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.normal = function () {
                return 1 - 2 * this.frac();
            };

            /**
            * Returns a valid v4 UUID hex string (from https://gist.github.com/1308368)
            * @method uuid
            * @return {String}
            * @public
            */
            RandomDataGenerator.prototype.uuid = function () {
                var a, b;

                for (b = a = ''; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : '-')
                    ;

                return b;
            };

            /**
            * Returns a random member of `array`
            * @method pick
            * @param {Any} array
            * @return {Any}
            * @public
            */
            RandomDataGenerator.prototype.pick = function (array) {
                return array[this.integerInRange(0, array.length)];
            };

            /**
            * Returns a random member of `array`, favoring the earlier entries
            * @method weightedPick
            * @param {Any} array
            * @return {Any}
            * @public
            */
            RandomDataGenerator.prototype.weightedPick = function (array) {
                return array[~~(Math.pow(this.frac(), 2) * array.length)];
            };

            /**
            * Returns a random word of lipsum
            * @method word
            * @return {String}
            * @public
            */
            RandomDataGenerator.prototype.word = function () {
                return this.pick(this._data.lipsum);
            };

            /**
            * Returns `n` random words of lipsum, 3 if not specified
            * @method words
            * @param {Number} [quantity=3] Amount of random words to get.
            * @return {String}
            * @public
            */
            RandomDataGenerator.prototype.words = function (quantity) {
                if (typeof quantity === "undefined") { quantity = 3; }
                var ret = [];

                for (var i = 0; i < quantity; i++) {
                    ret.push(this.pick(this._data.lipsum));
                }

                return ret.join(' ');
            };

            /**
            * Returns a random lipsum sentence
            * @method sentence
            * @return {String}
            * @public
            */
            RandomDataGenerator.prototype.sentence = function () {
                var ret;

                ret = this.words(this.integerInRange(2, 16)).replace(/[a-z]/, function (m) {
                    return m.toUpperCase();
                });

                return ret + '.';
            };

            /**
            * Returns `n` random lipsum sentences, 3 if not specified
            * @method sentences
            * @param {Number} [quantity=3] The number of sentences to grab.
            * @return {String}
            * @public
            */
            RandomDataGenerator.prototype.sentences = function (quantity) {
                if (typeof quantity === "undefined") { quantity = 3; }
                var ret = [];

                for (var i = 0; i < quantity; i++) {
                    ret.push(this.sentence());
                }

                return ret.join(' ');
            };

            /**
            * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified
            * @method timestamp
            * @param [min=946684800000] {Number} The lowest timestamp.
            * @param [max=1577862000000] {Number} The highest timestamp.
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.timestamp = function (min, max) {
                if (typeof min === "undefined") { min = 946684800000; }
                if (typeof max === "undefined") { max = 1577862000000; }
                return this.realInRange(min, max);
            };

            /**
            * Returns a random angle between -180 and 180
            * @method angle
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.angle = function () {
                return this.integerInRange(-180, 180);
            };
            return RandomDataGenerator;
        })();
        Utils.RandomDataGenerator = RandomDataGenerator;
    })(Kiwi.Utils || (Kiwi.Utils = {}));
    var Utils = Kiwi.Utils;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Utils
*/
var Kiwi;
(function (Kiwi) {
    (function (Utils) {
        /**
        * Abstracts away the use of RAF or setTimeout for the core game update loop. The callback can be re-mapped on the fly.
        *
        * @class RequestAnimationFrame
        * @constructor
        * @namespace Kiwi.Utils
        * @param callback {Any}
        * @return {RequestAnimationFrame} This object.
        *
        */
        var RequestAnimationFrame = (function () {
            function RequestAnimationFrame(callback) {
                /**
                * A boolean indicating whether or not we are using setTimeout for the RequestAnimationFrame or not.
                * @property _isSetTimeOut
                * @type boolean
                * @default false
                * @private
                */
                this._isSetTimeOut = false;
                /**
                * The last time at which the RAF was called. This is given a value at the end of the RAF loop.
                * @property lastTime
                * @type Number
                * @public
                */
                this.lastTime = 0;
                /**
                * A timestamp that has the current time. This is updated each time the RAF loop is executed. Is updated before the last time in the loop.
                * @property currentTime
                * @type Number
                * @public
                */
                this.currentTime = 0;
                /**
                * A boolean indicating whether or not the RAF is running.
                * @property isRunning
                * @type boolean
                * @default false
                * @public
                */
                this.isRunning = false;
                this._callback = callback;

                var vendors = ['ms', 'moz', 'webkit', 'o'];

                for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {
                    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
                    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'];
                }
            }
            /**
            * The type of obect that this is.
            * @method objType
            * @return {String}
            * @public
            */
            RequestAnimationFrame.prototype.objType = function () {
                return "RequestAnimationFrame";
            };

            /**
            * Sets the callback method that is to be executed each time the RAF is.
            * @method setCallback
            * @param {Any} callback
            * @public
            */
            RequestAnimationFrame.prototype.setCallback = function (callback) {
                this._callback = callback;
            };

            /**
            * Returns a boolean indicating whether or not setTimeout is being used instead of RAF.
            * @method usingSetTimeOut
            * @return {boolean}
            * @public
            */
            RequestAnimationFrame.prototype.isUsingSetTimeOut = function () {
                return this._isSetTimeOut;
            };

            /**
            * Returns a boolean indicating wheather or not we are using the RAF. If false it means we are using setTimeout for our update loop.
            * @method usingRAF
            * @return {boolean}
            * @public
            */
            RequestAnimationFrame.prototype.isUsingRAF = function () {
                if (this._isSetTimeOut === true) {
                    return false;
                } else {
                    return true;
                }
            };

            /**
            * Starts the RequestAnimationFrame (or setTimeout if RAF not supported).
            * @method start
            * @param [callback] {Any} A callback to be executed everyframe. Overrides the callback set at instantiation if passed.
            * @public
            */
            RequestAnimationFrame.prototype.start = function (callback) {
                if (typeof callback === "undefined") { callback = null; }
                var _this = this;
                if (callback) {
                    this._callback = callback;
                }

                if (!window.requestAnimationFrame) {
                    this._isSetTimeOut = true;
                    this._timeOutID = window.setTimeout(function () {
                        return _this.SetTimeoutUpdate();
                    }, 0);
                } else {
                    this._isSetTimeOut = false;
                    window.requestAnimationFrame(function () {
                        return _this.RAFUpdate();
                    });
                }

                this.isRunning = true;
            };

            /**
            * Stops the RAF from running.
            * @method stop
            * @public
            */
            RequestAnimationFrame.prototype.stop = function () {
                if (this._isSetTimeOut) {
                    clearTimeout(this._timeOutID);
                } else {
                    window.cancelAnimationFrame;
                }

                this.isRunning = false;
            };

            /**
            * The update loop that the RAF will continuously call.
            * @method RAFUpdate
            * @public
            */
            RequestAnimationFrame.prototype.RAFUpdate = function () {
                var _this = this;
                //  Not in IE8 (but neither is RAF) also doesn't use a high performance timer (window.performance.now)
                this.currentTime = Date.now();

                if (this._callback) {
                    this._callback();
                }

                var timeToCall = Math.max(0, 16 - (this.currentTime - this.lastTime));

                window.requestAnimationFrame(function () {
                    return _this.RAFUpdate();
                });

                this.lastTime = this.currentTime + timeToCall;
            };

            /**
            * The update loop that the setTimeout method will continuously call.
            * @method SetTimeoutUpdate
            * @public
            */
            RequestAnimationFrame.prototype.SetTimeoutUpdate = function () {
                var _this = this;
                //  Not in IE8
                this.currentTime = Date.now();

                if (this._callback) {
                    this._callback();
                }

                var timeToCall = Math.max(0, 16 - (this.currentTime - this.lastTime));

                this._timeOutID = window.setTimeout(function () {
                    return _this.SetTimeoutUpdate();
                }, timeToCall);

                this.lastTime = this.currentTime + timeToCall;
            };
            return RequestAnimationFrame;
        })();
        Utils.RequestAnimationFrame = RequestAnimationFrame;
    })(Kiwi.Utils || (Kiwi.Utils = {}));
    var Utils = Kiwi.Utils;
})(Kiwi || (Kiwi = {}));
/// <reference path="core/Game.ts" />
/// <reference path="core/Stage.ts" />
/// <reference path="core/ComponentManager.ts" />
/// <reference path="core/PluginManager.ts" />
/// <reference path="core/CameraManager.ts" />
/// <reference path="core/StateConfig.ts" />
/// <reference path="core/StateManager.ts" />
/// <reference path="core/IChild.ts" />
/// <reference path="core/Entity.ts" />
/// <reference path="core/Component.ts" />
/// <reference path="core/Group.ts" />
/// <reference path="core/State.ts" /> //must be initialised AFTER group - typescript issue #599
/// <reference path="core/Camera.ts" />
/// <reference path="core/Signal.ts" />
/// <reference path="core/SignalBinding.ts" />
/// <reference path="gameobjects/Sprite.ts" />
/// <reference path="gameobjects/StaticImage.ts" />
/// <reference path="gameobjects/Textfield.ts" />
/// <reference path="gameobjects/tilemap/TileType.ts" />
/// <reference path="gameobjects/tilemap/TileMap.ts" />
/// <reference path="gameobjects/tilemap/TileMapLayer.ts" />
/// <reference path="components/AnimationManager.ts" />
/// <reference path="components/Box.ts" />
/// <reference path="components/Input.ts" />
/// <reference path="components/Sound.ts" />
/// <reference path="components/ArcadePhysics.ts" />
/// <reference path="file/Loader.ts" />
/// <reference path="file/DataLibrary.ts" />
/// <reference path="file/File.ts" />
/// <reference path="file/FileStore.ts" />
/// <reference path="system/Bootstrap.ts" />
/// <reference path="system/Browser.ts" />
/// <reference path="system/Device.ts" />
/// <reference path="textures/TextureAtlas.ts" />
/// <reference path="textures/TextureLibrary.ts" />
/// <reference path="textures/SpriteSheet.ts" />
/// <reference path="textures/SingleImage.ts" />
/// <reference path="animations/tweens/easing/Back.ts" />
/// <reference path="animations/tweens/easing/Bounce.ts" />
/// <reference path="animations/tweens/easing/Circular.ts" />
/// <reference path="animations/tweens/easing/Cubic.ts" />
/// <reference path="animations/tweens/easing/Elastic.ts" />
/// <reference path="animations/tweens/easing/Exponential.ts" />
/// <reference path="animations/tweens/easing/Linear.ts" />
/// <reference path="animations/tweens/easing/Quadratic.ts" />
/// <reference path="animations/tweens/easing/Quartic.ts" />
/// <reference path="animations/tweens/easing/Quintic.ts" />
/// <reference path="animations/tweens/easing/Sinusoidal.ts" />
/// <reference path="animations/tweens/TweenManager.ts" />
/// <reference path="animations/tweens/Tween.ts" />
/// <reference path="render/CanvasRenderer.ts" />
/// <reference path="render/GLRenderManager.ts" />
/// <reference path="render/GLShaderManager.ts" />
/// <reference path="render/GLTextureWrapper.ts" />
/// <reference path="render/GLTextureManager.ts" />
/// <reference path="render/GLArrayBuffer.ts" />
/// <reference path="render/GLElementArrayBuffer.ts" />
/// <reference path="render/renderers/Renderer.ts" />
/// <reference path="render/renderers/TextureAtlasRenderer.ts" />
/// <reference path="render/shaders/ShaderPair.ts" />
/// <reference path="render/shaders/TextureAtlasShader.ts" />
/// <reference path="render/shaders/ShaderPair.ts" />
/// <reference path="animations/Animation.ts" />
/// <reference path="animations/Sequence.ts" />
/// <reference path="input/Key.ts" />
/// <reference path="input/Keyboard.ts" />
/// <reference path="input/Keycodes.ts" />
/// <reference path="input/InputManager.ts" />
/// <reference path="input/Mouse.ts" />
/// <reference path="input/Touch.ts" />
/// <reference path="input/Pointer.ts" />
/// <reference path="input/MouseCursor.ts" />
/// <reference path="input/Finger.ts" />
/// <reference path="geom/AABB.ts" />
/// <reference path="geom/Circle.ts" />
/// <reference path="geom/Ray.ts" />
/// <reference path="geom/Intersect.ts" />
/// <reference path="geom/IntersectResult.ts" />
/// <reference path="geom/Line.ts" />
/// <reference path="geom/Matrix.ts" />
/// <reference path="geom/Point.ts" />
/// <reference path="geom/Rectangle.ts" />
/// <reference path="geom/Transform.ts" />
/// <reference path="geom/Vector2.ts" />
/// <reference path="hud/HUDDisplay.ts" />
/// <reference path="hud/HUDManager.ts" />
/// <reference path="hud/HUDWidget.ts" />
/// <reference path="hud/widgets/TextField.ts" />
/// <reference path="hud/widgets/Bar.ts" />
/// <reference path="hud/widgets/Icon.ts" />
/// <reference path="hud/widgets/IconBar.ts" />
/// <reference path="hud/widgets/BasicScore.ts" />
/// <reference path="hud/widgets/Button.ts" />
/// <reference path="hud/widgets/Time.ts" />
/// <reference path="hud/widgets/Menu.ts" />
/// <reference path="hud/widgets/MenuItem.ts" />
/// <reference path="hud/components/Counter.ts" />
/// <reference path="hud/components/WidgetInput.ts" />
/// <reference path="hud/components/Time.ts" />
/// <reference path="sound/AudioManager.ts" />
/// <reference path="sound/Audio.ts" />
/// <reference path="sound/AudioLibrary.ts" />
/// <reference path="time/Clock.ts" />
/// <reference path="time/ClockManager.ts" />
/// <reference path="time/MasterClock.ts" />
/// <reference path="time/Timer.ts" />
/// <reference path="time/TimerEvent.ts" />
/// <reference path="utils/Canvas.ts" />
/// <reference path="utils/Common.ts" />
/// <reference path="utils/GameMath.ts" />
/// <reference path="utils/RandomDataGenerator.ts" />
/// <reference path="utils/RequestAnimationFrame.ts" />
/// <reference path="WebGL.d.ts"/>
/**
* Module - Kiwi (Core)
* The top level namespace in which all core classes and modules are defined.
* @module Kiwi
* @main Kiwi
*/
var Kiwi;
(function (Kiwi) {
    /**
    * The version of Kiwi that is currently being used.
    * @property VERSION
    * @static
    * @type string
    * @default '1.0'
    * @public
    */
    Kiwi.VERSION = "0.7.0";

    //DIFFERENT RENDERER STATIC VARIABLES
    /**
    * A Static property that contains the number associated with the CANVAS RENDERER.
    * @property RENDERER_CANVAS
    * @static
    * @type number
    * @default 0
    * @public
    */
    Kiwi.RENDERER_CANVAS = 0;

    /**
    * A Static property that contains the number associated with the WEBGL RENDERER.
    * @property RENDERER_WEBGL
    * @static
    * @type number
    * @default 1
    * @public
    */
    Kiwi.RENDERER_WEBGL = 1;

    // DEVICE TARGET STATIC VARIABLES
    /**
    * Contains the number associated with the targetting of browsers.
    * @property TARGET_BROWSER
    * @static
    * @type number
    * @default 0
    * @public
    */
    Kiwi.TARGET_BROWSER = 0;

    /**
    * Contains the number associated with the targetting of CocoonJS.
    * @property TARGET_COCOON
    * @static
    * @type number
    * @default 1
    * @public
    */
    Kiwi.TARGET_COCOON = 1;

    //DEBUG OPTION STATIC VARIABLES
    /**
    * Contains the number that is used to turn the Debug options on.
    * @property DEBUG_ON
    * @static
    * @type number
    * @default 0
    * @public
    */
    Kiwi.DEBUG_ON = 0;

    /**
    * Contains the number that is used to turn the Debug options off.
    * @property DEBUG_OFF
    * @static
    * @type number
    * @default 1
    * @public
    */
    Kiwi.DEBUG_OFF = 1;

    /**
    * Contains the Device class that is used to detirmine which features are supported by the users browser.
    * @property DEVICE
    * @static
    * @type Device
    * @public
    */
    Kiwi.DEVICE = null;

    //STATIC PROPERTIES FOR GENERAL OBJECT TYPE DETECTION
    /**
    * Contains a number that is used to identify objects that are a State.
    * @property STATE
    * @static
    * @type number
    * @default 0
    * @public
    */
    Kiwi.STATE = 0;

    /**
    * Contains a number that is used to identify objects that are a Group.
    * @property GROUP
    * @static
    * @type number
    * @default 2
    * @public
    */
    Kiwi.GROUP = 2;

    /**
    * Contains a number that is used to identify objects that are a Entity.
    * @property ENTITY
    * @static
    * @type number
    * @default 3
    * @public
    */
    Kiwi.ENTITY = 3;

    /**
    * Contains a number that is used to identify objects that are a Camera.
    * @property CAMERA
    * @static
    * @type number
    * @default 4
    * @public
    */
    Kiwi.CAMERA = 4;

    /**
    * Contains a number that is used to identify objects that are a HUD Widget.
    * @property HUD_WIDGET
    * @static
    * @type number
    * @default 5
    * @public
    */
    Kiwi.HUD_WIDGET = 5;

    /**
    * Contains a number that is used to identify objects that are a TILE_LAYER.
    * @property TILE_LAYER
    * @static
    * @type number
    * @default 6
    * @public
    */
    Kiwi.TILE_LAYER = 6;

    /**
    * The GameManager is used to maintain mulitple instances of Kiwi games within a single document.
    *
    * @class GameManager
    * @namespace Kiwi
    * @static
    */
    var GameManager = (function () {
        function GameManager() {
        }
        /**
        * The type of object that this is.
        * @method objType
        * @return {String}
        * @public
        */
        GameManager.prototype.objType = function () {
            return "GameManager";
        };

        /**
        * Used to register a new Game with this manager. Returns the new number of games that have been registered.
        * @method register
        * @param game {Game} The game you are wanting to register.
        * @return {Number] The new number of games registered.
        * @public
        */
        GameManager.register = function (game) {
            return Kiwi.GameManager._games.push(game);
        };

        /**
        * Returns the total number of game that are currently registered with this GameManager.
        * @method total
        * @return {Number} Total number of registered games.
        * @public
        */
        GameManager.total = function () {
            return Kiwi.GameManager._games.length;
        };
        GameManager._games = [];
        return GameManager;
    })();
    Kiwi.GameManager = GameManager;

    Kiwi.Plugins = {};

    Kiwi.extend = function (d, b) {
        for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        __.prototype = b.prototype;
        d.prototype = new __();
    };
})(Kiwi || (Kiwi = {}));

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.0
 */
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
(function(e){"use strict";var t={};typeof exports=="undefined"?typeof define=="function"&&typeof define.amd=="object"&&define.amd?(t.exports={},define(function(){return t.exports})):t.exports=typeof window!="undefined"?window:e:t.exports=exports,function(e){if(!t)var t=1e-6;if(!n)var n=typeof Float32Array!="undefined"?Float32Array:Array;if(!r)var r=Math.random;var i={};i.setMatrixArrayType=function(e){n=e},typeof e!="undefined"&&(e.glMatrix=i);var s={};s.create=function(){var e=new n(2);return e[0]=0,e[1]=0,e},s.clone=function(e){var t=new n(2);return t[0]=e[0],t[1]=e[1],t},s.fromValues=function(e,t){var r=new n(2);return r[0]=e,r[1]=t,r},s.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e},s.set=function(e,t,n){return e[0]=t,e[1]=n,e},s.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e},s.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e},s.sub=s.subtract,s.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e},s.mul=s.multiply,s.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e},s.div=s.divide,s.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e},s.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e},s.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e},s.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e},s.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return Math.sqrt(n*n+r*r)},s.dist=s.distance,s.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1];return n*n+r*r},s.sqrDist=s.squaredDistance,s.length=function(e){var t=e[0],n=e[1];return Math.sqrt(t*t+n*n)},s.len=s.length,s.squaredLength=function(e){var t=e[0],n=e[1];return t*t+n*n},s.sqrLen=s.squaredLength,s.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e},s.normalize=function(e,t){var n=t[0],r=t[1],i=n*n+r*r;return i>0&&(i=1/Math.sqrt(i),e[0]=t[0]*i,e[1]=t[1]*i),e},s.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]},s.cross=function(e,t,n){var r=t[0]*n[1]-t[1]*n[0];return e[0]=e[1]=0,e[2]=r,e},s.lerp=function(e,t,n,r){var i=t[0],s=t[1];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e},s.random=function(e,t){t=t||1;var n=r()*2*Math.PI;return e[0]=Math.cos(n)*t,e[1]=Math.sin(n)*t,e},s.transformMat2=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i,e[1]=n[1]*r+n[3]*i,e},s.transformMat2d=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[2]*i+n[4],e[1]=n[1]*r+n[3]*i+n[5],e},s.transformMat3=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[3]*i+n[6],e[1]=n[1]*r+n[4]*i+n[7],e},s.transformMat4=function(e,t,n){var r=t[0],i=t[1];return e[0]=n[0]*r+n[4]*i+n[12],e[1]=n[1]*r+n[5]*i+n[13],e},s.forEach=function(){var e=s.create();return function(t,n,r,i,s,o){var u,a;n||(n=2),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],s(e,e,o),t[u]=e[0],t[u+1]=e[1];return t}}(),s.str=function(e){return"vec2("+e[0]+", "+e[1]+")"},typeof e!="undefined"&&(e.vec2=s);var o={};o.create=function(){var e=new n(3);return e[0]=0,e[1]=0,e[2]=0,e},o.clone=function(e){var t=new n(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t},o.fromValues=function(e,t,r){var i=new n(3);return i[0]=e,i[1]=t,i[2]=r,i},o.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},o.set=function(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e},o.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e},o.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e},o.sub=o.subtract,o.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e},o.mul=o.multiply,o.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e},o.div=o.divide,o.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e},o.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e},o.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e},o.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e},o.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(n*n+r*r+i*i)},o.dist=o.distance,o.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2];return n*n+r*r+i*i},o.sqrDist=o.squaredDistance,o.length=function(e){var t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)},o.len=o.length,o.squaredLength=function(e){var t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r},o.sqrLen=o.squaredLength,o.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},o.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=n*n+r*r+i*i;return s>0&&(s=1/Math.sqrt(s),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s),e},o.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]},o.cross=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2];return e[0]=i*a-s*u,e[1]=s*o-r*a,e[2]=r*u-i*o,e},o.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e},o.random=function(e,t){t=t||1;var n=r()*2*Math.PI,i=r()*2-1,s=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*s,e[1]=Math.sin(n)*s,e[2]=i*t,e},o.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12],e[1]=n[1]*r+n[5]*i+n[9]*s+n[13],e[2]=n[2]*r+n[6]*i+n[10]*s+n[14],e},o.transformMat3=function(e,t,n){var r=t[0],i=t[1],s=t[2];return e[0]=r*n[0]+i*n[3]+s*n[6],e[1]=r*n[1]+i*n[4]+s*n[7],e[2]=r*n[2]+i*n[5]+s*n[8],e},o.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},o.forEach=function(){var e=o.create();return function(t,n,r,i,s,o){var u,a;n||(n=3),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2];return t}}(),o.str=function(e){return"vec3("+e[0]+", "+e[1]+", "+e[2]+")"},typeof e!="undefined"&&(e.vec3=o);var u={};u.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e},u.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},u.fromValues=function(e,t,r,i){var s=new n(4);return s[0]=e,s[1]=t,s[2]=r,s[3]=i,s},u.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},u.set=function(e,t,n,r,i){return e[0]=t,e[1]=n,e[2]=r,e[3]=i,e},u.add=function(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e},u.subtract=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e},u.sub=u.subtract,u.multiply=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e[3]=t[3]*n[3],e},u.mul=u.multiply,u.divide=function(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e[3]=t[3]/n[3],e},u.div=u.divide,u.min=function(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e[3]=Math.min(t[3],n[3]),e},u.max=function(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e[3]=Math.max(t[3],n[3]),e},u.scale=function(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e},u.scaleAndAdd=function(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e},u.distance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return Math.sqrt(n*n+r*r+i*i+s*s)},u.dist=u.distance,u.squaredDistance=function(e,t){var n=t[0]-e[0],r=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return n*n+r*r+i*i+s*s},u.sqrDist=u.squaredDistance,u.length=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)},u.len=u.length,u.squaredLength=function(e){var t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i},u.sqrLen=u.squaredLength,u.negate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e},u.normalize=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s;return o>0&&(o=1/Math.sqrt(o),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e[3]=t[3]*o),e},u.dot=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]},u.lerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3];return e[0]=i+r*(n[0]-i),e[1]=s+r*(n[1]-s),e[2]=o+r*(n[2]-o),e[3]=u+r*(n[3]-u),e},u.random=function(e,t){return t=t||1,e[0]=r(),e[1]=r(),e[2]=r(),e[3]=r(),u.normalize(e,e),u.scale(e,e,t),e},u.transformMat4=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3];return e[0]=n[0]*r+n[4]*i+n[8]*s+n[12]*o,e[1]=n[1]*r+n[5]*i+n[9]*s+n[13]*o,e[2]=n[2]*r+n[6]*i+n[10]*s+n[14]*o,e[3]=n[3]*r+n[7]*i+n[11]*s+n[15]*o,e},u.transformQuat=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=n[0],u=n[1],a=n[2],f=n[3],l=f*r+u*s-a*i,c=f*i+a*r-o*s,h=f*s+o*i-u*r,p=-o*r-u*i-a*s;return e[0]=l*f+p*-o+c*-a-h*-u,e[1]=c*f+p*-u+h*-o-l*-a,e[2]=h*f+p*-a+l*-u-c*-o,e},u.forEach=function(){var e=u.create();return function(t,n,r,i,s,o){var u,a;n||(n=4),r||(r=0),i?a=Math.min(i*n+r,t.length):a=t.length;for(u=r;u<a;u+=n)e[0]=t[u],e[1]=t[u+1],e[2]=t[u+2],e[3]=t[u+3],s(e,e,o),t[u]=e[0],t[u+1]=e[1],t[u+2]=e[2],t[u+3]=e[3];return t}}(),u.str=function(e){return"vec4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.vec4=u);var a={};a.create=function(){var e=new n(4);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},a.clone=function(e){var t=new n(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},a.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},a.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},a.transpose=function(e,t){if(e===t){var n=t[1];e[1]=t[2],e[2]=n}else e[0]=t[0],e[1]=t[2],e[2]=t[1],e[3]=t[3];return e},a.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*s-i*r;return o?(o=1/o,e[0]=s*o,e[1]=-r*o,e[2]=-i*o,e[3]=n*o,e):null},a.adjoint=function(e,t){var n=t[0];return e[0]=t[3],e[1]=-t[1],e[2]=-t[2],e[3]=n,e},a.determinant=function(e){return e[0]*e[3]-e[2]*e[1]},a.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*u+i*f,e[1]=r*a+i*l,e[2]=s*u+o*f,e[3]=s*a+o*l,e},a.mul=a.multiply,a.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+i*u,e[1]=r*-u+i*a,e[2]=s*a+o*u,e[3]=s*-u+o*a,e},a.scale=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1];return e[0]=r*u,e[1]=i*a,e[2]=s*u,e[3]=o*a,e},a.str=function(e){return"mat2("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.mat2=a);var f={};f.create=function(){var e=new n(6);return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},f.clone=function(e){var t=new n(6);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t},f.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e},f.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},f.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=n*s-r*i;return a?(a=1/a,e[0]=s*a,e[1]=-r*a,e[2]=-i*a,e[3]=n*a,e[4]=(i*u-s*o)*a,e[5]=(r*o-n*u)*a,e):null},f.determinant=function(e){return e[0]*e[3]-e[1]*e[2]},f.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=n[0],l=n[1],c=n[2],h=n[3],p=n[4],d=n[5];return e[0]=r*f+i*c,e[1]=r*l+i*h,e[2]=s*f+o*c,e[3]=s*l+o*h,e[4]=f*u+c*a+p,e[5]=l*u+h*a+d,e},f.mul=f.multiply,f.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=Math.sin(n),l=Math.cos(n);return e[0]=r*l+i*f,e[1]=-r*f+i*l,e[2]=s*l+o*f,e[3]=-s*f+l*o,e[4]=l*u+f*a,e[5]=l*a-f*u,e},f.scale=function(e,t,n){var r=n[0],i=n[1];return e[0]=t[0]*r,e[1]=t[1]*i,e[2]=t[2]*r,e[3]=t[3]*i,e[4]=t[4]*r,e[5]=t[5]*i,e},f.translate=function(e,t,n){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4]+n[0],e[5]=t[5]+n[1],e},f.str=function(e){return"mat2d("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+")"},typeof e!="undefined"&&(e.mat2d=f);var l={};l.create=function(){var e=new n(9);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},l.fromMat4=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e},l.clone=function(e){var t=new n(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t},l.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},l.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},l.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=i}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e},l.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=l*o-u*f,h=-l*s+u*a,p=f*s-o*a,d=n*c+r*h+i*p;return d?(d=1/d,e[0]=c*d,e[1]=(-l*r+i*f)*d,e[2]=(u*r-i*o)*d,e[3]=h*d,e[4]=(l*n-i*a)*d,e[5]=(-u*n+i*s)*d,e[6]=p*d,e[7]=(-f*n+r*a)*d,e[8]=(o*n-r*s)*d,e):null},l.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8];return e[0]=o*l-u*f,e[1]=i*f-r*l,e[2]=r*u-i*o,e[3]=u*a-s*l,e[4]=n*l-i*a,e[5]=i*s-n*u,e[6]=s*f-o*a,e[7]=r*a-n*f,e[8]=n*o-r*s,e},l.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8];return t*(f*s-o*a)+n*(-f*i+o*u)+r*(a*i-s*u)},l.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8];return e[0]=h*r+p*o+d*f,e[1]=h*i+p*u+d*l,e[2]=h*s+p*a+d*c,e[3]=v*r+m*o+g*f,e[4]=v*i+m*u+g*l,e[5]=v*s+m*a+g*c,e[6]=y*r+b*o+w*f,e[7]=y*i+b*u+w*l,e[8]=y*s+b*a+w*c,e},l.mul=l.multiply,l.translate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=n[0],p=n[1];return e[0]=r,e[1]=i,e[2]=s,e[3]=o,e[4]=u,e[5]=a,e[6]=h*r+p*o+f,e[7]=h*i+p*u+l,e[8]=h*s+p*a+c,e},l.rotate=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=Math.sin(n),p=Math.cos(n);return e[0]=p*r+h*o,e[1]=p*i+h*u,e[2]=p*s+h*a,e[3]=p*o-h*r,e[4]=p*u-h*i,e[5]=p*a-h*s,e[6]=f,e[7]=l,e[8]=c,e},l.scale=function(e,t,n){var r=n[0],i=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=i*t[3],e[4]=i*t[4],e[5]=i*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},l.fromMat2d=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e},l.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=n*u,c=n*a,h=r*u,p=r*a,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-(h+d),e[3]=l+g,e[6]=c-m,e[1]=l-g,e[4]=1-(f+d),e[7]=p+v,e[2]=c+m,e[5]=p-v,e[8]=1-(f+h),e},l.normalFromMat4=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(a*C-o*A-f*N)*O,e[2]=(o*L-u*C+f*T)*O,e[3]=(i*L-r*A-s*k)*O,e[4]=(n*A-i*C+s*N)*O,e[5]=(r*C-n*L-s*T)*O,e[6]=(v*x-m*S+g*E)*O,e[7]=(m*w-d*x-g*b)*O,e[8]=(d*S-v*w+g*y)*O,e):null},l.str=function(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"},typeof e!="undefined"&&(e.mat3=l);var c={};c.create=function(){var e=new n(16);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},c.clone=function(e){var t=new n(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t},c.copy=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},c.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},c.transpose=function(e,t){if(e===t){var n=t[1],r=t[2],i=t[3],s=t[6],o=t[7],u=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=s,e[11]=t[14],e[12]=i,e[13]=o,e[14]=u}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e},c.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15],y=n*u-r*o,b=n*a-i*o,w=n*f-s*o,E=r*a-i*u,S=r*f-s*u,x=i*f-s*a,T=l*v-c*d,N=l*m-h*d,C=l*g-p*d,k=c*m-h*v,L=c*g-p*v,A=h*g-p*m,O=y*A-b*L+w*k+E*C-S*N+x*T;return O?(O=1/O,e[0]=(u*A-a*L+f*k)*O,e[1]=(i*L-r*A-s*k)*O,e[2]=(v*x-m*S+g*E)*O,e[3]=(h*S-c*x-p*E)*O,e[4]=(a*C-o*A-f*N)*O,e[5]=(n*A-i*C+s*N)*O,e[6]=(m*w-d*x-g*b)*O,e[7]=(l*x-h*w+p*b)*O,e[8]=(o*L-u*C+f*T)*O,e[9]=(r*C-n*L-s*T)*O,e[10]=(d*S-v*w+g*y)*O,e[11]=(c*w-l*S-p*y)*O,e[12]=(u*N-o*k-a*T)*O,e[13]=(n*k-r*N+i*T)*O,e[14]=(v*b-d*E-m*y)*O,e[15]=(l*E-c*b+h*y)*O,e):null},c.adjoint=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=t[4],u=t[5],a=t[6],f=t[7],l=t[8],c=t[9],h=t[10],p=t[11],d=t[12],v=t[13],m=t[14],g=t[15];return e[0]=u*(h*g-p*m)-c*(a*g-f*m)+v*(a*p-f*h),e[1]=-(r*(h*g-p*m)-c*(i*g-s*m)+v*(i*p-s*h)),e[2]=r*(a*g-f*m)-u*(i*g-s*m)+v*(i*f-s*a),e[3]=-(r*(a*p-f*h)-u*(i*p-s*h)+c*(i*f-s*a)),e[4]=-(o*(h*g-p*m)-l*(a*g-f*m)+d*(a*p-f*h)),e[5]=n*(h*g-p*m)-l*(i*g-s*m)+d*(i*p-s*h),e[6]=-(n*(a*g-f*m)-o*(i*g-s*m)+d*(i*f-s*a)),e[7]=n*(a*p-f*h)-o*(i*p-s*h)+l*(i*f-s*a),e[8]=o*(c*g-p*v)-l*(u*g-f*v)+d*(u*p-f*c),e[9]=-(n*(c*g-p*v)-l*(r*g-s*v)+d*(r*p-s*c)),e[10]=n*(u*g-f*v)-o*(r*g-s*v)+d*(r*f-s*u),e[11]=-(n*(u*p-f*c)-o*(r*p-s*c)+l*(r*f-s*u)),e[12]=-(o*(c*m-h*v)-l*(u*m-a*v)+d*(u*h-a*c)),e[13]=n*(c*m-h*v)-l*(r*m-i*v)+d*(r*h-i*c),e[14]=-(n*(u*m-a*v)-o*(r*m-i*v)+d*(r*a-i*u)),e[15]=n*(u*h-a*c)-o*(r*h-i*c)+l*(r*a-i*u),e},c.determinant=function(e){var t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],o=e[5],u=e[6],a=e[7],f=e[8],l=e[9],c=e[10],h=e[11],p=e[12],d=e[13],v=e[14],m=e[15],g=t*o-n*s,y=t*u-r*s,b=t*a-i*s,w=n*u-r*o,E=n*a-i*o,S=r*a-i*u,x=f*d-l*p,T=f*v-c*p,N=f*m-h*p,C=l*v-c*d,k=l*m-h*d,L=c*m-h*v;return g*L-y*k+b*C+w*N-E*T+S*x},c.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=t[4],a=t[5],f=t[6],l=t[7],c=t[8],h=t[9],p=t[10],d=t[11],v=t[12],m=t[13],g=t[14],y=t[15],b=n[0],w=n[1],E=n[2],S=n[3];return e[0]=b*r+w*u+E*c+S*v,e[1]=b*i+w*a+E*h+S*m,e[2]=b*s+w*f+E*p+S*g,e[3]=b*o+w*l+E*d+S*y,b=n[4],w=n[5],E=n[6],S=n[7],e[4]=b*r+w*u+E*c+S*v,e[5]=b*i+w*a+E*h+S*m,e[6]=b*s+w*f+E*p+S*g,e[7]=b*o+w*l+E*d+S*y,b=n[8],w=n[9],E=n[10],S=n[11],e[8]=b*r+w*u+E*c+S*v,e[9]=b*i+w*a+E*h+S*m,e[10]=b*s+w*f+E*p+S*g,e[11]=b*o+w*l+E*d+S*y,b=n[12],w=n[13],E=n[14],S=n[15],e[12]=b*r+w*u+E*c+S*v,e[13]=b*i+w*a+E*h+S*m,e[14]=b*s+w*f+E*p+S*g,e[15]=b*o+w*l+E*d+S*y,e},c.mul=c.multiply,c.translate=function(e,t,n){var r=n[0],i=n[1],s=n[2],o,u,a,f,l,c,h,p,d,v,m,g;return t===e?(e[12]=t[0]*r+t[4]*i+t[8]*s+t[12],e[13]=t[1]*r+t[5]*i+t[9]*s+t[13],e[14]=t[2]*r+t[6]*i+t[10]*s+t[14],e[15]=t[3]*r+t[7]*i+t[11]*s+t[15]):(o=t[0],u=t[1],a=t[2],f=t[3],l=t[4],c=t[5],h=t[6],p=t[7],d=t[8],v=t[9],m=t[10],g=t[11],e[0]=o,e[1]=u,e[2]=a,e[3]=f,e[4]=l,e[5]=c,e[6]=h,e[7]=p,e[8]=d,e[9]=v,e[10]=m,e[11]=g,e[12]=o*r+l*i+d*s+t[12],e[13]=u*r+c*i+v*s+t[13],e[14]=a*r+h*i+m*s+t[14],e[15]=f*r+p*i+g*s+t[15]),e},c.scale=function(e,t,n){var r=n[0],i=n[1],s=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e},c.rotate=function(e,n,r,i){var s=i[0],o=i[1],u=i[2],a=Math.sqrt(s*s+o*o+u*u),f,l,c,h,p,d,v,m,g,y,b,w,E,S,x,T,N,C,k,L,A,O,M,_;return Math.abs(a)<t?null:(a=1/a,s*=a,o*=a,u*=a,f=Math.sin(r),l=Math.cos(r),c=1-l,h=n[0],p=n[1],d=n[2],v=n[3],m=n[4],g=n[5],y=n[6],b=n[7],w=n[8],E=n[9],S=n[10],x=n[11],T=s*s*c+l,N=o*s*c+u*f,C=u*s*c-o*f,k=s*o*c-u*f,L=o*o*c+l,A=u*o*c+s*f,O=s*u*c+o*f,M=o*u*c-s*f,_=u*u*c+l,e[0]=h*T+m*N+w*C,e[1]=p*T+g*N+E*C,e[2]=d*T+y*N+S*C,e[3]=v*T+b*N+x*C,e[4]=h*k+m*L+w*A,e[5]=p*k+g*L+E*A,e[6]=d*k+y*L+S*A,e[7]=v*k+b*L+x*A,e[8]=h*O+m*M+w*_,e[9]=p*O+g*M+E*_,e[10]=d*O+y*M+S*_,e[11]=v*O+b*M+x*_,n!==e&&(e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15]),e)},c.rotateX=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[4],o=t[5],u=t[6],a=t[7],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*i+f*r,e[5]=o*i+l*r,e[6]=u*i+c*r,e[7]=a*i+h*r,e[8]=f*i-s*r,e[9]=l*i-o*r,e[10]=c*i-u*r,e[11]=h*i-a*r,e},c.rotateY=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[8],l=t[9],c=t[10],h=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i-f*r,e[1]=o*i-l*r,e[2]=u*i-c*r,e[3]=a*i-h*r,e[8]=s*r+f*i,e[9]=o*r+l*i,e[10]=u*r+c*i,e[11]=a*r+h*i,e},c.rotateZ=function(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],o=t[1],u=t[2],a=t[3],f=t[4],l=t[5],c=t[6],h=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i+f*r,e[1]=o*i+l*r,e[2]=u*i+c*r,e[3]=a*i+h*r,e[4]=f*i-s*r,e[5]=l*i-o*r,e[6]=c*i-u*r,e[7]=h*i-a*r,e},c.fromRotationTranslation=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=r+r,a=i+i,f=s+s,l=r*u,c=r*a,h=r*f,p=i*a,d=i*f,v=s*f,m=o*u,g=o*a,y=o*f;return e[0]=1-(p+v),e[1]=c+y,e[2]=h-g,e[3]=0,e[4]=c-y,e[5]=1-(l+v),e[6]=d+m,e[7]=0,e[8]=h+g,e[9]=d-m,e[10]=1-(l+p),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e},c.fromQuat=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n+n,u=r+r,a=i+i,f=n*o,l=n*u,c=n*a,h=r*u,p=r*a,d=i*a,v=s*o,m=s*u,g=s*a;return e[0]=1-(h+d),e[1]=l+g,e[2]=c-m,e[3]=0,e[4]=l-g,e[5]=1-(f+d),e[6]=p+v,e[7]=0,e[8]=c+m,e[9]=p-v,e[10]=1-(f+h),e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},c.frustum=function(e,t,n,r,i,s,o){var u=1/(n-t),a=1/(i-r),f=1/(s-o);return e[0]=s*2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s*2*a,e[6]=0,e[7]=0,e[8]=(n+t)*u,e[9]=(i+r)*a,e[10]=(o+s)*f,e[11]=-1,e[12]=0,e[13]=0,e[14]=o*s*2*f,e[15]=0,e},c.perspective=function(e,t,n,r,i){var s=1/Math.tan(t/2),o=1/(r-i);return e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=(i+r)*o,e[11]=-1,e[12]=0,e[13]=0,e[14]=2*i*r*o,e[15]=0,e},c.ortho=function(e,t,n,r,i,s,o){var u=1/(t-n),a=1/(r-i),f=1/(s-o);return e[0]=-2*u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*f,e[11]=0,e[12]=(t+n)*u,e[13]=(i+r)*a,e[14]=(o+s)*f,e[15]=1,e},c.lookAt=function(e,n,r,i){var s,o,u,a,f,l,h,p,d,v,m=n[0],g=n[1],y=n[2],b=i[0],w=i[1],E=i[2],S=r[0],x=r[1],T=r[2];return Math.abs(m-S)<t&&Math.abs(g-x)<t&&Math.abs(y-T)<t?c.identity(e):(h=m-S,p=g-x,d=y-T,v=1/Math.sqrt(h*h+p*p+d*d),h*=v,p*=v,d*=v,s=w*d-E*p,o=E*h-b*d,u=b*p-w*h,v=Math.sqrt(s*s+o*o+u*u),v?(v=1/v,s*=v,o*=v,u*=v):(s=0,o=0,u=0),a=p*u-d*o,f=d*s-h*u,l=h*o-p*s,v=Math.sqrt(a*a+f*f+l*l),v?(v=1/v,a*=v,f*=v,l*=v):(a=0,f=0,l=0),e[0]=s,e[1]=a,e[2]=h,e[3]=0,e[4]=o,e[5]=f,e[6]=p,e[7]=0,e[8]=u,e[9]=l,e[10]=d,e[11]=0,e[12]=-(s*m+o*g+u*y),e[13]=-(a*m+f*g+l*y),e[14]=-(h*m+p*g+d*y),e[15]=1,e)},c.str=function(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"},typeof e!="undefined"&&(e.mat4=c);var h={};h.create=function(){var e=new n(4);return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},h.rotationTo=function(){var e=o.create(),t=o.fromValues(1,0,0),n=o.fromValues(0,1,0);return function(r,i,s){var u=o.dot(i,s);return u<-0.999999?(o.cross(e,t,i),o.length(e)<1e-6&&o.cross(e,n,i),o.normalize(e,e),h.setAxisAngle(r,e,Math.PI),r):u>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(o.cross(e,i,s),r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=1+u,h.normalize(r,r))}}(),h.setAxes=function(){var e=l.create();return function(t,n,r,i){return e[0]=r[0],e[3]=r[1],e[6]=r[2],e[1]=i[0],e[4]=i[1],e[7]=i[2],e[2]=n[0],e[5]=n[1],e[8]=n[2],h.normalize(t,h.fromMat3(t,e))}}(),h.clone=u.clone,h.fromValues=u.fromValues,h.copy=u.copy,h.set=u.set,h.identity=function(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},h.setAxisAngle=function(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e},h.add=u.add,h.multiply=function(e,t,n){var r=t[0],i=t[1],s=t[2],o=t[3],u=n[0],a=n[1],f=n[2],l=n[3];return e[0]=r*l+o*u+i*f-s*a,e[1]=i*l+o*a+s*u-r*f,e[2]=s*l+o*f+r*a-i*u,e[3]=o*l-r*u-i*a-s*f,e},h.mul=h.multiply,h.scale=u.scale,h.rotateX=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+o*u,e[1]=i*a+s*u,e[2]=s*a-i*u,e[3]=o*a-r*u,e},h.rotateY=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a-s*u,e[1]=i*a+o*u,e[2]=s*a+r*u,e[3]=o*a-i*u,e},h.rotateZ=function(e,t,n){n*=.5;var r=t[0],i=t[1],s=t[2],o=t[3],u=Math.sin(n),a=Math.cos(n);return e[0]=r*a+i*u,e[1]=i*a-r*u,e[2]=s*a+o*u,e[3]=o*a-s*u,e},h.calculateW=function(e,t){var n=t[0],r=t[1],i=t[2];return e[0]=n,e[1]=r,e[2]=i,e[3]=-Math.sqrt(Math.abs(1-n*n-r*r-i*i)),e},h.dot=u.dot,h.lerp=u.lerp,h.slerp=function(e,t,n,r){var i=t[0],s=t[1],o=t[2],u=t[3],a=n[0],f=n[1],l=n[2],c=n[3],h,p,d,v,m;return p=i*a+s*f+o*l+u*c,p<0&&(p=-p,a=-a,f=-f,l=-l,c=-c),1-p>1e-6?(h=Math.acos(p),d=Math.sin(h),v=Math.sin((1-r)*h)/d,m=Math.sin(r*h)/d):(v=1-r,m=r),e[0]=v*i+m*a,e[1]=v*s+m*f,e[2]=v*o+m*l,e[3]=v*u+m*c,e},h.invert=function(e,t){var n=t[0],r=t[1],i=t[2],s=t[3],o=n*n+r*r+i*i+s*s,u=o?1/o:0;return e[0]=-n*u,e[1]=-r*u,e[2]=-i*u,e[3]=s*u,e},h.conjugate=function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e},h.length=u.length,h.len=h.length,h.squaredLength=u.squaredLength,h.sqrLen=h.squaredLength,h.normalize=u.normalize,h.fromMat3=function(){var e=typeof Int8Array!="undefined"?new Int8Array([1,2,0]):[1,2,0];return function(t,n){var r=n[0]+n[4]+n[8],i;if(r>0)i=Math.sqrt(r+1),t[3]=.5*i,i=.5/i,t[0]=(n[7]-n[5])*i,t[1]=(n[2]-n[6])*i,t[2]=(n[3]-n[1])*i;else{var s=0;n[4]>n[0]&&(s=1),n[8]>n[s*3+s]&&(s=2);var o=e[s],u=e[o];i=Math.sqrt(n[s*3+s]-n[o*3+o]-n[u*3+u]+1),t[s]=.5*i,i=.5/i,t[3]=(n[u*3+o]-n[o*3+u])*i,t[o]=(n[o*3+s]+n[s*3+o])*i,t[u]=(n[u*3+s]+n[s*3+u])*i}return t}}(),h.str=function(e){return"quat("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"},typeof e!="undefined"&&(e.quat=h)}(t.exports)})(this);
